<?xml version="1.0" encoding="UTF-8"?>
<hdevelop file_version="1.2" halcon_version="19.11.0.0">
<procedure name="main">
<interface/>
<body>
<l>read_image (Image, '//mac/Home/Desktop/virtual_project/Data/BackLight/Image_20200806150516330.bmp')</l>
<l>get_image_size (Image, Width, Height)</l>
<l>dev_set_draw ('margin')    </l>
<l>count_seconds (StartTime)</l>
<l>gen_TwoCircle_info (Image, MaxCircleRow, MaxCircleColumn, MaxCircleRadius, MinCircleRow, MinCircleColumn, MinCircleRadius, TwoCirclePhi)</l>
<l>gen_L1L2_Measure10 (Image, MinCircleRow, MinCircleColumn, MinCircleRadius, TwoCirclePhi, Width, Height, RightCircleRowEdge1, RightCircleColumnEdge1, LeftCircleRowEdge1, LeftCircleColumnEdge1, RightCircleRowEdge2, RightCircleColumnEdge2, LeftCircleRowEdge2, LeftCircleColumnEdge2)</l>
<c>*分别计算L1、L2的中心坐标</c>
<l>RightCenterRow := (RightCircleRowEdge1+RightCircleRowEdge2)/2</l>
<l>RightCenterCol := (RightCircleColumnEdge1+RightCircleColumnEdge2)/2</l>
<l>LeftCenterRow := (LeftCircleRowEdge1+LeftCircleRowEdge2)/2</l>
<l>LeftCenterCol := (LeftCircleColumnEdge1+LeftCircleColumnEdge2)/2</l>
<c>*显示并计算L1、L2之间距离</c>
<l>distance_pp (RightCenterRow, RightCenterCol, LeftCenterRow, LeftCenterCol, L1_L2)</l>
<c>*定位右侧测量矩形</c>
<l>gen_right_edge(Image, MinCircleRow, MinCircleColumn, MinCircleRadius*3/4, MinCircleRadius*5/4, MaxCircleColumn, TwoCirclePhi, Width, Height, rad(180), 0, RightRowEdge1, RightColumnEdge1, RightRowEdge2, RightColumnEdge2)</l>
<c>*计算L3中心坐标和起点、终点坐标</c>
<l>L3CenterRow := (RightCenterRow + LeftCenterRow)/2</l>
<l>L3CenterCol := (RightCenterCol + LeftCenterCol)/2</l>
<l>L3StartRow := (RightCircleRowEdge1 + LeftCircleRowEdge2)/2</l>
<l>L3StartCol := (RightCircleColumnEdge1 + LeftCircleColumnEdge2)/2</l>
<l>L3EndRow := (RightCircleRowEdge2 + LeftCircleRowEdge1)/2</l>
<l>L3EndCol := (RightCircleColumnEdge2 + LeftCircleColumnEdge1)/2</l>
<c>*计算X1</c>
<l>distance_pl (L3CenterRow, L3CenterCol, RightRowEdge1, RightColumnEdge1, RightRowEdge2, RightColumnEdge2, X1)</l>
<c>*计算运行时间</c>
<l>count_seconds (StopTime)</l>
<l>runtime := (StopTime - StartTime)*1000</l>
<c>*输出结果</c>
<l>distanceL1L2 := L1_L2</l>
<l>distanceX1 := X1</l>
</body>
<docu id="main">
<parameters/>
</docu>
</procedure>
<procedure name="gen_Edge_Circle">
<interface>
<io>
<par name="Image" base_type="iconic" dimension="0"/>
</io>
<oo>
<par name="Circle" base_type="iconic" dimension="0"/>
</oo>
<ic>
<par name="CenterRow" base_type="ctrl" dimension="0"/>
<par name="CenterCol" base_type="ctrl" dimension="0"/>
<par name="BasePhi" base_type="ctrl" dimension="0"/>
<par name="ImageWidth" base_type="ctrl" dimension="0"/>
<par name="ImageHeight" base_type="ctrl" dimension="0"/>
<par name="RotatePhi" base_type="ctrl" dimension="0"/>
<par name="BaseRectDistRow" base_type="ctrl" dimension="0"/>
<par name="BaseRectDistColumn" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="LeftTopRowEdge" base_type="ctrl" dimension="0"/>
<par name="LeftTopColumnEdge" base_type="ctrl" dimension="0"/>
<par name="RightButtomRowEdge" base_type="ctrl" dimension="0"/>
<par name="RightButtomColumnEdge" base_type="ctrl" dimension="0"/>
<par name="LeftButtomRowEdge" base_type="ctrl" dimension="0"/>
<par name="LeftButtomColumnEdge" base_type="ctrl" dimension="0"/>
<par name="RightTopRowEdge" base_type="ctrl" dimension="0"/>
<par name="RightTopColumnEdge" base_type="ctrl" dimension="0"/>
<par name="FitCircleCenterRow" base_type="ctrl" dimension="0"/>
<par name="FitCircleCenterCol" base_type="ctrl" dimension="0"/>
<par name="FitCircleCenterRadius" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c>* 生成基准矩形</c>
<l>gen_rectangle2 (Rect, CenterRow, CenterCol+BaseRectDistColumn, 0, 100, 50)</l>
<c>* 生成测量矩形</c>
<l>vector_angle_to_rigid (CenterRow, CenterCol, 0, CenterRow, CenterCol, BasePhi+RotatePhi, HomMat2D1)</l>
<l>affine_trans_region (Rect, RightTopRectAffineTrans, HomMat2D1, 'nearest_neighbor')</l>
<l>area_center (RightTopRectAffineTrans, RightTopRectArea, RightTopRectRow, RightTopRectColumn)</l>
<l>orientation_region (RightTopRectAffineTrans, RightTopRectPhi)</l>
<l>gen_measure_rectangle2 (RightTopRectRow, RightTopRectColumn, RightTopRectPhi, 100, 50, ImageWidth, ImageHeight, 'bicubic', MeasureHandle1)</l>
<c></c>
<l>vector_angle_to_rigid (CenterRow, CenterCol, 0, CenterRow, CenterCol, BasePhi+RotatePhi+rad(90), HomMat2D2)</l>
<l>affine_trans_region (Rect, LeftTopRectAffineTrans, HomMat2D2, 'nearest_neighbor')</l>
<l>area_center (LeftTopRectAffineTrans, LeftTopRectArea, LeftTopRectRow, LeftTopRectColumn)</l>
<l>orientation_region (LeftTopRectAffineTrans, LeftTopRectPhi)</l>
<l>gen_measure_rectangle2 (LeftTopRectRow, LeftTopRectColumn, LeftTopRectPhi, 100, 50, ImageWidth, ImageHeight, 'bicubic', MeasureHandle2)</l>
<c></c>
<l>vector_angle_to_rigid (CenterRow, CenterCol, 0, CenterRow, CenterCol, BasePhi+RotatePhi+rad(180), HomMat2D3)</l>
<l>affine_trans_region (Rect, LeftButtomRectAffineTrans, HomMat2D3, 'nearest_neighbor')</l>
<l>area_center (LeftButtomRectAffineTrans, LeftButtomRectArea, LeftButtomRectRow, LeftButtomRectColumn)</l>
<l>orientation_region (LeftButtomRectAffineTrans, LeftButtomRectPhi)</l>
<l>gen_measure_rectangle2 (LeftButtomRectRow, LeftButtomRectColumn, LeftButtomRectPhi, 100, 50, ImageWidth, ImageHeight, 'bicubic', MeasureHandle3)</l>
<c></c>
<l>vector_angle_to_rigid (CenterRow, CenterCol, 0, CenterRow, CenterCol, BasePhi+RotatePhi+rad(270), HomMat2D4)</l>
<l>affine_trans_region (Rect, RightButtomRectAffineTrans, HomMat2D4, 'nearest_neighbor')</l>
<l>area_center (RightButtomRectAffineTrans, RightButtomRectArea, RightButtomRectRow, RightButtomRectColumn)</l>
<l>orientation_region (RightButtomRectAffineTrans, RightButtomRectPhi)</l>
<l>gen_measure_rectangle2 (RightButtomRectRow, RightButtomRectColumn, RightButtomRectPhi, 100, 50, ImageWidth, ImageHeight, 'bicubic', MeasureHandle4)</l>
<c>* 抓取大圆四个边缘点</c>
<l>measure_pos (Image, MeasureHandle2, 1, 60, 'all', 'all', LeftTopRowEdge, LeftTopColumnEdge, LeftTopAmplitude, LeftTopDistance)</l>
<l>measure_pos (Image, MeasureHandle4, 1, 60, 'all', 'all', RightButtomRowEdge, RightButtomColumnEdge, RightButtomAmplitude, RightButtomDistance)</l>
<l>measure_pos (Image, MeasureHandle3, 1, 60, 'all', 'all', LeftButtomRowEdge, LeftButtomColumnEdge, LeftButtomAmplitude, LeftButtomDistance)</l>
<l>measure_pos (Image, MeasureHandle1, 1, 60, 'all', 'all', RightTopRowEdge, RightTopColumnEdge, RightTopAmplitude, RightTopDistance)</l>
<l>close_measure (MeasureHandle1)</l>
<l>close_measure (MeasureHandle2)</l>
<l>close_measure (MeasureHandle3)</l>
<l>close_measure (MeasureHandle4)</l>
<c>* 计算大圆直径</c>
<l>gen_contour_polygon_xld (BigCircleContour, [LeftTopRowEdge,RightButtomRowEdge,LeftButtomRowEdge,RightTopRowEdge], [LeftTopColumnEdge,RightButtomColumnEdge,LeftButtomColumnEdge,RightTopColumnEdge])</l>
<l>fit_circle_contour_xld (BigCircleContour, 'geometric', -1, 0, 0, 5, 2, FitCircleCenterRow, FitCircleCenterCol, FitCircleCenterRadius, FitCircleCenterStartPhi, FitCircleCenterEndPhi, FitCircleCenterPointOrder)</l>
<l>gen_circle (Circle, FitCircleCenterRow, FitCircleCenterCol, FitCircleCenterRadius)</l>
<l>return ()</l>
</body>
<docu id="gen_Edge_Circle">
<parameters>
<parameter id="BasePhi"/>
<parameter id="BaseRectDistColumn"/>
<parameter id="BaseRectDistRow"/>
<parameter id="CenterCol"/>
<parameter id="CenterRow"/>
<parameter id="Circle"/>
<parameter id="FitCircleCenterCol"/>
<parameter id="FitCircleCenterRadius"/>
<parameter id="FitCircleCenterRow"/>
<parameter id="Image"/>
<parameter id="ImageHeight"/>
<parameter id="ImageWidth"/>
<parameter id="LeftButtomColumnEdge"/>
<parameter id="LeftButtomRowEdge"/>
<parameter id="LeftTopColumnEdge"/>
<parameter id="LeftTopRowEdge"/>
<parameter id="RightButtomColumnEdge"/>
<parameter id="RightButtomRowEdge"/>
<parameter id="RightTopColumnEdge"/>
<parameter id="RightTopRowEdge"/>
<parameter id="RotatePhi"/>
</parameters>
</docu>
</procedure>
<procedure name="add_colormap_to_image" access="local">
<interface>
<io>
<par name="GrayValueImage" base_type="iconic" dimension="0"/>
<par name="Image" base_type="iconic" dimension="0"/>
</io>
<oo>
<par name="ColoredImage" base_type="iconic" dimension="0"/>
</oo>
<ic>
<par name="HeatmapColorScheme" base_type="ctrl" dimension="0"/>
</ic>
</interface>
<body>
<c>* </c>
<c>* This procedure adds a gray-value image to a RGB image with a chosen colormap.</c>
<c>* </c>
<l>get_image_type (GrayValueImage, Type)</l>
<c>* The image LUT needs a byte image. Rescale real images.</c>
<l>if (Type == 'real')</l>
<l>    scale_image_range (GrayValueImage, GrayValueImage, 0, 1)</l>
<l>    convert_image_type (GrayValueImage, GrayValueImage, 'byte')</l>
<l>elseif (Type != 'byte')</l>
<l>    throw ('For this transformation, a byte or real image is needed!')</l>
<l>endif</l>
<c>* </c>
<c>* Apply the chosen color scheme on the gray value.</c>
<l>apply_colorscheme_on_gray_value_image (GrayValueImage, RGBValueImage, HeatmapColorScheme)</l>
<c>* </c>
<c>* Convert input image to byte image for visualization.</c>
<l>image_to_channels (Image, Channels)</l>
<l>count_channels (Image, NumChannels)</l>
<l>gen_empty_obj (ChannelsScaled)</l>
<l>for ChannelIndex := 1 to NumChannels by 1</l>
<l>    select_obj (Channels, Channel, ChannelIndex)</l>
<l>    min_max_gray (Channel, Channel, 0, ChannelMin, ChannelMax, _)</l>
<l>    scale_image_range (Channel, ChannelScaled, ChannelMin, ChannelMax)</l>
<l>    convert_image_type (ChannelScaled, ChannelScaledByte, 'byte')</l>
<l>    concat_obj (ChannelsScaled, ChannelScaledByte, ChannelsScaled)</l>
<l>endfor</l>
<l>channels_to_image (ChannelsScaled, ImageByte)</l>
<c>* </c>
<c>* Note that ImageByte needs to have the same number of channels as</c>
<c>* RGBValueImage to display colormap image correctly.</c>
<l>count_channels (ImageByte, NumChannels)</l>
<l>if (NumChannels != 3)</l>
<c>    * Just take the first channel and use this to generate</c>
<c>    * an image with 3 channels for visualization.</c>
<l>    access_channel (ImageByte, ImageByteR, 1)</l>
<l>    copy_image (ImageByteR, ImageByteG)</l>
<l>    copy_image (ImageByteR, ImageByteB)</l>
<l>    compose3 (ImageByteR, ImageByteG, ImageByteB, ImageByte)</l>
<l>endif</l>
<c>* </c>
<l>add_image (ImageByte, RGBValueImage, RGBValueImage, 0.5, 0)</l>
<l>ColoredImage := RGBValueImage</l>
<c>* </c>
<l>return ()</l>
</body>
<docu id="add_colormap_to_image">
<parameters>
<parameter id="ColoredImage"/>
<parameter id="GrayValueImage"/>
<parameter id="HeatmapColorScheme"/>
<parameter id="Image"/>
</parameters>
</docu>
</procedure>
<procedure name="analyze_dl_dataset_detection" access="local">
<interface>
<ic>
<par name="DLDataset" base_type="ctrl" dimension="0"/>
<par name="InstanceType" base_type="ctrl" dimension="0"/>
<par name="ImageWidthRaw" base_type="ctrl" dimension="0"/>
<par name="ImageHeightRaw" base_type="ctrl" dimension="0"/>
<par name="ImageWidthTarget" base_type="ctrl" dimension="0"/>
<par name="ImageHeightTarget" base_type="ctrl" dimension="0"/>
<par name="DomainHandling" base_type="ctrl" dimension="0"/>
<par name="PreprocessedPath" base_type="ctrl" dimension="0"/>
<par name="DatasetSplit" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="Areas" base_type="ctrl" dimension="0"/>
<par name="AspectRatios" base_type="ctrl" dimension="0"/>
<par name="Angles" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c>* This procedure creates various data collections from the given DLDataset</c>
<c>* for DL Object Detection which are</c>
<c>* - the areas of the ground truth bounding boxes</c>
<c>* - the aspect ratios of the ground truth bounding boxes</c>
<c>* - the orientations of the ground truth bounding boxes for rectangle2 object detection.</c>
<c>* </c>
<c>* Output data tuples.</c>
<l>Areas := []</l>
<l>AspectRatios := []</l>
<l>Angles := []</l>
<c>* </c>
<c>* Bounding box parameters for rectangle1.</c>
<l>Rows1 := []</l>
<l>Cols1 := []</l>
<l>Rows2 := []</l>
<l>Cols2 := []</l>
<c>* Bounding box parameters for rectangle2.</c>
<l>Lengths1 := []</l>
<l>Lengths2 := []</l>
<l>Phis := []</l>
<c>* </c>
<c>* Check whether the input dataset is already preprocessed.</c>
<l>Preprocessed := false</l>
<l>if (PreprocessedPath != '')</l>
<l>    Preprocessed := true</l>
<l>else</l>
<c>    * Otherwise, check whether the necessary preprocessing parameters are provided.</c>
<l>    if (ImageWidthTarget == [] or ImageHeightTarget == [])</l>
<l>        throw ('Please enter values for the target image width and height.')</l>
<l>    elseif (ImageWidthTarget &lt; 1 or ImageHeightTarget &lt; 1)</l>
<l>        throw ('Please enter valid values for the target image width and height.')</l>
<l>    endif</l>
<c>    * In case the original images are of the same size (specified by the input</c>
<c>    * parameters), the scaling factors can be calculated here.</c>
<l>    if (ImageWidthRaw != [] and ImageHeightRaw != [])</l>
<l>        FactorWidth := real(ImageWidthTarget) / ImageWidthRaw</l>
<l>        FactorHeight := real(ImageHeightTarget) / ImageHeightRaw</l>
<l>    endif</l>
<l>endif</l>
<c>* </c>
<c>* Get the samples in the dataset.</c>
<l>get_dict_tuple (DLDataset, 'samples', DLSamples)</l>
<l>get_dict_tuple (DLDataset, 'image_dir', ImageDir)</l>
<c>* </c>
<c>* Get the relevant sample indices.</c>
<l>SampleIndices := [0:|DLSamples| - 1]</l>
<l>if (DatasetSplit != 'all')</l>
<l>    find_dl_samples (DLSamples, 'split', DatasetSplit, 'match', SampleIndices)</l>
<l>    if (|SampleIndices| == 0)</l>
<l>        throw ('No samples found for the specified dataset split: ' + DatasetSplit + '.')</l>
<l>    endif</l>
<l>endif</l>
<c>* </c>
<c>* Iterate over the samples and store information on the ground truth</c>
<c>* bounding boxes.</c>
<l>for IterationIndex := 0 to |SampleIndices| - 1 by 1</l>
<l>    DLSampleCurrent := []</l>
<l>    SampleIndex := SampleIndices[IterationIndex]</l>
<l>    if (Preprocessed)</l>
<c>        * Check whether the file name key of the preprocessed samples is available.</c>
<l>        get_dict_param (DLSamples[SampleIndex], 'key_exists', 'dlsample_file_name', KeyFileExists)</l>
<l>        if (KeyFileExists)</l>
<l>            get_dict_tuple (DLSamples[SampleIndex], 'dlsample_file_name', FileNameRelative)</l>
<l>            FileNameSample := PreprocessedPath + '/' + FileNameRelative</l>
<l>        else</l>
<c>            * If the key does not exist, check if a corresponding file exists.</c>
<l>            get_dict_tuple (DLSamples[SampleIndex], 'image_id', ImageID)</l>
<l>            FileNameRelative := ImageID + '_dlsample.hdict'</l>
<l>            FileNameSample := PreprocessedPath + '/' + FileNameRelative</l>
<l>        endif</l>
<c>        * Read the dictionary of the preprocessed sample.</c>
<l>        try</l>
<l>            read_dict (FileNameSample, [], [], DLSampleCurrent)</l>
<l>        catch (Exception)</l>
<l>            throw ('An error has occurred while reading ' + FileNameSample + ' , HALCON error # ' + Exception[0])</l>
<l>        endtry</l>
<c>        * Set the scaling factors to 1 since the samples are already preprocessed.</c>
<l>        FactorWidth := 1.</l>
<l>        FactorHeight := 1.</l>
<l>    else</l>
<c>        * In case the samples are not preprocessed, we need to scale them according</c>
<c>        * to the target image sizes as well as perform domain handling if necessary.</c>
<l>        DLSampleCurrent := DLSamples[SampleIndex]</l>
<c>        * The images need to be read in case the raw sizes are not provided or</c>
<c>        * the domain should be cropped.</c>
<l>        if (ImageWidthRaw == [] or ImageHeightRaw == [] or DomainHandling == 'crop_domain')</l>
<l>            get_dict_tuple (DLSamples[SampleIndex], 'image_file_name', ImageName)</l>
<l>            try</l>
<l>                read_image (Image, ImageDir + '/' + ImageName)</l>
<l>            catch (Exception)</l>
<l>                throw ('Error while reading image ' + ImageDir + '/' + ImageName + '.')</l>
<l>            endtry</l>
<l>        endif</l>
<c>        * In case the original images have variable sizes, the image</c>
<c>        * sizes need to be read in order to calculate the scaling factors.</c>
<l>        if (ImageWidthRaw == [] or ImageHeightRaw == [])</l>
<c>            * Read the image.</c>
<l>            get_image_size (Image, Width, Height)</l>
<c>            * Get the object sizes after preprocessing.</c>
<l>            FactorWidth := real(ImageWidthTarget) / Width</l>
<l>            FactorHeight := real(ImageHeightTarget) / Height</l>
<l>        endif</l>
<c>        * Get the domain borders if the domain should be cropped.</c>
<l>        if (DomainHandling == 'crop_domain')</l>
<c>            * Get domain.</c>
<l>            get_domain (Image, Domain)</l>
<c>            * Set the size of the raw image to the domain extensions.</c>
<l>            smallest_rectangle1 (Domain, RowDomain1, ColumnDomain1, RowDomain2, ColumnDomain2)</l>
<c>            * Get the object sizes after preprocessing.</c>
<l>            WidthDomain := ColumnDomain2 - ColumnDomain1 + 1</l>
<l>            HeightDomain := RowDomain2 - RowDomain1 + 1</l>
<l>            FactorWidth := real(ImageWidthTarget) / WidthDomain</l>
<l>            FactorHeight := real(ImageHeightTarget) / HeightDomain</l>
<l>        endif</l>
<l>    endif</l>
<c>    * </c>
<c>    * Collect ground truth information for instance type rectangle1.</c>
<l>    if (InstanceType == 'rectangle1')</l>
<c>        * Get the sample bounding boxes.</c>
<l>        try</l>
<l>            get_dict_tuple (DLSampleCurrent, 'bbox_row1', Row1)</l>
<l>            get_dict_tuple (DLSampleCurrent, 'bbox_col1', Col1)</l>
<l>            get_dict_tuple (DLSampleCurrent, 'bbox_row2', Row2)</l>
<l>            get_dict_tuple (DLSampleCurrent, 'bbox_col2', Col2)</l>
<l>        catch (Exception)</l>
<l>            throw ('Bounding box label missing for rectangle1 object detection.')</l>
<l>        endtry</l>
<c>        * Crop the bounding boxes if necessary.</c>
<l>        if (not Preprocessed and DomainHandling == 'crop_domain')</l>
<l>            Row1 := max2(Row1,RowDomain1 - .5)</l>
<l>            Col1 := max2(Col1,ColumnDomain1 - .5)</l>
<l>            Row2 := min2(Row2,RowDomain2 + .5)</l>
<l>            Col2 := min2(Col2,ColumnDomain2 + .5)</l>
<c>            * Remove empty boxes resulted from the clipping.</c>
<l>            BoxMask := (Row1 [&lt;] Row2) and (Col1 [&lt;] Col2)</l>
<l>            Row1 := select_mask(Row1,BoxMask) - RowDomain1</l>
<l>            Row2 := select_mask(Row2,BoxMask) - RowDomain1</l>
<l>            Col1 := select_mask(Col1,BoxMask) - ColumnDomain1</l>
<l>            Col2 := select_mask(Col2,BoxMask) - ColumnDomain1</l>
<l>        endif</l>
<c>        * Collect the scaled bounding box data.</c>
<l>        Rows1 := [Rows1,Row1 * FactorHeight]</l>
<l>        Rows2 := [Rows2,Row2 * FactorHeight]</l>
<l>        Cols1 := [Cols1,Col1 * FactorWidth]</l>
<l>        Cols2 := [Cols2,Col2 * FactorWidth]</l>
<c>        * Collect ground truth information for instance type rectangle2.</c>
<l>    elseif (InstanceType == 'rectangle2')</l>
<c>        * Get the sample bounding boxes.</c>
<l>        try</l>
<l>            get_dict_tuple (DLSampleCurrent, 'bbox_row', Row)</l>
<l>            get_dict_tuple (DLSampleCurrent, 'bbox_col', Col)</l>
<l>            get_dict_tuple (DLSampleCurrent, 'bbox_length1', Length1)</l>
<l>            get_dict_tuple (DLSampleCurrent, 'bbox_length2', Length2)</l>
<l>            get_dict_tuple (DLSampleCurrent, 'bbox_phi', Phi)</l>
<l>        catch (Exception)</l>
<l>            throw ('Bounding box label missing for rectangle2 object detection.')</l>
<l>        endtry</l>
<c>        * Crop the bounding boxes by removing boxes with centers outside</c>
<c>        * of the domain.</c>
<l>        if (not Preprocessed and DomainHandling == 'crop_domain')</l>
<l>            BoxMask := Row [&gt;=] RowDomain1 and Col [&gt;=] ColumnDomain1 and Row [&lt;] RowDomain2 and Col [&lt;] ColumnDomain2</l>
<c>            * Store the bounding boxes after the clipping.</c>
<l>            Row := select_mask(Row,BoxMask) - RowDomain1</l>
<l>            Col := select_mask(Col,BoxMask) - ColumnDomain1</l>
<l>            Length1 := select_mask(Length1,BoxMask)</l>
<l>            Length2 := select_mask(Length2,BoxMask)</l>
<l>            Phi := select_mask(Phi,BoxMask)</l>
<l>        endif</l>
<c>        * Get the scaled bounding box data.</c>
<l>        if (FactorHeight == FactorWidth)</l>
<c>            * In case the factors in both directions are the same, the scaling</c>
<c>            * is simple and Phi stays unchanged.</c>
<l>            Length1 := Length1 * FactorHeight</l>
<l>            Length2 := Length2 * FactorWidth</l>
<l>        else</l>
<c>            * In case the factors in both directions are not the same, the scaling</c>
<c>            * differs for the two directions.</c>
<l>            scale_rectangle2_bbox (Row, Col, Length1, Length2, Phi, FactorHeight, FactorWidth, NewRow, NewCol, NewLength1, NewLength2, NewPhi)</l>
<l>            Length1 := NewLength1</l>
<l>            Length2 := NewLength2</l>
<l>            Phi := NewPhi</l>
<l>        endif</l>
<c>        * Collect the scaled bounding box data.</c>
<l>        Lengths1 := [Lengths1,Length1]</l>
<l>        Lengths2 := [Lengths2,Length2]</l>
<l>        Phis := [Phis,Phi]</l>
<l>    else</l>
<l>        throw ('Wrong instance type for deep learning object detection.')</l>
<l>    endif</l>
<l>endfor</l>
<c>* </c>
<c>* Compute the areas and aspect ratios of all bounding boxes. Also set the</c>
<c>* output angles in case of rectangle2.</c>
<l>if (InstanceType == 'rectangle1')</l>
<l>    Heights := Rows2 - Rows1</l>
<l>    Widths := Cols2 - Cols1</l>
<l>    Areas := Heights * Widths</l>
<l>    AspectRatios := Heights / real(Widths)</l>
<l>elseif (InstanceType == 'rectangle2')</l>
<l>    Areas := 4 * Lengths1 * Lengths2</l>
<l>    AspectRatios := Lengths2 / real(Lengths1)</l>
<l>    Angles := Phis</l>
<l>endif</l>
<c>* </c>
<l>return ()</l>
</body>
<docu id="analyze_dl_dataset_detection">
<abstract lang="en_US">This procedure collects data concerning the shape of the ground truth bounding boxes provided in DLDataset for a detection model depending on the InstaceType. It returns the following tuples:
- Areas: the area of every bounding box
- AspectRatios: the aspect ratio of every bounding box. Thereby, the definition of the ratio depends on the 'InstanceType':
  -- 'rectangle1': height to width ratio
  -- 'rectangle2': length1 to length2 ratio
- Angles (only for InstanceType 'rectangle2'): orientation angle of every bounding box.

The collected data is based on the bounding boxes scaled to the target model image sizes (ImageWidthTarget and ImageHeightTarget). If the domain definition of the images should be considered, set DomainHandling to 'crop_domain'. Otherwise set this parameter to 'full_domain' to use the full images. If the raw images have the same size, it can be given by setting ImageWidthRaw and ImageHeightRaw. If the raw images do not have the same size, ImageWidthRaw and ImageHeightRaw should be set to [].

Already preprocessed datasets can also be processed (i.e. to optimize the procedure for speed up) and in this case, the specified image sizes are not used. To use a preprocessed DLDataset, the path to the directory containing the DLDataset and preprocessed samples needs to be specified with PreprocessedPath.

If the DLDataset has been divided into 'train', 'validation' and 'test' splits, the specific split can be selected via DatasetSplit.
</abstract>
<chapters lang="en_US">
<item>Deep Learning</item>
<item>Object Detection</item>
</chapters>
<library lang="en_US">MVTec Standard Procedures</library>
<short lang="en_US">This procedure collects data concerning the shape of the ground truth bounding boxes provided in DLDataset.</short>
<parameters>
<parameter id="Angles">
<default_type>real</default_type>
<description lang="en_US">Tuple of the collected rotation angles.</description>
<mixed_type>false</mixed_type>
<multivalue>optional</multivalue>
<sem_type>real</sem_type>
<type_list>
<item>real</item>
</type_list>
</parameter>
<parameter id="Areas">
<default_type>real</default_type>
<description lang="en_US">Tuple of the collected bounding box areas.</description>
<mixed_type>false</mixed_type>
<multivalue>optional</multivalue>
<sem_type>real</sem_type>
<type_list>
<item>real</item>
</type_list>
</parameter>
<parameter id="AspectRatios">
<default_type>real</default_type>
<description lang="en_US">Tuple of the collected aspect ratios.</description>
<mixed_type>false</mixed_type>
<multivalue>optional</multivalue>
<sem_type>real</sem_type>
<type_list>
<item>real</item>
</type_list>
</parameter>
<parameter id="DLDataset">
<default_type>integer</default_type>
<description lang="en_US">Dictionary containing the dataset, including the ground truth bounding box annotations.</description>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>dict</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="DatasetSplit">
<default_type>string</default_type>
<default_value>'train'</default_value>
<description lang="en_US">Dataset split to be used.</description>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>string</sem_type>
<type_list>
<item>string</item>
</type_list>
<values>
<item>'train'</item>
<item>'validation'</item>
<item>'test'</item>
</values>
</parameter>
<parameter id="DomainHandling">
<default_type>string</default_type>
<default_value>'full_domain'</default_value>
<description lang="en_US">Handling of the image domain.</description>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>string</sem_type>
<type_list>
<item>string</item>
</type_list>
<values>
<item>'full_domain'</item>
<item>'crop_domain'</item>
</values>
</parameter>
<parameter id="ImageHeightRaw">
<default_type>integer</default_type>
<default_value>[]</default_value>
<description lang="en_US">Height of the raw images.</description>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>integer</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="ImageHeightTarget">
<default_type>integer</default_type>
<description lang="en_US">Target height of the images.</description>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>integer</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="ImageWidthRaw">
<default_type>integer</default_type>
<default_value>[]</default_value>
<description lang="en_US">Width of the raw images.</description>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>integer</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="ImageWidthTarget">
<default_type>integer</default_type>
<description lang="en_US">Target width of the images.</description>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>integer</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="InstanceType">
<default_type>string</default_type>
<description lang="en_US">Instance type of object detection.</description>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>string</sem_type>
<type_list>
<item>string</item>
</type_list>
<values>
<item>'rectangle1'</item>
<item>'rectangle2'</item>
</values>
</parameter>
<parameter id="PreprocessedPath">
<default_type>string</default_type>
<description lang="en_US">Path to the preprocessing directory containing the DLDataset and preprocessed samples.</description>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>string</sem_type>
<type_list>
<item>string</item>
</type_list>
</parameter>
</parameters>
</docu>
</procedure>
<procedure name="analyze_graph_event" access="local">
<interface>
<io>
<par name="BackgroundImage" base_type="iconic" dimension="0"/>
</io>
<ic>
<par name="Parameters" base_type="ctrl" dimension="0"/>
<par name="MouseMapping" base_type="ctrl" dimension="0"/>
<par name="Button" base_type="ctrl" dimension="0"/>
<par name="Row" base_type="ctrl" dimension="0"/>
<par name="Column" base_type="ctrl" dimension="0"/>
<par name="WindowHandle" base_type="ctrl" dimension="0"/>
<par name="WindowHandleBuffer" base_type="ctrl" dimension="0"/>
<par name="VirtualTrackball" base_type="ctrl" dimension="0"/>
<par name="TrackballSize" base_type="ctrl" dimension="0"/>
<par name="SelectedObjectIn" base_type="ctrl" dimension="0"/>
<par name="Scene3D" base_type="ctrl" dimension="0"/>
<par name="AlphaOrig" base_type="ctrl" dimension="0"/>
<par name="ObjectModel3DID" base_type="ctrl" dimension="0"/>
<par name="CamParam" base_type="ctrl" dimension="0"/>
<par name="Labels" base_type="ctrl" dimension="0"/>
<par name="Title" base_type="ctrl" dimension="0"/>
<par name="Information" base_type="ctrl" dimension="0"/>
<par name="GenParamName" base_type="ctrl" dimension="0"/>
<par name="GenParamValue" base_type="ctrl" dimension="0"/>
<par name="PosesIn" base_type="ctrl" dimension="0"/>
<par name="ButtonHoldIn" base_type="ctrl" dimension="0"/>
<par name="TBCenter" base_type="ctrl" dimension="0"/>
<par name="TBSize" base_type="ctrl" dimension="0"/>
<par name="WindowCenteredRotationlIn" base_type="ctrl" dimension="0"/>
<par name="MaxNumModels" base_type="ctrl" dimension="0"/>
<par name="MessageQueue" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="PosesOut" base_type="ctrl" dimension="0"/>
<par name="SelectedObjectOut" base_type="ctrl" dimension="0"/>
<par name="ButtonHoldOut" base_type="ctrl" dimension="0"/>
<par name="WindowCenteredRotationOut" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c>* This procedure reflects</c>
<c>* - the pose change that was introduced by the user by</c>
<c>*   moving the mouse</c>
<c>* - the selection of a single object</c>
<c>* </c>
<l>ButtonHoldOut := ButtonHoldIn</l>
<l>PosesOut := PosesIn</l>
<l>SelectedObjectOut := SelectedObjectIn</l>
<l>WindowCenteredRotationOut := WindowCenteredRotationlIn</l>
<l>VisualizeTB := max(SelectedObjectOut) != 0</l>
<l>InvLog2 := 1.0 / log(2)</l>
<c>* </c>
<l>if (Button == MouseMapping[6])</l>
<l>    if (ButtonHoldOut)</l>
<l>        return ()</l>
<l>    endif</l>
<c>    * Ctrl (16) + Alt (32) + left mouse button (1) =&gt; Toggle rotation center position</c>
<c>    * If WindowCenteredRotation is not 1, set it to 1, otherwise, set it to 2</c>
<l>    count_seconds (Seconds)</l>
<l>    if (WindowCenteredRotationOut == 1)</l>
<l>        WindowCenteredRotationOut := 2</l>
<l>    else</l>
<l>        WindowCenteredRotationOut := 1</l>
<l>    endif</l>
<l>    ButtonHoldOut := true</l>
<l>    return ()</l>
<l>endif</l>
<l>if (Button == MouseMapping[5] and |ObjectModel3DID| &lt;= MaxNumModels)</l>
<l>    if (ButtonHoldOut)</l>
<l>        return ()</l>
<l>    endif</l>
<c>    * Ctrl (16) + left mouse button (1) =&gt; Select an object</c>
<l>    try</l>
<l>        set_scene_3d_param (Scene3D, 'object_index_persistence', 'true')</l>
<l>        display_scene_3d (WindowHandleBuffer, Scene3D, 0)</l>
<l>        get_display_scene_3d_info (WindowHandleBuffer, Scene3D, Row, Column, 'object_index', ModelIndex)</l>
<l>        set_scene_3d_param (Scene3D, 'object_index_persistence', 'false')</l>
<l>    catch (Exception1)</l>
<c>        * * NO OpenGL, no selection possible</c>
<l>        return ()</l>
<l>    endtry</l>
<l>    if (ModelIndex == -1)</l>
<c>        * Background click:</c>
<l>        if (sum(SelectedObjectOut) == |SelectedObjectOut|)</l>
<c>            * If all objects are already selected, deselect all</c>
<l>            SelectedObjectOut := gen_tuple_const(|ObjectModel3DID|,0)</l>
<l>        else</l>
<c>            * Otherwise select all</c>
<l>            SelectedObjectOut := gen_tuple_const(|ObjectModel3DID|,1)</l>
<l>        endif</l>
<l>    else</l>
<c>        * Object click:</c>
<l>        SelectedObjectOut[ModelIndex] := not SelectedObjectOut[ModelIndex]</l>
<l>    endif</l>
<l>    ButtonHoldOut := true</l>
<l>else</l>
<c>    * Change the pose</c>
<l>    hom_mat3d_identity (HomMat3DIdentity)</l>
<l>    NumModels := |ObjectModel3DID|</l>
<l>    get_cam_par_data (CamParam, 'image_width', Width)</l>
<l>    get_cam_par_data (CamParam, 'image_height', Height)</l>
<l>    MinImageSize := min([Width,Height])</l>
<l>    TrackballRadiusPixel := TrackballSize * MinImageSize / 2.0</l>
<c>    * Set trackball fixed in the center of the window</c>
<l>    TrackballCenterRow := Height / 2</l>
<l>    TrackballCenterCol := Width / 2</l>
<l>    if (|ObjectModel3DID| &lt; MaxNumModels)</l>
<l>        if (WindowCenteredRotationOut == 1)</l>
<l>            get_trackball_center_fixed (SelectedObjectIn, TrackballCenterRow, TrackballCenterCol, TrackballRadiusPixel, Scene3D, ObjectModel3DID, PosesIn, WindowHandleBuffer, CamParam, GenParamName, GenParamValue, TBCenter, TBSize)</l>
<l>        else</l>
<l>            get_trackball_center (SelectedObjectIn, TrackballRadiusPixel, ObjectModel3DID, PosesIn, TBCenter, TBSize)</l>
<l>        endif</l>
<l>    endif</l>
<l>    if (min(SelectedObjectOut) == 0 and max(SelectedObjectOut) == 1)</l>
<c>        * At this point, multiple objects do not necessary have the same</c>
<c>        * pose any more. Consequently, we have to return a tuple of poses</c>
<c>        * as output of visualize_object_model_3d</c>
<l>        gIsSinglePose := false</l>
<l>        set_message_tuple (Parameters, 'gIsSinglePose', gIsSinglePose)</l>
<l>    endif</l>
<l>    count_channels (BackgroundImage, NumChannels)</l>
<l>    ColorImage := NumChannels == 3</l>
<c>    * Alt (32) =&gt; lower sensitivity</c>
<l>    tuple_rsh (Button, 5, BAnd)</l>
<l>    if (BAnd % 2)</l>
<l>        SensFactor := 0.1</l>
<l>    else</l>
<l>        SensFactor := 1.0</l>
<l>    endif</l>
<l>    IsButtonTrans := MouseMapping[0] == Button or (32 + MouseMapping[0]) == Button</l>
<l>    IsButtonRot := MouseMapping[1] == Button or (32 + MouseMapping[1]) == Button</l>
<l>    IsButtonDist := MouseMapping[2] == Button or (32 + MouseMapping[2]) == Button or MouseMapping[3] == Button or (32 + MouseMapping[3]) == Button or MouseMapping[4] == Button or (32 + MouseMapping[4]) == Button</l>
<l>    if (IsButtonTrans)</l>
<c>        * Translate in XY-direction</c>
<l>        MRow1 := Row</l>
<l>        MCol1 := Column</l>
<l>        while (IsButtonTrans)</l>
<l>            try</l>
<l>                get_mouse_info (WindowHandle, MessageQueue, [], Row, Column, ButtonLoop)</l>
<l>                IsButtonTrans := ButtonLoop == Button</l>
<l>                MRow2 := MRow1 + (Row - MRow1) * SensFactor</l>
<l>                MCol2 := MCol1 + (Column - MCol1) * SensFactor</l>
<l>                get_line_of_sight (MRow1, MCol1, CamParam, PX, PY, PZ, QX1, QY1, QZ1)</l>
<l>                get_line_of_sight (MRow2, MCol2, CamParam, PX, PY, PZ, QX2, QY2, QZ2)</l>
<l>                Len := sqrt(QX1 * QX1 + QY1 * QY1 + QZ1 * QZ1)</l>
<l>                Dist := sqrt(TBCenter[0] * TBCenter[0] + TBCenter[1] * TBCenter[1] + TBCenter[2] * TBCenter[2])</l>
<l>                Translate := [QX2 - QX1,QY2 - QY1,QZ2 - QZ1] * Dist / Len</l>
<l>                PosesOut := []</l>
<l>                if (NumModels &lt;= MaxNumModels)</l>
<l>                    for Index := 0 to NumModels - 1 by 1</l>
<l>                        PoseIn := PosesIn[Index * 7:Index * 7 + 6]</l>
<l>                        if (SelectedObjectOut[Index])</l>
<l>                            pose_to_hom_mat3d (PoseIn, HomMat3DIn)</l>
<l>                            hom_mat3d_translate (HomMat3DIn, Translate[0], Translate[1], Translate[2], HomMat3DOut)</l>
<l>                            hom_mat3d_to_pose (HomMat3DOut, PoseOut)</l>
<l>                            set_scene_3d_instance_pose (Scene3D, Index, PoseOut)</l>
<l>                        else</l>
<l>                            PoseOut := PoseIn</l>
<l>                        endif</l>
<l>                        PosesOut := [PosesOut,PoseOut]</l>
<l>                    endfor</l>
<l>                else</l>
<l>                    tuple_find (SelectedObjectOut, 1, Indices)</l>
<l>                    PoseIn := PosesIn[Indices[0] * 7:Indices[0] * 7 + 6]</l>
<l>                    pose_to_hom_mat3d (PoseIn, HomMat3DIn)</l>
<l>                    hom_mat3d_translate (HomMat3DIn, Translate[0], Translate[1], Translate[2], HomMat3DOut)</l>
<l>                    hom_mat3d_to_pose (HomMat3DOut, PoseOut)</l>
<l>                    Sequence := [0:NumModels * 7 - 1]</l>
<l>                    tuple_mod (Sequence, 7, Mod)</l>
<l>                    SequenceReal := [0:1.0 / 7.0:NumModels - (1.0 / 7.0)]</l>
<l>                    Sequence2Int := int(SequenceReal)</l>
<l>                    tuple_select (SelectedObjectOut, Sequence2Int, Selected)</l>
<l>                    InvSelected := 1 - Selected</l>
<l>                    tuple_select (PoseOut, Mod, PosesOut)</l>
<l>                    PosesOut := PosesOut * Selected + PosesIn * InvSelected</l>
<l>                    set_scene_3d_instance_pose (Scene3D, [0:NumModels - 1], PosesOut)</l>
<l>                endif</l>
<l>                dump_image_output (BackgroundImage, Parameters, WindowHandleBuffer, Scene3D, AlphaOrig, ObjectModel3DID, GenParamName, GenParamValue, CamParam, PosesOut, ColorImage, Title, Information, Labels, VisualizeTB, 'true', TrackballCenterRow, TrackballCenterCol, TBSize, SelectedObjectOut, WindowCenteredRotationOut == 1, TBCenter, [], [], [], [])</l>
<l>                dump_window_image (ImageDump, WindowHandleBuffer)</l>
<l>*                 dev_set_window (WindowHandle)</l>
<l>*                 dev_display (ImageDump)</l>
<l>                disp_obj (ImageDump, WindowHandle)</l>
<l>                send_pose_update (Parameters, PosesOut)</l>
<c>                * </c>
<l>                MRow1 := Row</l>
<l>                MCol1 := Column</l>
<l>                PosesIn := PosesOut</l>
<l>            catch (Exception)</l>
<c>                * Keep waiting</c>
<l>            endtry</l>
<l>        endwhile</l>
<l>    elseif (IsButtonDist)</l>
<c>        * Change the Z distance</c>
<l>        MRow1 := Row</l>
<l>        while (IsButtonDist)</l>
<l>            try</l>
<l>                get_mouse_info (WindowHandle, MessageQueue, [], Row, Column, ButtonLoop)</l>
<l>                IsButtonDist := ButtonLoop == Button</l>
<l>                MRow2 := Row</l>
<l>                DRow := MRow2 - MRow1</l>
<l>                Dist := sqrt(TBCenter[0] * TBCenter[0] + TBCenter[1] * TBCenter[1] + TBCenter[2] * TBCenter[2])</l>
<l>                TranslateZ := -Dist * DRow * 0.003 * SensFactor</l>
<l>                TBCenter[2] := TBCenter[2] + TranslateZ</l>
<l>                PosesOut := []</l>
<l>                if (NumModels &lt;= MaxNumModels)</l>
<l>                    for Index := 0 to NumModels - 1 by 1</l>
<l>                        PoseIn := PosesIn[Index * 7:Index * 7 + 6]</l>
<l>                        if (SelectedObjectOut[Index])</l>
<c>                            * Transform the whole scene or selected object only</c>
<l>                            pose_to_hom_mat3d (PoseIn, HomMat3DIn)</l>
<l>                            hom_mat3d_translate (HomMat3DIn, 0, 0, TranslateZ, HomMat3DOut)</l>
<l>                            hom_mat3d_to_pose (HomMat3DOut, PoseOut)</l>
<l>                            set_scene_3d_instance_pose (Scene3D, Index, PoseOut)</l>
<l>                        else</l>
<l>                            PoseOut := PoseIn</l>
<l>                        endif</l>
<l>                        PosesOut := [PosesOut,PoseOut]</l>
<l>                    endfor</l>
<l>                else</l>
<l>                    tuple_find (SelectedObjectOut, 1, Indices)</l>
<l>                    PoseIn := PosesIn[Indices[0] * 7:Indices[0] * 7 + 6]</l>
<l>                    pose_to_hom_mat3d (PoseIn, HomMat3DIn)</l>
<l>                    hom_mat3d_translate (HomMat3DIn, 0, 0, TranslateZ, HomMat3DOut)</l>
<l>                    hom_mat3d_to_pose (HomMat3DOut, PoseOut)</l>
<l>                    Sequence := [0:NumModels * 7 - 1]</l>
<l>                    tuple_mod (Sequence, 7, Mod)</l>
<l>                    SequenceReal := [0:1.0 / 7.0:NumModels - (1.0 / 7.0)]</l>
<l>                    Sequence2Int := int(SequenceReal)</l>
<l>                    tuple_select (SelectedObjectOut, Sequence2Int, Selected)</l>
<l>                    InvSelected := 1 - Selected</l>
<l>                    tuple_select (PoseOut, Mod, PosesOut)</l>
<l>                    PosesOut := PosesOut * Selected + PosesIn * InvSelected</l>
<l>                    set_scene_3d_instance_pose (Scene3D, [0:NumModels - 1], PosesOut)</l>
<l>                endif</l>
<l>                dump_image_output (BackgroundImage, Parameters, WindowHandleBuffer, Scene3D, AlphaOrig, ObjectModel3DID, GenParamName, GenParamValue, CamParam, PosesOut, ColorImage, Title, Information, Labels, VisualizeTB, 'true', TrackballCenterRow, TrackballCenterCol, TBSize, SelectedObjectOut, WindowCenteredRotationOut, TBCenter, [], [], [], [])</l>
<l>                dump_window_image (ImageDump, WindowHandleBuffer)</l>
<l>*                 dev_set_window (WindowHandle)</l>
<l>*                 dev_display (ImageDump)</l>
<l>                disp_obj (ImageDump, WindowHandle)</l>
<l>                send_pose_update (Parameters, PosesOut)</l>
<c>                * </c>
<l>                MRow1 := Row</l>
<l>                PosesIn := PosesOut</l>
<l>            catch (Exception)</l>
<c>                * Keep waiting</c>
<l>            endtry</l>
<l>        endwhile</l>
<l>    elseif (IsButtonRot)</l>
<c>        * Rotate the object</c>
<l>        MRow1 := Row</l>
<l>        MCol1 := Column</l>
<l>        while (IsButtonRot)</l>
<l>            try</l>
<l>                get_mouse_info (WindowHandle, MessageQueue, [], Row, Column, ButtonLoop)</l>
<l>                IsButtonRot := ButtonLoop == Button</l>
<l>                MRow2 := Row</l>
<l>                MCol2 := Column</l>
<c>                * Transform the pixel coordinates to relative image coordinates</c>
<l>                MX1 := (TrackballCenterCol - MCol1) / (0.5 * MinImageSize)</l>
<l>                MY1 := (TrackballCenterRow - MRow1) / (0.5 * MinImageSize)</l>
<l>                MX2 := (TrackballCenterCol - MCol2) / (0.5 * MinImageSize)</l>
<l>                MY2 := (TrackballCenterRow - MRow2) / (0.5 * MinImageSize)</l>
<c>                * Compute the quaternion rotation that corresponds to the mouse</c>
<c>                * movement</c>
<l>                trackball (MX1, MY1, MX2, MY2, VirtualTrackball, TrackballSize, SensFactor, RelQuaternion)</l>
<c>                * Transform the quaternion to a rotation matrix</c>
<l>                quat_to_hom_mat3d (RelQuaternion, HomMat3DRotRel)</l>
<l>                PosesOut := []</l>
<l>                if (NumModels &lt;= MaxNumModels)</l>
<l>                    for Index := 0 to NumModels - 1 by 1</l>
<l>                        PoseIn := PosesIn[Index * 7:Index * 7 + 6]</l>
<l>                        if (SelectedObjectOut[Index])</l>
<c>                            * Transform the whole scene or selected object only</c>
<l>                            pose_to_hom_mat3d (PoseIn, HomMat3DIn)</l>
<l>                            hom_mat3d_translate (HomMat3DIn, -TBCenter[0], -TBCenter[1], -TBCenter[2], HomMat3DIn)</l>
<l>                            hom_mat3d_compose (HomMat3DRotRel, HomMat3DIn, HomMat3DIn)</l>
<l>                            hom_mat3d_translate (HomMat3DIn, TBCenter[0], TBCenter[1], TBCenter[2], HomMat3DOut)</l>
<l>                            hom_mat3d_to_pose (HomMat3DOut, PoseOut)</l>
<l>                            set_scene_3d_instance_pose (Scene3D, Index, PoseOut)</l>
<l>                        else</l>
<l>                            PoseOut := PoseIn</l>
<l>                        endif</l>
<l>                        PosesOut := [PosesOut,PoseOut]</l>
<l>                    endfor</l>
<l>                else</l>
<l>                    tuple_find (SelectedObjectOut, 1, Indices)</l>
<l>                    PoseIn := PosesIn[Indices[0] * 7:Indices[0] * 7 + 6]</l>
<l>                    pose_to_hom_mat3d (PoseIn, HomMat3DIn)</l>
<l>                    hom_mat3d_translate (HomMat3DIn, -TBCenter[0], -TBCenter[1], -TBCenter[2], HomMat3DInTmp1)</l>
<l>                    hom_mat3d_compose (HomMat3DRotRel, HomMat3DInTmp1, HomMat3DInTmp)</l>
<l>                    hom_mat3d_translate (HomMat3DInTmp, TBCenter[0], TBCenter[1], TBCenter[2], HomMat3DOut)</l>
<l>                    hom_mat3d_to_pose (HomMat3DOut, PoseOut)</l>
<l>                    Sequence := [0:NumModels * 7 - 1]</l>
<l>                    tuple_mod (Sequence, 7, Mod)</l>
<l>                    SequenceReal := [0:1.0 / 7.0:NumModels - (1.0 / 7.0)]</l>
<l>                    Sequence2Int := int(SequenceReal)</l>
<l>                    tuple_select (SelectedObjectOut, Sequence2Int, Selected)</l>
<l>                    InvSelected := 1 - Selected</l>
<l>                    tuple_select (PoseOut, Mod, PosesOut)</l>
<l>                    PosesOut2 := PosesOut * Selected + PosesIn * InvSelected</l>
<l>                    PosesOut := PosesOut2</l>
<l>                    set_scene_3d_instance_pose (Scene3D, [0:NumModels - 1], PosesOut)</l>
<l>                endif</l>
<l>                dump_image_output (BackgroundImage, Parameters, WindowHandleBuffer, Scene3D, AlphaOrig, ObjectModel3DID, GenParamName, GenParamValue, CamParam, PosesOut, ColorImage, Title, Information, Labels, VisualizeTB, 'true', TrackballCenterRow, TrackballCenterCol, TBSize, SelectedObjectOut, WindowCenteredRotationOut, TBCenter, [], [], [], [])</l>
<l>                dump_window_image (ImageDump, WindowHandleBuffer)</l>
<l>*                 dev_set_window (WindowHandle)</l>
<l>*                 dev_display (ImageDump)</l>
<l>                disp_obj (ImageDump, WindowHandle)</l>
<l>                send_pose_update (Parameters, PosesOut)</l>
<c>                * </c>
<l>                MRow1 := Row</l>
<l>                MCol1 := Column</l>
<l>                PosesIn := PosesOut</l>
<l>            catch (Exception)</l>
<c>                * Keep waiting</c>
<l>            endtry</l>
<l>        endwhile</l>
<l>    endif</l>
<l>    PosesOut := PosesIn</l>
<l>endif</l>
<l>return ()</l>
</body>
<docu id="analyze_graph_event">
<chapters lang="de_DE">
<item>Graphik</item>
<item>Ausgabe</item>
</chapters>
<chapters lang="en_US">
<item>Graphics</item>
<item>Output</item>
</chapters>
<library lang="en_US">MVTec Standard Procedures</library>
<short lang="en_US">Reflect the pose change that was introduced by the user by moving the mouse</short>
<parameters>
<parameter id="AlphaOrig"/>
<parameter id="BackgroundImage"/>
<parameter id="Button"/>
<parameter id="ButtonHoldIn"/>
<parameter id="ButtonHoldOut"/>
<parameter id="CamParam"/>
<parameter id="Column"/>
<parameter id="GenParamName"/>
<parameter id="GenParamValue"/>
<parameter id="Information"/>
<parameter id="Labels"/>
<parameter id="MaxNumModels"/>
<parameter id="MessageQueue">
<default_type>integer</default_type>
<mixed_type>false</mixed_type>
<sem_type>message_queue</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="MouseMapping"/>
<parameter id="ObjectModel3DID"/>
<parameter id="Parameters">
<default_type>integer</default_type>
<mixed_type>false</mixed_type>
<sem_type>message</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="PosesIn"/>
<parameter id="PosesOut"/>
<parameter id="Row"/>
<parameter id="Scene3D"/>
<parameter id="SelectedObjectIn"/>
<parameter id="SelectedObjectOut"/>
<parameter id="TBCenter"/>
<parameter id="TBSize"/>
<parameter id="Title"/>
<parameter id="TrackballSize"/>
<parameter id="VirtualTrackball"/>
<parameter id="WindowCenteredRotationOut"/>
<parameter id="WindowCenteredRotationlIn"/>
<parameter id="WindowHandle">
<default_type>integer</default_type>
<mixed_type>false</mixed_type>
<sem_type>window</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="WindowHandleBuffer">
<default_type>integer</default_type>
<mixed_type>false</mixed_type>
<sem_type>window</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
</parameters>
</docu>
</procedure>
<procedure name="append_length_or_values">
<interface>
<ic>
<par name="Mode" base_type="ctrl" dimension="0"/>
<par name="Feature" base_type="ctrl" dimension="0"/>
<par name="AccumulatedResults" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="ExtendedResults" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c>* </c>
<c>* Auxiliary procedure used only by get_features and get_custom_features</c>
<c>* </c>
<l>if (Mode == 'get_lengths')</l>
<c>    * Output in 'get_lengths' mode is the length of the feature</c>
<l>    ExtendedResults := [AccumulatedResults,|Feature|]</l>
<l>elseif (Mode == 'calculate')</l>
<c>    * Output in 'calculate' mode is the feature vector</c>
<l>    ExtendedResults := [AccumulatedResults,Feature]</l>
<l>else</l>
<l>    ExtendedResults := AccumulatedResults</l>
<l>endif</l>
<l>return ()</l>
</body>
<docu id="append_length_or_values">
<abstract lang="en_US">This procedure is an auxiliary procedure for the get_custom_features and get_features procedures.
Please do not use it in other contexts.

For more information about the usage of the get_feature_set library, see documentation of calculate_features.

See documentation of get_custom_features for details on how to integrate user-defined features into this library.</abstract>
<chapters lang="de_DE">
<item>Klassifikation</item>
<item>Sonstiges</item>
</chapters>
<chapters lang="en_US">
<item>Classification</item>
<item>Misc</item>
</chapters>
<library lang="en_US">MVTec Standard Procedures</library>
<short lang="en_US">Auxiliary procedure for get_custom_features and get_features.</short>
<parameters>
<parameter id="AccumulatedResults">
<description lang="en_US">Accumulated results from get_features.</description>
<multivalue>optional</multivalue>
</parameter>
<parameter id="ExtendedResults">
<default_type>real</default_type>
<description lang="en_US">The accumulated results extended by the feature vector or its length.</description>
</parameter>
<parameter id="Feature">
<description lang="en_US">Current feature vector.</description>
<multivalue>optional</multivalue>
<sem_type>number</sem_type>
</parameter>
<parameter id="Mode">
<default_type>string</default_type>
<description lang="en_US">Processing mode.</description>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>string</sem_type>
<type_list>
<item>string</item>
</type_list>
<value_list>
<item>'get_names'</item>
<item>'get_lengths'</item>
<item>'get_groups'</item>
<item>'calculate'</item>
</value_list>
</parameter>
</parameters>
</docu>
</procedure>
<procedure name="append_names_or_groups">
<interface>
<ic>
<par name="Mode" base_type="ctrl" dimension="0"/>
<par name="Name" base_type="ctrl" dimension="0"/>
<par name="Groups" base_type="ctrl" dimension="0"/>
<par name="CurrentName" base_type="ctrl" dimension="0"/>
<par name="AccumulatedResults" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="ExtendedResults" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c>* </c>
<c>* Auxiliary procedure used only by get_features and get_custom_features</c>
<c>* </c>
<l>ExtendedResults := AccumulatedResults</l>
<l>if (Mode == 'get_names')</l>
<l>    FirstOccurrence := |AccumulatedResults| == 0 or find(AccumulatedResults,Name) == -1</l>
<l>    BelongsToGroup := find([Name,Groups],CurrentName) != -1 or CurrentName == 'all'</l>
<l>    if (FirstOccurrence and BelongsToGroup)</l>
<c>        * Output in 'get_names' mode is the name of the feature</c>
<l>        ExtendedResults := [AccumulatedResults,Name]</l>
<l>    endif</l>
<l>elseif (Mode == 'get_groups')</l>
<l>    ExtendedResults := [AccumulatedResults,Groups]</l>
<l>endif</l>
<l>return ()</l>
</body>
<docu id="append_names_or_groups">
<abstract lang="en_US">This procedure is an auxiliary procedure for the get_custom_features and get_features procedures. Please do not use it in other contexts.

For more information about the usage of the get_feature_set library, see documentation of calculate_features.

See documentation of get_custom_features for details on how to integrate user-defined features into this library.</abstract>
<chapters lang="de_DE">
<item>Klassifikation</item>
<item>Sonstiges</item>
</chapters>
<chapters lang="en_US">
<item>Classification</item>
<item>Misc</item>
</chapters>
<library lang="en_US">MVTec Standard Procedures</library>
<short lang="en_US">Auxiliary procedure for get_custom_features and get_features.</short>
<parameters>
<parameter id="AccumulatedResults">
<description lang="en_US">Accumulated results from get_features.</description>
<multivalue>optional</multivalue>
</parameter>
<parameter id="CurrentName">
<default_type>string</default_type>
<description lang="en_US">Current feature or group name.</description>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>string</sem_type>
<type_list>
<item>string</item>
</type_list>
</parameter>
<parameter id="ExtendedResults">
<default_type>string</default_type>
<description lang="en_US">The accumulated results extended by the feature name or the feature groups.</description>
<mixed_type>false</mixed_type>
<multivalue>optional</multivalue>
<sem_type>string</sem_type>
<type_list>
<item>string</item>
</type_list>
</parameter>
<parameter id="Groups">
<default_type>string</default_type>
<description lang="en_US">Feature group names.</description>
<mixed_type>false</mixed_type>
<multivalue>optional</multivalue>
<sem_type>string</sem_type>
<type_list>
<item>string</item>
</type_list>
</parameter>
<parameter id="Mode">
<default_type>string</default_type>
<description lang="en_US">Processing mode.</description>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>string</sem_type>
<type_list>
<item>string</item>
</type_list>
<value_list>
<item>'get_names'</item>
<item>'get_lengths'</item>
<item>'get_groups'</item>
<item>'calculate'</item>
</value_list>
</parameter>
<parameter id="Name">
<default_type>string</default_type>
<description lang="en_US">Feature name.</description>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>string</sem_type>
<type_list>
<item>string</item>
</type_list>
</parameter>
</parameters>
</docu>
</procedure>
<procedure name="append_names_or_groups_pyramid">
<interface>
<ic>
<par name="Mode" base_type="ctrl" dimension="0"/>
<par name="Groups" base_type="ctrl" dimension="0"/>
<par name="CurrentName" base_type="ctrl" dimension="0"/>
<par name="Names" base_type="ctrl" dimension="0"/>
<par name="NameRegExp" base_type="ctrl" dimension="0"/>
<par name="AccumulatedResults" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="ExtendedResults" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c>* </c>
<c>* Auxiliary procedure used only by get_features and get_custom_features</c>
<c>* </c>
<l>ExtendedResults := AccumulatedResults</l>
<l>if (Mode == 'get_names')</l>
<l>    BelongsToGroup := find(Groups,CurrentName) != -1 or CurrentName == 'all'</l>
<l>    if (CurrentName =~ NameRegExp)</l>
<l>        Names := CurrentName</l>
<l>    elseif (not BelongsToGroup)</l>
<l>        Names := []</l>
<l>    endif</l>
<l>    TmpNames := []</l>
<l>    for J := 0 to |Names| - 1 by 1</l>
<l>        FirstOccurrence := |AccumulatedResults| == 0 or find(AccumulatedResults,Names[J]) == -1</l>
<l>        if (FirstOccurrence)</l>
<c>            * Output in 'get_names' mode is the name of the feature</c>
<l>            TmpNames := [TmpNames,Names[J]]</l>
<l>        endif</l>
<l>    endfor</l>
<l>    ExtendedResults := [AccumulatedResults,TmpNames]</l>
<l>elseif (Mode == 'get_groups')</l>
<l>    ExtendedResults := [AccumulatedResults,Groups]</l>
<l>endif</l>
<l>return ()</l>
</body>
<docu id="append_names_or_groups_pyramid">
<abstract lang="en_US">This procedure is an auxiliary procedure for the get_custom_features and get_features procedures. Please do not use it in other contexts.

For more information about the usage of the get_feature_set library, see documentation of calculate_features.

See documentation of get_custom_features for details on how to integrate user-defined features into this library.</abstract>
<chapters lang="de_DE">
<item>Klassifikation</item>
<item>Sonstiges</item>
</chapters>
<chapters lang="en_US">
<item>Classification</item>
<item>Misc</item>
</chapters>
<library lang="en_US">MVTec Standard Procedures</library>
<short lang="en_US">Auxiliary procedure for get_features.</short>
<parameters>
<parameter id="AccumulatedResults">
<description lang="en_US">Accumulated results from get_features.</description>
</parameter>
<parameter id="CurrentName">
<default_type>string</default_type>
<description lang="en_US">Current feature or group name.</description>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>string</sem_type>
<type_list>
<item>string</item>
</type_list>
</parameter>
<parameter id="ExtendedResults">
<default_type>string</default_type>
<description lang="en_US">The accumulated results depending on the mode extended by the feature names or the feature groups.</description>
<mixed_type>false</mixed_type>
<multivalue>optional</multivalue>
<sem_type>string</sem_type>
<type_list>
<item>string</item>
</type_list>
</parameter>
<parameter id="Groups">
<default_type>string</default_type>
<description lang="en_US">Feature group names.</description>
<mixed_type>false</mixed_type>
<multivalue>optional</multivalue>
<sem_type>string</sem_type>
<type_list>
<item>string</item>
</type_list>
</parameter>
<parameter id="Mode">
<default_type>string</default_type>
<description lang="en_US">Processing mode.</description>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>string</sem_type>
<type_list>
<item>string</item>
</type_list>
<value_list>
<item>'get_names'</item>
<item>'get_lengths'</item>
<item>'get_groups'</item>
<item>'calculate'</item>
</value_list>
</parameter>
<parameter id="NameRegExp">
<default_type>string</default_type>
<description lang="en_US">Regular expression that describes the feature names.</description>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>string</sem_type>
<type_list>
<item>string</item>
</type_list>
</parameter>
<parameter id="Names">
<default_type>string</default_type>
<description lang="en_US">Feature names.</description>
<mixed_type>false</mixed_type>
<multivalue>true</multivalue>
<sem_type>string</sem_type>
<type_list>
<item>string</item>
</type_list>
</parameter>
</parameters>
</docu>
</procedure>
<procedure name="apply_brightness_variation_spot" access="local">
<interface>
<io>
<par name="Image" base_type="iconic" dimension="0"/>
</io>
<oo>
<par name="ImageSpot" base_type="iconic" dimension="0"/>
</oo>
<ic>
<par name="SpotSize" base_type="ctrl" dimension="0"/>
<par name="SpotRow" base_type="ctrl" dimension="0"/>
<par name="SpotColumn" base_type="ctrl" dimension="0"/>
<par name="BrightnessVariation" base_type="ctrl" dimension="0"/>
</ic>
</interface>
<body>
<c>* This procedure applies a brightness spot</c>
<c>* of a given intensity and size at a given location</c>
<c>* to the input image.</c>
<c>* The modified image is returned in ImageSpot.</c>
<c>* </c>
<l>if (BrightnessVariation &lt; 0)</l>
<l>    Direction := 0</l>
<l>    BrightnessVariation := -BrightnessVariation</l>
<l>else</l>
<l>    Direction := 1</l>
<l>endif</l>
<l>get_image_size (Image, Width, Height)</l>
<c>* Generate Gauss filter that simulates an illumination spot of size 'SpotSize'.</c>
<l>gen_gauss_filter (Filter, 1, 1, 0, 'none', 'dc_center', SpotSize, SpotSize)</l>
<c>* Shift the filter image to the given position.</c>
<l>ShiftRow := -(SpotSize / 2 - SpotRow)</l>
<l>ShiftCol := -(SpotSize / 2 - SpotColumn)</l>
<l>tile_images_offset (Filter, GaussImage, ShiftRow, ShiftCol, -1, -1, -1, -1, Width, Height)</l>
<l>full_domain (GaussImage, GaussFilter)</l>
<c>* Convert Gauss filter to target image type and apply brightness variation.</c>
<l>get_image_type (Image, Type)</l>
<l>scale_image (GaussFilter, Gauss, BrightnessVariation, 0)</l>
<l>convert_image_type (Gauss, GaussTargetType, Type)</l>
<c>* Add channels to fit input image.</c>
<l>count_channels (Image, NChannels)</l>
<l>copy_obj (GaussTargetType, AddImage, 1, 1)</l>
<l>for Index1 := 1 to NChannels - 1 by 1</l>
<l>    append_channel (AddImage, GaussTargetType, AddImage)</l>
<l>endfor</l>
<c>* Apply on image.</c>
<l>if (Direction)</l>
<l>    add_image (Image, AddImage, ImageSpot, 1, 0)</l>
<l>else</l>
<l>    sub_image (Image, AddImage, ImageSpot, 1, 0)</l>
<l>endif</l>
<l>return ()</l>
</body>
<docu id="apply_brightness_variation_spot">
<chapters lang="en_US">
<item>Image</item>
<item>Manipulation</item>
</chapters>
<library lang="en_US">MVTec Standard Procedures</library>
<parameters>
<parameter id="BrightnessVariation"/>
<parameter id="Image"/>
<parameter id="ImageSpot"/>
<parameter id="SpotColumn"/>
<parameter id="SpotRow"/>
<parameter id="SpotSize"/>
</parameters>
</docu>
</procedure>
<procedure name="apply_colorscheme_on_gray_value_image">
<interface>
<io>
<par name="InputImage" base_type="iconic" dimension="0"/>
</io>
<oo>
<par name="ResultImage" base_type="iconic" dimension="0"/>
</oo>
<ic>
<par name="Schema" base_type="ctrl" dimension="0"/>
</ic>
</interface>
<body>
<c>* </c>
<c>* This procedure generates an RGB ResultImage for a grey-value InputImage.</c>
<c>* In order to do so, create a color distribution as look up table</c>
<c>* according to the Schema.</c>
<c>* </c>
<l>X := [0:255]</l>
<l>tuple_gen_const (256, 0, Low)</l>
<l>tuple_gen_const (256, 255, High)</l>
<c>* </c>
<l>if (Schema == 'jet')</l>
<c>    * Scheme Jet: from blue to red</c>
<l>    OffR := 3.0 * 64.0</l>
<l>    OffG := 2.0 * 64.0</l>
<l>    OffB := 64.0</l>
<l>    A1 := -4.0</l>
<l>    A0 := 255.0 + 128.0</l>
<l>    R := min2(max2(abs(X - OffR) * A1 + A0,Low),High)</l>
<l>    G := min2(max2(abs(X - OffG) * A1 + A0,Low),High)</l>
<l>    B := min2(max2(abs(X - OffB) * A1 + A0,Low),High)</l>
<c>    * </c>
<l>elseif (Schema == 'inverse_jet')</l>
<c>    * Scheme InvJet: from red to blue.</c>
<l>    OffR := 64</l>
<l>    OffG := 2 * 64</l>
<l>    OffB := 3 * 64</l>
<l>    A1 := -4.0</l>
<l>    A0 := 255.0 + 128.0</l>
<l>    R := min2(max2(abs(X - OffR) * A1 + A0,Low),High)</l>
<l>    G := min2(max2(abs(X - OffG) * A1 + A0,Low),High)</l>
<l>    B := min2(max2(abs(X - OffB) * A1 + A0,Low),High)</l>
<c>    * </c>
<l>elseif (Schema == 'hot')</l>
<c>    * Scheme Hot.</c>
<l>    A1 := 3.0</l>
<l>    A0R := 0.0</l>
<l>    A0G := 1.0 / 3.0 * A1 * 255.0</l>
<l>    A0B := 2.0 / 3.0 * A1 * 255.0</l>
<l>    R := min2(max2(X * A1 - A0R,Low),High)</l>
<l>    G := min2(max2(X * A1 - A0G,Low),High)</l>
<l>    B := min2(max2(X * A1 - A0B,Low),High)</l>
<c>    * </c>
<l>elseif (Schema == 'inverse_hot')</l>
<c>    * Scheme Inverse Hot.</c>
<l>    A1 := -3.0</l>
<l>    A0R := A1 * 255.0</l>
<l>    A0G := 2.0 / 3.0 * A1 * 255.0</l>
<l>    A0B := 1.0 / 3.0 * A1 * 255.0</l>
<l>    R := min2(max2(X * A1 - A0R,Low),High)</l>
<l>    G := min2(max2(X * A1 - A0G,Low),High)</l>
<l>    B := min2(max2(X * A1 - A0B,Low),High)</l>
<c>    * </c>
<l>else</l>
<c>    * </c>
<l>    throw ('Unknown color schema: ' + Schema + '.')</l>
<c>    * </c>
<l>endif</l>
<c>* </c>
<l>lut_trans (InputImage, ImageR, R)</l>
<l>lut_trans (InputImage, ImageG, G)</l>
<l>lut_trans (InputImage, ImageB, B)</l>
<l>compose3 (ImageR, ImageG, ImageB, ResultImage)</l>
<c>* </c>
<l>return ()</l>
</body>
<docu id="apply_colorscheme_on_gray_value_image">
<abstract lang="en_US">This procedure converts the pixel values of the grey-scale InputImage into a color image ResultImage.
In order to do so, a lookup table according to the specified Schema is created.

Note: The images are assumed to be byte images, thus having a range [0,255].</abstract>
<library lang="en_US">MVTec Standard Procedures</library>
<short lang="en_US">Create a lookup table and convert a grey scale image.</short>
<parameters>
<parameter id="InputImage">
<description lang="en_US">Byte image whose gray values are to be displayed in color.</description>
<multichannel>false</multichannel>
<multivalue>false</multivalue>
<sem_type>image</sem_type>
<type_list>
<item>byte</item>
</type_list>
</parameter>
<parameter id="ResultImage">
<description lang="en_US">RGB image.</description>
<multichannel>true</multichannel>
<multivalue>false</multivalue>
<sem_type>image</sem_type>
<type_list>
<item>byte</item>
</type_list>
</parameter>
<parameter id="Schema">
<description lang="en_US">Color scheme defining the created LUT.</description>
<multivalue>false</multivalue>
<sem_type>string</sem_type>
</parameter>
</parameters>
</docu>
</procedure>
<procedure name="apply_dl_classifier_batchwise">
<interface>
<ic>
<par name="ImageFiles" base_type="ctrl" dimension="0"/>
<par name="DLClassifierHandle" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="DLClassifierResultIDs" base_type="ctrl" dimension="0"/>
<par name="PredictedClasses" base_type="ctrl" dimension="1"/>
<par name="Confidences" base_type="ctrl" dimension="1"/>
</oc>
</interface>
<body>
<c>* This procedure classifies the images given as paths</c>
<c>* by ImageFiles using the operator apply_dl_classifier.</c>
<c>* To avoid that the main memory is overloaded, the images</c>
<c>* are classified batchwise, according to the hyperparameter 'batch_size',</c>
<c>* which is stored in the DLClassifierHandle.</c>
<c>* As result, the classification result handles for every batch</c>
<c>* are returned in DLClassifierResultIDs.</c>
<c>* Additionally, for every image the descending sorted</c>
<c>* Confidences and corresponding PredictedClasses</c>
<c>* are returned as vectors.</c>
<c>* </c>
<c>* Get batch size from handle.</c>
<l>get_dl_classifier_param (DLClassifierHandle, 'batch_size', BatchSize)</l>
<c>* </c>
<c>* Check the input parameters.</c>
<l>if (|ImageFiles| &lt; 1)</l>
<l>    throw ('ImageFiles must not be empty.')</l>
<l>endif</l>
<c>* </c>
<c>* Sequence is used for easier indexing of the images.</c>
<l>NumImages := |ImageFiles|</l>
<l>Sequence := [0:NumImages - 1]</l>
<c>* </c>
<c>* Loop through all selected images.</c>
<l>PredictedClasses := {}</l>
<l>Confidences := {}</l>
<l>DLClassifierResultIDs := []</l>
<l>for BatchStartIndex := 0 to NumImages - 1 by BatchSize</l>
<c>    * Select the data for the current batch.</c>
<l>    BatchIndices := Sequence[BatchStartIndex:min2(BatchStartIndex + BatchSize - 1,NumImages - 1)]</l>
<l>    BatchImageFiles := ImageFiles[BatchIndices]</l>
<c>    * Read the current batch images.</c>
<l>    read_image (BatchImages, BatchImageFiles)</l>
<c>    * Apply the classifier for this batch.</c>
<l>    try</l>
<l>        apply_dl_classifier (BatchImages, DLClassifierHandle, DLClassifierResultID)</l>
<l>    catch (Exception)</l>
<l>        if (sum(Exception[0] [==] [2106,2107,3122,9001,9003]))</l>
<l>            throw ('Images need to fulfill the network requirements, please provide preprocessed images.')</l>
<l>        else</l>
<l>            throw (Exception)</l>
<l>        endif</l>
<l>    endtry</l>
<c>    * Get results from result handle.</c>
<l>    NumImagesInBatch := |BatchImageFiles|</l>
<l>    for Index := 0 to NumImagesInBatch - 1 by 1</l>
<l>        get_dl_classifier_result (DLClassifierResultID, Index, 'predicted_classes', PredictedClass)</l>
<l>        get_dl_classifier_result (DLClassifierResultID, Index, 'confidences', ClassConfidence)</l>
<c>        * Store the classification results.</c>
<l>        VectorIndex := BatchStartIndex + Index</l>
<l>        PredictedClasses.at(VectorIndex) := PredictedClass</l>
<l>        Confidences.at(VectorIndex) := ClassConfidence</l>
<l>    endfor</l>
<l>    DLClassifierResultIDs := [DLClassifierResultIDs,DLClassifierResultID]</l>
<l>endfor</l>
<l>return ()</l>
</body>
<docu id="apply_dl_classifier_batchwise">
<abstract lang="en_US">This procedure classifies the images given as paths by ImageFiles using the operator apply_dl_classifier. To avoid that the main memory is overloaded, the images are classified batchwise, according to the hyperparameter 'batch_size', which is stored in the DLClassifierHandle. As result, the classification result handles for every batch are returned in DLClassifierResultIDs. Additionally, for every image a tuple with the ascending sorted Confidences and corresponding PredictedClasses are returned in the vectors of that name. 

The tuples in the output vectors PredictedClasses and Confidences are sorted in the same order as the input ImageFiles. The read ImageFiles must already be preprocessed as specified by the network (see rerence entry of read_dl_classifier). If there was a custom preprocessing during training, this preprocessing should have been applied to the read images as well.

The result handles DLClassifierResultIDs can be passed on to the procedure evaluate_dl_classifier, to get evaluation measures of the classifier performance. If you use apply_dl_classifier_batchwise and evaluate_dl_classifier during training to evaluate the training progress, you might want to reduce the amount of data handed over to save runtime. The latter can be achieved using the procedure select_percentage_dl_classifier_data.

This procedure returns a handle. This handle should be cleared using clear_dl_result when it is not needed anymore, to free the allocated memory.</abstract>
<chapters lang="en_US">
<item>Legacy</item>
<item>DL Classification</item>
</chapters>
<library lang="en_US">MVTec Standard Procedures</library>
<short lang="en_US">Return the classification results for the given images.</short>
<warning lang="en_US">apply_dl_classifier_batchwise is obsolete and is only provided for reasons of backward compatibility.
New applications should use the general CNN-based procedure train_dl_model_batch.</warning>
<parameters>
<parameter id="Confidences">
<default_type>real</default_type>
<description lang="en_US">The confidences belonging to the PredictedClasses.</description>
<mixed_type>false</mixed_type>
<multivalue>optional</multivalue>
<sem_type>real</sem_type>
<type_list>
<item>real</item>
</type_list>
</parameter>
<parameter id="DLClassifierHandle">
<default_type>integer</default_type>
<description lang="en_US">Handle of the deep-learning-based classifier.</description>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>dl_classifier</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="DLClassifierResultIDs">
<default_type>integer</default_type>
<description lang="en_US">The tuple of result handles (respective results of apply_dl_classifier).</description>
<mixed_type>false</mixed_type>
<multivalue>optional</multivalue>
<sem_type>dl_classifier_result</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="ImageFiles">
<default_type>string</default_type>
<description lang="en_US">Tuple of the image paths.</description>
<mixed_type>false</mixed_type>
<multivalue>optional</multivalue>
<sem_type>string</sem_type>
<type_list>
<item>string</item>
</type_list>
</parameter>
<parameter id="PredictedClasses">
<default_type>string</default_type>
<description lang="en_US">The classes predicted from the classifier.</description>
<mixed_type>false</mixed_type>
<multivalue>optional</multivalue>
<sem_type>string</sem_type>
<type_list>
<item>string</item>
</type_list>
</parameter>
</parameters>
</docu>
</procedure>
<procedure name="area_iou" access="local">
<interface>
<ic>
<par name="Sample" base_type="ctrl" dimension="0"/>
<par name="Result" base_type="ctrl" dimension="0"/>
<par name="InstanceType" base_type="ctrl" dimension="0"/>
<par name="ResultSortIndices" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="SampleArea" base_type="ctrl" dimension="0"/>
<par name="ResultArea" base_type="ctrl" dimension="0"/>
<par name="IoU" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c>* </c>
<c>* Compute the intersection over union (IoU) between</c>
<c>* the ground truth and the inferred bounding box of the object instances.</c>
<c>* The bounding box type is determined over the InstanceType.</c>
<c>* </c>
<l>if (InstanceType == 'rectangle1')</l>
<c>    * Get bounding box coordinates.</c>
<l>    get_dict_tuple (Sample, 'bbox_row1', GtRow1)</l>
<l>    get_dict_tuple (Sample, 'bbox_col1', GtCol1)</l>
<l>    get_dict_tuple (Sample, 'bbox_row2', GtRow2)</l>
<l>    get_dict_tuple (Sample, 'bbox_col2', GtCol2)</l>
<l>    get_dict_tuple (Result, 'bbox_row1', ResRow1)</l>
<l>    get_dict_tuple (Result, 'bbox_col1', ResCol1)</l>
<l>    get_dict_tuple (Result, 'bbox_row2', ResRow2)</l>
<l>    get_dict_tuple (Result, 'bbox_col2', ResCol2)</l>
<c>    * </c>
<c>    * Sort the results.</c>
<l>    ResRow1 := ResRow1[ResultSortIndices]</l>
<l>    ResCol1 := ResCol1[ResultSortIndices]</l>
<l>    ResRow2 := ResRow2[ResultSortIndices]</l>
<l>    ResCol2 := ResCol2[ResultSortIndices]</l>
<c>    * </c>
<c>    * Compute areas.</c>
<l>    SampleArea := (GtRow2 - GtRow1) * (GtCol2 - GtCol1)</l>
<l>    ResultArea := (ResRow2 - ResRow1) * (ResCol2 - ResCol1)</l>
<c>    * </c>
<c>    * Compute IoUs.</c>
<l>    IoU := gen_tuple_const(|GtRow1| * |ResRow1|,0)</l>
<l>    if (|IoU| &gt; 0)</l>
<l>        for GtIdx := 0 to |GtRow1| - 1 by 1</l>
<l>            Height := min2(GtRow2[GtIdx],ResRow2) - max2(GtRow1[GtIdx],ResRow1)</l>
<l>            Width := min2(GtCol2[GtIdx],ResCol2) - max2(GtCol1[GtIdx],ResCol1)</l>
<l>            ValidIdxs := find(Height [&gt;] 0 and Width [&gt;] 0,1)</l>
<l>            if (ValidIdxs &gt; -1)</l>
<l>                Intersection := Height[ValidIdxs] * Width[ValidIdxs]</l>
<l>                Union := SampleArea[GtIdx] + ResultArea[ValidIdxs] - Intersection</l>
<l>                IoU[GtIdx * |ResRow1| + ValidIdxs] := real(Intersection) / Union</l>
<l>            endif</l>
<l>        endfor</l>
<l>    endif</l>
<l>elseif (InstanceType == 'rectangle2')</l>
<c>    * Get bounding box coordinates.</c>
<l>    get_dict_tuple (Sample, 'bbox_row', GtRow)</l>
<l>    get_dict_tuple (Sample, 'bbox_col', GtCol)</l>
<l>    get_dict_tuple (Sample, 'bbox_length1', GtLength1)</l>
<l>    get_dict_tuple (Sample, 'bbox_length2', GtLength2)</l>
<l>    get_dict_tuple (Sample, 'bbox_phi', GtPhi)</l>
<l>    get_dict_tuple (Result, 'bbox_row', ResRow)</l>
<l>    get_dict_tuple (Result, 'bbox_col', ResCol)</l>
<l>    get_dict_tuple (Result, 'bbox_length1', ResLength1)</l>
<l>    get_dict_tuple (Result, 'bbox_length2', ResLength2)</l>
<l>    get_dict_tuple (Result, 'bbox_phi', ResPhi)</l>
<c>    * </c>
<c>    * Sort results.</c>
<l>    ResRow := ResRow[ResultSortIndices]</l>
<l>    ResCol := ResCol[ResultSortIndices]</l>
<l>    ResLength1 := ResLength1[ResultSortIndices]</l>
<l>    ResLength2 := ResLength2[ResultSortIndices]</l>
<l>    ResPhi := ResPhi[ResultSortIndices]</l>
<c>    * </c>
<c>    * Compute Areas.</c>
<l>    SampleArea := 4.0 * GtLength1 * GtLength2</l>
<l>    ResultArea := 4.0 * ResLength1 * ResLength2</l>
<c>    * </c>
<c>    * Compute IoUs.</c>
<l>    IoU := gen_tuple_const(|GtRow| * |ResRow|,0)</l>
<l>    if (|IoU| &gt; 0)</l>
<l>        for GtIdx := 0 to |GtRow| - 1 by 1</l>
<l>            ValidIdxs := find(SampleArea[GtIdx] [&gt;] 0 and ResultArea [&gt;] 0,1)</l>
<l>            if (ValidIdxs &gt; -1)</l>
<l>                area_intersection_rectangle2 (GtRow[GtIdx], GtCol[GtIdx], GtPhi[GtIdx], GtLength1[GtIdx], GtLength2[GtIdx], ResRow[ValidIdxs], ResCol[ValidIdxs], ResPhi[ValidIdxs], ResLength1[ValidIdxs], ResLength2[ValidIdxs], Intersection)</l>
<l>                Union := SampleArea[GtIdx] + ResultArea[ValidIdxs] - Intersection</l>
<l>                IoU[GtIdx * |ResRow| + ValidIdxs] := real(Intersection) / Union</l>
<l>            endif</l>
<l>        endfor</l>
<l>    endif</l>
<l>else</l>
<l>    throw ('Instance type \'' + InstanceType + '\' is not supported')</l>
<l>endif</l>
<l>return ()</l>
</body>
<docu id="area_iou">
<abstract lang="en_US">Calculate the areas and intersection over union (IoU) for the given bounding boxes of a sample.
The sample and its object instances with their ground truth bounding boxes is given by Sample (a DLSample dictionary).
Result is the dictionary of the results obtained for this sample.
InstanceType specifies the type of bounding box used for the object instances belonging to the sample.
ResultSortIndices specifies, how to sort the results (e.g. according to descending confidence values).

The procedure returns the following values. 
SampleArea gives the areas of the ground truth object instances for the sample.
ResultArea gives the areas of the object instances for the sample.
IoU gives the intersection over union for each object instance of a Sample with each (sorted) Result instance.
The IoU of the instance i with result instance j is given in the entry i*(number of results)+j.
</abstract>
<chapters lang="de_DE">
<item>Deep Learning</item>
<item>Evaluierung</item>
</chapters>
<chapters lang="en_US">
<item>Deep Learning</item>
<item>Evaluation</item>
</chapters>
<library lang="en_US">MVTec Standard Procedures</library>
<parameters>
<parameter id="InstanceType">
<default_value>'rectangle1'</default_value>
<description lang="en_US">The type of bounding box used for the object instances.</description>
<sem_type>string</sem_type>
<value_list>
<item>'rectangle1'</item>
<item>'rectangle2'</item>
</value_list>
</parameter>
<parameter id="IoU">
<default_type>real</default_type>
<description lang="en_US">Tuple containing the IoU for each instance of a Sample with each (sorted) Result instance.</description>
<sem_type>any</sem_type>
<type_list>
<item>real</item>
</type_list>
</parameter>
<parameter id="Result">
<default_type>integer</default_type>
<default_value>Result</default_value>
<description lang="en_US">Dictionary with the results for the sample given in Sample.</description>
<mixed_type>false</mixed_type>
<sem_type>dict</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="ResultArea">
<default_type>real</default_type>
<description lang="en_US">Tuple containing the areas of all object instances given in Result, sorted by ResultSortIndices.</description>
<sem_type>any</sem_type>
<type_list>
<item>real</item>
</type_list>
</parameter>
<parameter id="ResultSortIndices">
<default_type>integer</default_type>
<description lang="en_US">The index order to sort the Result object instances.</description>
<sem_type>any</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="Sample">
<default_type>integer</default_type>
<default_value>Sample</default_value>
<description lang="en_US">Dictionary DLSample, containing the ground truth information of the given sample.</description>
<mixed_type>false</mixed_type>
<sem_type>dict</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="SampleArea">
<default_type>real</default_type>
<description lang="en_US">Tuple containing the areas of all object instances given in Sample.</description>
<sem_type>any</sem_type>
<type_list>
<item>real</item>
</type_list>
</parameter>
</parameters>
</docu>
</procedure>
<procedure name="augment_dl_samples">
<interface>
<ic>
<par name="DLSampleBatch" base_type="ctrl" dimension="0"/>
<par name="GenParam" base_type="ctrl" dimension="0"/>
</ic>
</interface>
<body>
<c>* </c>
<c>* This procedure chooses random samples in the DLSampleBatch</c>
<c>* and modifies them in order to augment the dataset.</c>
<c>* The augmentation method has to be specified</c>
<c>* using the dictionary GenParam.</c>
<c>* </c>
<c>* If no augmentation parameter is given we return directly and the samples stay unchanged.</c>
<l>if (|GenParam| == 0)</l>
<l>    return ()</l>
<l>endif</l>
<c>* </c>
<c>* ** Set the default values: ***</c>
<c>* </c>
<c>* The percentage of the images that are to be augmented.</c>
<l>AugmentationPercentage := ['augmentation_percentage',50]</l>
<c>* Step size for possible rotations.</c>
<l>Rotation := ['rotate',0]</l>
<c>* Allowed mirroring types are coded by 'r' (row), 'c' (column).</c>
<l>Mirror := ['mirror','off']</l>
<c>* The absolute brightness change can vary in the range [-value, +value].</c>
<l>BrightnessVariation := ['brightness_variation',0]</l>
<c>* The absolute brightness peak of a randomly positioned spot can vary in the range [-value, +value].</c>
<l>BrightnessVariationSpot := ['brightness_variation_spot',0]</l>
<c>* </c>
<c>* In case of a classification model there are more augmentation types.</c>
<c>* Fraction of image length and width that remains after cropping (in %).</c>
<l>CropPercentage := ['crop_percentage','off']</l>
<c>* Image length and width that remains after cropping (in pixel).</c>
<l>CropPixel := ['crop_pixel','off']</l>
<c>* Step range for rotations with step size 1.</c>
<l>RotationRange := ['rotate_range',0]</l>
<c>* </c>
<c>* In case of a detection model of instance_type 'rectangle2': Use directions of instances within bounding boxes.</c>
<l>IgnoreDirection := ['ignore_direction',false]</l>
<c>* In case of a detection model of instance_type 'rectangle2': Class IDs without orientation.</c>
<l>ClassIDsNoOrientationExist := ['class_ids_no_orientation',false]</l>
<l>ClassIDsNoOrientation := []</l>
<c>* ** Set user-defined parameters: ***</c>
<c>* </c>
<l>get_dict_param (GenParam, 'key_exists', AugmentationPercentage[0], AugmentationPercentageExists)</l>
<l>get_dict_param (GenParam, 'key_exists', Rotation[0], RotationExists)</l>
<l>get_dict_param (GenParam, 'key_exists', Mirror[0], MirrorExists)</l>
<l>get_dict_param (GenParam, 'key_exists', BrightnessVariation[0], BrightnessVariationExists)</l>
<l>get_dict_param (GenParam, 'key_exists', BrightnessVariationSpot[0], BrightnessVariationSpotExists)</l>
<l>get_dict_param (GenParam, 'key_exists', CropPercentage[0], CropPercentageExists)</l>
<l>get_dict_param (GenParam, 'key_exists', CropPixel[0], CropPixelExists)</l>
<l>get_dict_param (GenParam, 'key_exists', RotationRange[0], RotationRangeExists)</l>
<l>get_dict_param (GenParam, 'key_exists', IgnoreDirection[0], IgnoreDirectionExists)</l>
<l>get_dict_param (GenParam, 'key_exists', ClassIDsNoOrientationExist[0], ClassIDsNoOrientationExists)</l>
<c>* </c>
<l>if (AugmentationPercentageExists)</l>
<c>    * Set augmentation percentage.</c>
<l>    get_dict_tuple (GenParam, AugmentationPercentage[0], CurrentParamValue)</l>
<l>    AugmentationPercentage[1] := CurrentParamValue</l>
<c>    * Check if input value is in range of 0-100 %.</c>
<l>    Exception := 'The given value for augmentation_percentage has to be in the range 0-100.'</l>
<l>    if (is_number(CurrentParamValue))</l>
<l>        if (CurrentParamValue &lt; 0 or CurrentParamValue &gt; 100)</l>
<l>            throw (Exception)</l>
<l>        endif</l>
<l>    else</l>
<l>        throw (Exception)</l>
<l>    endif</l>
<l>endif</l>
<c>* If nothing should be augmented we return immediately.</c>
<l>if (AugmentationPercentage[1] == 0)</l>
<l>    return ()</l>
<l>endif</l>
<l>if (RotationExists)</l>
<c>    * Set rotation.</c>
<l>    get_dict_tuple (GenParam, Rotation[0], CurrentParamValue)</l>
<l>    Rotation[1] := CurrentParamValue</l>
<c>    * Check if the input value is either 0, 90, or 180.</c>
<l>    Exception := 'The value given for rotation has to be either 0, 90, or 180.'</l>
<l>    if (is_number(CurrentParamValue))</l>
<l>        if (find([0,90,180],CurrentParamValue) == -1)</l>
<l>            throw (Exception)</l>
<l>        endif</l>
<l>    else</l>
<l>        throw (Exception)</l>
<l>    endif</l>
<l>endif</l>
<l>if (MirrorExists)</l>
<c>    * Set mirroring.</c>
<l>    get_dict_tuple (GenParam, Mirror[0], CurrentParamValue)</l>
<l>    Mirror[1] := CurrentParamValue</l>
<c>    * Check if the input is a string and contains either 'off' or the mirroring code.</c>
<l>    if (is_number(CurrentParamValue) or not (CurrentParamValue == 'off' or CurrentParamValue == 'c' or CurrentParamValue == 'r' or CurrentParamValue == 'cr' or CurrentParamValue == 'rc'))</l>
<l>        throw ('Unknown type for mirroring.')</l>
<l>    endif</l>
<l>endif</l>
<l>if (BrightnessVariationExists)</l>
<c>    * Set brightness variation.</c>
<l>    get_dict_tuple (GenParam, BrightnessVariation[0], CurrentParamValue)</l>
<l>    BrightnessVariation[1] := CurrentParamValue</l>
<c>    * Check if the input value is in range of 0-255.</c>
<l>    Exception := 'The given value for brightness_variation has to be in the range 0-255.'</l>
<l>    if (is_number(CurrentParamValue))</l>
<l>        if (CurrentParamValue &lt; 0 or CurrentParamValue &gt; 255)</l>
<l>            throw (Exception)</l>
<l>        endif</l>
<l>    else</l>
<l>        throw (Exception)</l>
<l>    endif</l>
<l>endif</l>
<l>if (BrightnessVariationSpotExists)</l>
<c>    * Set brightness variation spot.</c>
<l>    get_dict_tuple (GenParam, BrightnessVariationSpot[0], CurrentParamValue)</l>
<l>    BrightnessVariationSpot[1] := CurrentParamValue</l>
<c>    * Check if the input value is in range of 0-255.</c>
<l>    Exception := 'The given value for brightness_variation_spot has to be in the range 0-255.'</l>
<l>    if (is_number(CurrentParamValue))</l>
<l>        if (CurrentParamValue &lt; 0 or CurrentParamValue &gt; 255)</l>
<l>            throw (Exception)</l>
<l>        endif</l>
<l>    else</l>
<l>        throw (Exception)</l>
<l>    endif</l>
<l>endif</l>
<l>if (CropPercentageExists)</l>
<c>    * Set cropping with percentage.</c>
<l>    get_dict_tuple (GenParam, CropPercentage[0], CurrentParamValue)</l>
<l>    CropPercentage[1] := CurrentParamValue</l>
<c>    * Check if the input value is in range of 1-100%.</c>
<l>    Exception := 'The given value for crop_percentage has to be in the range 1-100.'</l>
<l>    if (is_number(CurrentParamValue))</l>
<l>        if (CurrentParamValue &lt; 1 or CurrentParamValue &gt; 100)</l>
<l>            throw (Exception)</l>
<l>        endif</l>
<l>    else</l>
<l>        throw (Exception)</l>
<l>    endif</l>
<l>endif</l>
<l>if (CropPixelExists)</l>
<c>    * Set cropping with pixels.</c>
<l>    get_dict_tuple (GenParam, CropPixel[0], CurrentParamValue)</l>
<l>    CropPixel[1] := CurrentParamValue</l>
<c>    * Check if the input value is greater 0.</c>
<l>    Exception := 'The given value for crop_pixel has to be greater or equal to 1.'</l>
<l>    if (is_number(CurrentParamValue))</l>
<l>        if (CurrentParamValue &lt; 1)</l>
<l>            throw (Exception)</l>
<l>        endif</l>
<l>    else</l>
<l>        throw (Exception)</l>
<l>    endif</l>
<l>endif</l>
<l>if (RotationRangeExists)</l>
<c>    * Set brightness variation.</c>
<l>    get_dict_tuple (GenParam, RotationRange[0], CurrentParamValue)</l>
<l>    RotationRange[1] := CurrentParamValue</l>
<c>    * Check if the input value is in range of 0-255.</c>
<l>    Exception := 'The given value for brightness_variation has to be in the range 0-255.'</l>
<l>    if (is_number(CurrentParamValue))</l>
<l>        if (CurrentParamValue &lt; 0 or CurrentParamValue &gt; 255)</l>
<l>            throw (Exception)</l>
<l>        endif</l>
<l>    else</l>
<l>        throw (Exception)</l>
<l>    endif</l>
<l>endif</l>
<l>if (IgnoreDirectionExists)</l>
<c>    * Set if the direction is to be ignored or not.</c>
<l>    get_dict_tuple (GenParam, IgnoreDirection[0], CurrentParamValue)</l>
<l>    IgnoreDirection[1] := CurrentParamValue</l>
<l>    Exception := 'The value given for ignore_direction has to be either \'true\',\'false\', true or false.'</l>
<l>    if (find(['true','false',true,false],IgnoreDirection[1]) == -1)</l>
<l>        throw (Exception)</l>
<l>    endif</l>
<l>    if (CurrentParamValue == 'false')</l>
<l>        IgnoreDirection[1] := false</l>
<l>    elseif (CurrentParamValue == 'true')</l>
<l>        IgnoreDirection[1] := true</l>
<l>    endif</l>
<l>endif</l>
<l>if (ClassIDsNoOrientationExists)</l>
<c>    * Set the IDs of the classes, for whose instances the orientation is not to be considered.</c>
<l>    get_dict_tuple (GenParam, ClassIDsNoOrientationExist[0], CurrentParamValue)</l>
<l>    ClassIDsNoOrientationExist[1] := CurrentParamValue != []</l>
<l>    if (CurrentParamValue != [])</l>
<l>        ClassIDsNoOrientation := CurrentParamValue</l>
<l>    endif</l>
<l>endif</l>
<c>* </c>
<c>* Aggregate all possible distortions and parameter values into a vector.</c>
<c>* </c>
<l>AvailableDistortions := {}</l>
<c>* Rotation with a given angular step size.</c>
<l>if (Rotation[1] &gt; 0)</l>
<l>    AvailableDistortions.at(AvailableDistortions.length()) := Rotation</l>
<l>endif</l>
<c>* Mirroring is allowed in row and column direction.</c>
<l>if (Mirror[1] =~ 'r' or Mirror[1] =~ 'c')</l>
<l>    AvailableDistortions.at(AvailableDistortions.length()) := Mirror</l>
<l>endif</l>
<c>* Brightness variation.</c>
<l>if (BrightnessVariation[1] &gt; 0)</l>
<l>    AvailableDistortions.at(AvailableDistortions.length()) := BrightnessVariation</l>
<l>endif</l>
<c>* Brightness variation spot.</c>
<l>if (BrightnessVariationSpot[1] &gt; 0)</l>
<l>    AvailableDistortions.at(AvailableDistortions.length()) := BrightnessVariationSpot</l>
<l>endif</l>
<c>* Cropping percentage.</c>
<l>if (is_number(CropPercentage[1]))</l>
<l>    AvailableDistortions.at(AvailableDistortions.length()) := CropPercentage</l>
<l>endif</l>
<c>* Cropping pixels.</c>
<l>if (is_number(CropPixel[1]))</l>
<l>    AvailableDistortions.at(AvailableDistortions.length()) := CropPixel</l>
<l>endif</l>
<c>* Rotation within a given range (step size 1).</c>
<l>if (RotationRange[1] &gt; 0)</l>
<l>    AvailableDistortions.at(AvailableDistortions.length()) := RotationRange</l>
<l>endif</l>
<c>* </c>
<c>* ** Choose random samples and augmentation methods: ***</c>
<c>* </c>
<c>* Number of samples to be augmented.</c>
<l>NumSamples := |DLSampleBatch|</l>
<l>if (NumSamples == 0)</l>
<l>    throw ('There are no DLSamples to be processed.')</l>
<l>endif</l>
<c>* Check number of selected distortions.</c>
<l>NumAvailableDistortions := AvailableDistortions.length()</l>
<l>if (NumAvailableDistortions == 0)</l>
<l>    return ()</l>
<l>endif</l>
<c>* </c>
<c>* Select randomly a distortion type for each sample.</c>
<c>* </c>
<c>* Augment (distort) the samples.</c>
<c>* </c>
<l>for SampleIndex := 0 to NumSamples - 1 by 1</l>
<l>    if (rand(1) * 100 &gt; AugmentationPercentage[1])</l>
<c>        * Only augment the given percentage of samples.</c>
<l>        continue</l>
<l>    endif</l>
<c>    * Select the distortion type.</c>
<l>    SelectedDistortion := int(rand(1) * NumAvailableDistortions)</l>
<l>    CurrentDistortion := AvailableDistortions.at(SelectedDistortion)</l>
<c>    * </c>
<c>    * Select the image to be augmented.</c>
<l>    DLSample := DLSampleBatch[SampleIndex]</l>
<l>    get_dict_object (Image, DLSample, 'image')</l>
<l>    get_dict_param (DLSample, 'key_exists', 'image_label_id', ClassificationImageExists)</l>
<l>    get_dict_param (DLSample, 'key_exists', 'bbox_row1', Rectangle1ParamExist)</l>
<l>    get_dict_param (DLSample, 'key_exists', 'bbox_phi', Rectangle2ParamExist)</l>
<l>    get_dict_param (DLSample, 'key_exists', 'segmentation_image', SegmentationImageExists)</l>
<l>    get_dict_param (DLSample, 'key_exists', 'weight_image', WeightImageExists)</l>
<c>    * Check which keys have to be modified as well.</c>
<l>    if (Rectangle1ParamExist)</l>
<l>        get_dict_tuple (DLSample, 'bbox_row1', BBoxRow1)</l>
<l>        get_dict_tuple (DLSample, 'bbox_col1', BBoxCol1)</l>
<l>        get_dict_tuple (DLSample, 'bbox_row2', BBoxRow2)</l>
<l>        get_dict_tuple (DLSample, 'bbox_col2', BBoxCol2)</l>
<l>    elseif (Rectangle2ParamExist)</l>
<l>        get_dict_tuple (DLSample, 'bbox_row', BBoxRow)</l>
<l>        get_dict_tuple (DLSample, 'bbox_col', BBoxCol)</l>
<l>        get_dict_tuple (DLSample, 'bbox_length1', BBoxLength1)</l>
<l>        get_dict_tuple (DLSample, 'bbox_length2', BBoxLength2)</l>
<l>        get_dict_tuple (DLSample, 'bbox_phi', BBoxPhi)</l>
<l>        if (ClassIDsNoOrientationExist[1])</l>
<l>            get_dict_tuple (DLSample, 'bbox_label_id', BBoxLabelID)</l>
<l>        endif</l>
<l>    endif</l>
<l>    if (SegmentationImageExists)</l>
<l>        get_dict_object (SegmentationImage, DLSample, 'segmentation_image')</l>
<l>    endif</l>
<l>    if (WeightImageExists)</l>
<l>        get_dict_object (WeightImage, DLSample, 'weight_image')</l>
<l>    endif</l>
<c>    * Some augmentation methods are only allowed for model type classification.</c>
<l>    if (not ClassificationImageExists)</l>
<l>        if (CurrentDistortion[0] == CropPercentage[0])</l>
<l>            throw ('The augmentation method crop_percentage is only allowed for model type classification.')</l>
<l>        elseif (CurrentDistortion[0] == CropPixel[0])</l>
<l>            throw ('The augmentation method crop_pixel is only allowed for model type classification.')</l>
<l>        elseif (CurrentDistortion[0] == RotationRange[0])</l>
<l>            throw ('The augmentation method rotate_range is only allowed for model type classification.')</l>
<l>        endif</l>
<l>    endif</l>
<c>    * </c>
<l>    if (CurrentDistortion[0] == Rotation[0])</l>
<c>        * </c>
<c>        * Rotation</c>
<c>        * </c>
<c>        * Determine rotation angle for distortion type 'rotate' (angle in range (0:CurrentDistortion[1]:360)).</c>
<l>        RotationStep := CurrentDistortion[1]</l>
<l>        NumPossibleRotations := 360.0 / RotationStep - 1</l>
<l>        CurrentRotation := RotationStep * (int(NumPossibleRotations * rand(1)) + 1)</l>
<c>        * </c>
<l>        if (CurrentRotation != 0)</l>
<l>            get_image_size (Image, ImageWidth, ImageHeight)</l>
<l>            if (ImageWidth != ImageHeight and (CurrentRotation != 180.0))</l>
<c>                * If an image is not quadratic, a rotation by 90 or 270 degrees is ignored.</c>
<l>                continue</l>
<l>            endif</l>
<c>            * </c>
<l>            rotate_image (Image, ImageRotate, CurrentRotation, 'constant')</l>
<l>            set_dict_object (ImageRotate, DLSample, 'image')</l>
<c>            * </c>
<l>            if (Rectangle1ParamExist or Rectangle2ParamExist)</l>
<c>                * Create a transformation matrix for the rotation of the bounding boxes.</c>
<l>                get_image_size (Image, ImageWidth, ImageHeight)</l>
<l>                hom_mat2d_identity (HomMat2DIdentity)</l>
<l>                hom_mat2d_translate (HomMat2DIdentity, 0.5, 0.5, HomMat2DTmp)</l>
<l>                hom_mat2d_translate_local (HomMat2DTmp, -0.5, -0.5, HomMat2DAdapted)</l>
<l>                Offset := (ImageHeight - ImageWidth) * 0.5 * sin(rad(CurrentRotation))</l>
<l>                hom_mat2d_translate (HomMat2DAdapted, Offset, Offset, HomMat2DAdapted)</l>
<l>                hom_mat2d_rotate (HomMat2DAdapted, rad(CurrentRotation), ImageHeight * 0.5, ImageWidth * 0.5, HomMat2DRotate)</l>
<l>            endif</l>
<l>            if (Rectangle1ParamExist)</l>
<l>                affine_trans_pixel (HomMat2DRotate, BBoxRow1, BBoxCol1, RowTrans1, ColTrans1)</l>
<l>                affine_trans_pixel (HomMat2DRotate, BBoxRow2, BBoxCol2, RowTrans2, ColTrans2)</l>
<l>                if (CurrentRotation == 90)</l>
<l>                    BBoxRow1 := RowTrans2</l>
<l>                    BBoxCol1 := ColTrans1</l>
<l>                    BBoxRow2 := RowTrans1</l>
<l>                    BBoxCol2 := ColTrans2</l>
<l>                elseif (CurrentRotation == 180)</l>
<l>                    BBoxRow1 := RowTrans2</l>
<l>                    BBoxCol1 := ColTrans2</l>
<l>                    BBoxRow2 := RowTrans1</l>
<l>                    BBoxCol2 := ColTrans1</l>
<l>                elseif (CurrentRotation == 270)</l>
<l>                    BBoxRow1 := RowTrans1</l>
<l>                    BBoxCol1 := ColTrans2</l>
<l>                    BBoxRow2 := RowTrans2</l>
<l>                    BBoxCol2 := ColTrans1</l>
<l>                endif</l>
<c>                * </c>
<l>                set_dict_tuple (DLSample, 'bbox_row1', BBoxRow1)</l>
<l>                set_dict_tuple (DLSample, 'bbox_col1', BBoxCol1)</l>
<l>                set_dict_tuple (DLSample, 'bbox_row2', BBoxRow2)</l>
<l>                set_dict_tuple (DLSample, 'bbox_col2', BBoxCol2)</l>
<l>            elseif (Rectangle2ParamExist)</l>
<l>                affine_trans_pixel (HomMat2DRotate, BBoxRow, BBoxCol, RowTrans, ColTrans)</l>
<c>                * Write the bounding box angles phi in the expected interval:</c>
<c>                * -180° &lt; phi &lt;= 180° or if IgnoreDirection set to true -90° &lt; phi &lt;= 90°.</c>
<l>                if (not IgnoreDirection[1])</l>
<l>                    BBoxPhi := BBoxPhi + rad(CurrentRotation)</l>
<l>                    MaxAngle := 180</l>
<l>                    DiffAngle := 360</l>
<l>                else</l>
<l>                    if (CurrentRotation == 90 or CurrentRotation == 270)</l>
<l>                        BBoxPhi := BBoxPhi + rad(90)</l>
<l>                    endif</l>
<l>                    MaxAngle := 90</l>
<l>                    DiffAngle := 180</l>
<l>                endif</l>
<l>                IndicesLarge := find(BBoxPhi [&gt;] rad(MaxAngle),1)</l>
<l>                if (IndicesLarge != -1)</l>
<l>                    BBoxPhi[IndicesLarge] := BBoxPhi[IndicesLarge] - rad(DiffAngle)</l>
<l>                endif</l>
<c>                * Check that the angle BBoxPhi for objects without orientation is always set to 0.0.</c>
<l>                if (ClassIDsNoOrientationExist[1])</l>
<l>                    for ObjIdx := 0 to |BBoxLabelID| - 1 by 1</l>
<l>                        if (find(ClassIDsNoOrientation,BBoxLabelID[ObjIdx]) != -1)</l>
<l>                            BBoxPhi[ObjIdx] := 0.0</l>
<c>                            * These classes require Length1 &lt;= Length2: exchange them for 90° or 270° rotations.</c>
<l>                            if (CurrentRotation == 90 or CurrentRotation == 270)</l>
<l>                                BBoxLengthTmp := BBoxLength1[ObjIdx]</l>
<l>                                BBoxLength1[ObjIdx] := BBoxLength2[ObjIdx]</l>
<l>                                BBoxLength2[ObjIdx] := BBoxLengthTmp</l>
<l>                            endif</l>
<l>                        endif</l>
<l>                    endfor</l>
<l>                endif</l>
<l>                set_dict_tuple (DLSample, 'bbox_row', RowTrans)</l>
<l>                set_dict_tuple (DLSample, 'bbox_col', ColTrans)</l>
<l>                set_dict_tuple (DLSample, 'bbox_phi', BBoxPhi)</l>
<l>                set_dict_tuple (DLSample, 'bbox_length1', BBoxLength1)</l>
<l>                set_dict_tuple (DLSample, 'bbox_length2', BBoxLength2)</l>
<l>            endif</l>
<l>            if (SegmentationImageExists)</l>
<l>                rotate_image (SegmentationImage, SegmentationImage, int(CurrentRotation), 'constant')</l>
<l>                set_dict_object (SegmentationImage, DLSample, 'segmentation_image')</l>
<l>            endif</l>
<l>            if (WeightImageExists)</l>
<l>                rotate_image (WeightImage, WeightImage, int(CurrentRotation), 'constant')</l>
<l>                set_dict_object (WeightImage, DLSample, 'weight_image')</l>
<l>            endif</l>
<l>        endif</l>
<l>    elseif (CurrentDistortion[0] == Mirror[0])</l>
<c>        * </c>
<c>        * Mirroring</c>
<c>        * </c>
<c>        * If more than one axis is allowed,</c>
<c>        * choose mirror axis/axes to be applied.</c>
<l>        NumMirrorMethods := strlen(CurrentDistortion[1])</l>
<l>        ProbabilityMethods := 1.0 / NumMirrorMethods</l>
<l>        StrMirror := ''</l>
<l>        while (StrMirror == '')</l>
<l>            for StrIdx := 0 to NumMirrorMethods - 1 by 1</l>
<l>                SelectedChar := CurrentDistortion[1]{StrIdx}</l>
<l>                if (rand(1) &lt; ProbabilityMethods)</l>
<l>                    StrMirror := StrMirror + SelectedChar</l>
<l>                endif</l>
<l>            endfor</l>
<l>        endwhile</l>
<c>        * Apply the chosen mirror axis/axes to the given sample data.</c>
<l>        get_image_size (Image, ImageWidth, ImageHeight)</l>
<l>        if (StrMirror =~ 'c')</l>
<l>            mirror_image (Image, Image, 'column')</l>
<l>            if (Rectangle1ParamExist)</l>
<l>                BBoxCol1Mirror := ImageWidth - BBoxCol2 - 1</l>
<l>                BBoxCol2Mirror := ImageWidth - BBoxCol1 - 1</l>
<l>                BBoxCol1 := BBoxCol1Mirror</l>
<l>                BBoxCol2 := BBoxCol2Mirror</l>
<l>            elseif (Rectangle2ParamExist)</l>
<l>                BBoxCol := ImageWidth - BBoxCol - 1</l>
<c>                * Check that BBoxPhi is only mirrored for classes with orientation.</c>
<l>                if (ClassIDsNoOrientationExist[1])</l>
<l>                    for ObjIdx := 0 to |BBoxLabelID| - 1 by 1</l>
<l>                        if (find(ClassIDsNoOrientation,BBoxLabelID[ObjIdx]) == -1)</l>
<l>                            if (IgnoreDirection[1])</l>
<l>                                BBoxPhi[ObjIdx] := -BBoxPhi[ObjIdx]</l>
<l>                            else</l>
<l>                                BBoxPhi[ObjIdx] := (-(BBoxPhi[ObjIdx] [&lt;] 0.0) + (BBoxPhi[ObjIdx] [&gt;=] 0.0)) * rad(180) - BBoxPhi[ObjIdx]</l>
<l>                            endif</l>
<l>                        endif</l>
<l>                    endfor</l>
<l>                else</l>
<l>                    if (IgnoreDirection[1])</l>
<l>                        BBoxPhi := -BBoxPhi</l>
<l>                    else</l>
<l>                        BBoxPhi := (-(BBoxPhi [&lt;] 0.0) + (BBoxPhi [&gt;=] 0.0)) * rad(180) - BBoxPhi</l>
<l>                    endif</l>
<l>                endif</l>
<l>            endif</l>
<l>            if (SegmentationImageExists)</l>
<l>                mirror_image (SegmentationImage, SegmentationImage, 'column')</l>
<l>            endif</l>
<l>            if (WeightImageExists)</l>
<l>                mirror_image (WeightImage, WeightImage, 'column')</l>
<l>            endif</l>
<l>        endif</l>
<c>        * </c>
<l>        if (StrMirror =~ 'r')</l>
<l>            mirror_image (Image, Image, 'row')</l>
<l>            if (Rectangle1ParamExist)</l>
<l>                BBoxRow1Mirror := ImageHeight - BBoxRow2 - 1</l>
<l>                BBoxRow2Mirror := ImageHeight - BBoxRow1 - 1</l>
<l>                BBoxRow1 := BBoxRow1Mirror</l>
<l>                BBoxRow2 := BBoxRow2Mirror</l>
<l>            elseif (Rectangle2ParamExist)</l>
<l>                BBoxRow := ImageHeight - BBoxRow - 1</l>
<l>                if (ClassIDsNoOrientationExist[1])</l>
<l>                    for ObjIdx := 0 to |BBoxLabelID| - 1 by 1</l>
<l>                        if (find(ClassIDsNoOrientation,BBoxLabelID[ObjIdx]) == -1)</l>
<l>                            BBoxPhi[ObjIdx] := -BBoxPhi[ObjIdx]</l>
<l>                        endif</l>
<l>                    endfor</l>
<l>                else</l>
<l>                    BBoxPhi := -BBoxPhi</l>
<l>                endif</l>
<l>            endif</l>
<l>            if (SegmentationImageExists)</l>
<l>                mirror_image (SegmentationImage, SegmentationImage, 'row')</l>
<l>            endif</l>
<l>            if (WeightImageExists)</l>
<l>                mirror_image (WeightImage, WeightImage, 'row')</l>
<l>            endif</l>
<l>        endif</l>
<c>        * </c>
<c>        * Set the mirrored data to DLSample.</c>
<l>        set_dict_object (Image, DLSample, 'image')</l>
<l>        if (Rectangle1ParamExist)</l>
<l>            set_dict_tuple (DLSample, 'bbox_col1', BBoxCol1)</l>
<l>            set_dict_tuple (DLSample, 'bbox_row1', BBoxRow1)</l>
<l>            set_dict_tuple (DLSample, 'bbox_col2', BBoxCol2)</l>
<l>            set_dict_tuple (DLSample, 'bbox_row2', BBoxRow2)</l>
<l>        elseif (Rectangle2ParamExist)</l>
<l>            set_dict_tuple (DLSample, 'bbox_row', BBoxRow)</l>
<l>            set_dict_tuple (DLSample, 'bbox_col', BBoxCol)</l>
<l>            set_dict_tuple (DLSample, 'bbox_phi', BBoxPhi)</l>
<l>        endif</l>
<l>        if (SegmentationImageExists)</l>
<l>            set_dict_object (SegmentationImage, DLSample, 'segmentation_image')</l>
<l>        endif</l>
<l>        if (WeightImageExists)</l>
<l>            set_dict_object (WeightImage, DLSample, 'weight_image')</l>
<l>        endif</l>
<l>    elseif (CurrentDistortion[0] == BrightnessVariation[0])</l>
<c>        * Brightness variation:</c>
<c>        * Add random brightness variation.</c>
<l>        BrightnessVariationValue := (rand(1) * 2 - 1) * CurrentDistortion[1]</l>
<l>        scale_image (Image, ImageScaled, 1.0, BrightnessVariationValue)</l>
<c>        * </c>
<c>        * Set the augmented image to DLSample.</c>
<l>        set_dict_object (ImageScaled, DLSample, 'image')</l>
<l>    elseif (CurrentDistortion[0] == BrightnessVariationSpot[0])</l>
<l>        get_image_size (Image, ImageWidth, ImageHeight)</l>
<c>        * Determine random brightness variation.</c>
<l>        BrightnessVariationValue := (rand(1) * 2 - 1) * CurrentDistortion[1]</l>
<c>        * Determine random spot size between [0.5*ImageHeight, ImageWidth]</c>
<l>        SpotSize := ImageWidth * (rand(1) / 2 + 0.5)</l>
<c>        * Determine random spot position.</c>
<l>        SpotRow := rand(1) * ImageHeight</l>
<l>        SpotColumn := rand(1) * ImageWidth</l>
<c>        * </c>
<l>        if (BrightnessVariationValue &lt; 0)</l>
<l>            Direction := 0</l>
<l>            BrightnessVariationValue := -BrightnessVariationValue</l>
<l>        else</l>
<l>            Direction := 1</l>
<l>        endif</l>
<c>        * Generate Gauss filter that simulates an illumination spot of size 'SpotSize'.</c>
<l>        gen_gauss_filter (Filter, 1, 1, 0, 'none', 'dc_center', SpotSize, SpotSize)</l>
<c>        * Shift the filter image to the given position.</c>
<l>        ShiftRow := -(SpotSize / 2 - SpotRow)</l>
<l>        ShiftCol := -(SpotSize / 2 - SpotColumn)</l>
<l>        tile_images_offset (Filter, GaussImage, ShiftRow, ShiftCol, -1, -1, -1, -1, ImageWidth, ImageHeight)</l>
<l>        full_domain (GaussImage, GaussFilter)</l>
<c>        * Convert Gauss filter to target image type and apply brightness variation.</c>
<l>        get_image_type (Image, Type)</l>
<l>        scale_image (GaussFilter, Gauss, BrightnessVariationValue, 0)</l>
<l>        convert_image_type (Gauss, GaussTargetType, Type)</l>
<c>        * Add channels to fit input image.</c>
<l>        count_channels (Image, NChannels)</l>
<l>        copy_obj (GaussTargetType, AddImage, 1, 1)</l>
<l>        for Index1 := 1 to NChannels - 1 by 1</l>
<l>            append_channel (AddImage, GaussTargetType, AddImage)</l>
<l>        endfor</l>
<c>        * Apply on image.</c>
<l>        if (Direction)</l>
<l>            add_image (Image, AddImage, ImageSpot, 1, 0)</l>
<l>        else</l>
<l>            sub_image (Image, AddImage, ImageSpot, 1, 0)</l>
<l>        endif</l>
<c>        * </c>
<c>        * Set the augmented image to DLSample.</c>
<l>        set_dict_object (ImageSpot, DLSample, 'image')</l>
<l>    elseif (CurrentDistortion[0] == CropPercentage[0])</l>
<l>        get_image_size (Image, ImageWidth, ImageHeight)</l>
<c>        * Define cropping rectangle.</c>
<l>        CropRate := CurrentDistortion[1] * 0.01</l>
<l>        Row1 := floor((1 - CropRate) * ImageHeight * rand(1))</l>
<l>        Row2 := Row1 + CropRate * ImageHeight</l>
<l>        Column1 := floor((1 - CropRate) * ImageWidth * rand(1))</l>
<l>        Column2 := Column1 + CropRate * ImageWidth</l>
<c>        * Crop the image.</c>
<l>        crop_rectangle1 (Image, ImagePart, Row1, Column1, Row2, Column2)</l>
<c>        * Scale image to the input size and set the augmented image to DLSample.</c>
<l>        zoom_image_size (ImagePart, ImagePart, ImageWidth, ImageHeight, 'constant')</l>
<l>        set_dict_object (ImagePart, DLSample, 'image')</l>
<l>    elseif (CurrentDistortion[0] == CropPixel[0])</l>
<l>        get_image_size (Image, ImageWidth, ImageHeight)</l>
<c>        * Define cropping rectangle.</c>
<l>        Length := CurrentDistortion[1]</l>
<l>        Row1 := rand(1) * (ImageHeight - Length)</l>
<l>        Row2 := Row1 + Length - 1</l>
<l>        Column1 := rand(1) * (ImageWidth - Length)</l>
<l>        Column2 := Column1 + Length - 1</l>
<c>        * Crop the image.</c>
<l>        crop_rectangle1 (Image, ImagePart, Row1, Column1, Row2, Column2)</l>
<c>        * Scale the image to the input size and set the augmented image to DLSample.</c>
<l>        zoom_image_size (ImagePart, ImagePart, ImageWidth, ImageHeight, 'constant')</l>
<l>        set_dict_object (ImagePart, DLSample, 'image')</l>
<l>    elseif (CurrentDistortion[0] == RotationRange[0])</l>
<l>        get_image_size (Image, ImageWidth, ImageHeight)</l>
<c>        * Determine rotation angle for method 'rotate_range' (angle in range [0:1:CurrentDistortion[1])).</c>
<l>        RotationStep := 1</l>
<l>        NumPossibleRotations := CurrentDistortion[1]</l>
<l>        CurrentRotation := RotationStep * (int(NumPossibleRotations * rand(1)) + 1)</l>
<c>        * Select direction of rotation randomly.</c>
<l>        if (round(rand(1)) &gt; 0.5)</l>
<l>            CurrentRotation := 360.0 - CurrentRotation</l>
<l>        endif</l>
<l>        if (int(CurrentRotation) == CurrentRotation and int(CurrentRotation) % 90 == 0)</l>
<c>            * Rotations around 90 degrees are faster with rotate_image.</c>
<l>            rotate_image (Image, ImagePart, int(CurrentRotation), 'constant')</l>
<l>        else</l>
<c>            * Create rotation matrix.</c>
<l>            hom_mat2d_identity (HomMat2DIdentity)</l>
<l>            hom_mat2d_rotate (HomMat2DIdentity, rad(CurrentRotation), ImageHeight / 2.0, ImageWidth / 2.0, HomMat2DRotate)</l>
<c>            * Apply rotation.</c>
<l>            affine_trans_image (Image, ImageRotated, HomMat2DRotate, 'constant', 'false')</l>
<c>            * Remove potential undefined domain.</c>
<l>            get_domain (ImageRotated, DomainRotated)</l>
<l>            inner_rectangle1 (DomainRotated, Row1, Column1, Row2, Column2)</l>
<l>            crop_rectangle1 (ImageRotated, ImagePart, Row1, Column1, Row2, Column2)</l>
<c>            * Scale image to the input size.</c>
<l>            zoom_image_size (ImagePart, ImagePart, ImageWidth, ImageHeight, 'constant')</l>
<l>        endif</l>
<c>        * </c>
<c>        * Set the augmented image to DLSample.</c>
<l>        set_dict_object (ImagePart, DLSample, 'image')</l>
<l>    endif</l>
<l>endfor</l>
<l>return ()</l>
</body>
<docu id="augment_dl_samples">
<abstract lang="en_US">This procedure can be used to augment the dataset in modifying the samples of DLSampleBatch.
Therefore, different augmentation methods can be specified using GenParam.
Please note, it is highly dependent on the dataset and the given model type which methods are suitable to improve the performance of the trained deep-learning-based model.

Data augmentation is achieved by modifying every sample with a probability determined in 'augmentation_percentage'.
This parameter can be set in GenParam and has a default of 50, meaning on average 50% of the images are modified.

The possible augmentation methods, set or adjusted using GenParam, are :

For all model types:
- 'rotate': This value determines the step size of the allowed rotations. The images selected for rotation are rotated by a random multiple of the given step size. The resulting rotation angle is in the range of [0°:360°]. This implies, you can specify either 0, 90, or 180. Note that if an image is not quadratic, a rotation by 90° is ignored.

Set 0 to switch off rotations. The default value is 0.
- 'mirror': This parameter encodes the allowed mirroring axes in the following way: 'r' (row) and 'c' (column). It is possible to allow both axes, e.g. by giving 'rc'. An image augmented by mirroring will be mirrored by a random combination of the allowed axes.
Set 'off' to disable mirroring. The default value is 'off'.

- 'brightness_variation': Apply a global, random brightness variation in the range of plus/minus the given gray value [-brightness_variation:brightness_variation]. The value range is 0-255, suggested value e.g. '20'.  Setting the parameter to '0' will disable this method. The default is '0'.

- 'brightness_variation_spot': Apply one local brightness spot in the range of plus/minus the given gray value [-brightness_variation_spot:brightness_variation_spot]. The spot size and position in the image are chosen randomly. The value range is 0-255, suggested value e.g. '20'. Alternatively, you can set it to '0'. The default is '0'.

For model type 'classification':
- 'crop_percentage': This parameter determines the percentage of the image side lengths in row and column direction after random cropping. The position of the cropped area is chosen randomly. The value range is 1 to 100 [%]. Set the parameter to 'off' or '100' to switch off random cropping. The default is 'off'.

- 'crop_pixel': This parameter determines the remaining size of the image side lengths in row and column direction after random cropping. The position of the cropped area is chosen randomly. The value must be greater then or equal to '1'. Set the parameter to 'off' to switch off random cropping. The default is 'off'.

- 'rotate_range': This method rotates the images around their center within a given angular range. The images selected for rotation by this method are rotated by a random angle in the range of [-'rotate_range':1°:'rotate_range']. Note that the image is cropped, if undefined pixels would result from the rotation. The value range is 0 to 180, the suggested value is '5'. Use '0' to switch off rotation. The default is '0'.


For each sample that is augmented, from the distortions allowed a random one is selected.

Please note that for reproducibility of the output images, the random seed has to be set using set_system before calling the procedure.
</abstract>
<chapters lang="de_DE">
<item>Deep Learning</item>
<item>Modell</item>
</chapters>
<chapters lang="en_US">
<item>Deep Learning</item>
<item>Model</item>
</chapters>
<library lang="en_US">MVTec Standard Procedures</library>
<short lang="en_US">Distort the given samples to augment the dataset.</short>
<parameters>
<parameter id="DLSampleBatch">
<default_type>integer</default_type>
<description lang="en_US">Tuple of DLSample dictionaries.</description>
<mixed_type>false</mixed_type>
<multivalue>optional</multivalue>
<sem_type>dict</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="GenParam">
<description lang="en_US">Generic parameter to control the behavior of the procedure. If [] is given, no augmentation is applied.</description>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>dict</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
</parameters>
</docu>
</procedure>
<procedure name="augment_images">
<interface>
<io>
<par name="Images" base_type="iconic" dimension="0"/>
</io>
<oo>
<par name="ImagesAugmented" base_type="iconic" dimension="0"/>
</oo>
<ic>
<par name="GenParamName" base_type="ctrl" dimension="0"/>
<par name="GenParamValue" base_type="ctrl" dimension="0"/>
</ic>
</interface>
<body>
<c>* This procedure can be used to augment given input Images</c>
<c>* using different methods, which can be specified using</c>
<c>* GenParamName and GenParamValue. The augmented images are returned</c>
<c>* in ImagesAugmented.</c>
<c>* </c>
<c>* Set default parameters.</c>
<c>* </c>
<c>* The percentages of the images that are to be augmented.</c>
<l>AugmentationPercentage := ['augmentation_percentage',50]</l>
<c>* Fraction of image length and width that remains after cropping (in %).</c>
<l>CropPercentage := ['crop_percentage','off']</l>
<c>* Image length and width that remains after cropping (in pixel).</c>
<l>CropPixel := ['crop_pixel','off']</l>
<c>* Step size for possible rotations.</c>
<l>Rotation := ['rotate',0]</l>
<c>* Step range for rotations with step size 1.</c>
<l>RotationRange := ['rotate_range',0]</l>
<c>* Allowed mirroring methods coded by 'r' (row), 'c' (column).</c>
<l>Mirror := ['mirror','off']</l>
<c>* The absolute brightness change can vary in the range[-value, +value].</c>
<l>BrightnessVariation := ['brightness_variation',0]</l>
<c>* The absolute brightness peak of a randomly positioned spot can vary in the range[-value, +value].</c>
<l>BrightnessVariationSpot := ['brightness_variation_spot',0]</l>
<c>* </c>
<c>* Parse the generic parameters.</c>
<c>* </c>
<c>* Check if GenParamName matches GenParamValue.</c>
<l>if (|GenParamName| != |GenParamValue|)</l>
<l>    throw ('Number of generic parameters does not match number of generic parameter values')</l>
<l>endif</l>
<c>* Check for generic parameter names and overwrite defaults.</c>
<l>for GenParamIndex := 0 to |GenParamName| - 1 by 1</l>
<l>    CurrentParamName := GenParamName[GenParamIndex]</l>
<l>    CurrentParamValue := GenParamValue[GenParamIndex]</l>
<c>    * </c>
<l>    if (CurrentParamName == AugmentationPercentage[0])</l>
<c>        * Set augmentation percentage.</c>
<l>        AugmentationPercentage[1] := CurrentParamValue</l>
<c>        * Check if input value is in range of 1-100 %.</c>
<l>        if (is_number(CurrentParamValue))</l>
<l>            if (CurrentParamValue &lt; 1 or CurrentParamValue &gt; 100)</l>
<l>                throw ('The given value for augmentation_percentage has to be in the range 1-100.')</l>
<l>            endif</l>
<l>        else</l>
<l>            throw ('The given value for augmentation_percentage has to be in the range 1-100.')</l>
<l>        endif</l>
<l>    elseif (CurrentParamName == Rotation[0])</l>
<c>        * Set rotation.</c>
<l>        Rotation[1] := CurrentParamValue</l>
<c>        * Check if input value is in range of 0-180 deg.</c>
<l>        if (is_number(CurrentParamValue))</l>
<l>            if (CurrentParamValue &lt; 0 or CurrentParamValue &gt; 180)</l>
<l>                throw ('The given value for rotate has to be in the range 0-180.')</l>
<l>            endif</l>
<l>        else</l>
<l>            throw ('The given value for rotate has to be in the range 0-180.')</l>
<l>        endif</l>
<l>    elseif (CurrentParamName == RotationRange[0])</l>
<c>        * Set rotation.</c>
<l>        RotationRange[1] := CurrentParamValue</l>
<c>        * Check if input value is in range of 0-180 deg.</c>
<l>        if (is_number(CurrentParamValue))</l>
<l>            if (CurrentParamValue &lt; 0 or CurrentParamValue &gt; 180)</l>
<l>                throw ('The given value for rotate_range has to be in the range 0-180."')</l>
<l>            endif</l>
<l>        else</l>
<l>            throw ('The given value for rotate_range has to be in the range 0-180.')</l>
<l>        endif</l>
<l>    elseif (CurrentParamName == Mirror[0])</l>
<c>        * Set mirroring.</c>
<l>        Mirror[1] := CurrentParamValue</l>
<c>        * Check if input is string and is 'off' or contains the wanted strings.</c>
<l>        if (is_number(CurrentParamValue) or not (CurrentParamValue == 'off' or CurrentParamValue == 'c' or CurrentParamValue == 'r' or CurrentParamValue == 'cr' or CurrentParamValue == 'rc'))</l>
<l>            throw ('Unknown mirror method.')</l>
<l>        endif</l>
<l>    elseif (CurrentParamName == CropPercentage[0])</l>
<c>        * Set cropping with percentage.</c>
<l>        CropPercentage[1] := CurrentParamValue</l>
<c>        * Check if input value is in range of 1-100 %.</c>
<l>        if (is_number(CurrentParamValue))</l>
<l>            if (CurrentParamValue &lt; 1 or CurrentParamValue &gt; 100)</l>
<l>                throw ('The given value for crop_percentage has to be in the range 1-100.')</l>
<l>            endif</l>
<l>        else</l>
<l>            throw ('The given value for crop_percentage has to be in the range 1-100.')</l>
<l>        endif</l>
<l>    elseif (CurrentParamName == CropPixel[0])</l>
<c>        * Set cropping with pixels.</c>
<l>        CropPixel[1] := CurrentParamValue</l>
<c>        * Check if input value is greater 0.</c>
<l>        if (is_number(CurrentParamValue))</l>
<l>            if (CurrentParamValue &lt; 1)</l>
<l>                throw ('The given value for crop_pixel has to be greater then or equal to 1.')</l>
<l>            endif</l>
<l>        else</l>
<l>            throw ('The given value for crop_pixel has to be a string.')</l>
<l>        endif</l>
<l>    elseif (CurrentParamName == BrightnessVariation[0])</l>
<c>        * Set brightness variation.</c>
<l>        BrightnessVariation[1] := CurrentParamValue</l>
<c>        * Check if input value is in range of 0-255.</c>
<l>        if (is_number(CurrentParamValue))</l>
<l>            if (CurrentParamValue &lt; 0 or CurrentParamValue &gt; 255)</l>
<l>                throw ('The given value for brightness_variation has to be in the range 0-255.')</l>
<l>            endif</l>
<l>        else</l>
<l>            throw ('The given value for brightness_variation has to be in the range 0-255.')</l>
<l>        endif</l>
<l>    elseif (CurrentParamName == BrightnessVariationSpot[0])</l>
<c>        * Set brightness variation of spot.</c>
<l>        BrightnessVariationSpot[1] := CurrentParamValue</l>
<c>        * Check if input value is in range of 0-255.</c>
<l>        if (is_number(CurrentParamValue))</l>
<l>            if (CurrentParamValue &lt; 0 or CurrentParamValue &gt; 255)</l>
<l>                throw ('The given value for brightness_variation_spot has to be in the range 0-255.')</l>
<l>            endif</l>
<l>        else</l>
<l>            throw ('The given value for brightness_variation_spot has to be in the range 0-255.')</l>
<l>        endif</l>
<l>    else</l>
<l>        throw ('Unknown generic parameter: \'' + GenParamName[GenParamIndex] + '\'')</l>
<l>    endif</l>
<l>endfor</l>
<c>* </c>
<c>* Aggregate all possible distortions and parameter values into a vector.</c>
<c>* </c>
<l>AvailableDistortions := {}</l>
<c>* Cropping percentage.</c>
<l>if (is_number(CropPercentage[1]))</l>
<l>    AvailableDistortions.at(AvailableDistortions.length()) := CropPercentage</l>
<l>endif</l>
<c>* Cropping pixel.</c>
<l>if (is_number(CropPixel[1]))</l>
<l>    AvailableDistortions.at(AvailableDistortions.length()) := CropPixel</l>
<l>endif</l>
<c>* Rotation with a given angular step size.</c>
<l>if (Rotation[1] &gt; 0)</l>
<l>    AvailableDistortions.at(AvailableDistortions.length()) := Rotation</l>
<l>endif</l>
<c>* Rotation within a given range (step size 1).</c>
<l>if (RotationRange[1] &gt; 0)</l>
<l>    AvailableDistortions.at(AvailableDistortions.length()) := RotationRange</l>
<l>endif</l>
<c>* Mirroring: in row and column direction are allowed.</c>
<l>if (Mirror[1] =~ 'r' or Mirror[1] =~ 'c')</l>
<l>    AvailableDistortions.at(AvailableDistortions.length()) := Mirror</l>
<l>endif</l>
<c>* Brightness variation.</c>
<l>if (BrightnessVariation[1] &gt; 0)</l>
<l>    AvailableDistortions.at(AvailableDistortions.length()) := BrightnessVariation</l>
<l>endif</l>
<c>* Brightness variation spot.</c>
<l>if (BrightnessVariationSpot[1] &gt; 0)</l>
<l>    AvailableDistortions.at(AvailableDistortions.length()) := BrightnessVariationSpot</l>
<l>endif</l>
<c>* Check number of available distortions</c>
<l>NumAvailableDistortions := AvailableDistortions.length()</l>
<l>if (NumAvailableDistortions == 0)</l>
<l>    ImagesAugmented := Images</l>
<l>    return ()</l>
<l>endif</l>
<c>* </c>
<c>* Randomly choose images and augmentation methods.</c>
<c>* </c>
<c>* Number of images to be augmented.</c>
<l>count_obj (Images, NumImages)</l>
<l>if (NumImages == 0)</l>
<l>    throw ('There are no images to be processed.')</l>
<l>endif</l>
<c>* Calculate how many images are to be augmented.</c>
<l>AugmentationRate := AugmentationPercentage[1] * 0.01</l>
<l>NumAugmentations := int(ceil(AugmentationRate * NumImages))</l>
<c>* Select a random subset of images</c>
<c>* that are to be augmented.</c>
<l>tuple_shuffle ([0:NumImages - 1], ImageIndices)</l>
<l>SelectedImages := ImageIndices[0:NumAugmentations - 1]</l>
<c>* Select a random distortion method for each image.</c>
<l>SelectedDistortions := int(floor(rand(NumAugmentations) * NumAvailableDistortions))</l>
<c>* Fill up vector of distortions for all input images.</c>
<l>Distortions := {}</l>
<l>IndexDistortion := 0</l>
<l>for Index := 0 to NumImages - 1 by 1</l>
<c>    * Check if Index corresponds to a selected image.</c>
<l>    if (sum(SelectedImages [==] Index) &gt; 0)</l>
<c>        * Add a distortion method.</c>
<l>        Distortions.at(Index) := AvailableDistortions.at(SelectedDistortions[IndexDistortion])</l>
<l>        IndexDistortion := IndexDistortion + 1</l>
<l>    else</l>
<c>        * Image will not be distorted.</c>
<l>        Distortions.at(Index) := ['none',0]</l>
<l>    endif</l>
<l>endfor</l>
<c>* </c>
<c>* Augment (distort) the images.</c>
<c>* </c>
<c>* Generate output image array.</c>
<l>gen_empty_obj (ImagesAugmented)</l>
<c>* Loop over all images and apply distortions.</c>
<l>for ImageIndex := 0 to NumImages - 1 by 1</l>
<c>    * Get distortion method.</c>
<l>    CurrentDistortion := Distortions.at(ImageIndex)</l>
<c>    * Get image to be processed.</c>
<l>    select_obj (Images, ImageSelected, ImageIndex + 1)</l>
<l>    get_image_size (ImageSelected, Width, Height)</l>
<l>    if (CurrentDistortion[0] == CropPercentage[0])</l>
<c>        * Cropping:</c>
<c>        * Define cropping rectangle.</c>
<l>        CropRate := CurrentDistortion[1] * 0.01</l>
<l>        Row1 := floor((1 - CropRate) * Height * rand(1))</l>
<l>        Row2 := Row1 + CropRate * Height</l>
<l>        Column1 := floor((1 - CropRate) * Width * rand(1))</l>
<l>        Column2 := Column1 + CropRate * Width</l>
<c>        * Crop the image and add to output.</c>
<l>        crop_rectangle1 (ImageSelected, ImagePart, Row1, Column1, Row2, Column2)</l>
<l>        concat_obj (ImagesAugmented, ImagePart, ImagesAugmented)</l>
<l>    elseif (CurrentDistortion[0] == CropPixel[0])</l>
<c>        * Cropping:</c>
<c>        * Define cropping rectangle.</c>
<l>        Length := CurrentDistortion[1]</l>
<l>        Row1 := rand(1) * (Height - Length)</l>
<l>        Row2 := Row1 + Length - 1</l>
<l>        Column1 := rand(1) * (Width - Length)</l>
<l>        Column2 := Column1 + Length - 1</l>
<c>        * Crop the image and add to output.</c>
<l>        crop_rectangle1 (ImageSelected, ImagePart, Row1, Column1, Row2, Column2)</l>
<l>        concat_obj (ImagesAugmented, ImagePart, ImagesAugmented)</l>
<l>    elseif (CurrentDistortion[0] == Rotation[0] or CurrentDistortion[0] == RotationRange[0])</l>
<c>        * Rotation:</c>
<l>        if (CurrentDistortion[0] == Rotation[0])</l>
<c>            * Determine rotation angle for method 'rotate' (angle in range [0:CurrentDistortion[1]:360)).</c>
<l>            RotationStep := CurrentDistortion[1]</l>
<l>            NumPossibleRotations := 360.0 / RotationStep</l>
<l>            CurrentRotation := RotationStep * (int(NumPossibleRotations * rand(1)) + 1)</l>
<l>        else</l>
<c>            * Determine rotation angle for method 'rotate_range' (angle in range [0:1:CurrentDistortion[1])).</c>
<l>            RotationStep := 1</l>
<l>            NumPossibleRotations := CurrentDistortion[1]</l>
<l>            CurrentRotation := RotationStep * (int(NumPossibleRotations * rand(1)) + 1)</l>
<c>            * Select direction of rotation randomly.</c>
<l>            if (round(rand(1)) &gt; 0.5)</l>
<l>                CurrentRotation := 360.0 - CurrentRotation</l>
<l>            endif</l>
<l>        endif</l>
<l>        if (int(CurrentRotation) == CurrentRotation and int(CurrentRotation) % 90 == 0)</l>
<c>            * Rotations around 90 degrees are faster with rotate_image</c>
<l>            rotate_image (ImageSelected, ImagePart, int(CurrentRotation), 'constant')</l>
<l>        else</l>
<c>            * Create rotation matrix.</c>
<l>            hom_mat2d_identity (HomMat2DIdentity)</l>
<l>            hom_mat2d_rotate (HomMat2DIdentity, rad(CurrentRotation), Height / 2.0, Width / 2.0, HomMat2DRotate)</l>
<c>            * Apply rotation.</c>
<l>            affine_trans_image (ImageSelected, ImageRotated, HomMat2DRotate, 'constant', 'false')</l>
<c>            * Remove potential undefined domain.</c>
<l>            get_domain (ImageRotated, DomainRotated)</l>
<l>            inner_rectangle1 (DomainRotated, Row1, Column1, Row2, Column2)</l>
<l>            crop_rectangle1 (ImageRotated, ImagePart, Row1, Column1, Row2, Column2)</l>
<l>        endif</l>
<c>        * Add the image to the output.</c>
<l>        concat_obj (ImagesAugmented, ImagePart, ImagesAugmented)</l>
<l>    elseif (CurrentDistortion[0] == Mirror[0])</l>
<c>        * Mirroring:</c>
<c>        * If more than one method is allowed, chose mirroring method(s) to be applied.</c>
<l>        NumMirrorMethods := strlen(CurrentDistortion[1])</l>
<l>        PropabilityMethods := 1.0 / NumMirrorMethods</l>
<l>        StrMirror := ''</l>
<l>        while (StrMirror == '')</l>
<l>            for StrIdx := 0 to NumMirrorMethods - 1 by 1</l>
<l>                SelectedChar := CurrentDistortion[1]{StrIdx}</l>
<l>                if (rand(1) &lt; PropabilityMethods)</l>
<l>                    StrMirror := StrMirror + SelectedChar</l>
<l>                endif</l>
<l>            endfor</l>
<l>        endwhile</l>
<c>        * Apply the chosen mirroring method(s).</c>
<l>        if (StrMirror =~ 'c')</l>
<l>            mirror_image (ImageSelected, ImageSelected, 'column')</l>
<l>        endif</l>
<l>        if (StrMirror =~ 'r')</l>
<l>            mirror_image (ImageSelected, ImageSelected, 'row')</l>
<l>        endif</l>
<c>        * Add the image to the output.</c>
<l>        concat_obj (ImagesAugmented, ImageSelected, ImagesAugmented)</l>
<l>    elseif (CurrentDistortion[0] == BrightnessVariation[0])</l>
<c>        * Brightness variation:</c>
<c>        * Add random brightness variation.</c>
<l>        BrightnessVariationValue := (rand(1) * 2 - 1) * CurrentDistortion[1]</l>
<l>        scale_image (ImageSelected, ImageScaled, 1.0, BrightnessVariationValue)</l>
<c>        * Add the image to the output.</c>
<l>        concat_obj (ImagesAugmented, ImageScaled, ImagesAugmented)</l>
<l>    elseif (CurrentDistortion[0] == BrightnessVariationSpot[0])</l>
<c>        * Determine random brightness variation.</c>
<l>        BrightnessVariationValue := (rand(1) * 2 - 1) * CurrentDistortion[1]</l>
<c>        * Determine random spot size between [0.5*Width, Width].</c>
<l>        SpotSize := Width * (rand(1) / 2 + .5)</l>
<c>        * Determine random spot position.</c>
<l>        SpotRow := rand(1) * Height</l>
<l>        SpotColumn := rand(1) * Width</l>
<l>        apply_brightness_variation_spot (ImageSelected, ImageSpot, SpotSize, SpotRow, SpotColumn, BrightnessVariationValue)</l>
<c>        * Add the image to the output.</c>
<l>        concat_obj (ImagesAugmented, ImageSpot, ImagesAugmented)</l>
<l>    else</l>
<c>        * Add unchanged image to the output.</c>
<l>        concat_obj (ImagesAugmented, ImageSelected, ImagesAugmented)</l>
<l>    endif</l>
<l>endfor</l>
<l>return ()</l>
</body>
<docu id="augment_images">
<abstract lang="en_US">This procedure can be used to augment given Images using different methods, which can be specified using GenParamName and GenParamValue. The augmented images are returned in ImagesAugmented. 

Data augmentation is achieved by modification of some of the images, i.e. the number of images in Images and ImagesAugmented is identical. To prevent augmentation of all input images, i.e. no 'original' images are left in ImagesAugmented, you can set the 'augmentation_percentage' using GenParamName and GenParamValue. The default is '50', meaning 50% of the images  are returned unchanged.

For each image that is augmented one augmentation method is selected randomly from the methods listed below. They can be adjusted or switched off by giving the method name in GenParamName and respective parameters in GenParamValue:
 
  * 'rotate': This value determines the step size of the allowed rotations. The images selected for rotation are rotated by a randomly chosen multiple of the given step size. The resulting rotation angle is in the range of [0°:360°]. Note that the image is cropped if undefined pixels would result from the rotation. The value range is 0 to 180, the suggested value is '90'. Use '0' to switch off rotation. The default is '0'.

  * 'rotate_range': This method rotates the images within a given angular range. The images selected for rotation by this method are rotated by a random angle in the range of [-'rotate_range':1°:'rotate_range']. Note that the image is cropped, if undefined pixels would result from the rotation. The value range is 0 to 180, the suggested value is '5'. Use '0' to switch off rotation. The default is '0'.

 * 'crop_percentage': This parameter determines the remaining percentage of the image side lengths in row and column direction after random cropping. The position of the cropped area is chosen randomly. The value range is 1 to 100 [%]. Set the parameter to 'off' or '100' to switch off random cropping. The default is 'off'.

 * 'crop_pixel': This parameter determines the remaining size of the image side lengths in row and column direction after random cropping. The position of the cropped area is chosen randomly. The value must be greater then or equal to '1'. Set the parameter to 'off' to switch off random cropping. The default is 'off'.

 * 'mirror': This parameter codes the allowed mirroring methods in the following way: 'r' (row) and 'c' (column). Is is possible to allow both methods, e.g. by giving 'rc'. An image augmented by mirroring will be mirrored by a random combination of the allowed methods. Alternatively, you can set it to 'off' to disable the mirroring. The default is 'off'.

 * 'brightness_variation': Apply a global, random brightness variation in the range of plus/minus the given gray value[-brightness_variation:brightness_variation]. The value range is 0-255, suggested value e.g. '20'.  Setting the parameter to '0' will disable this method. The default is '0'.

 * 'brightness_variation_spot': Apply one local brightness spot in the range of plus/minus the given gray value [-brightness_variation_spot:brightness_variation_spot]. The spot size and position in the image are chosen randomly. The value range is 0-255, suggested value e.g. '20'. Alternatively, you can set it to '0'. The default is '0'.

ATTENTION: Please note that the image size will be affected by rotations (other than 180°) and cropping.

Also, please note that for reproducibility of the output images, the random seed has to be set using set_system before calling the procedure.</abstract>
<chapters lang="en_US">
<item>Image</item>
<item>Manipulation</item>
</chapters>
<keywords lang="en_US">
<item>augmentation</item>
<item>augment</item>
</keywords>
<library lang="en_US">MVTec Standard Procedures</library>
<short lang="en_US">Augment/distort the given images.</short>
<parameters>
<parameter id="GenParamName">
<default_type>string</default_type>
<default_value>[]</default_value>
<description lang="en_US">Name of the generic parameter.</description>
<mixed_type>false</mixed_type>
<multivalue>optional</multivalue>
<sem_type>attribute.name</sem_type>
<type_list>
<item>string</item>
</type_list>
<values>
<item>'augmentation_percentage'</item>
<item>'rotate'</item>
<item>'rotate_range'</item>
<item>'crop_percentage, 'crop_pixel''</item>
<item>'mirror'</item>
<item>'brightness_variation'</item>
<item>'brightness_variation_spot'</item>
</values>
</parameter>
<parameter id="GenParamValue">
<default_type>integer</default_type>
<default_value>[]</default_value>
<description lang="en_US">Value of the generic parameter.</description>
<mixed_type>optional</mixed_type>
<multivalue>optional</multivalue>
<sem_type>attribute.value</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
<item>string</item>
</type_list>
<values>
<item>0</item>
<item>5</item>
<item>10</item>
<item>25</item>
<item>50</item>
<item>70</item>
<item>90</item>
<item>180</item>
<item>255</item>
<item>'rc'</item>
<item>'r'</item>
<item>'c'</item>
<item>'off'</item>
</values>
</parameter>
<parameter id="Images">
<description lang="en_US">Images that are to be augmented.</description>
<multichannel>optional</multichannel>
<multivalue>optional</multivalue>
<sem_type>image</sem_type>
<type_list>
<item>byte</item>
<item>real</item>
</type_list>
</parameter>
<parameter id="ImagesAugmented">
<description lang="en_US">The augmented / distorted images.</description>
<multichannel>optional</multichannel>
<multivalue>optional</multivalue>
<sem_type>image</sem_type>
</parameter>
</parameters>
</docu>
</procedure>
<procedure name="calc_feature_color_intensity" access="local">
<interface>
<io>
<par name="Region" base_type="iconic" dimension="0"/>
<par name="Image" base_type="iconic" dimension="0"/>
</io>
<ic>
<par name="ColorSpace" base_type="ctrl" dimension="0"/>
<par name="Mode" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="Feature" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c>* </c>
<c>* Calculate color features</c>
<c>* </c>
<c>* Transform an RGB image into the given ColorSpace</c>
<c>* and calculate the mean gray value and the deviation</c>
<c>* for all three channels.</c>
<c>* </c>
<l>count_channels (Image, Channels)</l>
<l>if (Channels != 3)</l>
<l>    throw (['Error when calculating feature ' + ColorSpace + '_' + Mode,'Please use a 3-channel RGB image or remove color feature from the list.'])</l>
<l>endif</l>
<l>decompose3 (Image, R, G, B)</l>
<l>if (ColorSpace == 'rgb')</l>
<l>    intensity (Region, R, Mean1, Deviation1)</l>
<l>    intensity (Region, G, Mean2, Deviation2)</l>
<l>    intensity (Region, B, Mean3, Deviation3)</l>
<l>else</l>
<l>    trans_from_rgb (R, G, B, I1, I2, I3, ColorSpace)</l>
<l>    intensity (Region, I1, Mean1, Deviation1)</l>
<l>    intensity (Region, I2, Mean2, Deviation2)</l>
<l>    intensity (Region, I3, Mean3, Deviation3)</l>
<l>endif</l>
<l>if (Mode == 'mean')</l>
<l>    Tmp1 := Mean1</l>
<l>    Tmp2 := Mean2</l>
<l>    Tmp3 := Mean3</l>
<l>elseif (Mode == 'deviation')</l>
<l>    Tmp1 := Deviation1</l>
<l>    Tmp2 := Deviation2</l>
<l>    Tmp3 := Deviation3</l>
<l>endif</l>
<l>count_obj (Region, NumRegions)</l>
<l>if (NumRegions &gt; 0)</l>
<l>    Index := [0:3:3 * NumRegions - 1]</l>
<l>    Feature[Index] := Tmp1</l>
<l>    Feature[1 + Index] := Tmp2</l>
<l>    Feature[2 + Index] := Tmp3</l>
<l>else</l>
<l>    Feature := []</l>
<l>endif</l>
<l>return ()</l>
</body>
<docu id="calc_feature_color_intensity">
<abstract lang="en_US">This procedure transforms the RGB image Image into the given ColorSpace and calculates the mean gray value and the deviation for all three channels.

For more information about the usage of the get_feature_set library, see documentation of calculate_features.</abstract>
<chapters lang="de_DE">
<item>Klassifikation</item>
<item>Sonstiges</item>
</chapters>
<chapters lang="en_US">
<item>Classification</item>
<item>Misc</item>
</chapters>
<library lang="en_US">MVTec Standard Procedures</library>
<short lang="en_US">Calculate color intensity features.</short>
<parameters>
<parameter id="ColorSpace">
<default_type>string</default_type>
<default_value>'cielab'</default_value>
<description lang="en_US">Target color space.</description>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>string</sem_type>
<type_list>
<item>string</item>
</type_list>
<value_list>
<item>'rgb'</item>
<item>'cielab'</item>
<item>'hls'</item>
</value_list>
</parameter>
<parameter id="Feature">
<default_type>real</default_type>
<description lang="en_US">Calculated feature values.</description>
<mixed_type>false</mixed_type>
<multivalue>optional</multivalue>
<sem_type>real</sem_type>
<type_list>
<item>real</item>
</type_list>
</parameter>
<parameter id="Image">
<description lang="en_US">RGB image.</description>
<multichannel>true</multichannel>
<multivalue>false</multivalue>
<sem_type>image</sem_type>
<type_list>
<item>byte</item>
</type_list>
</parameter>
<parameter id="Mode">
<default_type>string</default_type>
<default_value>'mean'</default_value>
<description lang="en_US">Feature that is calculated from the transformed color values.</description>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>string</sem_type>
<type_list>
<item>string</item>
</type_list>
<values>
<item>'mean'</item>
<item>'deviation'</item>
</values>
</parameter>
<parameter id="Region">
<description lang="en_US">Regions to be examined. </description>
<multivalue>optional</multivalue>
<sem_type>region</sem_type>
</parameter>
</parameters>
</docu>
</procedure>
<procedure name="calc_feature_edge_density" access="local">
<interface>
<io>
<par name="Region" base_type="iconic" dimension="0"/>
<par name="Image" base_type="iconic" dimension="0"/>
</io>
<oc>
<par name="Feature" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c>* </c>
<c>* Calculate the edge density, i.e.</c>
<c>* the ratio of the edge amplitudes to the area of the region.</c>
<c>* </c>
<l>union1 (Region, RegionUnion)</l>
<l>reduce_domain (Image, RegionUnion, ImageReduced)</l>
<l>area_center (Region, Area, Row, Column)</l>
<l>get_image_size (ImageReduced, Width, Height)</l>
<l>if (Width &gt; 1 and Height &gt; 1)</l>
<l>    sobel_amp (ImageReduced, EdgeAmplitude, 'sum_abs', 3)</l>
<l>    area_center_gray (Region, EdgeAmplitude, AreaGray, Row, Column)</l>
<l>    ZeroIndex := find(Area,0)</l>
<l>    if (ZeroIndex != -1)</l>
<l>        Area[ZeroIndex] := 1</l>
<l>        AreaGray[ZeroIndex] := 0</l>
<l>    endif</l>
<l>    Feature := AreaGray / Area</l>
<l>else</l>
<l>    Feature := gen_tuple_const(|Area|,0.0)</l>
<l>endif</l>
<l>return ()</l>
</body>
<docu id="calc_feature_edge_density">
<abstract lang="en_US">Calculate the edge density, i.e., the ratio of the edge amplitudes to the area of the region.

For more information about the usage of the get_feature_set library, see documentation of calculate_features.</abstract>
<chapters lang="de_DE">
<item>Klassifikation</item>
<item>Sonstiges</item>
</chapters>
<chapters lang="en_US">
<item>Classification</item>
<item>Misc</item>
</chapters>
<library lang="en_US">MVTec Standard Procedures</library>
<short lang="en_US">Calculate edge density.</short>
<parameters>
<parameter id="Feature">
<default_type>real</default_type>
<description lang="en_US">Calculated feature values.</description>
<mixed_type>false</mixed_type>
<multivalue>optional</multivalue>
<sem_type>real</sem_type>
<type_list>
<item>real</item>
</type_list>
</parameter>
<parameter id="Image">
<description lang="en_US">Gray value image.</description>
<multichannel>false</multichannel>
<multivalue>false</multivalue>
<sem_type>image</sem_type>
</parameter>
<parameter id="Region">
<description lang="en_US">Regions to be examined.</description>
<multivalue>optional</multivalue>
<sem_type>region</sem_type>
</parameter>
</parameters>
</docu>
</procedure>
<procedure name="calc_feature_edge_density_histogram" access="local">
<interface>
<io>
<par name="Region" base_type="iconic" dimension="0"/>
<par name="Image" base_type="iconic" dimension="0"/>
</io>
<ic>
<par name="NumBins" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="Feature" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c>* </c>
<c>* Calculate the edge density histogram, i.e.</c>
<c>* the ratio of the edge amplitude histogram to the area of the region.</c>
<c>* </c>
<l>Feature := []</l>
<l>get_image_size (Image, ImageWidth, ImageHeight)</l>
<l>count_obj (Region, NumRegions)</l>
<l>if (ImageWidth &gt; 1 and ImageHeight &gt; 1)</l>
<l>    access_channel (Image, Channel1, 1)</l>
<l>    sobel_amp (Channel1, EdgeAmplitude, 'sum_abs', 3)</l>
<l>    for J := 1 to NumRegions by 1</l>
<l>        select_obj (Region, RegionSelected, J)</l>
<l>        area_center (RegionSelected, Area, Row, Column)</l>
<l>        if (Area &gt; 0)</l>
<l>            gray_histo_range (RegionSelected, EdgeAmplitude, 0, 255, NumBins, Histo, BinSize)</l>
<l>            Feature := [Feature,real(Histo) / sum(Histo)]</l>
<l>        else</l>
<l>            Feature := [Feature,1.0,gen_tuple_const(NumBins - 1,0.0)]</l>
<l>        endif</l>
<l>    endfor</l>
<l>else</l>
<l>    Feature := gen_tuple_const(NumRegions * NumBins,0.0)</l>
<l>endif</l>
<l>return ()</l>
</body>
<docu id="calc_feature_edge_density_histogram">
<abstract lang="en_US">Calculate the edge density histogram, i.e. the ratio of the edge amplitude histogram to the area of the region.

For more information about the usage of the get_feature_set library, see documentation of calculate_features.</abstract>
<chapters lang="de_DE">
<item>Klassifikation</item>
<item>Sonstiges</item>
</chapters>
<chapters lang="en_US">
<item>Classification</item>
<item>Misc</item>
</chapters>
<library lang="en_US">MVTec Standard Procedures</library>
<short lang="en_US">Calculate edge density histogram feature.</short>
<parameters>
<parameter id="Feature">
<default_type>real</default_type>
<description lang="en_US">Calculated feature values.</description>
<mixed_type>false</mixed_type>
<multivalue>optional</multivalue>
<sem_type>real</sem_type>
<type_list>
<item>real</item>
</type_list>
</parameter>
<parameter id="Image">
<description lang="en_US">Gray value image.</description>
<multichannel>false</multichannel>
<multivalue>false</multivalue>
<sem_type>image</sem_type>
</parameter>
<parameter id="NumBins">
<default_type>integer</default_type>
<default_value>4</default_value>
<description lang="en_US">Number of bins of the edge density histogram.</description>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>integer</sem_type>
<type_list>
<item>integer</item>
</type_list>
<value_min>1</value_min>
</parameter>
<parameter id="Region">
<description lang="en_US">Regions to be examined.</description>
<multivalue>optional</multivalue>
<sem_type>region</sem_type>
</parameter>
</parameters>
</docu>
</procedure>
<procedure name="calc_feature_grad_dir_histo" access="local">
<interface>
<io>
<par name="Region" base_type="iconic" dimension="0"/>
<par name="Image" base_type="iconic" dimension="0"/>
</io>
<ic>
<par name="NumBins" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="Feature" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c>* </c>
<c>* Calculate gradient direction histogram</c>
<c>* </c>
<l>access_channel (Image, Channel1, 1)</l>
<l>count_obj (Region, NumRegions)</l>
<l>Feature := []</l>
<l>for Index := 1 to NumRegions by 1</l>
<l>    select_obj (Region, RegionSelected, Index)</l>
<l>    reduce_domain (Channel1, RegionSelected, ImageReduced)</l>
<l>    sobel_dir (ImageReduced, EdgeAmplitude, EdgeDirection, 'sum_abs_binomial', 3)</l>
<l>    gray_histo_range (RegionSelected, EdgeDirection, 0, 179, NumBins, Histo, BinSize)</l>
<l>    Sum := sum(Histo)</l>
<l>    if (Sum != 0)</l>
<l>        Feature := [Feature,real(Histo) / Sum]</l>
<l>    else</l>
<l>        Feature := [Feature,Histo]</l>
<l>    endif</l>
<l>endfor</l>
<l>return ()</l>
</body>
<docu id="calc_feature_grad_dir_histo">
<abstract lang="en_US">Calculate the gradient direction histogram.

For more information about the usage of the get_feature_set library, see documentation of calculate_features.</abstract>
<chapters lang="de_DE">
<item>Klassifikation</item>
<item>Sonstiges</item>
</chapters>
<chapters lang="en_US">
<item>Classification</item>
<item>Misc</item>
</chapters>
<library lang="en_US">MVTec Standard Procedures</library>
<short lang="en_US">Calculate the gradient direction histogram.</short>
<parameters>
<parameter id="Feature">
<default_type>real</default_type>
<description lang="en_US">Calculated feature values.</description>
<mixed_type>false</mixed_type>
<multivalue>optional</multivalue>
<sem_type>real</sem_type>
<type_list>
<item>real</item>
</type_list>
</parameter>
<parameter id="Image">
<description lang="en_US">Gray value image.</description>
<multichannel>false</multichannel>
<multivalue>false</multivalue>
<sem_type>image</sem_type>
</parameter>
<parameter id="NumBins">
<default_type>integer</default_type>
<default_value>20</default_value>
<description lang="en_US">Number of bins of the gradient direction histogram.</description>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>integer</sem_type>
<type_list>
<item>integer</item>
</type_list>
<value_min>1</value_min>
</parameter>
<parameter id="Region">
<description lang="en_US">Regions to be examined.</description>
<multivalue>optional</multivalue>
<sem_type>region</sem_type>
</parameter>
</parameters>
</docu>
</procedure>
<procedure name="calc_feature_gray_proj">
<interface>
<io>
<par name="Region" base_type="iconic" dimension="0"/>
<par name="Image" base_type="iconic" dimension="0"/>
</io>
<ic>
<par name="Mode" base_type="ctrl" dimension="0"/>
<par name="Size" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="Feature" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c>* </c>
<c>* Calculate gray-value projections and their histograms</c>
<c>* </c>
<l>count_obj (Region, NumRegions)</l>
<l>Feature := []</l>
<c>* </c>
<l>for Index := 1 to NumRegions by 1</l>
<l>    select_obj (Region, RegionTmp, Index)</l>
<c>    * Test empty region</c>
<l>    get_region_points (RegionTmp, RowsTmp, ColumnsTmp)</l>
<l>    if (|RowsTmp| == 0)</l>
<l>        HorProjectionFilledUp := gen_tuple_const(Size,-1.0)</l>
<l>        VertProjectionFilledUp := gen_tuple_const(Size,-1.0)</l>
<l>    else</l>
<c>        * Zoom image and region to Size x Size pixels</c>
<l>        smallest_rectangle1 (RegionTmp, Row1, Column1, Row2, Column2)</l>
<l>        move_region (RegionTmp, RegionMoved, -Row1, -Column1)</l>
<l>        crop_rectangle1 (Image, ImageTmp, Row1, Column1, Row2, Column2)</l>
<l>        ScaleHeight := real(Size) / (Row2 - Row1 + 1)</l>
<l>        ScaleWidth := real(Size) / (Column2 - Column1 + 1)</l>
<l>        zoom_image_factor (ImageTmp, ImageTmp, ScaleWidth, ScaleHeight, 'constant')</l>
<l>        zoom_region (RegionMoved, RegionTmp, ScaleWidth, ScaleHeight)</l>
<c>        * Calculate gray value projection</c>
<l>        gray_projections (RegionTmp, ImageTmp, 'simple', HorProjection, VertProjection)</l>
<c>        * Fill up projection in case the zoomed region is smaller than</c>
<c>        * Size x Size pixels due to interpolation effects</c>
<l>        smallest_rectangle1 (RegionTmp, Row1, Column1, Row2, Column2)</l>
<l>        HorProjectionFilledUpFront := [gen_tuple_const(max2(0,Row1),-1.0),HorProjection]</l>
<l>        HorProjectionFilledUp := [HorProjectionFilledUpFront,gen_tuple_const(Size - |HorProjectionFilledUpFront|,-1.0)]</l>
<l>        VertProjectionFilledUpFront := [gen_tuple_const(max2(0,Column1),-1.0),VertProjection]</l>
<l>        VertProjectionFilledUp := [VertProjectionFilledUpFront,gen_tuple_const(Size - |VertProjectionFilledUpFront|,-1.0)]</l>
<l>    endif</l>
<l>    if (Mode == 'hor')</l>
<l>        Feature := [Feature,HorProjectionFilledUp]</l>
<l>    elseif (Mode == 'vert')</l>
<l>        Feature := [Feature,VertProjectionFilledUp]</l>
<l>    elseif (Mode == 'hor_histo')</l>
<l>        tuple_histo_range (HorProjectionFilledUp, 0, 255, Size, Histo, BinSize)</l>
<l>        Feature := [Feature,Histo]</l>
<l>    elseif (Mode == 'vert_histo')</l>
<l>        tuple_histo_range (VertProjectionFilledUp, 0, 255, Size, Histo, BinSize)</l>
<l>        Feature := [Feature,Histo]</l>
<l>    endif</l>
<l>endfor</l>
<l>return ()</l>
</body>
<docu id="calc_feature_gray_proj">
<abstract lang="en_US">Calculate gray-value projections and their histograms.

For more information about the usage of the get_feature_set library, see documentation of calculate_features.</abstract>
<chapters lang="de_DE">
<item>Klassifikation</item>
<item>Sonstiges</item>
</chapters>
<chapters lang="en_US">
<item>Classification</item>
<item>Misc</item>
</chapters>
<library lang="en_US">MVTec Standard Procedures</library>
<short lang="en_US">Calculate gray-value projections and their histograms.</short>
<parameters>
<parameter id="Feature">
<default_type>real</default_type>
<description lang="en_US">Calculated feature values.</description>
<mixed_type>false</mixed_type>
<multivalue>optional</multivalue>
<sem_type>real</sem_type>
<type_list>
<item>real</item>
</type_list>
</parameter>
<parameter id="Image">
<description lang="en_US">Gray value image.</description>
<multichannel>false</multichannel>
<multivalue>false</multivalue>
<sem_type>image</sem_type>
</parameter>
<parameter id="Mode">
<default_type>string</default_type>
<default_value>'hor'</default_value>
<description lang="en_US">Calculation mode.</description>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>string</sem_type>
<type_list>
<item>string</item>
</type_list>
<value_list>
<item>'hor'</item>
<item>'vert'</item>
<item>'hor_histo'</item>
<item>'vert_histo'</item>
</value_list>
</parameter>
<parameter id="Region">
<description lang="en_US">Regions to be examined.</description>
<multivalue>optional</multivalue>
<sem_type>region</sem_type>
</parameter>
<parameter id="Size">
<default_type>integer</default_type>
<default_value>20</default_value>
<description lang="en_US">Resolution of the gray value projection.</description>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>extent</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
</parameters>
</docu>
</procedure>
<procedure name="calc_feature_polar_gray_proj" access="local">
<interface>
<io>
<par name="Region" base_type="iconic" dimension="0"/>
<par name="Image" base_type="iconic" dimension="0"/>
</io>
<ic>
<par name="Mode" base_type="ctrl" dimension="0"/>
<par name="Width" base_type="ctrl" dimension="0"/>
<par name="Height" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="Features" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c>* </c>
<c>* Calculate gray-value projections of</c>
<c>* polar-transformed image regions.</c>
<c>* </c>
<l>count_obj (Region, NumRegions)</l>
<l>Features := []</l>
<l>for Index := 1 to NumRegions by 1</l>
<l>    select_obj (Region, RegionSelected, Index)</l>
<l>    smallest_circle (RegionSelected, Row, Column, Radius)</l>
<l>    polar_trans_image_ext (Image, PolarTransImage, Row, Column, 0, rad(360), 0, max([Radius,1]), Width, Height, 'bilinear')</l>
<c>    * </c>
<l>    if (Mode == 'hor_gray')</l>
<l>        gray_projections (PolarTransImage, PolarTransImage, 'simple', HorProjection, VertProjection)</l>
<l>        Features := [Features,HorProjection]</l>
<l>    elseif (Mode == 'vert_gray')</l>
<l>        gray_projections (PolarTransImage, PolarTransImage, 'simple', HorProjection, VertProjection)</l>
<l>        Features := [Features,VertProjection]</l>
<l>    elseif (Mode == 'hor_sobel_amp')</l>
<l>        sobel_amp (PolarTransImage, EdgeAmplitude, 'sum_abs', 3)</l>
<l>        abs_image (EdgeAmplitude, ImageAbs)</l>
<l>        gray_projections (ImageAbs, ImageAbs, 'simple', HorProjection, VertProjection)</l>
<l>        Features := [Features,HorProjection]</l>
<l>    elseif (Mode == 'vert_sobel_amp')</l>
<l>        sobel_amp (PolarTransImage, EdgeAmplitude, 'sum_abs', 3)</l>
<l>        abs_image (EdgeAmplitude, ImageAbs)</l>
<l>        gray_projections (ImageAbs, ImageAbs, 'simple', HorProjection, VertProjection)</l>
<l>        Features := [Features,VertProjection]</l>
<l>    elseif (Mode == 'hor_sobel_x')</l>
<l>        sobel_amp (PolarTransImage, EdgeAmplitude, 'x_binomial', 3)</l>
<l>        abs_image (EdgeAmplitude, ImageAbs)</l>
<l>        gray_projections (ImageAbs, ImageAbs, 'simple', HorProjection, VertProjection)</l>
<l>        Features := [Features,HorProjection]</l>
<l>    elseif (Mode == 'vert_sobel_x')</l>
<l>        sobel_amp (PolarTransImage, EdgeAmplitude, 'x_binomial', 3)</l>
<l>        abs_image (EdgeAmplitude, ImageAbs)</l>
<l>        gray_projections (ImageAbs, ImageAbs, 'simple', HorProjection, VertProjection)</l>
<l>        Features := [Features,VertProjection]</l>
<l>    elseif (Mode == 'hor_sobel_y')</l>
<l>        sobel_amp (PolarTransImage, EdgeAmplitude, 'y_binomial', 3)</l>
<l>        abs_image (EdgeAmplitude, ImageAbs)</l>
<l>        gray_projections (ImageAbs, ImageAbs, 'simple', HorProjection, VertProjection)</l>
<l>        Features := [Features,HorProjection]</l>
<l>    elseif (Mode == 'vert_sobel_y')</l>
<l>        sobel_amp (PolarTransImage, EdgeAmplitude, 'y_binomial', 3)</l>
<l>        abs_image (EdgeAmplitude, ImageAbs)</l>
<l>        gray_projections (ImageAbs, ImageAbs, 'simple', HorProjection, VertProjection)</l>
<l>        Features := [Features,VertProjection]</l>
<l>    else</l>
<l>        throw ('Unknown Mode: ' + Mode + ' in calc_feature_polar_proj')</l>
<l>    endif</l>
<l>endfor</l>
<l>return ()</l>
</body>
<docu id="calc_feature_polar_gray_proj">
<abstract lang="en_US">Calculate gray-value projections of polar-transformed image regions.

For more information about the usage of the get_feature_set library, see documentation of calculate_features.</abstract>
<chapters lang="de_DE">
<item>Klassifikation</item>
<item>Sonstiges</item>
</chapters>
<chapters lang="en_US">
<item>Classification</item>
<item>Misc</item>
</chapters>
<library lang="en_US">MVTec Standard Procedures</library>
<short lang="en_US">Calculate gray-value projections of polar-transformed image regions.</short>
<parameters>
<parameter id="Features">
<default_type>real</default_type>
<description lang="en_US">Calculated feature values.</description>
<mixed_type>false</mixed_type>
<multivalue>optional</multivalue>
<sem_type>real</sem_type>
<type_list>
<item>real</item>
</type_list>
</parameter>
<parameter id="Height">
<default_type>integer</default_type>
<default_value>40</default_value>
<description lang="en_US">Height of the polar transformed image.</description>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>extent.y</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="Image">
<description lang="en_US">Gray value image.</description>
<multichannel>false</multichannel>
<multivalue>false</multivalue>
<sem_type>image</sem_type>
</parameter>
<parameter id="Mode">
<default_type>string</default_type>
<description lang="en_US">Calculation mode.</description>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>string</sem_type>
<type_list>
<item>string</item>
</type_list>
<value_list>
<item>'hor_gray'</item>
<item>vert_gray'</item>
<item>'hor_sobel_amp'</item>
<item>'vert_sobel_amp'</item>
<item>'hor_sobel_x'</item>
<item>'vert_sobel_x'</item>
<item>'hor_sobel_y'</item>
<item>'vert_sobel_y'</item>
</value_list>
</parameter>
<parameter id="Region">
<description lang="en_US">Regions to be examined.</description>
<multivalue>optional</multivalue>
<sem_type>region</sem_type>
</parameter>
<parameter id="Width">
<default_type>integer</default_type>
<default_value>100</default_value>
<description lang="en_US">Width of the polar transformed image.</description>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>extent.x</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
</parameters>
</docu>
</procedure>
<procedure name="calc_feature_pyramid" access="local">
<interface>
<io>
<par name="Region" base_type="iconic" dimension="0"/>
<par name="Image" base_type="iconic" dimension="0"/>
</io>
<ic>
<par name="FeatureName" base_type="ctrl" dimension="0"/>
<par name="NumLevels" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="Feature" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c>* </c>
<c>* Calculate a feature for different pyramid levels</c>
<c>* </c>
<l>Zoom := 0.5</l>
<l>Feature := []</l>
<l>count_obj (Region, NumRegions)</l>
<l>if (NumRegions &gt; 0)</l>
<l>    for I := 1 to NumLevels by 1</l>
<l>        if (I &gt; 1)</l>
<l>            zoom_image_factor (ImageZoom, ImageZoom, Zoom, Zoom, 'constant')</l>
<l>            zoom_region (RegionZoom, RegionZoom, Zoom, Zoom)</l>
<l>            calculate_features (RegionZoom, ImageZoom, FeatureName, Features)</l>
<l>        else</l>
<l>            copy_obj (Image, ImageZoom, 1, 1)</l>
<l>            copy_obj (Region, RegionZoom, 1, NumRegions)</l>
<l>            calculate_features (RegionZoom, ImageZoom, FeatureName, Features)</l>
<l>            FeatureLength := |Features| / NumRegions</l>
<l>            Step := NumLevels * FeatureLength</l>
<l>        endif</l>
<l>        Indices := []</l>
<l>        for J := 0 to NumRegions - 1 by 1</l>
<l>            Start := J * Step + (I - 1) * FeatureLength</l>
<l>            End := Start + FeatureLength - 1</l>
<l>            Indices := [Indices,[Start:End]]</l>
<l>        endfor</l>
<l>        Feature[Indices] := Features</l>
<l>    endfor</l>
<l>endif</l>
<l>return ()</l>
</body>
<docu id="calc_feature_pyramid">
<abstract lang="en_US">Calculate a feature on multiple image pyramid levels.

For more information about the usage of the get_feature_set library, see documentation of calculate_features.</abstract>
<chapters lang="de_DE">
<item>Klassifikation</item>
<item>Sonstiges</item>
</chapters>
<chapters lang="en_US">
<item>Classification</item>
<item>Misc</item>
</chapters>
<library lang="en_US">MVTec Standard Procedures</library>
<short lang="en_US">Calculate a feature on different image pyramid levels.</short>
<parameters>
<parameter id="Feature">
<default_type>real</default_type>
<description lang="en_US">Calculated feature values.</description>
<mixed_type>false</mixed_type>
<multivalue>optional</multivalue>
<sem_type>real</sem_type>
<type_list>
<item>real</item>
</type_list>
</parameter>
<parameter id="FeatureName">
<default_type>string</default_type>
<description lang="en_US">Name of the feature that shall be calculated on multiple pyramid levels.</description>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>string</sem_type>
<type_list>
<item>string</item>
</type_list>
</parameter>
<parameter id="Image">
<description lang="en_US">Input image.</description>
<multichannel>optional</multichannel>
<multivalue>false</multivalue>
<sem_type>image</sem_type>
</parameter>
<parameter id="NumLevels">
<default_type>integer</default_type>
<default_value>4</default_value>
<description lang="en_US">Number of pyramid levels.</description>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>integer</sem_type>
<type_list>
<item>integer</item>
</type_list>
<value_min>1</value_min>
<values>
<item>2</item>
<item>3</item>
<item>4</item>
</values>
</parameter>
<parameter id="Region">
<description lang="en_US">Regions to be examined.</description>
<multivalue>optional</multivalue>
<sem_type>region</sem_type>
</parameter>
</parameters>
</docu>
</procedure>
<procedure name="calculate_dl_segmentation_class_weights">
<interface>
<ic>
<par name="DLDataset" base_type="ctrl" dimension="0"/>
<par name="MaxWeight" base_type="ctrl" dimension="0"/>
<par name="IgnoreClassIDs" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="ClassWeights" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c>* </c>
<c>* This procedure calculates a weight for each class that is present in the Dataset.</c>
<c>* The class weights are calculated according to the inverse class frequencies</c>
<c>* in the training dataset.</c>
<c>* Therefore, the dataset has to be split before calling this procedure.</c>
<c>* </c>
<c>* Check if the input is correct.</c>
<l>get_dict_param (DLDataset, 'key_exists', ['samples','class_ids'], KeysExists)</l>
<l>if (not KeysExists[0])</l>
<l>    throw ('DLDataset must contain a key-value pair for \'samples\'')</l>
<l>endif</l>
<l>if (not KeysExists[1])</l>
<l>    throw ('DLDataset must contain a key-value pair for \'class_ids\'')</l>
<l>endif</l>
<l>if (MaxWeight &lt;= 0)</l>
<l>    throw ('MaxWeight must be greater than 0')</l>
<l>endif</l>
<c>* </c>
<c>* Get the samples of the dataset.</c>
<l>get_dict_tuple (DLDataset, 'samples', DLSamples)</l>
<c>* Get the train samples.</c>
<l>find_dl_samples (DLSamples, 'split', 'train', 'match', SampleIndices)</l>
<l>if (|SampleIndices| == 0)</l>
<l>    throw ('The DLDataset does not contain any samples with value \'train\' for key \'split\'')</l>
<l>endif</l>
<c>* </c>
<c>* Get the class IDs of the dataset.</c>
<l>get_dict_tuple (DLDataset, 'class_ids', ClassIDs)</l>
<l>NumClasses := |ClassIDs|</l>
<c>* </c>
<c>* Define mapping from class ID to class index.</c>
<l>ClassIDsToClassIdx := gen_tuple_const(max(ClassIDs) + 1,-1)</l>
<l>ClassIDsToClassIdx[ClassIDs] := [0:|ClassIDs| - 1]</l>
<c>* </c>
<c>* We want to collect the number of pixels for each class.</c>
<l>ClassAreas := gen_tuple_const(|ClassIDs|,0)</l>
<c>* </c>
<c>* Loop over the samples.</c>
<l>for SampleIndex := 0 to |SampleIndices| - 1 by 1</l>
<c>    * </c>
<c>    * Read the sample.</c>
<l>    read_dl_samples (DLDataset, SampleIndices[SampleIndex], DLSample)</l>
<c>    * </c>
<c>    * Get the segmentation image.</c>
<l>    get_dict_object (SegmentationImage, DLSample, 'segmentation_image')</l>
<c>    * </c>
<c>    * Convert the segmentation image if necessary.</c>
<l>    get_image_type (SegmentationImage, ImageType)</l>
<l>    if (find(['int1','int2','uint2','byte'],ImageType) == -1)</l>
<l>        convert_image_type (SegmentationImage, SegmentationImage, 'uint2')</l>
<l>    endif</l>
<c>    * </c>
<c>    * Get the number of pixels for each class.</c>
<l>    gray_histo_abs (SegmentationImage, SegmentationImage, 1, AbsoluteHisto)</l>
<c>    * </c>
<c>    * Accumulate the areas.</c>
<l>    ClassAreas := ClassAreas + AbsoluteHisto[ClassIDs]</l>
<l>endfor</l>
<c>* </c>
<c>* Get the total number of pixels without the area of ignore classes.</c>
<l>ClassAreas[ClassIDsToClassIdx[IgnoreClassIDs]] := 0</l>
<l>TotalArea := sum(ClassAreas)</l>
<c>* </c>
<c>* Calculate the inverse class frequencies.</c>
<l>ClassWeights := gen_tuple_const(|ClassIDs|,0.)</l>
<l>ValidClasses := find(ClassAreas [!=] 0,1)</l>
<l>ClassFreq := ClassAreas / real(TotalArea)</l>
<l>ClassWeights[ValidClasses] := 1. / (ClassFreq[ValidClasses] + 0.0001)</l>
<c>* </c>
<c>* Scale the weights to obtain a final output of 1.0 for the most frequent class.</c>
<l>ClassWeights := ClassWeights / min(ClassWeights[ValidClasses])</l>
<c>* Clip the weights.</c>
<l>IndicesToClip := find(ClassWeights [&gt;] MaxWeight,1)</l>
<l>if (IndicesToClip != -1)</l>
<l>    ClassWeights[IndicesToClip] := MaxWeight</l>
<l>endif</l>
<c></c>
<l>return ()</l>
</body>
<docu id="calculate_dl_segmentation_class_weights">
<abstract lang="en_US">This procedure calculates the class weights for a given dataset used in a segmentation model.
The class weights are calculated based on the inverse class frequency in the training dataset.
The weights are scaled such that the minimum value of not ignored classes is 1. Weight values are limited to MaxWeight.
For classes which are declared as to be ignored over IgnoreClassIDs, the weight is set to 0.</abstract>
<chapters lang="de_DE">
<item>Deep Learning</item>
<item>Semantische Segmentierung</item>
</chapters>
<chapters lang="en_US">
<item>Deep Learning</item>
<item>Semantic Segmentation</item>
</chapters>
<library lang="en_US">MVTec Standard Procedures</library>
<short lang="en_US">Calculate the class weights for a semantic segmentation dataset.</short>
<parameters>
<parameter id="ClassWeights">
<default_type>real</default_type>
<description lang="en_US">A tuple containing a weight for each class which is contained in DLDataset.</description>
<multivalue>optional</multivalue>
<sem_type>any</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
<parameter id="DLDataset">
<default_type>integer</default_type>
<default_value>DLDataset</default_value>
<description lang="en_US">The dataset for which the class weights should be calculated.</description>
<mixed_type>false</mixed_type>
<sem_type>dict</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="IgnoreClassIDs">
<default_type>integer</default_type>
<default_value>[]</default_value>
<description lang="en_US">For all given ignore class IDs the weight is set to 0.</description>
<mixed_type>false</mixed_type>
<multivalue>optional</multivalue>
<sem_type>integer</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="MaxWeight">
<default_type>real</default_type>
<default_value>1000</default_value>
<description lang="en_US">Weights greater than this value are clipped to max_weight (default: 1000)</description>
<multivalue>false</multivalue>
<sem_type>real</sem_type>
<type_list>
<item>real</item>
</type_list>
</parameter>
</parameters>
</docu>
</procedure>
<procedure name="calculate_evaluation_measures">
<interface>
<ic>
<par name="RunningMeasures" base_type="ctrl" dimension="0"/>
<par name="EvalParams" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="EvaluationResult" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c>* </c>
<c>* This procedure calculates the final measures depending on the evaluation type.</c>
<c>* </c>
<l>get_dict_tuple (EvalParams, 'evaluation_type', EvaluationType)</l>
<l>if (EvaluationType == 'anomaly_detection')</l>
<l>    calculate_image_anomaly_measures (RunningMeasures, EvalParams, EvaluationResult)</l>
<l>elseif (EvaluationType == 'classification')</l>
<l>    calculate_image_classification_measures (RunningMeasures, EvalParams, EvaluationResult)</l>
<l>elseif (EvaluationType == 'detection')</l>
<l>    calculate_instance_measures (RunningMeasures, EvalParams, EvaluationResult)</l>
<l>elseif (EvaluationType == 'segmentation')</l>
<l>    calculate_pixel_measures (RunningMeasures, EvalParams, EvaluationResult)</l>
<l>endif</l>
<c>* </c>
<l>return ()</l>
</body>
<docu id="calculate_evaluation_measures">
<abstract lang="en_US">Calculate the evaluation measures specified in the dictionary EvalParams, using the current values stored in RunningMeasures.
The dictionary RunningMeasures accumulates all hitherto per-image evaluation results.
All resulting measure values are given in the output dictionary EvaluationResult.

Which evaluation measure is possible depends on the type of evaluation, specified in EvalParams by the key 'evaluate_type':

- For 'evaluation_type' set to 'anomaly_detection' these measures are:
   -- 'anomaly_score_histogram': Histogram of scores predicted by the anomaly detection model.

- For 'evaluation_type' set to 'classification' these measures are:
  -- 'abolute_confusion_matrix' (overall): Confusion matrix, where entry (i,j) is the number of images with ground truth class_ids[j] predicted as class_ids[i].
  -- 'relatve_confusion_matrix' (overall): Confusion matrix, but every entry (i,j) is normalized by the number of ground truth labels of the class in column j.
  For each evaluated class given by the key 'class_ids_to_evaluate' that is not 'global':
  -- 'topK_error' (per-class): Ratio of predictions where the ground truth class is not within the K predicted classes with highest probability. Thereby, K can be a number within the interval [1,number of classes]. The error is only calculated for the selected class.
  -- 'precision' (per-class): Proportion of all correct predicted positives to all predicted positives (true and false ones).
  -- 'recall' (per-class): Proportion of all correct predicted positives to all real positives.
  -- 'f_score' (per-class): Harmonic mean of precision and recall.
  In case that 'class_ids_to_evaluate' is set to 'global' (which means that all classes are evaluated):
  -- 'topK_error' (per-class): Ratio of predictions where the ground truth class is not within the K predicted classes with highest probability. Thereby, K can be a number within the interval [1,number of classes]. The error is calculated over all classes.
  -- 'precision_per_class': Precision for all classes.
  -- 'mean_precision': Mean over all precision values.
  -- 'recall_per_class': Recall for all classes.
  -- 'mean_recall': Mean over all recall values.
  -- 'f_score_per_class': F-score for all classes.
  -- 'mean_f_score': Mean over all F-score values.
In addition, EvaluationResult contains a dictionary 'evaluated_samples' that keeps the following information about the evaluated samples:
  -- 'image_ids': Image IDs of the samples that have been evaluated.
  -- 'image_label_ids': Ground truth image label IDs of the samples that have been evaluated.
  -- 'top1_predictions': Predictions of the evaluated samples.

- For 'evaluation_type' set to 'detection', the measures are given for all entries fulfilling the specifications in the dictionary EvalParams given over the keys 'max_num_detections' and 'area_ranges'.
  These measures are:
     -- 'mean_ap' (per-class and overall): Mean average precision, i.e. the mean of the per class average precision. The average precision is obtained from the area under the (interpolated) precision-recall-curve. The value is given per IoU threshold and as a mean over the given IoU thresholds.
     -- 'mean_soap_tp' (per-class and overall, only for instance_type 'rectangle2'): Score of Angle Precision (SoAP). This score is calculated only for true positive instances and has a value range from 0 (meaning that all orientations of true positive instances are maximally wrong) to 1 (all orientations of true positive instances are totally correct).
  If the key 'detailed_evaluation' in EvalParams has the value 'true', the following additional measures are calculated. Except 'mean_soap_all' they are calculated per IoU threshold and stored under the key 'detailed_evaluation_iou_&lt;iou_threshold&gt;':
     -- 'num_tp' (per-class and overall): Number of true positives, i.e. the number of correctly detected ground truth annotations.
     -- 'num_fn' (per-class and overall): Number of false negatives, i.e. the number of not detected ground truth annotations.
     -- 'num_fp' (per-class and overall): Total Number of false positives, i.e. the number of detections not matching to a ground truth annotation. This group is subdivided:
     -- 'num_fp_class' (per-class and overall): Number of detections with a wrong inferred class.
     -- 'num_fp_background' (per-class and overall): Number of detections within background regions, i.e., without overlap to any ground truth.
     -- 'num_fp_localization' (per-class and overall): Number of detections with a correct inferred class and overlapping with a ground truth annotation, but where the IoU is too low to be a true positive.
     -- 'num_fp_duplicate' (per-class and overall): Number of detections that are correct with respect to class and IoU, but where another correct detection with higher confidence to the ground truth annotation exists.
     -- 'num_fp_multiple' (per-class and overall): Number of detections with multiple reasons for being false positive, e.g. wrong class and low IoU.
     -- 'detection_confusion_matrix' (overall): A matrix of size (num_classes + 1, num_classes + 4) that shows on the diagonal the number of true positives and in entry (i,j) the number detections of class index i that have been confused with class index j (for i, j = 0, 1, ..., num_classes-1). In entry (i, num_classes) 'num_fp_background', in entry (i, num_classes+1) 'num_fp_localization', in entry (i, num_classes+2) 'num_fp_duplicate', in entry (i, num_classes+3) 'num_fp_multiple' for class index i, respectively. In entry (num_classes, j) 'num_fn' for class index j is depicted.
     -- 'image_ids_with_false_negatives' (overall): A tuple with the IDs of all images containing at least one false negative, i.e., a  ground truth annotation that has not been correctly detected.
     -- 'image_ids_with_false_positives' (overall): A tuple with the IDs of all images containing at least one false positive detection.
     -- 'mean_soap_all' (only for instance_type 'rectangle2'): The SoAP scores for true positives, false positives due to wrong class, wrong localization, duplicate, and multiple reasons are averaged over all IoU thresholds and over all classes (weighted by class occurrence). 
     -- 'soap_fp_class' (per-class and overall, only for instance_type 'rectangle2'): The SoAP score calculated for those false positives that have the wrong class.
     -- 'soap_fp_localization' (per-class and overall, only for instance_type 'rectangle2'): The SoAP score calculated for those false positives that are false due to the localization.
     -- 'soap_fp_duplicate' (per-class and overall, only for instance_type 'rectangle2'): The SoAP score calculated for those false positives that are false due to duplicate detections.
     -- 'soap_fp_multiple' (per-class and overall, only for instance_type 'rectangle2'): The SoAP score calculated for those false positives that are false due to multiple reasons.
  Note that classes without any ground truth instances are ignored in the mean/average calculations. Their individual per-class measures are set to -1. If there is no ground truth instance given for a class in the whole dataset, also the false positives are ignored for this class in the evaluation.
  SoAP scores for classes without according instance (i.g., the according num_ = 0) are set to -1 and do not contribute to the averages.

- For 'evaluation_type' set to 'segmentation' these measures are:
   -- 'class_iou' (per-class): Intersection over union between the ground truth and the result regions.
   -- 'mean_iou' (overall): Mean (over classes) of 'class_iou'.
   -- 'frequency_weighted_iou' (overall): Average (over classes) of 'class_iou', where each class is weighted by the ratio of pixels belonging to that class.
   -- 'class_pixel_accuracy' (per-class): Ratio of pixels predicted with the correct class-label.
   -- 'pixel_accuracy' (overall): Ratio of pixels predicted with the correct class-label, accumulated over classes.
   -- 'mean_accuracy' (overall): Mean (over classes) of 'class_pixel_accuracy'.
   -- 'pixel_confusion_matrix' (overall): Confusion matrix, where entry (i,j) is the number of pixels with ground truth class_ids[j] predicted as class_ids[i].
       Note, the use of this measure slows down the evaluation process.
   -- 'all': Same as specifying all measures.
  Note that classes without any ground truth pixels are ignored in the mean/average calculations. Their individual per-class measures are set to -1.

The dictionary EvalParams can be created using the procedure create_evaluation_default_param.
The dictionary RunningMeasures can be created and initialized using the procedure init_running_evaluation_measures. For updating RunningMeasures based on samples and the corresponding results, use the procedure update_running_evaluation_measures.</abstract>
<chapters lang="de_DE">
<item>Deep Learning</item>
<item>Evaluierung</item>
</chapters>
<chapters lang="en_US">
<item>Deep Learning</item>
<item>Evaluation</item>
</chapters>
<library lang="en_US">MVTec Standard Procedures</library>
<short lang="en_US">Calculate evaluation measures based on the values of RunningMeasures and the settings in EvalParams.</short>
<parameters>
<parameter id="EvalParams">
<default_type>integer</default_type>
<default_value>EvalParams</default_value>
<description lang="en_US">Dictionary with the evaluation parameters.</description>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>dict</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="EvaluationResult">
<default_type>integer</default_type>
<description lang="en_US">Dictionary with the output measures.</description>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>dict</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="RunningMeasures">
<default_type>integer</default_type>
<default_value>RunningMeasures</default_value>
<description lang="en_US">Running, current measure values to be summarized to different measures.</description>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>dict</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
</parameters>
</docu>
</procedure>
<procedure name="calculate_features">
<interface>
<io>
<par name="Region" base_type="iconic" dimension="0"/>
<par name="Image" base_type="iconic" dimension="0"/>
</io>
<ic>
<par name="FeatureNames" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="Features" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c>* </c>
<c>* Calculate features given in FeatureNames</c>
<c>* for the input regions in Region</c>
<c>* (if needed supported by the underlying</c>
<c>* gray-value or color image Image).</c>
<c>* </c>
<l>get_features (Region, Image, FeatureNames, 'calculate', Features)</l>
<l>return ()</l>
</body>
<docu id="calculate_features">
<abstract lang="en_US">calculate_features calculates the features indicated in FeatureNames for each input region in Region, if necessary using the underlying gray values of  Image, and returns the feature vectors in Features. If the input region contains several unconnected components that are to be classified individually, they should be separated, e.g., using connection before calculating the features.

The feature vectors in Features are sorted as follows:
The full first feature comes first for regions, then the second feature, and so on ([F1R1, F1R2,...,F1Rm,F2R1,...,F2Rm,...,FnRm] with FiRj being the feature vector for the i-th feature and the j-th region). This corresponds to the 'feature_column' order used by add_sample_class_train_data.

_____________________________________________________

HOW TO USE THE CALCULATE_FEATURE_SET.HDPL LIBRARY
_____________________________________________________

1. Overview

The library contains a set of convenience procedures to calculate features of pre-segmented regions and images. The contained features belong to several groups. This makes it easier to access only features with particular characteristics.

2. Available procedures

- query_feature_group_names
Query all available feature groups.

- query_feature_names_by_group
Get a list of all features and the groups they belong to.

- get_feature_names
Get a list of all features belonging to one or more given groups.

- get_feature_lengths
Get the lengths of the feature vectors of given features.

- calculate_features
Calculate multiple features of one or more input regions in one call.

While already a large number of features is contained in the library, it is designed in a way that it can be easily extended by user-defined features. To do this, simply follow the instructions contained in the comments of the get_custom_feature procedure. There also exists a convenience procedure that allows to test if features are implemented according to the library specifications.

- test_features (Names)
 If a problem is detected, the test_features procedure throws an exception.

3. Usage

The procedure is designed to be used together with HALCON's automatic feature selection.
First, choose the features of the group(s) that are suitable for your application. E.g.:

get_feature_names ('REGION', RegionFeatureNames)

Then, prepare training data structure for automatic feature selection:

get_feature_lengths (RegionFeatureNames, Lengths)
create_class_train_data (sum(Lengths), ClassTrainDataHandle)
set_feature_lengths_class_train_data (ClassTrainDataHandle, Lengths, RegionFeatureNames)

Then, calculate features for the samples and add them to the class_train_data:

calculate_features (RegionsClass0, Image, RegionFeatureNames, Features0)
add_sample_class_train_data (ClassTrainDataHandle, 'feature_column', Features0, 0)
calculate_features (RegionsClass1, Image, RegionFeatureNames, Features1)
add_sample_class_train_data (ClassTrainDataHandle, 'feature_column', Features1, 1)

Then, select the best features automatically:

select_feature_set_mlp (ClassTrainDataHandle, 'greedy', [], [], MLPHandle, SelectedFeatures, Score)

Finally, use the resulting classifier to classify the data:

calculate_features (ObjectSelected, Image, SelectedFeatures, Features)
classify_class_mlp (MLPHandle, Features, 1, Class, Confidence)

For more information of the implemented features, see get_features.
</abstract>
<alternatives>
<item>region_features</item>
<item>gray_features</item>
</alternatives>
<chapters lang="de_DE">
<item>Klassifikation</item>
<item>Sonstiges</item>
</chapters>
<chapters lang="en_US">
<item>Classification</item>
<item>Misc</item>
</chapters>
<example lang="en_US">* Query group names and corresponding features 
query_feature_group_names (AllGroupNames)
query_feature_names_by_group (AllGroupNames, FeatureNames, Groups)
* Get region features and their lengths
get_feature_names ('REGION', RegionFeatureNames)
get_feature_lengths (RegionFeatureNames, Lengths)
* Prepare training data structure 
create_class_train_data (sum(Lengths), ClassTrainDataHandle)
set_feature_lengths_class_train_data (ClassTrainDataHandle, Lengths, RegionFeatureNames)
* Segment training samples
read_image (Image, 'clip')
binary_threshold (Image, Region, 'otsu', 'dark', UsedThreshold)
connection (Region, ConnectedRegions)
select_obj (ConnectedRegions, RegionsClass0, [2,5,9]) 
select_obj (ConnectedRegions, RegionsClass1, [3,8,13])
* Train class 0
calculate_features (RegionsClass0, Image, RegionFeatureNames, Features0)
add_sample_class_train_data (ClassTrainDataHandle, 'feature_column', Features0, 0)
* Train class 1
calculate_features (RegionsClass1, Image, RegionFeatureNames, Features1)
add_sample_class_train_data (ClassTrainDataHandle, 'feature_column', Features1, 1)
* Select suitable features
select_feature_set_mlp (ClassTrainDataHandle, 'greedy', [], [], MLPHandle, SelectedFeatures, Score)
* Classify all regions with selected feature(s)
Color := ['blue','orange']
count_obj (ConnectedRegions, Number)
for I := 1 to Number by 1
select_obj (ConnectedRegions, ObjectSelected, I)
calculate_features (ObjectSelected, Image, SelectedFeatures, Features)
classify_class_mlp (MLPHandle, Features, 1, Class, Confidence)
dev_set_color (Color[Class])
dev_display (ObjectSelected)
endfor

</example>
<keywords lang="en_US">
<item>classification</item>
<item>features</item>
</keywords>
<library lang="en_US">MVTec Standard Procedures</library>
<predecessor>
<item>connection</item>
<item>select_shape</item>
<item>get_feature_names</item>
<item>get_feature_lengths</item>
</predecessor>
<see_also>
<item>get_feature_names</item>
<item>get_feature_lengths</item>
<item>add_sample_class_train_data</item>
<item>select_feature_set_knn</item>
<item>select_feature_set_svm</item>
<item>select_feature_set_mlp</item>
</see_also>
<short lang="en_US">Calculate one or more features of a given image and/or region.</short>
<successor>
<item>add_sample_class_train_data</item>
<item>classify_class_knn</item>
<item>classify_class_svm</item>
<item>classify_class_mlp</item>
</successor>
<parameters>
<parameter id="FeatureNames">
<default_type>string</default_type>
<default_value>'area'</default_value>
<description lang="en_US">Names of the feature to be calculated. These names are typically obtained from get_feature_names.</description>
<mixed_type>false</mixed_type>
<multivalue>optional</multivalue>
<sem_type>string</sem_type>
<type_list>
<item>string</item>
</type_list>
<values>
<item>'area'</item>
<item>'width'</item>
<item>'height'</item>
<item>'ra'</item>
<item>'rb'</item>
<item>'phi'</item>
<item>'roundness'</item>
<item>'num_sides'</item>
<item>'num_connected'</item>
<item>'num_holes'</item>
<item>'area_holes'</item>
<item>'max_diameter'</item>
<item>'orientation'</item>
<item>'outer_radius'</item>
<item>'inner_radius'</item>
<item>'inner_width'</item>
<item>'inner_height'</item>
<item>'circularity'</item>
<item>'compactness'</item>
<item>'convexity'</item>
<item>'rectangularity'</item>
<item>'anisometry'</item>
<item>'bulkiness'</item>
<item>'struct_factor'</item>
<item>'dist_mean'</item>
<item>'dist_deviation'</item>
<item>'euler_number'</item>
<item>'rect2_phi'</item>
<item>'rect2_len1'</item>
<item>'rect2_len2'</item>
<item>'contlength'</item>
<item>'porosity'</item>
<item>'gray_area'</item>
<item>'gray_ra'</item>
<item>'gray_rb'</item>
<item>'gray_phi'</item>
<item>'gray_min'</item>
<item>'gray_max'</item>
<item>'gray_range'</item>
<item>'gray_mean'</item>
<item>'gray_deviation'</item>
<item>'gray_plane_deviation'</item>
<item>'gray_anisotropy'</item>
<item>'gray_entropy'</item>
<item>'gray_hor_proj'</item>
<item>'gray_vert_proj'</item>
<item>'gray_hor_proj_histo'</item>
<item>'gray_vert_proj_histo'</item>
<item>'grad_dir_histo'</item>
<item>'edge_density'</item>
<item>'edge_density_histogram'</item>
<item>'edge_density_pyramid_2'</item>
<item>'edge_density_pyramid_3'</item>
<item>'edge_density_pyramid_4'</item>
<item>'edge_density_histogram_pyramid_2'</item>
<item>'edge_density_histogram_pyramid_3'</item>
<item>'edge_density_histogram_pyramid_4'</item>
<item>'cooc'</item>
<item>'cooc_pyramid_2'</item>
<item>'cooc_pyramid_3'</item>
<item>'cooc_pyramid_4'</item>
<item>'polar_gray_proj'</item>
<item>'polar_grad_proj'</item>
<item>'polar_grad_x_proj'</item>
<item>'polar_grad_y_proj'</item>
<item>'polar_gray_proj_histo'</item>
<item>'cielab_mean'</item>
<item>'cielab_dev'</item>
<item>'hls_mean'</item>
<item>'hls_dev'</item>
<item>'rgb_mean'</item>
<item>'rgb_dev'</item>
</values>
</parameter>
<parameter id="Features">
<default_type>real</default_type>
<description lang="en_US">Calculated feature values.</description>
<mixed_type>false</mixed_type>
<multivalue>optional</multivalue>
<sem_type>real</sem_type>
<type_list>
<item>real</item>
</type_list>
</parameter>
<parameter id="Image">
<description lang="en_US">Input image, from which the features are calculated.</description>
<sem_type>image</sem_type>
</parameter>
<parameter id="Region">
<description lang="en_US">Input region(s), from which the features are calculated.</description>
<multivalue>optional</multivalue>
<sem_type>region</sem_type>
</parameter>
</parameters>
</docu>
</procedure>
<procedure name="calculate_image_anomaly_measures" access="local">
<interface>
<ic>
<par name="RunningMeasures" base_type="ctrl" dimension="0"/>
<par name="EvalParams" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="EvaluationResult" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c>* </c>
<c>* This procedure calculates the final summarizing image anomaly detection measures based on the running measures.</c>
<c>* </c>
<c>* Set some parameters.</c>
<l>MinScaling := 0.7</l>
<l>MaxScaling := 1.3</l>
<c>* Get and check values in RunningMeasures.</c>
<c>* </c>
<c>* Get image ids.</c>
<l>get_dict_tuple (RunningMeasures, 'image_ids', ImageIDs)</l>
<c>* Get anomaly ids.</c>
<l>get_dict_tuple (RunningMeasures, 'anomaly_label_ids', AnomalyLabelIDs)</l>
<c>* Get image scores.</c>
<l>get_dict_tuple (RunningMeasures, 'anomaly_scores', AnomalyScores)</l>
<c>* Get anomaly score thresholds from EvalParams.</c>
<l>try</l>
<l>    get_dict_tuple (EvalParams, 'anomaly_score_histogram', AnomalyScoreHistogram)</l>
<l>catch (Exception)</l>
<l>    MinScorePlot := MinScaling * min(AnomalyScores)</l>
<l>    MaxScorePlot := MaxScaling * max(AnomalyScores)</l>
<l>    NumBins := |AnomalyScores|</l>
<l>endtry</l>
<c>* </c>
<c>* No minimum value given.</c>
<l>try</l>
<l>    get_dict_tuple (AnomalyScoreHistogram, 'min', MinScorePlot)</l>
<l>catch (Exception)</l>
<l>    MinScorePlot := real(MinScaling * min(AnomalyScores))</l>
<l>endtry</l>
<c>* </c>
<c>* No maximum value given.</c>
<l>try</l>
<l>    get_dict_tuple (AnomalyScoreHistogram, 'max', MaxScorePlot)</l>
<l>catch (Exception)</l>
<l>    MaxScorePlot := real(MaxScaling * max(AnomalyScores))</l>
<l>endtry</l>
<c>* </c>
<c>* No number of bins given.</c>
<l>try</l>
<l>    get_dict_tuple (AnomalyScoreHistogram, 'num_bins', NumBins)</l>
<l>catch (Exception)</l>
<l>    NumBins := |AnomalyScores|</l>
<l>endtry</l>
<c>* </c>
<c>* Estimate thresholds for histogram calculation by using min/max of the anomaly scores.</c>
<l>if (MinScorePlot == -1 or |MinScorePlot| == 0)</l>
<l>    MinScorePlot := MinScaling * min(AnomalyScores)</l>
<l>elseif (MinScorePlot &lt; 0)</l>
<l>    throw ('Invalid value for minimum histogram value. Must be &gt;= 0.')</l>
<l>endif</l>
<c>* </c>
<l>if (MaxScorePlot == -1 or |MaxScorePlot| == 0)</l>
<l>    MaxScorePlot := min2(1.0,MaxScaling * max(AnomalyScores))</l>
<l>elseif (MaxScorePlot &lt;= 0)</l>
<l>    throw ('Invalid value for maximum histogram value. Must be &gt; 0.')</l>
<l>endif</l>
<c>* </c>
<l>if (NumBins == -1 or |NumBins| == 0)</l>
<l>    NumBins := |AnomalyScores|</l>
<l>elseif (NumBins == 0)</l>
<l>    throw ('Invalid number of bins. Must at least be 1.')</l>
<l>endif</l>
<c>* </c>
<c>* Assign scores with the right labels.</c>
<l>OKIndices := find(AnomalyLabelIDs,0)</l>
<l>ImageLevelScoresOK := AnomalyScores[OKIndices]</l>
<c>* </c>
<c>* Calculate histograms.</c>
<l>tuple_histo_range (ImageLevelScoresOK, MinScorePlot, MaxScorePlot, NumBins, HistoOK, BinSize)</l>
<c>* </c>
<c>* Calculate cumulative histogram</c>
<l>HistoCumulOK := 1. - cumul(HistoOK / real(max2(1.0,sum(HistoOK))))</l>
<c>* </c>
<l>NOKIndices := find(AnomalyLabelIDs,1)</l>
<l>if (NOKIndices != -1)</l>
<l>    ImageLevelScoresNOK := AnomalyScores[NOKIndices]</l>
<l>    tuple_histo_range (ImageLevelScoresNOK, MinScorePlot, MaxScorePlot, NumBins, HistoNOK, BinSize)</l>
<l>    HistoCumulNOK := cumul(HistoNOK / real(max2(1.0,sum(HistoNOK))))</l>
<l>else</l>
<l>    HistoCumulNOK := []</l>
<l>endif</l>
<c>* </c>
<c>* Calculate left sided bins.</c>
<l>AnomalyScoreBins := [MinScorePlot:BinSize:MinScorePlot + (NumBins - 1 + 1e-4) * BinSize]</l>
<c>* </c>
<c>* Create dictionary for the score histogram.</c>
<l>create_dict (ScoreHistogram)</l>
<l>set_dict_tuple (ScoreHistogram, 'ok', HistoCumulOK)</l>
<l>set_dict_tuple (ScoreHistogram, 'nok', HistoCumulNOK)</l>
<c>* </c>
<c>* Set the score histogram in the results dictionary.</c>
<l>create_dict (EvaluationResult)</l>
<l>set_dict_tuple (EvaluationResult, 'anomaly_score_histogram', ScoreHistogram)</l>
<l>set_dict_tuple (EvaluationResult, 'anomaly_score_bins', AnomalyScoreBins)</l>
<c>* </c>
<l>return ()</l>
</body>
<docu id="calculate_image_anomaly_measures">
<abstract lang="en_US">Based on the RunningMeasures and the parameters in EvalParams, the final anomaly detection evaluation is performed.

Which measures are calculated as output is determined in the dictionary EvalParams under the entry with the key 'measures'.
Possible values that are returned by EvaluationResult are:
  - 'anomaly_score_histogram': Calculated histogram of scores for samples of class 'ok' and 'nok' (if present) for different thresholds.</abstract>
<chapters lang="en_US">
<item>Deep Learning</item>
<item>Anomaly Detection</item>
</chapters>
<library lang="en_US">MVTec Standard Procedures</library>
<short lang="en_US">Calculate anomaly detection measures based on RunningMeasures.</short>
<parameters>
<parameter id="EvalParams"/>
<parameter id="EvaluationResult"/>
<parameter id="RunningMeasures"/>
</parameters>
</docu>
</procedure>
<procedure name="calculate_image_classification_measures" access="local">
<interface>
<ic>
<par name="RunningMeasures" base_type="ctrl" dimension="0"/>
<par name="EvalParams" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="EvaluationResult" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c>* </c>
<c>* This procedure calculates the final summarizing image classification measures based on the running measures.</c>
<c>* </c>
<c>* Set default values.</c>
<l>TopKErrorKs := []</l>
<l>CalcPrecision := false</l>
<l>CalcRecall := false</l>
<l>CalcFScore := false</l>
<l>CalcAbsoluteConfusionMatrix := false</l>
<l>CalcRelativeConfusionMatrix := false</l>
<c>* </c>
<c>* Check which measures are to be calculated.</c>
<l>get_dict_tuple (EvalParams, 'measures', Measures)</l>
<l>RegExpTopKError := 'top([0-9]+)_error'</l>
<l>for M := 0 to |Measures| - 1 by 1</l>
<l>    ComputeTopKError := Measures[M] =~ 'top([0-9]+)_error'</l>
<l>    if (ComputeTopKError)</l>
<l>        K := number(regexp_match(Measures[M],RegExpTopKError))</l>
<l>        TopKErrorKs := sort([TopKErrorKs,K])</l>
<l>    elseif (Measures[M] == 'precision')</l>
<l>        CalcPrecision := true</l>
<l>    elseif (Measures[M] == 'recall')</l>
<l>        CalcRecall := true</l>
<l>    elseif (Measures[M] == 'f_score')</l>
<l>        CalcFScore := true</l>
<l>    elseif (Measures[M] == 'absolute_confusion_matrix')</l>
<l>        CalcAbsoluteConfusionMatrix := true</l>
<l>    elseif (Measures[M] == 'relative_confusion_matrix')</l>
<l>        CalcRelativeConfusionMatrix := true</l>
<l>    elseif (Measures[M] == 'all')</l>
<l>        TopKErrorKs := sort([TopKErrorKs,1])</l>
<l>        CalcPrecision := true</l>
<l>        CalcRecall := true</l>
<l>        CalcFScore := true</l>
<l>        CalcAbsoluteConfusionMatrix := true</l>
<l>        CalcRelativeConfusionMatrix := true</l>
<l>    else</l>
<l>        throw ('Unknown image classification measure: ' + Measures[M])</l>
<l>    endif</l>
<l>endfor</l>
<c>* </c>
<c>* Initialize output dictionary and get necessary evaluation parameters.</c>
<l>create_dict (EvaluationResult)</l>
<l>get_dict_tuple (EvalParams, 'class_ids', ClassIDs)</l>
<l>get_dict_param (EvalParams, 'key_exists', 'class_names_to_evaluate', KeyExists)</l>
<l>if (KeyExists)</l>
<l>    get_dict_tuple (EvalParams, 'class_names_to_evaluate', ClassesToEvaluate)</l>
<l>    ClassIDsToEvaluate := []</l>
<l>    get_dict_tuple (EvalParams, 'class_names', ClassNames)</l>
<l>    for Index := 0 to |ClassesToEvaluate| - 1 by 1</l>
<l>        Position := find(['global',ClassNames] [==] ClassesToEvaluate[Index],1)</l>
<l>        if (Position == -1 or Position == [])</l>
<l>            throw ('Invalid entry in  \'class_names_to_evaluate\': ' + ['global',ClassesToEvaluate][Index])</l>
<l>        endif</l>
<l>        ClassIDsToEvaluate := [ClassIDsToEvaluate,['global',ClassIDs][Position]]</l>
<l>    endfor</l>
<l>    set_dict_tuple (EvalParams, 'class_ids_to_evaluate', ClassIDsToEvaluate)</l>
<l>endif</l>
<l>get_dict_tuple (EvalParams, 'class_ids_to_evaluate', ClassIDsToEvaluate)</l>
<c>* </c>
<c>* Get and check values in RunningMeasures.</c>
<l>get_dict_tuple (RunningMeasures, 'image_ids', ImageIDs)</l>
<l>get_dict_tuple (RunningMeasures, 'image_label_ids', ImageLabelIDs)</l>
<l>get_dict_tuple (RunningMeasures, 'top1_predictions', Predictions)</l>
<l>get_dict_tuple (RunningMeasures, 'topk_predictions', TopKPredictions)</l>
<c>* </c>
<c>* Check if needed classes appear in image label IDs.</c>
<c>* For the confusion matrices, all classes need to be represented.</c>
<l>CalcAbsoluteConfusionMatrix := CalcPrecision or CalcRecall or CalcFScore or CalcAbsoluteConfusionMatrix</l>
<l>CalcRelativeConfusionMatrix := CalcPrecision or CalcRecall or CalcFScore or CalcRelativeConfusionMatrix</l>
<l>if (CalcAbsoluteConfusionMatrix or CalcRelativeConfusionMatrix)</l>
<l>    if (uniq(sort(ImageLabelIDs)) != sort(ClassIDs))</l>
<l>        throw ('Not all classes are represented in the ground truth labels. \nPlease check your data split.')</l>
<l>    endif</l>
<l>endif</l>
<c>* For top-K errors, the evaluated classes need to be represented.</c>
<l>if (TopKErrorKs != [])</l>
<l>    for EvalIndex := 0 to |ClassIDsToEvaluate| - 1 by 1</l>
<l>        CurrentEvalClass := ClassIDsToEvaluate[EvalIndex]</l>
<l>        if (CurrentEvalClass != 'global')</l>
<l>            IndexClass := find(ImageLabelIDs,CurrentEvalClass)</l>
<l>            if (IndexClass == -1 or IndexClass == [])</l>
<l>                throw ('The evaluated class ID ' + CurrentEvalClass + ' is not represented in the ground truth labels.')</l>
<l>            endif</l>
<l>        endif</l>
<l>    endfor</l>
<l>endif</l>
<c>* </c>
<c>* Set image IDs, image label IDs, and top1-predictions to of evaluated samples EvaluationResult.</c>
<l>create_dict (EvaluatedSamples)</l>
<l>set_dict_tuple (EvaluatedSamples, 'image_ids', ImageIDs)</l>
<l>set_dict_tuple (EvaluatedSamples, 'image_label_ids', ImageLabelIDs)</l>
<l>set_dict_tuple (EvaluatedSamples, 'top1_predictions', Predictions)</l>
<l>set_dict_tuple (EvaluationResult, 'evaluated_samples', EvaluatedSamples)</l>
<c>* </c>
<c>* Calculate absolute confusion matrix if needed and set it to EvaluationResult.</c>
<l>if (CalcAbsoluteConfusionMatrix)</l>
<l>    gen_confusion_matrix (ImageLabelIDs, Predictions, 'display_matrix', 'none', [], ConfusionMatrix)</l>
<l>    set_dict_tuple (EvaluationResult, 'absolute_confusion_matrix', ConfusionMatrix)</l>
<l>endif</l>
<c>* </c>
<c>* Calculate relative confusion matrix.</c>
<l>if (CalcRelativeConfusionMatrix)</l>
<l>    gen_confusion_matrix (ImageLabelIDs, Predictions, ['display_matrix','return_matrix'], ['none','relative'], [], RelativeConfusionMatrix)</l>
<l>    set_dict_tuple (EvaluationResult, 'relative_confusion_matrix', RelativeConfusionMatrix)</l>
<l>endif</l>
<c>* </c>
<c>*  Calcuate measures for every class to be evaluated.</c>
<l>for EvalIndex := 0 to |ClassIDsToEvaluate| - 1 by 1</l>
<l>    CurrentEvalClass := ClassIDsToEvaluate[EvalIndex]</l>
<l>    create_dict (EvalClassID)</l>
<c>    * </c>
<c>    * Calculate top-K errors.</c>
<l>    for KIndex := 0 to |TopKErrorKs| - 1 by 1</l>
<l>        K := TopKErrorKs[KIndex]</l>
<l>        if (CurrentEvalClass == 'global')</l>
<l>            Indices := [0:|ImageLabelIDs| - 1]</l>
<l>        else</l>
<l>            Indices := find(ImageLabelIDs,CurrentEvalClass)</l>
<l>        endif</l>
<l>        compute_top_k_error (ImageLabelIDs[Indices], TopKPredictions[Indices], K, TopKError)</l>
<l>        set_dict_tuple (EvalClassID, 'top' + K + '_error', TopKError)</l>
<l>    endfor</l>
<c>    * </c>
<l>    if (CurrentEvalClass == 'global')</l>
<c>        * Compute the mean of the measures for all classes.</c>
<l>        NumClasses := |ClassIDs|</l>
<l>        IndexClass := ClassIDs</l>
<l>    else</l>
<c>        * Compute the measures for a certain class.</c>
<l>        NumClasses := 1</l>
<l>        IndexClass := find(ClassIDs,CurrentEvalClass)</l>
<l>    endif</l>
<c>    * </c>
<c>    * Calculate prediction.</c>
<l>    if (CalcPrecision or CalcFScore)</l>
<l>        ClassPrecisions := []</l>
<l>        sum_matrix (ConfusionMatrix, 'rows', MatrixRowSumID)</l>
<l>        for Index := 0 to NumClasses - 1 by 1</l>
<c>            * Compute the precision for every selected class.</c>
<l>            get_value_matrix (ConfusionMatrix, IndexClass[Index], IndexClass[Index], TruePositive)</l>
<l>            get_value_matrix (MatrixRowSumID, IndexClass[Index], 0, SumPredictedClass)</l>
<l>            if (SumPredictedClass == 0)</l>
<l>                ClassPrecision := 0</l>
<l>            else</l>
<l>                ClassPrecision := TruePositive / SumPredictedClass</l>
<l>            endif</l>
<l>            ClassPrecisions := [ClassPrecisions,ClassPrecision]</l>
<l>        endfor</l>
<l>        Precision := mean(ClassPrecisions)</l>
<l>        clear_matrix (MatrixRowSumID)</l>
<l>        if (NumClasses == 1)</l>
<l>            set_dict_tuple (EvalClassID, 'precision', Precision)</l>
<l>        else</l>
<l>            set_dict_tuple (EvalClassID, 'mean_precision', Precision)</l>
<l>            set_dict_tuple (EvalClassID, 'precision_per_class', ClassPrecisions)</l>
<l>        endif</l>
<l>    endif</l>
<c>    * </c>
<c>    * Calculate recall.</c>
<l>    if (CalcRecall or CalcFScore)</l>
<l>        ClassRecalls := []</l>
<l>        sum_matrix (ConfusionMatrix, 'columns', MatrixColumnSumID)</l>
<l>        for Index := 0 to NumClasses - 1 by 1</l>
<c>            * Compute the recall for every class.</c>
<l>            get_value_matrix (ConfusionMatrix, IndexClass[Index], IndexClass[Index], TruePositive)</l>
<l>            get_value_matrix (MatrixColumnSumID, 0, IndexClass[Index], SumLabel)</l>
<l>            ClassRecall := TruePositive / SumLabel</l>
<l>            ClassRecalls := [ClassRecalls,ClassRecall]</l>
<l>        endfor</l>
<l>        Recall := mean(ClassRecalls)</l>
<l>        clear_matrix (MatrixColumnSumID)</l>
<l>        if (NumClasses == 1)</l>
<l>            set_dict_tuple (EvalClassID, 'recall', Recall)</l>
<l>        else</l>
<l>            set_dict_tuple (EvalClassID, 'mean_recall', Recall)</l>
<l>            set_dict_tuple (EvalClassID, 'recall_per_class', ClassRecalls)</l>
<l>        endif</l>
<l>    endif</l>
<c>    * </c>
<c>    * Calculate F-score.</c>
<l>    if (CalcFScore)</l>
<l>        tuple_gen_const (|ClassPrecisions|, 0.0, ClassFScores)</l>
<l>        SumPrecisionRecall := ClassPrecisions + ClassRecalls</l>
<l>        PositiveIndices := find(SumPrecisionRecall [!=] 0.0,1)</l>
<l>        if (PositiveIndices != -1 and PositiveIndices != [])</l>
<l>            ClassFScores[PositiveIndices] := (2 * ClassPrecisions[PositiveIndices] * ClassRecalls[PositiveIndices]) / SumPrecisionRecall[PositiveIndices]</l>
<l>        endif</l>
<l>        FScore := mean(ClassFScores)</l>
<l>        if (NumClasses == 1)</l>
<l>            set_dict_tuple (EvalClassID, 'f_score', FScore)</l>
<l>        else</l>
<l>            set_dict_tuple (EvalClassID, 'mean_f_score', FScore)</l>
<l>            set_dict_tuple (EvalClassID, 'f_score_per_class', ClassFScores)</l>
<l>        endif</l>
<l>    endif</l>
<c>    * </c>
<c>    * Set evaluation results for current class ID.</c>
<l>    KeyName := ClassIDsToEvaluate[EvalIndex]</l>
<l>    if (ClassIDsToEvaluate[EvalIndex] != 'global')</l>
<l>        KeyName := 'class_id_' + KeyName</l>
<l>    endif</l>
<l>    set_dict_tuple (EvaluationResult, KeyName, EvalClassID)</l>
<l>endfor</l>
<c>* </c>
<l>return ()</l>
</body>
<docu id="calculate_image_classification_measures">
<abstract lang="en_US">Based on the RunningMeasures and the parameters in EvalParams, the final image classification evaluation is performed.

Which measures are calculated as output is determined in the dictionary EvalParams under the entry with the key 'measures'.
Possible values that are returned by EvaluationResult are:
  -- 'abolute_confusion_matrix' (overall): Confusion matrix, where entry (i,j) is the number of images with ground truth class_ids[j] predicted as class_ids[i].
  -- 'relatve_confusion_matrix' (overall): Confusion matrix, but every entry (i,j) is normalized by the number of ground truth labels of the class in column j.
  For each evaluated class given by the key 'class_ids_to_evaluate' that is not 'global':
  -- 'topK_error' (per-class): Ratio of predictions where the ground truth class is not within the K predicted classes with highest probability. Thereby, K can be a number within the interval [1,number of classes]. The error is only calculated for the selected class.
  -- 'precision' (per-class): Proportion of all correct predicted positives to all predicted positives (true and false ones).
  -- 'recall' (per-class): Proportion of all correct predicted positives to all real positives.
  -- 'f_score' (per-class): Harmonic mean of precision and recall.
  In case that 'class_ids_to_evaluate' is set to 'global' (which means that all classes are evaluated):
  -- 'topK_error' (per-class): Ratio of predictions where the ground truth class is not within the K predicted classes with highest probability. Thereby, K can be a number within the interval [1,number of classes]. The error is calculated over all classes.
  -- 'precision_per_class': Precision for all classes.
  -- 'mean_precision': Mean over all precision values.
  -- 'recall_per_class': Recall for all classes.
  -- 'mean_recall': Mean over all recall values.
  -- 'f_score_per_class': F-score for all classes.
  -- 'mean_f_score': Mean over all F-score values.
In addition, EvaluationResult contains a dictionary 'evaluated_samples' that keeps the following information about the evaluated samples:
  -- 'image_ids': Image IDs of the samples that have been evaluated.
  -- 'image_label_ids': Ground truth image label IDs of the samples that have been evaluated.
  -- 'top1_predictions': Predictions of the evaluated samples.

Each measure is calculated for every class given in the key 'class_ids_to_evaluate' of EvalParams.</abstract>
<chapters lang="en_US">
<item>Deep Learning</item>
<item>Evaluation</item>
</chapters>
<library lang="en_US">MVTec Standard Procedures</library>
<short lang="en_US">Calculate image classification measures based on RunningMeasures.</short>
<parameters>
<parameter id="EvalParams"/>
<parameter id="EvaluationResult"/>
<parameter id="RunningMeasures"/>
</parameters>
</docu>
</procedure>
<procedure name="calculate_instance_measures" access="local">
<interface>
<ic>
<par name="RunningMeasures" base_type="ctrl" dimension="0"/>
<par name="EvalParams" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="EvaluationResult" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c>* </c>
<c>* This procedure calculates the final summarizing instance measures based on the running measures.</c>
<c>* </c>
<c>* Set default values.</c>
<l>CalcClassAP := false</l>
<l>CalcMeanAP := false</l>
<l>CalcSoAP := false</l>
<c>* Check which measures are to be calculated.</c>
<l>get_dict_tuple (EvalParams, 'instance_type', InstanceType)</l>
<l>get_dict_tuple (EvalParams, 'measures', Measures)</l>
<l>for M := 0 to |Measures| - 1 by 1</l>
<l>    if (Measures[M] == 'mean_ap')</l>
<l>        CalcMeanAP := true</l>
<c>        * As we need to calculate the class APs anyway, we also write them out.</c>
<l>        CalcClassAP := true</l>
<l>    elseif (Measures[M] == 'soap' and InstanceType == 'rectangle2')</l>
<l>        CalcSoAP := true</l>
<l>    elseif (Measures[M] == 'all')</l>
<l>        CalcClassAP := true</l>
<l>        CalcMeanAP := true</l>
<l>        if (InstanceType == 'rectangle2')</l>
<l>            CalcSoAP := true</l>
<l>        endif</l>
<l>    else</l>
<l>        throw ('Unknown Instance Measure: ' + Measures[M])</l>
<l>    endif</l>
<l>endfor</l>
<c>* *</c>
<c>* Dependencies of measures:</c>
<c>* </c>
<c>* Recall (per-class)       *                   --&gt; AP per class --&gt; mAP</c>
<c>* Precision (per-class)  /</c>
<c>* </c>
<c>* *</c>
<c>* Initialize output dictionary and get necessary evaluation parameters.</c>
<l>create_dict (EvaluationResult)</l>
<l>get_dict_tuple (EvalParams, 'class_ids', ClassIDs)</l>
<l>get_dict_tuple (EvalParams, 'num_classes', NumClasses)</l>
<l>get_dict_tuple (EvalParams, 'max_num_detections', MaxNumDetections)</l>
<l>get_dict_tuple (EvalParams, 'area_ranges', AreaRanges)</l>
<l>get_dict_tuple (EvalParams, 'iou_threshold', IoUThresholds)</l>
<c>* Check if a detailed evaluation should be done.</c>
<l>DetailedEvaluation := false</l>
<l>get_dict_param (EvalParams, 'key_exists', 'detailed_evaluation', KeyExists)</l>
<l>if (KeyExists[0])</l>
<l>    get_dict_tuple (EvalParams, 'detailed_evaluation', DetailedEvaluation)</l>
<l>endif</l>
<c>* </c>
<c>* Get information about area ranges.</c>
<l>get_dict_tuple (AreaRanges, 'name', AreaNames)</l>
<l>get_dict_tuple (AreaRanges, 'min', MinAreas)</l>
<l>get_dict_tuple (AreaRanges, 'max', MaxAreas)</l>
<c>* </c>
<c>* Equidistant thresholds used to approximate the area under the Precision-Recall curve.</c>
<l>RecThreshs := [0.0:0.01:1.0]</l>
<c>* Start with calculation.</c>
<l>if (CalcClassAP or CalcMeanAP)</l>
<c>    * Loop over maximal number of detections.</c>
<l>    for MDIdx := 0 to |MaxNumDetections| - 1 by 1</l>
<c>        * </c>
<c>        * Get corresponding running measures.</c>
<l>        MaxNum := MaxNumDetections[MDIdx]</l>
<l>        MaxNumStr := '' + MaxNum</l>
<l>        if (MaxNum == -1)</l>
<l>            MaxNumStr := 'all'</l>
<l>        endif</l>
<l>        get_dict_tuple (RunningMeasures, 'max_num_detections_' + MaxNumStr, CurrentRunningMeasures)</l>
<c>        * </c>
<c>        * Initialize output dictionary.</c>
<l>        create_dict (PerMaxNumEvaluationResult)</l>
<c>        * </c>
<c>        * Loop over area ranges.</c>
<l>        for AreaIdx := 0 to |AreaNames| - 1 by 1</l>
<c>            * Get area thresholds.</c>
<l>            MinArea := MinAreas[AreaIdx]</l>
<l>            MaxArea := MaxAreas[AreaIdx]</l>
<l>            AreaName := AreaNames[AreaIdx]</l>
<c>            * </c>
<l>            get_dict_tuple (CurrentRunningMeasures, 'area_' + AreaName, AreaRunningMeasures)</l>
<c>            * </c>
<l>            get_dict_tuple (AreaRunningMeasures, 'num_gt', PerClassNumGt)</l>
<l>            get_dict_tuple (AreaRunningMeasures, 'num_pred', PerClassNumPred)</l>
<l>            get_dict_tuple (AreaRunningMeasures, 'confidence', PerClassConfidence)</l>
<l>            get_dict_tuple (AreaRunningMeasures, 'num_gt_ignore', PerClassNumGtIgnore)</l>
<c>            * </c>
<c>            * Initialize output dictionary.</c>
<l>            create_dict (CurrentEvaluationResult)</l>
<l>            for ITIdx := 0 to |IoUThresholds| - 1 by 1</l>
<l>                create_dict (PerIoUAP)</l>
<l>                set_dict_tuple (CurrentEvaluationResult, 'ap_iou_' + regexp_replace('' + IoUThresholds[ITIdx],'\\.',''), PerIoUAP)</l>
<l>                if (CalcSoAP)</l>
<l>                    create_dict (PerIoUSoAP)</l>
<l>                    set_dict_tuple (CurrentEvaluationResult, 'soap_tp_iou_' + regexp_replace('' + IoUThresholds[ITIdx],'\\.',''), PerIoUSoAP)</l>
<l>                endif</l>
<l>                if (DetailedEvaluation)</l>
<c>                    * Initialize detailed measures.</c>
<l>                    create_dict (PerIoUDetailedEvaluation)</l>
<l>                    for ClsIdx := 0 to NumClasses - 1 by 1</l>
<l>                        create_dict (PerClassDetailedEvaluation)</l>
<c>                        * Initialize with zeros in case there is no ground truth for this class.</c>
<l>                        set_dict_tuple (PerClassDetailedEvaluation, 'num_tp', 0)</l>
<l>                        set_dict_tuple (PerClassDetailedEvaluation, 'num_fn', 0)</l>
<l>                        set_dict_tuple (PerClassDetailedEvaluation, 'num_fp', 0)</l>
<l>                        set_dict_tuple (PerClassDetailedEvaluation, 'num_fp_class', 0)</l>
<l>                        set_dict_tuple (PerClassDetailedEvaluation, 'num_fp_background', 0)</l>
<l>                        set_dict_tuple (PerClassDetailedEvaluation, 'num_fp_duplicate', 0)</l>
<l>                        set_dict_tuple (PerClassDetailedEvaluation, 'num_fp_localization', 0)</l>
<l>                        set_dict_tuple (PerClassDetailedEvaluation, 'num_fp_multiple', 0)</l>
<l>                        if (CalcSoAP)</l>
<l>                            set_dict_tuple (PerClassDetailedEvaluation, 'soap_fp_class', -1)</l>
<l>                            set_dict_tuple (PerClassDetailedEvaluation, 'soap_fp_duplicate', -1)</l>
<l>                            set_dict_tuple (PerClassDetailedEvaluation, 'soap_fp_localization', -1)</l>
<l>                            set_dict_tuple (PerClassDetailedEvaluation, 'soap_fp_multiple', -1)</l>
<l>                        endif</l>
<l>                        set_dict_tuple (PerIoUDetailedEvaluation, 'class_' + ClassIDs[ClsIdx], PerClassDetailedEvaluation)</l>
<l>                    endfor</l>
<l>                    create_matrix (NumClasses + 1, NumClasses + 4, 0, DetectionConfusionMatrix)</l>
<l>                    set_dict_tuple (PerIoUDetailedEvaluation, 'detection_confusion_matrix', DetectionConfusionMatrix)</l>
<c>                    * </c>
<c>                    * Get and set image IDs with false negatives and false positives.</c>
<l>                    get_dict_tuple (AreaRunningMeasures, 'iou_' + regexp_replace('' + IoUThresholds[ITIdx],'\\.',''), PerIoUMeasure)</l>
<c>                    * Get image IDs with false negatives and false positives, respectively.</c>
<l>                    get_dict_tuple (PerIoUMeasure, 'num_image_ids_with_false_negatives', NumImgIDsWithFN)</l>
<l>                    get_dict_tuple (PerIoUMeasure, 'num_image_ids_with_false_positives', NumImgIDsWithFP)</l>
<l>                    get_dict_tuple (PerIoUMeasure, 'image_ids_with_false_negatives', ImgIDsWithFN)</l>
<l>                    get_dict_tuple (PerIoUMeasure, 'image_ids_with_false_positives', ImgIDsWithFP)</l>
<c>                    * Set in current output.</c>
<l>                    set_dict_tuple (PerIoUDetailedEvaluation, 'image_ids_with_false_negatives', ImgIDsWithFN[0:NumImgIDsWithFN - 1])</l>
<l>                    set_dict_tuple (PerIoUDetailedEvaluation, 'image_ids_with_false_positives', ImgIDsWithFP[0:NumImgIDsWithFP - 1])</l>
<c>                    * </c>
<c>                    * Set output for this IoU.</c>
<l>                    set_dict_tuple (CurrentEvaluationResult, 'detailed_evaluation_iou_' + regexp_replace('' + IoUThresholds[ITIdx],'\\.',''), PerIoUDetailedEvaluation)</l>
<l>                endif</l>
<l>            endfor</l>
<l>            create_dict (ClassMAPDict)</l>
<l>            set_dict_tuple (CurrentEvaluationResult, 'mean_iou_ap', ClassMAPDict)</l>
<l>            if (CalcSoAP)</l>
<l>                create_dict (ClassMSoAPDict)</l>
<l>                set_dict_tuple (CurrentEvaluationResult, 'mean_iou_soap_tp', ClassMSoAPDict)</l>
<l>            endif</l>
<c>            * </c>
<c>            * Check which classes have ground truth annotations.</c>
<l>            ClassesWithGt := find((PerClassNumGt - PerClassNumGtIgnore) [&gt;] 0,1)</l>
<l>            if (ClassesWithGt == -1)</l>
<l>                ClassesWithGt := []</l>
<l>            endif</l>
<c>            * </c>
<c>            * Initialize PerClassMAP, i.e. mean average precision over IoU-thresholds per class.</c>
<l>            PerClassMAP := gen_tuple_const(NumClasses,-1.0)</l>
<c>            * </c>
<c>            * Initialize PerIoUMAP, i.e. mean average precision over classes per IoU-threshold.</c>
<l>            PerIoUMAP := gen_tuple_const(|IoUThresholds|,0.0)</l>
<c>            * </c>
<l>            if (CalcSoAP)</l>
<c>                * Initialize PerClassMSoAP, i.e. mean SoAP over IoU-thresholds per class.</c>
<l>                PerClassMSoAP := gen_tuple_const(NumClasses,-1.0)</l>
<c>                * Initialize PerIoUMSoAP, i.e. mean SoAP over classes per IoU-threshold.</c>
<l>                PerIoUMSoAP := gen_tuple_const(|IoUThresholds|,0.0)</l>
<c>                * Initialize PerIoUNumClassesWithTP to store the class-indices where true positives occured.</c>
<l>                PerIoUNumClassesWithTP := gen_tuple_const(|IoUThresholds|,0)</l>
<l>            endif</l>
<c>            * </c>
<l>            if (DetailedEvaluation)</l>
<c>                * Initialize overall num_fn, num_tp, ...</c>
<l>                PerIoUTP := gen_tuple_const(|IoUThresholds|,0)</l>
<l>                PerIoUFN := gen_tuple_const(|IoUThresholds|,0)</l>
<l>                PerIoUFP := gen_tuple_const(|IoUThresholds|,0)</l>
<l>                PerIoUFPClass := gen_tuple_const(|IoUThresholds|,0)</l>
<l>                PerIoUFPBackground := gen_tuple_const(|IoUThresholds|,0)</l>
<l>                PerIoUFPLocalization := gen_tuple_const(|IoUThresholds|,0)</l>
<l>                PerIoUFPDuplicate := gen_tuple_const(|IoUThresholds|,0)</l>
<l>                PerIoUFPMultiple := gen_tuple_const(|IoUThresholds|,0)</l>
<l>                if (CalcSoAP)</l>
<l>                    PerIoUSoAPClass := gen_tuple_const(|IoUThresholds|,-1)</l>
<l>                    PerIoUSoAPLocalization := gen_tuple_const(|IoUThresholds|,-1)</l>
<l>                    PerIoUSoAPDuplicate := gen_tuple_const(|IoUThresholds|,-1)</l>
<l>                    PerIoUSoAPMultiple := gen_tuple_const(|IoUThresholds|,-1)</l>
<l>                    PerIoUNumClassesWithFPClass := gen_tuple_const(|IoUThresholds|,0)</l>
<l>                    PerIoUNumClassesWithFPLocalization := gen_tuple_const(|IoUThresholds|,0)</l>
<l>                    PerIoUNumClassesWithFPDuplicate := gen_tuple_const(|IoUThresholds|,0)</l>
<l>                    PerIoUNumClassesWithFPMultiple := gen_tuple_const(|IoUThresholds|,0)</l>
<l>                endif</l>
<l>            endif</l>
<c>            * Loop over all classes.</c>
<l>            for ClsIdx := 0 to NumClasses - 1 by 1</l>
<c>                * </c>
<c>                * Initialize per-class AP per IoU-threshold (only for one class).</c>
<l>                ClassAPPerIoU := gen_tuple_const(|IoUThresholds|,-1.0)</l>
<c>                * </c>
<l>                if (CalcSoAP)</l>
<l>                    ClassSoAPPerIoU := gen_tuple_const(|IoUThresholds|,-1.0)</l>
<l>                endif</l>
<c>                * Get results for this class.</c>
<l>                NumGt := PerClassNumGt[ClsIdx]</l>
<l>                NumGtIgnore := PerClassNumGtIgnore[ClsIdx]</l>
<l>                if ((NumGt - NumGtIgnore) &gt; 0)</l>
<l>                    NumPred := PerClassNumPred[ClsIdx]</l>
<l>                    get_dict_tuple (PerClassConfidence, 'class_' + ClassIDs[ClsIdx], Confidences)</l>
<c>                    * </c>
<c>                    * Sort the confidences in descending order and</c>
<c>                    * only take the first NumPred ones due to block allocation.</c>
<l>                    SortIdxs := sort_index(-Confidences[0:NumPred - 1])</l>
<l>                    Confidences := Confidences[SortIdxs]</l>
<l>                endif</l>
<c>                * </c>
<c>                * Loop over IoU thresholds.</c>
<l>                for ITIdx := 0 to |IoUThresholds| - 1 by 1</l>
<c>                    * </c>
<c>                    * Check if there are ground truth labels for this class.</c>
<l>                    if ((NumGt - NumGtIgnore) &gt; 0)</l>
<c>                        * </c>
<c>                        * Get results for this class and IoU-threshold.</c>
<l>                        get_dict_tuple (AreaRunningMeasures, 'iou_' + regexp_replace('' + IoUThresholds[ITIdx],'\\.',''), PerIoUMeasure)</l>
<l>                        get_dict_tuple (PerIoUMeasure, 'class_' + ClassIDs[ClsIdx], CurrentClassMeasures)</l>
<l>                        get_dict_tuple (CurrentClassMeasures, 'is_tp', IsTP)</l>
<l>                        get_dict_tuple (CurrentClassMeasures, 'ignore', Ignore)</l>
<c>                        * </c>
<c>                        * Sort the arrays IsTP and Ignore according to the confidence values.</c>
<l>                        IsTP := IsTP[SortIdxs]</l>
<l>                        Ignore := Ignore[SortIdxs]</l>
<c>                        * </c>
<c>                        * Sort out the ignored results.</c>
<l>                        if (|IsTP| &gt; 0)</l>
<l>                            NoIgnoreIdxs := find(Ignore,0)</l>
<l>                            if (NoIgnoreIdxs != -1)</l>
<l>                                IsTP := IsTP[NoIgnoreIdxs]</l>
<l>                                IsFP := not IsTP</l>
<l>                            else</l>
<l>                                IsTP := []</l>
<l>                                IsFP := []</l>
<l>                            endif</l>
<l>                        else</l>
<l>                            IsFP := []</l>
<l>                        endif</l>
<c>                        * </c>
<c>                        * Accumulate IsTP and IsFP.</c>
<l>                        AccumulatedIsTP := cumul(IsTP)</l>
<l>                        AccumulatedIsFP := cumul(IsFP)</l>
<c>                        * </c>
<c>                        * Compute recall.</c>
<c>                        * The recall is computed with respect to all ground truth instances,</c>
<c>                        * independent of MaxNum.</c>
<l>                        Recall := real(AccumulatedIsTP) / (NumGt - NumGtIgnore)</l>
<c>                        * </c>
<c>                        * Compute precision.</c>
<l>                        Precision := real(AccumulatedIsTP) / (AccumulatedIsTP + AccumulatedIsFP)</l>
<c>                        * </c>
<c>                        * Smooth precision-curve.</c>
<l>                        InterpolatedPrecision := Precision</l>
<l>                        for PIdx := |NumPred| - 2 to 0 by -1</l>
<l>                            InterpolatedPrecision[PIdx] := max2(Precision[PIdx],Precision[PIdx + 1])</l>
<l>                        endfor</l>
<c>                        * Compute approximated area under the Precision-Recall curve using Recall-Thresholds.</c>
<l>                        PrecisionAtRecThreshs := gen_tuple_const(|RecThreshs|,0.)</l>
<l>                        for RTIdx := 0 to |RecThreshs| - 1 by 1</l>
<l>                            RecQuantile := find_first(Recall [&gt;=] RecThreshs[RTIdx],1)</l>
<l>                            if (RecQuantile &gt; -1)</l>
<l>                                PrecisionAtRecThreshs[RTIdx] := InterpolatedPrecision[RecQuantile]</l>
<l>                            endif</l>
<l>                        endfor</l>
<c>                        * </c>
<c>                        * Calculate AP as mean of precision at equidistant recall values.</c>
<l>                        ClassAPPerIoU[ITIdx] := mean(PrecisionAtRecThreshs)</l>
<c>                        * </c>
<c>                        * Accumulate AP over classes.</c>
<l>                        PerIoUMAP[ITIdx] := PerIoUMAP[ITIdx] + ClassAPPerIoU[ITIdx]</l>
<c>                        * </c>
<l>                        if (CalcSoAP)</l>
<c>                            * Calculate SoAP out of the mean over absolute orientation differences.</c>
<l>                            get_dict_tuple (CurrentClassMeasures, 'abs_orientation_diff', AOD)</l>
<l>                            IdxsTP := find(IsTP,1)</l>
<l>                            if (|IdxsTP| &gt; 0 and IdxsTP != -1)</l>
<l>                                ClassSoAPPerIoU[ITIdx] := 1.0 - mean(AOD[SortIdxs[NoIgnoreIdxs[IdxsTP]]]) / rad(180)</l>
<c>                                * Accumulate SoAP over classes.</c>
<l>                                PerIoUMSoAP[ITIdx] := PerIoUMSoAP[ITIdx] + ClassSoAPPerIoU[ITIdx]</l>
<l>                            endif</l>
<c>                            * Update PerIoUNumClassesWithTP.</c>
<l>                            if (|AccumulatedIsTP| &gt; 0)</l>
<l>                                PerIoUNumClassesWithTP[ITIdx] := PerIoUNumClassesWithTP[ITIdx] + (AccumulatedIsTP[|AccumulatedIsTP| - 1] [&gt;] 0)</l>
<l>                            endif</l>
<l>                        endif</l>
<c>                        * </c>
<l>                        if (DetailedEvaluation)</l>
<c>                            * Summarize detailed evaluation running measures, set matrix-values and update overall detailed measures.</c>
<c>                            * </c>
<c>                            * Get the necessary running measures.</c>
<l>                            get_dict_tuple (CurrentClassMeasures, 'is_fp_class', IsFPClass)</l>
<l>                            get_dict_tuple (CurrentClassMeasures, 'is_fp_background', IsFPBackground)</l>
<l>                            get_dict_tuple (CurrentClassMeasures, 'is_fp_localization', IsFPLocalization)</l>
<l>                            get_dict_tuple (CurrentClassMeasures, 'is_fp_duplicate', IsFPDuplicate)</l>
<l>                            get_dict_tuple (CurrentClassMeasures, 'is_fp_multiple', IsFPMultiple)</l>
<c>                            * </c>
<c>                            * We use the values with maximal recall,</c>
<c>                            * in case a higher precision is desired, increase 'min_confidence'.</c>
<l>                            if (|AccumulatedIsTP| &gt; 0)</l>
<l>                                NumTP := AccumulatedIsTP[|AccumulatedIsTP| - 1]</l>
<l>                            else</l>
<l>                                NumTP := 0</l>
<l>                            endif</l>
<l>                            if (|AccumulatedIsFP| &gt; 0)</l>
<l>                                NumFP := AccumulatedIsFP[|AccumulatedIsFP| - 1]</l>
<l>                            else</l>
<l>                                NumFP := 0</l>
<l>                            endif</l>
<l>                            NumFN := NumGt - NumGtIgnore - NumTP</l>
<l>                            NumFPClass := sum(IsFPClass[SortIdxs] [&gt;] -1)</l>
<l>                            NumFPBackground := sum(IsFPBackground[SortIdxs] [&gt;] 0)</l>
<l>                            NumFPLocalization := sum(IsFPLocalization[SortIdxs] [&gt;] 0)</l>
<l>                            NumFPDuplicate := sum(IsFPDuplicate[SortIdxs] [&gt;] 0)</l>
<l>                            NumFPMultiple := sum(IsFPMultiple[SortIdxs] [&gt;] 0)</l>
<l>                            if (|SortIdxs| == 0)</l>
<l>                                NumFPClass := 0</l>
<l>                                NumFPBackground := 0</l>
<l>                                NumFPLocalization := 0</l>
<l>                                NumFPDuplicate := 0</l>
<l>                                NumFPMultiple := 0</l>
<l>                            endif</l>
<c>                            * Consistency checks.</c>
<l>                            if (min([NumTP,NumFN,NumFP,NumFPClass,NumFPBackground,NumFPLocalization,NumFPDuplicate,NumFPMultiple]) &lt; 0)</l>
<l>                                throw ('Fatal error while calculating instance measures.')</l>
<l>                            endif</l>
<l>                            if (NumFP != NumFPClass + NumFPBackground + NumFPLocalization + NumFPDuplicate + NumFPMultiple)</l>
<l>                                throw ('Fatal error while calculating instance measures.')</l>
<l>                            endif</l>
<c>                            * </c>
<c>                            * Set per-class measures.</c>
<l>                            get_dict_tuple (CurrentEvaluationResult, 'detailed_evaluation_iou_' + regexp_replace('' + IoUThresholds[ITIdx],'\\.',''), PerIoUDetailedEvaluation)</l>
<l>                            get_dict_tuple (PerIoUDetailedEvaluation, 'class_' + ClassIDs[ClsIdx], PerClassDetailedEvaluation)</l>
<l>                            set_dict_tuple (PerClassDetailedEvaluation, 'num_tp', NumTP)</l>
<l>                            set_dict_tuple (PerClassDetailedEvaluation, 'num_fn', NumFN)</l>
<l>                            set_dict_tuple (PerClassDetailedEvaluation, 'num_fp', NumFP)</l>
<l>                            set_dict_tuple (PerClassDetailedEvaluation, 'num_fp_class', NumFPClass)</l>
<l>                            set_dict_tuple (PerClassDetailedEvaluation, 'num_fp_background', NumFPBackground)</l>
<l>                            set_dict_tuple (PerClassDetailedEvaluation, 'num_fp_duplicate', NumFPDuplicate)</l>
<l>                            set_dict_tuple (PerClassDetailedEvaluation, 'num_fp_localization', NumFPLocalization)</l>
<l>                            set_dict_tuple (PerClassDetailedEvaluation, 'num_fp_multiple', NumFPMultiple)</l>
<c>                            * </c>
<c>                            * Set detection confusion matrix values.</c>
<l>                            get_dict_tuple (PerIoUDetailedEvaluation, 'detection_confusion_matrix', DetectionConfusionMatrix)</l>
<l>                            set_value_matrix (DetectionConfusionMatrix, ClsIdx, ClsIdx, NumTP)</l>
<l>                            set_value_matrix (DetectionConfusionMatrix, NumClasses, ClsIdx, NumFN)</l>
<l>                            set_value_matrix (DetectionConfusionMatrix, ClsIdx, NumClasses, NumFPBackground)</l>
<l>                            set_value_matrix (DetectionConfusionMatrix, ClsIdx, NumClasses + 1, NumFPLocalization)</l>
<l>                            set_value_matrix (DetectionConfusionMatrix, ClsIdx, NumClasses + 2, NumFPDuplicate)</l>
<l>                            set_value_matrix (DetectionConfusionMatrix, ClsIdx, NumClasses + 3, NumFPMultiple)</l>
<c>                            * </c>
<c>                            * Go over IsFPClass and set confusions in matrix.</c>
<l>                            IndicesWithClassConfusion := find(IsFPClass[SortIdxs] [&gt;] -1,1)</l>
<l>                            IsFPClassIdxs := []</l>
<l>                            if (IndicesWithClassConfusion &gt; -1)</l>
<l>                                IsFPClassIdxs := IsFPClass[SortIdxs[IndicesWithClassConfusion]]</l>
<l>                            endif</l>
<l>                            ClassIdxsConfused := uniq(sort(IsFPClassIdxs))</l>
<l>                            for Idx := 0 to |ClassIdxsConfused| - 1 by 1</l>
<l>                                NumConfusedThisIdx := sum(find(IsFPClassIdxs,ClassIdxsConfused[Idx]) [&gt;] -1)</l>
<l>                                set_value_matrix (DetectionConfusionMatrix, ClsIdx, ClassIdxsConfused[Idx], NumConfusedThisIdx)</l>
<l>                            endfor</l>
<c>                            * </c>
<c>                            * Update overall measures.</c>
<l>                            PerIoUFN[ITIdx] := PerIoUFN[ITIdx] + NumFN</l>
<l>                            PerIoUTP[ITIdx] := PerIoUTP[ITIdx] + NumTP</l>
<l>                            PerIoUFP[ITIdx] := PerIoUFP[ITIdx] + NumFP</l>
<l>                            PerIoUFPClass[ITIdx] := PerIoUFPClass[ITIdx] + NumFPClass</l>
<l>                            PerIoUFPBackground[ITIdx] := PerIoUFPBackground[ITIdx] + NumFPBackground</l>
<l>                            PerIoUFPLocalization[ITIdx] := PerIoUFPLocalization[ITIdx] + NumFPLocalization</l>
<l>                            PerIoUFPDuplicate[ITIdx] := PerIoUFPDuplicate[ITIdx] + NumFPDuplicate</l>
<l>                            PerIoUFPMultiple[ITIdx] := PerIoUFPMultiple[ITIdx] + NumFPMultiple</l>
<l>                            if (CalcSoAP)</l>
<c>                                * Calculate and update absolute difference of orientation for class false positives.</c>
<l>                                get_dict_tuple (CurrentClassMeasures, 'abs_orientation_diff_class', AODClass)</l>
<l>                                IdxsClass := find(AODClass [&gt;] -1,1)</l>
<l>                                if (IdxsClass != -1)</l>
<l>                                    ResSoAPClass := 1.0 - mean(AODClass[IdxsClass]) / rad(180)</l>
<l>                                    set_dict_tuple (PerClassDetailedEvaluation, 'soap_fp_class', ResSoAPClass)</l>
<c>                                    * Update mean over classes.</c>
<l>                                    PerIoUNumClassesWithFPClass[ITIdx] := PerIoUNumClassesWithFPClass[ITIdx] + 1</l>
<l>                                    if (PerIoUSoAPClass[ITIdx] == -1)</l>
<l>                                        PerIoUSoAPClass[ITIdx] := ResSoAPClass</l>
<l>                                    else</l>
<l>                                        PerIoUSoAPClass[ITIdx] := PerIoUSoAPClass[ITIdx] + ResSoAPClass</l>
<l>                                    endif</l>
<l>                                endif</l>
<c>                                * Calculate and update absolute difference of orientation for localization false positives.</c>
<l>                                get_dict_tuple (CurrentClassMeasures, 'abs_orientation_diff_localization', AODLocalization)</l>
<l>                                IdxsLocalization := find(AODLocalization [&gt;] -1,1)</l>
<l>                                if (IdxsLocalization != -1)</l>
<l>                                    ResSoAPLocalization := 1.0 - mean(AODLocalization[IdxsLocalization]) / rad(180)</l>
<l>                                    set_dict_tuple (PerClassDetailedEvaluation, 'soap_fp_localization', ResSoAPLocalization)</l>
<c>                                    * Update mean over classes.</c>
<l>                                    PerIoUNumClassesWithFPLocalization[ITIdx] := PerIoUNumClassesWithFPLocalization[ITIdx] + 1</l>
<l>                                    if (PerIoUSoAPLocalization[ITIdx] == -1)</l>
<l>                                        PerIoUSoAPLocalization[ITIdx] := ResSoAPLocalization</l>
<l>                                    else</l>
<l>                                        PerIoUSoAPLocalization[ITIdx] := PerIoUSoAPLocalization[ITIdx] + ResSoAPLocalization</l>
<l>                                    endif</l>
<l>                                endif</l>
<c>                                * Calculate and update absolute difference of orientation for class false positives.</c>
<l>                                get_dict_tuple (CurrentClassMeasures, 'abs_orientation_diff_duplicate', AODDuplicate)</l>
<l>                                IdxsDuplicate := find(AODDuplicate [&gt;] -1,1)</l>
<l>                                if (IdxsDuplicate != -1)</l>
<l>                                    ResSoAPDuplicate := 1.0 - mean(AODDuplicate[IdxsDuplicate]) / rad(180)</l>
<l>                                    set_dict_tuple (PerClassDetailedEvaluation, 'soap_fp_duplicate', ResSoAPDuplicate)</l>
<c>                                    * Update mean over classes.</c>
<l>                                    PerIoUNumClassesWithFPDuplicate[ITIdx] := PerIoUNumClassesWithFPDuplicate[ITIdx] + 1</l>
<l>                                    if (PerIoUSoAPDuplicate[ITIdx] == -1)</l>
<l>                                        PerIoUSoAPDuplicate[ITIdx] := ResSoAPDuplicate</l>
<l>                                    else</l>
<l>                                        PerIoUSoAPDuplicate[ITIdx] := PerIoUSoAPDuplicate[ITIdx] + ResSoAPDuplicate</l>
<l>                                    endif</l>
<l>                                endif</l>
<c>                                * Calculate and update absolute difference of orientation for multiple false positives.</c>
<l>                                get_dict_tuple (CurrentClassMeasures, 'abs_orientation_diff_multiple', AODMultiple)</l>
<l>                                IdxsMultiple := find(AODMultiple [&gt;] -1,1)</l>
<l>                                if (IdxsMultiple != -1)</l>
<l>                                    ResSoAPMultiple := 1.0 - mean(AODMultiple[IdxsMultiple]) / rad(180)</l>
<l>                                    set_dict_tuple (PerClassDetailedEvaluation, 'soap_fp_multiple', ResSoAPMultiple)</l>
<c>                                    * Update mean over classes.</c>
<l>                                    PerIoUNumClassesWithFPMultiple[ITIdx] := PerIoUNumClassesWithFPMultiple[ITIdx] + 1</l>
<l>                                    if (PerIoUSoAPMultiple[ITIdx] == -1)</l>
<l>                                        PerIoUSoAPMultiple[ITIdx] := ResSoAPMultiple</l>
<l>                                    else</l>
<l>                                        PerIoUSoAPMultiple[ITIdx] := PerIoUSoAPMultiple[ITIdx] + ResSoAPMultiple</l>
<l>                                    endif</l>
<l>                                endif</l>
<l>                            endif</l>
<l>                        endif</l>
<l>                    endif</l>
<c>                    * </c>
<c>                    * Write to output.</c>
<l>                    get_dict_tuple (CurrentEvaluationResult, 'ap_iou_' + regexp_replace('' + IoUThresholds[ITIdx],'\\.',''), PerIoUAP)</l>
<l>                    set_dict_tuple (PerIoUAP, 'class_' + ClassIDs[ClsIdx], ClassAPPerIoU[ITIdx])</l>
<l>                    if (CalcSoAP)</l>
<l>                        get_dict_tuple (CurrentEvaluationResult, 'soap_tp_iou_' + regexp_replace('' + IoUThresholds[ITIdx],'\\.',''), PerIoUSoAP)</l>
<l>                        set_dict_tuple (PerIoUSoAP, 'class_' + ClassIDs[ClsIdx], ClassSoAPPerIoU[ITIdx])</l>
<l>                    endif</l>
<l>                endfor</l>
<c>                * </c>
<c>                * Class mAP is the mean over IoU-thresholds.</c>
<l>                PerClassMAP[ClsIdx] := mean(ClassAPPerIoU)</l>
<l>                get_dict_tuple (CurrentEvaluationResult, 'mean_iou_ap', ClassMAPDict)</l>
<l>                set_dict_tuple (ClassMAPDict, 'class_' + ClassIDs[ClsIdx], PerClassMAP[ClsIdx])</l>
<l>                if (CalcSoAP)</l>
<c>                    * ClassMSoAP is the mean over IoU-thresholds.</c>
<l>                    PerClassMSoAP[ClsIdx] := mean(ClassSoAPPerIoU)</l>
<l>                    get_dict_tuple (CurrentEvaluationResult, 'mean_iou_soap_tp', ClassMSoAPDict)</l>
<l>                    set_dict_tuple (ClassMSoAPDict, 'class_' + ClassIDs[ClsIdx], PerClassMSoAP[ClsIdx])</l>
<l>                endif</l>
<l>            endfor</l>
<c>            * </c>
<c>            * Calculate the mean AP and optionally mean SoAP (over classes) per IoU-threshold.</c>
<l>            for ITIdx := 0 to |IoUThresholds| - 1 by 1</l>
<l>                get_dict_tuple (CurrentEvaluationResult, 'ap_iou_' + regexp_replace('' + IoUThresholds[ITIdx],'\\.',''), PerIoUAP)</l>
<c>                * </c>
<c>                * Consider only present classes.</c>
<l>                MeanClassAP := -1.0</l>
<l>                if (|ClassesWithGt| &gt; 0)</l>
<l>                    MeanClassAP := PerIoUMAP[ITIdx] / |ClassesWithGt|</l>
<l>                endif</l>
<l>                set_dict_tuple (PerIoUAP, 'mean_class_ap', MeanClassAP)</l>
<l>                if (CalcSoAP)</l>
<l>                    get_dict_tuple (CurrentEvaluationResult, 'soap_tp_iou_' + regexp_replace('' + IoUThresholds[ITIdx],'\\.',''), PerIoUSoAP)</l>
<c>                    * </c>
<c>                    * Consider only present classes.</c>
<l>                    MeanClassSoAP := -1.0</l>
<l>                    if (PerIoUNumClassesWithTP[ITIdx] &gt; 0)</l>
<l>                        MeanClassSoAP := PerIoUMSoAP[ITIdx] / PerIoUNumClassesWithTP[ITIdx]</l>
<l>                    endif</l>
<l>                    set_dict_tuple (PerIoUSoAP, 'mean_class_soap_tp', MeanClassSoAP)</l>
<l>                endif</l>
<c>                * </c>
<l>                if (DetailedEvaluation)</l>
<c>                    * Add overall measures for TP, FN, FP, ...</c>
<l>                    get_dict_tuple (CurrentEvaluationResult, 'detailed_evaluation_iou_' + regexp_replace('' + IoUThresholds[ITIdx],'\\.',''), PerIoUDetailedEvaluation)</l>
<l>                    set_dict_tuple (PerIoUDetailedEvaluation, 'num_tp', PerIoUTP[ITIdx])</l>
<l>                    set_dict_tuple (PerIoUDetailedEvaluation, 'num_fn', PerIoUFN[ITIdx])</l>
<l>                    set_dict_tuple (PerIoUDetailedEvaluation, 'num_fp', PerIoUFP[ITIdx])</l>
<l>                    set_dict_tuple (PerIoUDetailedEvaluation, 'num_fp_class', PerIoUFPClass[ITIdx])</l>
<l>                    set_dict_tuple (PerIoUDetailedEvaluation, 'num_fp_background', PerIoUFPBackground[ITIdx])</l>
<l>                    set_dict_tuple (PerIoUDetailedEvaluation, 'num_fp_duplicate', PerIoUFPDuplicate[ITIdx])</l>
<l>                    set_dict_tuple (PerIoUDetailedEvaluation, 'num_fp_localization', PerIoUFPLocalization[ITIdx])</l>
<l>                    set_dict_tuple (PerIoUDetailedEvaluation, 'num_fp_multiple', PerIoUFPMultiple[ITIdx])</l>
<l>                    if (CalcSoAP)</l>
<l>                        if (PerIoUNumClassesWithFPClass[ITIdx] &gt; 0)</l>
<l>                            PerIoUSoAPClass[ITIdx] := PerIoUSoAPClass[ITIdx] / PerIoUNumClassesWithFPClass[ITIdx]</l>
<l>                        endif</l>
<l>                        if (PerIoUNumClassesWithFPLocalization[ITIdx] &gt; 0)</l>
<l>                            PerIoUSoAPLocalization[ITIdx] := PerIoUSoAPLocalization[ITIdx] / PerIoUNumClassesWithFPLocalization[ITIdx]</l>
<l>                        endif</l>
<l>                        if (PerIoUNumClassesWithFPDuplicate[ITIdx] &gt; 0)</l>
<l>                            PerIoUSoAPDuplicate[ITIdx] := PerIoUSoAPDuplicate[ITIdx] / PerIoUNumClassesWithFPDuplicate[ITIdx]</l>
<l>                        endif</l>
<l>                        if (PerIoUNumClassesWithFPMultiple[ITIdx] &gt; 0)</l>
<l>                            PerIoUSoAPMultiple[ITIdx] := PerIoUSoAPMultiple[ITIdx] / PerIoUNumClassesWithFPMultiple[ITIdx]</l>
<l>                        endif</l>
<l>                        set_dict_tuple (PerIoUDetailedEvaluation, 'soap_fp_class', PerIoUSoAPClass[ITIdx])</l>
<l>                        set_dict_tuple (PerIoUDetailedEvaluation, 'soap_fp_localization', PerIoUSoAPLocalization[ITIdx])</l>
<l>                        set_dict_tuple (PerIoUDetailedEvaluation, 'soap_fp_duplicate', PerIoUSoAPDuplicate[ITIdx])</l>
<l>                        set_dict_tuple (PerIoUDetailedEvaluation, 'soap_fp_multiple', PerIoUSoAPMultiple[ITIdx])</l>
<l>                    endif</l>
<l>                endif</l>
<l>            endfor</l>
<c>            * </c>
<c>            * Calculate overall mean AP (over classes and IoU-thresholds).</c>
<c>            * Also here only classes with ground truth annotations are taken into account.</c>
<l>            MAP := -1.0</l>
<l>            if (|ClassesWithGt| &gt; 0)</l>
<l>                MAP := sum(PerClassMAP[ClassesWithGt]) / |ClassesWithGt|</l>
<l>            endif</l>
<l>            set_dict_tuple (CurrentEvaluationResult, 'mean_ap', MAP)</l>
<l>            if (CalcSoAP)</l>
<l>                MSoAP := -1.0</l>
<l>                if (sum(PerIoUNumClassesWithTP) &gt; 0)</l>
<l>                    IoUsWithTP := find(PerIoUNumClassesWithTP [&gt;] 0,1)</l>
<l>                    MSoAP := sum(PerIoUMSoAP[IoUsWithTP] / PerIoUNumClassesWithTP[IoUsWithTP]) / |IoUsWithTP|</l>
<l>                endif</l>
<l>                set_dict_tuple (CurrentEvaluationResult, 'mean_soap_tp', MSoAP)</l>
<l>                if (DetailedEvaluation)</l>
<l>                    MSoAPAll := 0.0</l>
<l>                    NumSoAPAll := 0</l>
<l>                    if (sum(PerIoUNumClassesWithTP) &gt; 0)</l>
<l>                        IoUsWithTP := find(PerIoUNumClassesWithTP [&gt;] 0,1)</l>
<l>                        MSoAPAll := MSoAP * sum(PerIoUNumClassesWithTP[IoUsWithTP])</l>
<l>                        NumSoAPAll := NumSoAPAll + sum(PerIoUNumClassesWithTP[IoUsWithTP])</l>
<l>                    endif</l>
<l>                    if (sum(PerIoUNumClassesWithFPClass) &gt; 0)</l>
<l>                        IoUsWithFPClass := find(PerIoUNumClassesWithFPClass [&gt;] 0,1)</l>
<l>                        MSoAPAll := MSoAPAll + (sum(PerIoUSoAPClass[IoUsWithFPClass]) / |IoUsWithFPClass|) * sum(PerIoUNumClassesWithFPClass[IoUsWithFPClass])</l>
<l>                        NumSoAPAll := NumSoAPAll + sum(PerIoUNumClassesWithFPClass[IoUsWithFPClass])</l>
<l>                    endif</l>
<l>                    if (sum(PerIoUNumClassesWithFPLocalization) &gt; 0)</l>
<l>                        IoUsWithFPLocalization := find(PerIoUNumClassesWithFPLocalization [&gt;] 0,1)</l>
<l>                        MSoAPAll := MSoAPAll + (sum(PerIoUSoAPLocalization[IoUsWithFPLocalization]) / |IoUsWithFPLocalization|) * sum(PerIoUNumClassesWithFPLocalization[IoUsWithFPLocalization])</l>
<l>                        NumSoAPAll := NumSoAPAll + sum(PerIoUNumClassesWithFPLocalization[IoUsWithFPLocalization])</l>
<l>                    endif</l>
<l>                    if (sum(PerIoUNumClassesWithFPDuplicate) &gt; 0)</l>
<l>                        IoUsWithFPDuplicate := find(PerIoUNumClassesWithFPDuplicate [&gt;] 0,1)</l>
<l>                        MSoAPAll := MSoAPAll + (sum(PerIoUSoAPDuplicate[IoUsWithFPDuplicate]) / |IoUsWithFPDuplicate|) * sum(PerIoUNumClassesWithFPDuplicate[IoUsWithFPDuplicate])</l>
<l>                        NumSoAPAll := NumSoAPAll + sum(PerIoUNumClassesWithFPDuplicate[IoUsWithFPDuplicate])</l>
<l>                    endif</l>
<l>                    if (sum(PerIoUNumClassesWithFPMultiple) &gt; 0)</l>
<l>                        IoUsWithFPMultiple := find(PerIoUNumClassesWithFPMultiple [&gt;] 0,1)</l>
<l>                        MSoAPAll := MSoAPAll + (sum(PerIoUSoAPMultiple[IoUsWithFPMultiple]) / |IoUsWithFPMultiple|) * sum(PerIoUNumClassesWithFPMultiple[IoUsWithFPMultiple])</l>
<l>                        NumSoAPAll := NumSoAPAll + sum(PerIoUNumClassesWithFPMultiple[IoUsWithFPMultiple])</l>
<l>                    endif</l>
<l>                    if (NumSoAPAll &gt; 0)</l>
<l>                        set_dict_tuple (CurrentEvaluationResult, 'mean_soap_all', real(MSoAPAll) / NumSoAPAll)</l>
<l>                    else</l>
<l>                        set_dict_tuple (CurrentEvaluationResult, 'mean_soap_all', -1)</l>
<l>                    endif</l>
<c></c>
<l>                endif</l>
<l>            endif</l>
<c>            * </c>
<c>            * Add CurrentEvaluationResult to output.</c>
<l>            set_dict_tuple (PerMaxNumEvaluationResult, 'area_' + AreaName, CurrentEvaluationResult)</l>
<l>        endfor</l>
<c>        * Add PerMaxNumEvaluationResult to output.</c>
<l>        set_dict_tuple (EvaluationResult, 'max_num_detections_' + MaxNumStr, PerMaxNumEvaluationResult)</l>
<l>    endfor</l>
<l>endif</l>
<c>* </c>
<l>return ()</l>
</body>
<docu id="calculate_instance_measures">
<abstract lang="en_US">Based on the RunningMeasures the final instance evaluation for detection is performed.

Which measures are calculated as output is determined in the dictionary EvalParams under the entry with the key 'measures'. Possible values are:
- 'mean_ap': Mean over the per-class average precisions. Note, if a class is not present in the ground truth, it is excluded from the mean calculation.
- 'soap' (only for instance_type 'rectangle2'): Percent absolute degree difference of orientation.
- 'all': Same as specifying 'mean_ap'.

In case the key 'detailed_evaluation' in EvalParams has the value 'true', the measures described in calculate_evaluation_measures are calculated.
</abstract>
<chapters lang="de_DE">
<item>Deep Learning</item>
<item>Evaluierung</item>
</chapters>
<chapters lang="en_US">
<item>Deep Learning</item>
<item>Evaluation</item>
</chapters>
<library lang="en_US">MVTec Standard Procedures</library>
<short lang="en_US">Calculate instance measures based on RunningMeasures.</short>
<parameters>
<parameter id="EvalParams">
<default_type>integer</default_type>
<default_value>EvalParams</default_value>
<description lang="en_US">Dictionary of evaluation parameters.</description>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>dict</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="EvaluationResult">
<default_type>integer</default_type>
<description lang="en_US">Dictionary containing output measures depending on EvalParams key 'measures'.</description>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>dict</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="RunningMeasures">
<default_type>integer</default_type>
<default_value>RunningMeasures</default_value>
<description lang="en_US">The input evaluation RunningMeasures to calculate the final measures.</description>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>dict</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
</parameters>
</docu>
</procedure>
<procedure name="calculate_lines_gauss_parameters">
<interface>
<ic>
<par name="MaxLineWidth" base_type="ctrl" dimension="0"/>
<par name="Contrast" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="Sigma" base_type="ctrl" dimension="0"/>
<par name="Low" base_type="ctrl" dimension="0"/>
<par name="High" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c>* Check control parameters</c>
<l>if (|MaxLineWidth| != 1)</l>
<l>    throw ('Wrong number of values of control parameter: 1')</l>
<l>endif</l>
<l>if (not is_number(MaxLineWidth))</l>
<l>    throw ('Wrong type of control parameter: 1')</l>
<l>endif</l>
<l>if (MaxLineWidth &lt;= 0)</l>
<l>    throw ('Wrong value of control parameter: 1')</l>
<l>endif</l>
<l>if (|Contrast| != 1 and |Contrast| != 2)</l>
<l>    throw ('Wrong number of values of control parameter: 2')</l>
<l>endif</l>
<l>if (min(is_number(Contrast)) == 0)</l>
<l>    throw ('Wrong type of control parameter: 2')</l>
<l>endif</l>
<c>* Set and check ContrastHigh</c>
<l>ContrastHigh := Contrast[0]</l>
<l>if (ContrastHigh &lt; 0)</l>
<l>    throw ('Wrong value of control parameter: 2')</l>
<l>endif</l>
<c>* Set or derive ContrastLow</c>
<l>if (|Contrast| == 2)</l>
<l>    ContrastLow := Contrast[1]</l>
<l>else</l>
<l>    ContrastLow := ContrastHigh / 3.0</l>
<l>endif</l>
<c>* Check ContrastLow</c>
<l>if (ContrastLow &lt; 0)</l>
<l>    throw ('Wrong value of control parameter: 2')</l>
<l>endif</l>
<l>if (ContrastLow &gt; ContrastHigh)</l>
<l>    throw ('Wrong value of control parameter: 2')</l>
<l>endif</l>
<c>* </c>
<c>* Calculate the parameters Sigma, Low, and High for lines_gauss</c>
<l>if (MaxLineWidth &lt; sqrt(3.0))</l>
<c>    * Note that LineWidthMax &lt; sqrt(3.0) would result in a Sigma &lt; 0.5,</c>
<c>    * which does not make any sense, because the corresponding smoothing</c>
<c>    * filter mask would be of size 1x1.</c>
<c>    * To avoid this, LineWidthMax is restricted to values greater or equal</c>
<c>    * to sqrt(3.0) and the contrast values are adapted to reflect the fact</c>
<c>    * that lines that are thinner than sqrt(3.0) pixels have a lower contrast</c>
<c>    * in the smoothed image (compared to lines that are sqrt(3.0) pixels wide).</c>
<l>    ContrastLow := ContrastLow * MaxLineWidth / sqrt(3.0)</l>
<l>    ContrastHigh := ContrastHigh * MaxLineWidth / sqrt(3.0)</l>
<l>    MaxLineWidth := sqrt(3.0)</l>
<l>endif</l>
<c>* Convert LineWidthMax and the given contrast values into the input parameters</c>
<c>* Sigma, Low, and High required by lines_gauss</c>
<l>HalfWidth := MaxLineWidth / 2.0</l>
<l>Sigma := HalfWidth / sqrt(3.0)</l>
<l>Help := -2.0 * HalfWidth / (sqrt(6.283185307178) * pow(Sigma,3.0)) * exp(-0.5 * pow(HalfWidth / Sigma,2.0))</l>
<l>High := fabs(ContrastHigh * Help)</l>
<l>Low := fabs(ContrastLow * Help)</l>
<l>return ()</l>
</body>
<docu id="calculate_lines_gauss_parameters">
<abstract lang="en_US">calculate_lines_gauss_parameters calculates the parameters Sigma, Low, and High for lines_gauss from the maximum width and the contrast of the lines to be extracted.

MaxLineWidth defines the maximum width of the lines to be extracted with lines_gauss.

Contrast should be set to the gray value contrast of a typical line to be extracted. All lines that have a higher contrast will be extracted in any case.

Optionally, the parameter Contrast may contain a second value, which then defines the minimum contrast of the lines to be extracted. This second value of the parameter Contrast must not be larger than the first value. If only one value is given, the minimum contrast is set to Contrast/3.0. A smaller value for the minimum contrast results in longer lines, which extend into areas with low contrast. A higher value results in shorter but more salient lines.

Note that lines_gauss uses a hysteresis thresholding approach, that uses the parameters Low and High, which are calculated from MaxLineWidth and the two contrast values described above. In simple terms, the hysteresis thresholding approach works such that all points that lie on lines with a contrast above (the first value of) Contrast are considered as salient line points. These salient line points are extended with neighboring line points as long as those line points have a contrast above the minimum contrast.</abstract>
<chapters lang="de_DE">
<item>Filter</item>
<item>Linien</item>
</chapters>
<chapters lang="en_US">
<item>Filters</item>
<item>Lines</item>
</chapters>
<example lang="en_US">read_image (Image, 'mreut')
*
calculate_lines_gauss_parameters (30, 60, Sigma, Low, High)
*
lines_gauss (Image, Lines, Sigma, Low, High, 'light', 'true', 'bar-shaped', 'true')
dev_display (Image)
dev_display (Lines)</example>
<keywords lang="en_US">
<item>extract lines</item>
</keywords>
<library lang="en_US">MVTec Standard Procedures</library>
<references lang="en_US">Carsten Steger: Unbiased Extraction of Curvilinear Structures from 2D and 3D Images. Dissertation. Fakultät für Informatik, Technische Universität München, 1998.</references>
<short lang="en_US">Calculates the parameters Sigma, Low, and High for lines_gauss from the maximum width and the contrast of the lines to be extracted.</short>
<successor>
<item>lines_gauss</item>
</successor>
<parameters>
<parameter id="Contrast">
<default_type>real</default_type>
<default_value>60</default_value>
<description lang="en_US">Typical contrast of the lines to be extracted with lines_gauss. Optionally, a tuple with two values may be given. Then, the second value defines the minimum contrast of the lines to be extracted and must not be larger than the first value.</description>
<mixed_type>optional</mixed_type>
<multivalue>optional</multivalue>
<sem_type>number</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
<values>
<item>20</item>
<item>40</item>
<item>60</item>
<item>80</item>
<item>100</item>
<item>150</item>
<item>[60,5]</item>
<item>[60, 50]</item>
</values>
</parameter>
<parameter id="High">
<default_type>real</default_type>
<description lang="en_US">Parameter High to be used with lines_gauss.</description>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>number</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
<parameter id="Low">
<default_type>real</default_type>
<description lang="en_US">Parameter Low to be used with lines_gauss.</description>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>number</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
<parameter id="MaxLineWidth">
<default_type>real</default_type>
<default_value>5</default_value>
<description lang="en_US">Maximum width of the lines to be extracted with lines_gauss.</description>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>number</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
<values>
<item>3</item>
<item>5</item>
<item>10</item>
<item>20</item>
<item>30</item>
</values>
</parameter>
<parameter id="Sigma">
<default_type>real</default_type>
<description lang="en_US">Parameter Sigma to be used with lines_gauss.</description>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>number</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
</parameters>
</docu>
</procedure>
<procedure name="calculate_pixel_measures" access="local">
<interface>
<ic>
<par name="RunningMeasures" base_type="ctrl" dimension="0"/>
<par name="EvalParams" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="EvaluationResult" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c>* </c>
<c>* This procedure calculates the pixel-wise measures based on the values in running measures.</c>
<c>* </c>
<c>* Set default values.</c>
<l>CalcClassPixelAccuracy := false</l>
<l>CalcPixelAccuracy := false</l>
<l>CalcPixelConfusionMatrix := false</l>
<l>CalcMeanAccuracy := false</l>
<l>CalcMeanIou := false</l>
<l>CalcClassIou := false</l>
<l>CalcFWIou := false</l>
<c>* Check which measures are to be calculated.</c>
<l>get_dict_tuple (EvalParams, 'measures', Measures)</l>
<l>create_dict (EvaluationResult)</l>
<l>for M := 0 to |Measures| - 1 by 1</l>
<l>    if (Measures[M] == 'pixel_accuracy')</l>
<l>        CalcPixelAccuracy := true</l>
<l>    elseif (Measures[M] == 'class_pixel_accuracy')</l>
<l>        CalcClassPixelAccuracy := true</l>
<l>    elseif (Measures[M] == 'pixel_confusion_matrix')</l>
<l>        CalcPixelConfusionMatrix := true</l>
<l>    elseif (Measures[M] == 'mean_accuracy')</l>
<l>        CalcMeanAccuracy := true</l>
<l>    elseif (Measures[M] == 'mean_iou')</l>
<l>        CalcMeanIou := true</l>
<l>    elseif (Measures[M] == 'class_iou')</l>
<l>        CalcClassIou := true</l>
<l>    elseif (Measures[M] == 'frequency_weighted_iou')</l>
<l>        CalcFWIou := true</l>
<l>    elseif (Measures[M] == 'all')</l>
<l>        CalcPixelAccuracy := true</l>
<l>        CalcClassPixelAccuracy := true</l>
<l>        CalcPixelConfusionMatrix := true</l>
<l>        CalcMeanAccuracy := true</l>
<l>        CalcMeanIou := true</l>
<l>        CalcClassIou := true</l>
<l>        CalcFWIou := true</l>
<l>    else</l>
<l>        throw ('Unknown Segmentation Measure: ' + Measures[M])</l>
<l>    endif</l>
<l>endfor</l>
<c>* </c>
<c>* Depending on the running measure values (ConfusionMatrix or TP/FP/FN),</c>
<c>* we first calculate TP/FP/FN from the ConfusionMatrix.</c>
<l>if (CalcPixelConfusionMatrix)</l>
<c>    * Get the running measures.</c>
<l>    get_dict_tuple (RunningMeasures, 'pixel_confusion_matrix', ConfMatrix)</l>
<c>    * Get the per-class true positives as the diagonal of the matrix.</c>
<l>    get_diagonal_matrix (ConfMatrix, 0, TPMat)</l>
<l>    get_full_matrix (TPMat, TP)</l>
<c>    * For the confusion matrix, the row determines the predicted class-IDs,</c>
<c>    * the column determines the ground truth class-IDs.</c>
<c>    * Get the per-class false positives (FP) as the sum over the rows minus the diagonal (TP).</c>
<l>    sum_matrix (ConfMatrix, 'rows', SumRowMat)</l>
<l>    get_full_matrix (SumRowMat, RowSum)</l>
<l>    FP := RowSum - TP</l>
<c>    * Get the per-class false negatives (FN) as the sum over the columns minus the diagonal (TP).</c>
<l>    sum_matrix (ConfMatrix, 'columns', SumColMat)</l>
<l>    get_full_matrix (SumColMat, ColSum)</l>
<l>    FN := ColSum - TP</l>
<c>    * We do not want to count the false positives (FP) in the ignore region.</c>
<c>    * The false negatives (FN) are not affected, since the model does not predict the ignore class.</c>
<l>    get_dict_tuple (EvalParams, 'ignore_class_ids', IgnoreClassIDs)</l>
<l>    if (|IgnoreClassIDs| &gt; 0)</l>
<c>        * The ignore class corresponds to the last row/column in the confusion matrix.</c>
<l>        get_size_matrix (ConfMatrix, Rows, Columns)</l>
<l>        get_value_matrix (ConfMatrix, [0:Rows - 1], gen_tuple_const(Rows,Columns - 1), FPIgnore)</l>
<l>        FP := FP - FPIgnore</l>
<c>        * Remove last entries of TP, FP, FN (those related to the ignore class).</c>
<l>        TP := TP[0:|TP| - 2]</l>
<l>        FP := FP[0:|FP| - 2]</l>
<l>        FN := FN[0:|FN| - 2]</l>
<c>        * Remove last row/column from confusion matrix.</c>
<l>        get_sub_matrix (ConfMatrix, 0, 0, Rows - 1, Columns - 1, ConfMatrix)</l>
<l>    endif</l>
<c>    * Paste the confusion matrix to the output.</c>
<l>    set_dict_tuple (EvaluationResult, 'pixel_confusion_matrix', ConfMatrix)</l>
<l>else</l>
<c>    * Get the running measure values.</c>
<l>    get_dict_tuple (RunningMeasures, 'tp', TP)</l>
<l>    get_dict_tuple (RunningMeasures, 'fp', FP)</l>
<l>    get_dict_tuple (RunningMeasures, 'fn', FN)</l>
<l>endif</l>
<c>* </c>
<c>* It might be the case, that some of the classes are not present in the set of validation images.</c>
<c>* --&gt; Exclude these classes (they are indirectly present as they reduce the number of TP for other classes).</c>
<l>GT := TP + FN</l>
<l>ClsIdxValid := find(GT [&gt;] 0,1)</l>
<c>* </c>
<c>* Mean Accuracy, Class Pixel Accuracy.</c>
<c>* -&gt; If one of 'mean_accuracy', 'class_pixel_accuracy' is specified, we give back both of them</c>
<c>*    as they have to be calculated anyway (to the most part).</c>
<l>if (CalcClassPixelAccuracy or CalcMeanAccuracy)</l>
<c>    * Compute pixel accuracy per class (although we might only use it for the overall pixel accuracy).</c>
<l>    ClassPixelAccuracy := gen_tuple_const(|GT|,-1)</l>
<l>    MeanAccuracy := -1</l>
<l>    if (ClsIdxValid[0] &gt; -1)</l>
<l>        ClassPixelAccuracy[ClsIdxValid] := real(TP[ClsIdxValid]) / GT[ClsIdxValid]</l>
<l>        MeanAccuracy := mean(ClassPixelAccuracy[ClsIdxValid])</l>
<l>    endif</l>
<l>    set_dict_tuple (EvaluationResult, 'class_pixel_accuracy', ClassPixelAccuracy)</l>
<l>    set_dict_tuple (EvaluationResult, 'mean_accuracy', MeanAccuracy)</l>
<l>endif</l>
<c>* Pixel Accuracy</c>
<l>if (CalcPixelAccuracy)</l>
<c>    * Compute pixel accuracy as the total ratio of pixels that have been correctly predicted.</c>
<l>    PixelAccuracy := -1</l>
<l>    if (ClsIdxValid[0] &gt; -1)</l>
<l>        PixelAccuracy := real(sum(TP[ClsIdxValid])) / sum(GT[ClsIdxValid])</l>
<l>    endif</l>
<l>    set_dict_tuple (EvaluationResult, 'pixel_accuracy', PixelAccuracy)</l>
<l>endif</l>
<c>* Mean IoU, class IoU, frequency weighted IoU:</c>
<c>* -&gt; If the measures 'class_iou', 'mean_iou' or 'frequency_weighted_iou' is specified,</c>
<c>*    we return all three of them as they have to be calculated anyway (to the most part).</c>
<l>if (CalcMeanIou or CalcClassIou or CalcFWIou)</l>
<l>    ClassIoU := gen_tuple_const(|GT|,-1)</l>
<l>    MeanIoU := -1</l>
<l>    FWIoU := -1</l>
<l>    if (ClsIdxValid[0] &gt; -1)</l>
<l>        ClassIoU[ClsIdxValid] := real(TP[ClsIdxValid]) / (GT[ClsIdxValid] + FP[ClsIdxValid])</l>
<l>        MeanIoU := mean(ClassIoU[ClsIdxValid])</l>
<l>        FwWeights := real(GT) / sum(GT)</l>
<l>        FWIoU := sum(FwWeights[ClsIdxValid] * ClassIoU[ClsIdxValid])</l>
<l>    endif</l>
<l>    set_dict_tuple (EvaluationResult, 'class_iou', ClassIoU)</l>
<l>    set_dict_tuple (EvaluationResult, 'mean_iou', MeanIoU)</l>
<l>    set_dict_tuple (EvaluationResult, 'frequency_weighted_iou', FWIoU)</l>
<l>endif</l>
<c>* </c>
<l>return ()</l>
</body>
<docu id="calculate_pixel_measures">
<abstract lang="en_US">Calculate the pixel-based evaluation measures for segmentation based on the values in running measures.
The dictionary RunningMeasures contains the necessary current evaluation measure values (either TP, FP, FN or confusion matrix).
The dictionary EvalParams determines the evaluation measures to be calculated.
EvaluationResult is a dictionary returning the desired measures.

This procedure is typically used to evaluate deep-learning-based segmentation models.
</abstract>
<chapters lang="de_DE">
<item>Deep Learning</item>
<item>Evaluierung</item>
</chapters>
<chapters lang="en_US">
<item>Deep Learning</item>
<item>Evaluation</item>
</chapters>
<library lang="en_US">MVTec Standard Procedures</library>
<short lang="en_US">Calculate pixel measures based on RunningMeasures.</short>
<parameters>
<parameter id="EvalParams">
<default_type>integer</default_type>
<default_value>EvalParams</default_value>
<description lang="en_US">Dictionary with the evaluation parameters.</description>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>dict</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="EvaluationResult">
<default_type>integer</default_type>
<description lang="en_US">Result dictionary containing the values for the measures determined in EvalParams by the key 'measures'.</description>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>dict</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="RunningMeasures">
<default_type>integer</default_type>
<default_value>RunningMeasures</default_value>
<description lang="en_US">A dictionary containing the running measure values in tuples for TP, FP and FN or a pixel confusion matrix.</description>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>dict</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
</parameters>
</docu>
</procedure>
<procedure name="calculate_tool_in_base_robot_path_poses">
<interface>
<ic>
<par name="ToolInModelRobotPathPoses" base_type="ctrl" dimension="1"/>
<par name="ModelInBasePose" base_type="ctrl" dimension="0"/>
<par name="Poses" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="ToolInBaseRobotPathPoses" base_type="ctrl" dimension="1"/>
</oc>
</interface>
<body>
<c>* </c>
<l>read_dict_tuple (Poses, 'OrderOfTransform', OrderOfTransform)</l>
<l>read_dict_tuple (Poses, 'OrderOfRotation', OrderOfRotation)</l>
<l>read_dict_tuple (Poses, 'ViewOfTransform', ViewOfTransform)</l>
<c>* </c>
<l>for Index1 := 0 to ToolInModelRobotPathPoses.length() - 1 by 1</l>
<l>    pose_compose (ModelInBasePose, ToolInModelRobotPathPoses.at(Index1), ToolInBaseRobotPathPose)</l>
<l>    convert_pose_type (ToolInBaseRobotPathPose, OrderOfTransform, OrderOfRotation, ViewOfTransform, ToolInBaseRobotPathPose)</l>
<l>    ToolInBaseRobotPathPoses.at(Index1) := ToolInBaseRobotPathPose</l>
<l>endfor</l>
<l>return ()</l>
</body>
<docu id="calculate_tool_in_base_robot_path_poses">
<abstract lang="en_US">This procedure uses the pose of an object ModelInBasePose and the robot path poses ToolInModelRobotPathPoses to calculate the poses which can be used to approach, grasp, ... the object. 

To get the correct pose type for your robot, the input dict Poses must contain the parameters OrderOfTransform, OrderOfRotation, and ViewOfTransform.</abstract>
<chapters lang="de_DE">
<item>Transformationen</item>
<item>Posen</item>
</chapters>
<chapters lang="en_US">
<item>Transformations</item>
<item>Poses</item>
</chapters>
<library lang="en_US">MVTec Standard Procedures</library>
<short lang="en_US">Calculate the poses to grasp an object.</short>
<parameters>
<parameter id="ModelInBasePose">
<default_type>real</default_type>
<description lang="en_US">Pose of the current match.</description>
<multivalue>true</multivalue>
<sem_type>pose</sem_type>
<type_list>
<item>real</item>
</type_list>
</parameter>
<parameter id="Poses">
<default_type>integer</default_type>
<description lang="en_US">Must contain the parameters OrderOfTransform, OrderOfRotation, and ViewOfTransform.</description>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>dict</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="ToolInBaseRobotPathPoses">
<default_type>real</default_type>
<description lang="en_US">Poses to approach, grasp, ... the current object.</description>
<multivalue>true</multivalue>
<sem_type>pose</sem_type>
<type_list>
<item>real</item>
</type_list>
</parameter>
<parameter id="ToolInModelRobotPathPoses">
<default_type>real</default_type>
<description lang="en_US">Trained poses to approach, grasp, ... an object.</description>
<multivalue>true</multivalue>
<sem_type>pose</sem_type>
<type_list>
<item>real</item>
</type_list>
</parameter>
</parameters>
</docu>
</procedure>
<procedure name="calibrate_camera_and_plane_single_image">
<interface>
<ic>
<par name="CalibObjectData" base_type="ctrl" dimension="0"/>
</ic>
</interface>
<body>
<l>read_dict_object (ImageCaltab, CalibObjectData, 'ImageCaltab')</l>
<l>read_dict_tuple (CalibObjectData, 'CalPlateDescr', CalPlateDescr)</l>
<l>read_dict_tuple (CalibObjectData, 'CalPlateThickness', CalPlateThickness)</l>
<l>read_dict_tuple (CalibObjectData, 'StartCamParam', StartCamParam)</l>
<c>* </c>
<c>* Check input</c>
<l>if (StartCamParam[0] =~ 'line_scan')</l>
<l>    throw ('Line-scan cameras are not supported')</l>
<l>endif</l>
<c>* </c>
<c>* Create a HALCON calibration data model.</c>
<l>create_calib_data ('calibration_object', 1, 1, CalibDataID)</l>
<c>* Set the needed calibration information.</c>
<l>set_calib_data_cam_param (CalibDataID, 0, [], StartCamParam)</l>
<l>set_calib_data_calib_object (CalibDataID, 0, CalPlateDescr)</l>
<c>* Find the calibration plate.</c>
<l>find_calib_object (ImageCaltab, CalibDataID, 0, 0, 0, [], [])</l>
<c>* Calibrating from only one view requires some parameter to be excluded</c>
<c>* from the optimization.</c>
<l>set_calib_data (CalibDataID, 'camera', 0, 'excluded_settings', 'focus')</l>
<c>* Calibrate the camera.</c>
<l>calibrate_cameras (CalibDataID, ErrorCamCalibInPixel)</l>
<c>* Get the calibration results.</c>
<l>get_calib_data (CalibDataID, 'camera', 0, 'params', CamParam)</l>
<l>get_calib_data (CalibDataID, 'calib_obj_pose', [0,0], 'pose', PlaneInCamPose0)</l>
<l>set_origin_pose (PlaneInCamPose0, 0, 0, CalPlateThickness, PlaneInCamPose)</l>
<c>* Convert pose to standard pose type.</c>
<l>convert_pose_type (PlaneInCamPose, 'Rp+T', 'gba', 'point', PlaneInCamPose)</l>
<c>* </c>
<c>* Add data to output dict.</c>
<l>set_dict_tuple (CalibObjectData, 'ErrorCamCalibInPixel', ErrorCamCalibInPixel)</l>
<l>set_dict_tuple (CalibObjectData, 'CamParam', CamParam)</l>
<l>set_dict_tuple (CalibObjectData, 'PlaneInCamPose', PlaneInCamPose)</l>
<c>* Clean up.</c>
<l>clear_calib_data (CalibDataID)</l>
<l>return ()</l>
</body>
<docu id="calibrate_camera_and_plane_single_image">
<abstract lang="en_US">This procedure calibrates a camera with a single image of a calibration plate in the measurement plane. The input dict CalibObjectData containing the necessary data can easily be collected with the procedure collect_single_image_calibration_data.

The optimized camera parameters are stored in CamParam.
The output parameter ErrorCamCalibInPixel returns the error of the camera calibration of the current setup.
The plane that is defined by the calibration plate is first corrected using the thickness of the calibration plate and then stored in the parameter PlaneInCamPose. These three parameters are saved in the dict CalibObjectData, in addition to the already available input parameters.</abstract>
<chapters lang="de_DE">
<item>Kalibrierung</item>
<item>Monokular</item>
</chapters>
<chapters lang="en_US">
<item>Calibration</item>
<item>Monocular</item>
</chapters>
<keywords lang="en_US">
<item>set_dict_tuple</item>
</keywords>
<library lang="de_DE">MVTec Standard Procedures</library>
<library lang="en_US">MVTec Standard Procedures</library>
<predecessor>
<item>collect_single_image_calibration_data</item>
</predecessor>
<short lang="en_US">Calibrate a camera with a single image.</short>
<successor>
<item>get_dict_tuple</item>
</successor>
<parameters>
<parameter id="CalibObjectData">
<default_type>integer</default_type>
<description lang="en_US">Calibration data.</description>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>dict</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
</parameters>
</docu>
</procedure>
<procedure name="calibrate_hand_eye_stationary_cam_approx">
<interface>
<ic>
<par name="RobotTouchingPointInToolCoordinates" base_type="ctrl" dimension="0"/>
<par name="RowsTouchingPointInPlane" base_type="ctrl" dimension="0"/>
<par name="ColumnsTouchingPointInPlane" base_type="ctrl" dimension="0"/>
<par name="ToolInBasePoses" base_type="ctrl" dimension="1"/>
<par name="CalibObjectData" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="HandEyeCalibData" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c>* </c>
<l>read_dict_tuple (CalibObjectData, 'CamParam', CamParam)</l>
<l>read_dict_tuple (CalibObjectData, 'CalPlateThickness', CalPlateThickness)</l>
<l>read_dict_tuple (CalibObjectData, 'PlaneInCamPose', PlaneInCamPose)</l>
<c>* </c>
<c>* Check input</c>
<l>if (|RowsTouchingPointInPlane| &lt; 3 or |ColumnsTouchingPointInPlane| &lt; 3 or ToolInBasePoses.length() &lt; 3)</l>
<l>    throw ('Please specify at least three image coordinates and robot poses.')</l>
<l>endif</l>
<l>if (|RowsTouchingPointInPlane| != |ColumnsTouchingPointInPlane| or |RowsTouchingPointInPlane| != ToolInBasePoses.length())</l>
<l>    throw ('The number of image coordinates and robot poses have to be equal.')</l>
<l>endif</l>
<l>if (CamParam[0] =~ 'line_scan')</l>
<l>    throw ('Line-scan cameras are not supported')</l>
<l>endif</l>
<c>* </c>
<c>* If points on top of the calibration plate are approached, we have to adapt the PlaneInCamPose accordingly.</c>
<l>set_origin_pose (PlaneInCamPose, 0, 0, -CalPlateThickness, PlaneInCamPose)</l>
<c>* Keep track of the pose type used by the robot.</c>
<l>get_pose_type (ToolInBasePoses.at(0), OrderOfTransform0, OrderOfRotation0, ViewOfTransform0)</l>
<l>convert_pose_type (ToolInBasePoses.at(0), 'Rp+T', 'gba', 'point', ToolInBasePoses.at(0))</l>
<l>for Index := 1 to ToolInBasePoses.length() - 1 by 1</l>
<l>    get_pose_type (ToolInBasePoses.at(Index), OrderOfTransform, OrderOfRotation, ViewOfTransform)</l>
<l>    if (OrderOfTransform0 != OrderOfTransform or OrderOfRotation0 != OrderOfRotation or ViewOfTransform0 != ViewOfTransform)</l>
<l>        throw ('ToolInBasePoses have different pose types.')</l>
<l>    endif</l>
<c>    * Convert to default pose type.</c>
<l>    convert_pose_type (ToolInBasePoses.at(Index), 'Rp+T', 'gba', 'point', ToolInBasePoses.at(Index))</l>
<l>endfor</l>
<c>* </c>
<c>* Collect the robot translations.</c>
<l>create_pose (RobotTouchingPointInToolCoordinates[0], RobotTouchingPointInToolCoordinates[1], RobotTouchingPointInToolCoordinates[2], 0, 0, 0, 'Rp+T', 'gba', 'point', TouchingPointInToolPose)</l>
<l>XBase := []</l>
<l>YBase := []</l>
<l>ZBase := []</l>
<l>for Index := 0 to |RowsTouchingPointInPlane| - 1 by 1</l>
<l>    pose_compose (ToolInBasePoses.at(Index), TouchingPointInToolPose, TouchingPointInBasePose)</l>
<l>    XBase := [XBase,TouchingPointInBasePose[0]]</l>
<l>    YBase := [YBase,TouchingPointInBasePose[1]]</l>
<l>    ZBase := [ZBase,TouchingPointInBasePose[2]]</l>
<l>endfor</l>
<c>* </c>
<c>* Get the plane coordinates of the input image points.</c>
<l>image_points_to_world_plane (CamParam, PlaneInCamPose, RowsTouchingPointInPlane, ColumnsTouchingPointInPlane, 'm', XPlane, YPlane)</l>
<l>tuple_gen_const (|XPlane|, 0, ZPlane)</l>
<l>vector_to_hom_mat3d ('rigid', XPlane, YPlane, ZPlane, XBase, YBase, ZBase, HomMat3DPlaneToBase)</l>
<l>hom_mat3d_to_pose (HomMat3DPlaneToBase, PlaneInBasePose)</l>
<c>* If points on top of the calibration plate are approached, we have to readapt the Plane accordingly.</c>
<l>set_origin_pose (PlaneInCamPose, 0, 0, CalPlateThickness, PlaneInCamPose)</l>
<l>set_origin_pose (PlaneInBasePose, 0, 0, CalPlateThickness, PlaneInBasePose)</l>
<l>pose_invert (PlaneInBasePose, BaseInPlanePose)</l>
<l>pose_compose (PlaneInCamPose, BaseInPlanePose, BaseInCamPose)</l>
<c>* </c>
<c>* Get the BaseInCamPose.</c>
<l>pose_invert (PlaneInBasePose, BaseInPlanePose)</l>
<l>pose_compose (PlaneInCamPose, BaseInPlanePose, BaseInCamPose)</l>
<c>* Convert to output pose type.</c>
<l>convert_pose_type (BaseInCamPose, OrderOfTransform0, OrderOfRotation0, ViewOfTransform0, BaseInCamPose)</l>
<l>convert_pose_type (PlaneInBasePose, OrderOfTransform0, OrderOfRotation0, ViewOfTransform0, PlaneInBasePose)</l>
<c></c>
<c>* Get the difference of the points in the plane as seen by the camera</c>
<c>* to the points in the plane as approached by the robot.</c>
<l>affine_trans_point_3d (HomMat3DPlaneToBase, XPlane, YPlane, ZPlane, XPlaneBase, YPlaneBase, ZPlaneBase)</l>
<l>DiffX := XPlaneBase - XBase</l>
<l>DiffY := YPlaneBase - YBase</l>
<l>DiffZ := ZPlaneBase - ZBase</l>
<l>SqrDiff := DiffX * DiffX + DiffY * DiffY + DiffZ * DiffZ</l>
<l>PlanePointsRMS := sqrt(sum(SqrDiff) / |DiffX|)</l>
<l>PlanePointsMaxDiff := max(sqrt(SqrDiff))</l>
<c>* </c>
<c>* Create output dict.</c>
<l>create_dict (HandEyeCalibData)</l>
<l>set_dict_tuple (HandEyeCalibData, 'CamParam', CamParam)</l>
<l>set_dict_tuple (HandEyeCalibData, 'BaseInCamPose', BaseInCamPose)</l>
<l>set_dict_tuple (HandEyeCalibData, 'PlaneInBasePose', PlaneInBasePose)</l>
<l>set_dict_tuple (HandEyeCalibData, 'PlaneInCamPose0', PlaneInCamPose)</l>
<l>set_dict_tuple (HandEyeCalibData, 'PlanePointsRMS', PlanePointsRMS)</l>
<l>set_dict_tuple (HandEyeCalibData, 'PlanePointsMaxDiff', PlanePointsMaxDiff)</l>
<l>return ()</l>
</body>
<docu id="calibrate_hand_eye_stationary_cam_approx">
<abstract lang="en_US">This procedures performs an approximate hand-eye calibration of a six-axis robot for the case where a camera is stationary with respect to the robot. The measurement plane of the robot has to be observable and known with respect to the camera.

The parameter RobotTouchingPointInToolCoordinates describes a point on the gripper that touches the measurement plane. If the tool coordinate system already lies in the gripper, the touching point is a 1 x 3 vector with all its entries being zero. Otherwise, the vector describes the translation in x-, y- and z-direction of the tool origin to the touching point.
Please note that the touching point has to be fixed w.r.t. the tool coordinate system, but does not have to be located on the surface of the gripper, i.e. it can lie halfway between two fingers of a gripper.

The parameters RowsTouchingPointInPlane and ColsTouchingPointInPlane are the image coordinates in row and column direction, respectively that have been approached by the touching point. The corresponding robot poses have to be specified in the parameter ToolInBasePoses. 

Please note that at least three row, column and robot poses have to be used and that these parameters have to be of equal
size. It is further important that all row and column coordinates lie in the plane PlaneInCamPose and that the touching point of the robot has to approach the plane exactly at these points.

The input dict CalibObjectData must contain the following data: 
  - The internal camera parameters have to be specified in the parameter CamParam.
  - The parameter PlaneInCamPose describes the measurement plane with respect to the camera.
  - The parameter CalPlateThickness describes the thickness of the calibration plate, in meters.

The output parameters are stored in the dict HandEyeCalibData. The following data is stored:
  - The camera parameters CamParam.
  - The parameter BaseInCamPose, which is the pose of the robot's base with respect to the camera.
  - The parameter PlaneInBasePose, which is the pose of the plane with respect to the robot's base.
  - The parameters PlaneInCamPose, which is the pose of the plane with respect to the camera.
  - A qualitative statement about the calibration and the measurement plane is given in the parameters PlanePointsRMS and PlanePointsMaxDiff: The PlanePointsRMS describes the root mean square error of the difference between the rows and columns projected into the measurement plane and the identical points that have been approached by the touching point. The PlanePointsMaxDiff describes the maximum error of the Euclidean distances of the projected and the approached points. </abstract>
<alternatives>
<item>calibrate_hand_eye_stationary_cam_approx_without_calib_plate</item>
<item>calibrate_hand_eye</item>
</alternatives>
<chapters lang="de_DE">
<item>Kalibrierung</item>
<item>Hand-Auge</item>
</chapters>
<chapters lang="en_US">
<item>Calibration</item>
<item>Hand-Eye</item>
</chapters>
<library lang="de_DE">MVTec Standard Procedures</library>
<library lang="en_US">MVTec Standard Procedures</library>
<predecessor>
<item>get_nearest_finder_pattern_coordinates</item>
</predecessor>
<short lang="en_US">Perform a hand-eye calibration with a stationary camera.</short>
<parameters>
<parameter id="CalibObjectData">
<default_type>integer</default_type>
<description lang="en_US">Calibration data.</description>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>dict</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="ColumnsTouchingPointInPlane">
<default_type>real</default_type>
<default_value>[]</default_value>
<description lang="en_US">Column coordinates of points in the measurement plane that have been approached by the robot's touching point.</description>
<multivalue>true</multivalue>
<sem_type>point.x</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
<parameter id="HandEyeCalibData">
<default_type>integer</default_type>
<description lang="en_US"> Hand-eye calibration data.</description>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>dict</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="RobotTouchingPointInToolCoordinates">
<default_type>real</default_type>
<default_value>[]</default_value>
<description lang="en_US">A point on the gripper that has been used to approach points in the measurement plane of the robot.</description>
<multivalue>true</multivalue>
<sem_type>coordinates</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
<parameter id="RowsTouchingPointInPlane">
<default_type>real</default_type>
<default_value>[]</default_value>
<description lang="en_US">Row coordinates of points in the measurement plane that have been approached by the robot's touching point.</description>
<multivalue>true</multivalue>
<sem_type>point.y</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
<parameter id="ToolInBasePoses">
<default_type>real</default_type>
<default_value>[]</default_value>
<description lang="en_US">Robot positions that have been acquired while touching the corresponding image points.</description>
<multivalue>true</multivalue>
<sem_type>pose</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
</parameters>
</docu>
</procedure>
<procedure name="calibrate_hand_eye_stationary_cam_approx_without_calib_plate">
<interface>
<ic>
<par name="RowsTouchingPointInPlane" base_type="ctrl" dimension="0"/>
<par name="ColumnsTouchingPointInPlane" base_type="ctrl" dimension="0"/>
<par name="ToolInBasePoses" base_type="ctrl" dimension="1"/>
<par name="RobotTouchingPointInToolCoordinates" base_type="ctrl" dimension="0"/>
<par name="DistanceObjectTouchingPointToPlane" base_type="ctrl" dimension="0"/>
<par name="DistancePlaneToCamera" base_type="ctrl" dimension="0"/>
<par name="Width" base_type="ctrl" dimension="0"/>
<par name="Height" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="HandEyeCalibData" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c>* Check input.</c>
<l>if (|RowsTouchingPointInPlane| &lt; 4 or |ColumnsTouchingPointInPlane| &lt; 4 or ToolInBasePoses.length() &lt; 4)</l>
<l>    throw ('Please specify at least four image coordinates and robot poses.')</l>
<l>endif</l>
<l>if (|RowsTouchingPointInPlane| != |ColumnsTouchingPointInPlane| or |RowsTouchingPointInPlane| != ToolInBasePoses.length())</l>
<l>    throw ('The number of image coordinates and robot poses have to be equal.')</l>
<l>endif</l>
<l>if (Width &lt;= 0 or Height &lt;= 0)</l>
<l>    throw ('Width or Height must be greater than 0.')</l>
<l>endif</l>
<l>if (DistancePlaneToCamera &lt;= 0)</l>
<l>    throw ('DistancePlaneToCamera must be greater than 0.')</l>
<l>endif</l>
<l>if (DistancePlaneToCamera &lt;= 0)</l>
<l>    throw ('DistanceObjectTouchingPointToPlane must be greater than 0.')</l>
<l>endif</l>
<c>* </c>
<c>* Keep track of the pose type used by the robot.</c>
<l>get_pose_type (ToolInBasePoses.at(0), OrderOfTransform0, OrderOfRotation0, ViewOfTransform0)</l>
<l>convert_pose_type (ToolInBasePoses.at(0), 'Rp+T', 'gba', 'point', ToolInBasePoses.at(0))</l>
<l>for Index := 1 to ToolInBasePoses.length() - 1 by 1</l>
<l>    get_pose_type (ToolInBasePoses.at(Index), OrderOfTransform, OrderOfRotation, ViewOfTransform)</l>
<l>    if (OrderOfTransform0 != OrderOfTransform or OrderOfRotation0 != OrderOfRotation or ViewOfTransform0 != ViewOfTransform)</l>
<l>        throw ('ToolInBasePoses have different pose types.')</l>
<l>    endif</l>
<c>    * Convert to default pose type.</c>
<l>    convert_pose_type (ToolInBasePoses.at(Index), 'Rp+T', 'gba', 'point', ToolInBasePoses.at(Index))</l>
<l>endfor</l>
<c>* </c>
<c>* Collect the robot translations.</c>
<l>create_pose (RobotTouchingPointInToolCoordinates[0], RobotTouchingPointInToolCoordinates[1], RobotTouchingPointInToolCoordinates[2], 0, 0, 0, 'Rp+T', 'gba', 'point', RobotTouchingPointToToolXYZPose)</l>
<l>XBase := []</l>
<l>YBase := []</l>
<l>ZBase := []</l>
<l>for Index := 0 to |RowsTouchingPointInPlane| - 1 by 1</l>
<l>    pose_compose (ToolInBasePoses.at(Index), RobotTouchingPointToToolXYZPose, TouchingPointInBasePose)</l>
<l>    XBase := [XBase,TouchingPointInBasePose[0]]</l>
<l>    YBase := [YBase,TouchingPointInBasePose[1]]</l>
<l>    ZBase := [ZBase,TouchingPointInBasePose[2]]</l>
<l>endfor</l>
<c>* </c>
<c>*  Use the specified robot translations to obtain the PlaneInBasePose.</c>
<l>gen_object_model_3d_from_points (XBase, YBase, ZBase, OM3DPlanePoints)</l>
<l>fit_primitives_object_model_3d (OM3DPlanePoints, 'primitive_type', 'plane', OM3DPlane)</l>
<l>get_object_model_3d_params (OM3DPlane, 'primitive_pose', TouchingPointPlaneInBasePose)</l>
<c>* </c>
<c>* Obtain fictitious camera parameters.</c>
<l>FocusOrig := 0.008</l>
<l>DiffRow := RowsTouchingPointInPlane[0:|RowsTouchingPointInPlane| - 2] - RowsTouchingPointInPlane[1:|RowsTouchingPointInPlane| - 1]</l>
<l>DiffCol := ColumnsTouchingPointInPlane[0:|ColumnsTouchingPointInPlane| - 2] - ColumnsTouchingPointInPlane[1:|ColumnsTouchingPointInPlane| - 1]</l>
<l>DistPixel := sqrt(DiffRow * DiffRow + DiffCol * DiffCol)</l>
<l>DiffX := XBase[0:|XBase| - 2] - XBase[1:|XBase| - 1]</l>
<l>DiffY := YBase[0:|YBase| - 2] - YBase[1:|YBase| - 1]</l>
<l>DiffZ := ZBase[0:|ZBase| - 2] - ZBase[1:|ZBase| - 1]</l>
<l>DistWorld := sqrt(DiffX * DiffX + DiffY * DiffY + DiffZ * DiffZ)</l>
<l>Quotient := median(DistWorld / DistPixel)</l>
<c>* Camera parameter will be generated in the following form:</c>
<l>* SX := Quotient * FocusOrig / DistancePlaneToCamera</l>
<l>* SY := SX</l>
<l>* gen_cam_par_area_scan_division (FocusOrig, 0, SX, SY, Width / 2.0, Height / 2.0, Width, Height, HandEyeCalibData)</l>
<c>* </c>
<c>* Use the specified image points and robot translations to obtain the BaseInCamPose.</c>
<l>FocusShift := [0.1,0.2,0.33,0.5,0.75,1.0,1.5,2,3,3.125,3.5,4]</l>
<l>BestIndex := -1</l>
<c>* The value of focus should not have much influence when camera and plane are parallel,</c>
<c>* but just in case, check different values.</c>
<l>ErrorBasePoseInPixel := 1e9</l>
<l>for NumFocus := 0 to |FocusShift| - 1 by 1</l>
<l>    Focus := FocusOrig * FocusShift[NumFocus]</l>
<l>    SX := Quotient * Focus / DistancePlaneToCamera</l>
<l>    SY := SX</l>
<l>    gen_cam_par_area_scan_division (Focus, 0, SX, SY, Width / 2.0, Height / 2.0, Width, Height, CamParam0)</l>
<l>    vector_to_pose (XBase, YBase, ZBase, RowsTouchingPointInPlane, ColumnsTouchingPointInPlane, CamParam0, 'iterative', 'error', BaseInCamPose0, ErrorBasePoseInPixelTmp)</l>
<l>    if (ErrorBasePoseInPixel &gt; ErrorBasePoseInPixelTmp)</l>
<l>        BaseInCamPose := BaseInCamPose0</l>
<l>        ErrorBasePoseInPixel := ErrorBasePoseInPixelTmp</l>
<l>        CamParam := CamParam0</l>
<l>    endif</l>
<l>endfor</l>
<c>* Get the PlaneInCamPose.</c>
<l>pose_compose (BaseInCamPose, TouchingPointPlaneInBasePose, TouchingPointPlaneInCamPose)</l>
<c>* </c>
<c>* The z-axis of the plane should point away from the camera.</c>
<l>TouchingPointPlaneInCamPose0Rot := TouchingPointPlaneInCamPose</l>
<l>TouchingPointPlaneInCamPose0Rot[0:2] := [0,0,0]</l>
<l>pose_to_hom_mat3d (TouchingPointPlaneInCamPose0Rot, HomMat3D)</l>
<l>affine_trans_point_3d (HomMat3D, 0, 0, 1, Qx, Qy, CosAngleBetweenZAxis)</l>
<l>if (CosAngleBetweenZAxis &lt; 0)</l>
<l>    create_pose (0, 0, 0, 180, 0, 0, 'Rp+T', 'gba', 'point', SwitchZDirection)</l>
<l>    pose_compose (TouchingPointPlaneInCamPose, SwitchZDirection, TouchingPointPlaneInCamPose1)</l>
<l>    TouchingPointPlaneInCamPose := TouchingPointPlaneInCamPose1</l>
<l>    pose_invert (BaseInCamPose, CamInBasePose)</l>
<l>    pose_compose (CamInBasePose, TouchingPointPlaneInCamPose, TouchingPointPlaneInBasePose)</l>
<l>endif</l>
<c>* </c>
<c>* Get the difference of the points in the plane as seen by the camera</c>
<c>* to the points in the plane as approached by the robot.</c>
<l>image_points_to_world_plane (CamParam, TouchingPointPlaneInCamPose, RowsTouchingPointInPlane, ColumnsTouchingPointInPlane, 'm', TouchingPointPlanePointsCamX, TouchingPointPlanePointsCamY)</l>
<l>tuple_gen_const (|TouchingPointPlanePointsCamY|, 0.0, TouchingPointPlanePointsCamZ)</l>
<l>pose_invert (TouchingPointPlaneInBasePose, BaseInTouchingPointPlanePose)</l>
<l>pose_to_hom_mat3d (BaseInTouchingPointPlanePose, HomMat3D1)</l>
<l>affine_trans_point_3d (HomMat3D1, XBase, YBase, ZBase, TouchingPointPlanePointsToolX, TouchingPointPlanePointsToolY, TouchingPointPlanePointsToolZ)</l>
<l>DiffX := TouchingPointPlanePointsCamX - TouchingPointPlanePointsToolX</l>
<l>DiffY := TouchingPointPlanePointsCamY - TouchingPointPlanePointsToolY</l>
<l>DiffZ := TouchingPointPlanePointsCamZ - TouchingPointPlanePointsToolZ</l>
<l>SqrDiff := DiffX * DiffX + DiffY * DiffY + DiffZ * DiffZ</l>
<l>PlanePointsRMS := sqrt(sum(SqrDiff) / |DiffX|)</l>
<l>PlanePointsMaxDiff := max(sqrt(SqrDiff))</l>
<c>* </c>
<l>set_origin_pose (TouchingPointPlaneInBasePose, 0, 0, DistanceObjectTouchingPointToPlane, PlaneInBasePose)</l>
<l>set_origin_pose (TouchingPointPlaneInCamPose, 0, 0, DistanceObjectTouchingPointToPlane, PlaneInCamPose)</l>
<c>* </c>
<c>* Convert to output pose type.</c>
<l>convert_pose_type (BaseInCamPose, OrderOfTransform0, OrderOfRotation0, ViewOfTransform0, BaseInCamPose)</l>
<l>convert_pose_type (PlaneInBasePose, OrderOfTransform0, OrderOfRotation0, ViewOfTransform0, PlaneInBasePose)</l>
<l>convert_pose_type (PlaneInCamPose, OrderOfTransform0, OrderOfRotation0, ViewOfTransform0, PlaneInCamPose)</l>
<c>* </c>
<c>* Create output dict.</c>
<l>create_dict (HandEyeCalibData)</l>
<l>set_dict_tuple (HandEyeCalibData, 'CamParam', CamParam)</l>
<l>set_dict_tuple (HandEyeCalibData, 'BaseInCamPose', BaseInCamPose)</l>
<l>set_dict_tuple (HandEyeCalibData, 'PlaneInBasePose', PlaneInBasePose)</l>
<l>set_dict_tuple (HandEyeCalibData, 'PlaneInCamPose0', PlaneInCamPose)</l>
<l>set_dict_tuple (HandEyeCalibData, 'PlanePointsRMS', PlanePointsRMS)</l>
<l>set_dict_tuple (HandEyeCalibData, 'PlanePointsMaxDiff', PlanePointsMaxDiff)</l>
<l>return ()</l>
</body>
<docu id="calibrate_hand_eye_stationary_cam_approx_without_calib_plate">
<abstract lang="en_US">This procedures performs a hand-eye calibration of a six-axis robot for the case where a camera is stationary with respect to the robot. For the camera calibration part of this procedure, the internal camera parameters neither have to be specified nor known. Note that the camera has to look perpendicularly onto the plane.

The parameters RowsTouchingPointInPlane and ColumnsTouchingPointInPlane are the image coordinates that have been approached by the touching point of the robot. The corresponding robot poses have to be specified in the parameter ToolInBasePoses.
Please note that at least four row, column and robot poses have to be used and that these parameters have to be of equal size. To achieve reliable results it is important that these points are well distributed over the entire field of view. To increase the accuracy of the estimation, it is recommended to use more than just four correspondences. 

The parameter RobotTouchingPointInToolCoordinates describes the the touching point of the robot, i. e., a point on the gripper that touches the measurement plane. If the tool coordinate system already lies in the gripper, the touching point is a 1 x 3 vector with all its entries being zero. Otherwise, the vector describes the translation in x-, y- and z-direction of the tool origin to the touching point.
Please note that the touching point has to be fixed with respect to the tool coordinate system, but does not have to be located on the surface of the gripper, i.e. it can lie halfway between two fingers of a gripper.

The parameter DistancePlaneToCamera describes the (orthogonal) distance between the measurement plane and the camera center.

The image size has to be specified in the parameter Width and Height.

If you approached a three-dimensional object to gather the parameters RowsTouchingPointInPlane and ColumnsTouchingPointInPlane, you have to specify the height of this object's touching point above the plane in DistanceObjectTouchingPointToPlane.

The output parameters are stored in the dict HandEyeCalibData. The following data is stored:
  - The result of the camera calibration is returned in the parameter CamParam.
  - The parameter BaseInCamPose, which is the pose of the robot's base with respect to the camera.
  - The parameter PlaneInBasePose, which is the pose of the plane with respect to the robot's base.
  - The parameters PlaneInCamPose, which is the pose of the plane with respect to the camera.
  - A qualitative statement about the calibration and the measurement plane is given in the parameters PlanePointsRMS and PlanePointsMaxDiff: The PlanePointsRMS describes the root mean square error of the difference between the rows and columns projected into the measurement plane and the identical points that have been approached by the touching point. The PlanePointsMaxDiff describes the maximum error of the Euclidean distances of the projected and the approached points. 
</abstract>
<alternatives>
<item>calibrate_hand_eye_stationary_cam</item>
</alternatives>
<chapters lang="de_DE">
<item>Kalibrierung</item>
<item>Hand-Auge</item>
</chapters>
<chapters lang="en_US">
<item>Calibration</item>
<item>Hand-Eye</item>
</chapters>
<library lang="de_DE">MVTec Standard Procedures</library>
<library lang="en_US">MVTec Standard Procedures</library>
<predecessor>
<item>calibrate_robot_touching_point</item>
<item>get_image_size</item>
</predecessor>
<short lang="en_US">Perform a hand-eye calibration with a stationary camera.</short>
<parameters>
<parameter id="ColumnsTouchingPointInPlane">
<default_type>real</default_type>
<description lang="en_US">Column coordinates of points in the measurement plane that have been approached by the robot's touching point.</description>
<multivalue>true</multivalue>
<sem_type>point.x</sem_type>
<type_list>
<item>real</item>
</type_list>
</parameter>
<parameter id="DistanceObjectTouchingPointToPlane">
<default_type>real</default_type>
<description lang="en_US"> Height of the touching point above the plane.</description>
<multivalue>false</multivalue>
<sem_type>real</sem_type>
<type_list>
<item>real</item>
</type_list>
</parameter>
<parameter id="DistancePlaneToCamera">
<default_type>real</default_type>
<description lang="en_US">Perpendicular distance from camera to plane.</description>
<multivalue>false</multivalue>
<sem_type>real</sem_type>
<type_list>
<item>real</item>
</type_list>
</parameter>
<parameter id="HandEyeCalibData">
<default_type>integer</default_type>
<description lang="en_US">Hand-eye calibration data.</description>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>dict</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="Height">
<default_type>integer</default_type>
<description lang="en_US">Image height.</description>
<multivalue>false</multivalue>
<sem_type>extent.y</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="RobotTouchingPointInToolCoordinates">
<default_type>real</default_type>
<description lang="en_US">A point on the gripper that has been used to approach points in the measurement plane of the robot.</description>
<multivalue>true</multivalue>
<sem_type>coordinates</sem_type>
<type_list>
<item>real</item>
</type_list>
</parameter>
<parameter id="RowsTouchingPointInPlane">
<default_type>real</default_type>
<description lang="en_US">Row coordinates of points in the measurement plane that have been approached by the robot's touching point.</description>
<multivalue>true</multivalue>
<sem_type>point.y</sem_type>
<type_list>
<item>real</item>
</type_list>
</parameter>
<parameter id="ToolInBasePoses">
<default_type>real</default_type>
<description lang="en_US">Robot positions that have been acquired while touching the corresponding image points.</description>
<multivalue>true</multivalue>
<sem_type>pose</sem_type>
<type_list>
<item>real</item>
</type_list>
</parameter>
<parameter id="Width">
<default_type>integer</default_type>
<description lang="en_US">Image width.</description>
<multivalue>false</multivalue>
<sem_type>extent.x</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
</parameters>
</docu>
</procedure>
<procedure name="calibrate_robot_touching_point">
<interface>
<ic>
<par name="DataDir" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="RobotTouchingPointInToolCoordinates" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c>* </c>
<c>* Open a new window.</c>
<l>open_new_window (WindowHandle, WindowHandleGraphics)</l>
<c>* Display introduction.</c>
<l>dev_disp_introduction (WindowHandle, WindowHandleGraphics)</l>
<l>stop ()</l>
<c>* </c>
<c>* Read three ToolInBasesPoses which are used</c>
<c>* to calibrate the RobotTouchingPointInToolCoordinates.</c>
<l>for Index := 1 to 3 by 1</l>
<l>    read_pose (DataDir + 'tool_in_base_pose_touching_point_0' + Index + '.dat', ToolInBasePoseTouchingPoint)</l>
<l>    dev_disp_approach_pose_touching_point_instructions (WindowHandle, WindowHandleGraphics, Index)</l>
<l>    stop ()</l>
<c>    * Collect poses in vector.</c>
<l>    ToolInBasePosesTouchingPoint.at(Index-1) := ToolInBasePoseTouchingPoint</l>
<l>endfor</l>
<l>dev_set_window (WindowHandleGraphics)</l>
<l>dev_close_window ()</l>
<c>* </c>
<c>* Calculate the coordinates of the touching point</c>
<c>* of the robot with respect to the robot's tool.</c>
<l>get_robot_touching_point_in_tool_coordinates (ToolInBasePosesTouchingPoint, RobotTouchingPointInToolCoordinates)</l>
<c>* </c>
<c>* Visualize results.</c>
<l>visualize_calibrated_touching_point (RobotTouchingPointInToolCoordinates, ToolInBasePosesTouchingPoint, WindowHandle)</l>
<l>return ()</l>
</body>
<docu id="calibrate_robot_touching_point">
<abstract lang="en_US">This procedure helps you to calibrate the touching point of your robot, i.e., the touching point with respect to the tool coordinate system of the robot.

These coordinates are necessary, for example, for the hand-eye calibration in the HDevelop example program calibrate_hand_eye_stationary_cam_approx.hdev.</abstract>
<alternatives>
<item>get_robot_touching_point_in_tool_coordinates</item>
</alternatives>
<chapters lang="de_DE">
<item>Kalibrierung</item>
<item>Hand-Auge</item>
</chapters>
<chapters lang="en_US">
<item>Calibration</item>
<item>Hand-Eye</item>
</chapters>
<library lang="en_US">MVTec Standard Procedures</library>
<short lang="en_US">Calibrate the X, Y, Z coordinates of a touching point of a robot.</short>
<parameters>
<parameter id="DataDir">
<default_type>string</default_type>
<default_value>''</default_value>
<description lang="en_US">Directory where the camera parameters and poses are read.</description>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>string</sem_type>
<type_list>
<item>string</item>
</type_list>
</parameter>
<parameter id="RobotTouchingPointInToolCoordinates">
<default_type>real</default_type>
<description lang="en_US">The X, Y, Z coordinates of the touching point relative to the tool of the robot.</description>
<multivalue>true</multivalue>
<sem_type>coordinates</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
</parameters>
</docu>
</procedure>
<procedure name="check_dl_preprocess_param" access="local">
<interface>
<ic>
<par name="DLPreprocessParam" base_type="ctrl" dimension="0"/>
</ic>
</interface>
<body>
<c>* </c>
<c>* This procedure checks a dictionary with parameters for DL preprocessing.</c>
<c>* </c>
<l>try</l>
<l>    get_dict_tuple (DLPreprocessParam, 'model_type', DLModelType)</l>
<l>catch (Exception)</l>
<l>    throw ('DLPreprocessParam needs the parameter: \'' + 'model_type' + '\'')</l>
<l>endtry</l>
<c>* </c>
<c>* Check for correct model type.</c>
<l>SupportedModelTypes := ['anomaly_detection','classification','detection','segmentation']</l>
<l>tuple_find (SupportedModelTypes, DLModelType, Index)</l>
<l>if ((Index == -1) or (Index == []))</l>
<l>    throw ('Only models of type \'anomaly_detection\', \'classification\', \'detection\', or \'segmentation\' are supported')</l>
<l>    return ()</l>
<l>endif</l>
<c>* </c>
<c>* Parameter names that are required.</c>
<c>* General parameters.</c>
<l>ParamNamesGeneral := ['model_type','image_width','image_height','image_num_channels','image_range_min','image_range_max','normalization_type','domain_handling']</l>
<c>* Segmentation specific parameters.</c>
<l>ParamNamesSegmentation := ['ignore_class_ids','set_background_id','class_ids_background']</l>
<c>* Detection specific parameters.</c>
<l>ParamNamesDetectionOptional := ['instance_type','ignore_direction','class_ids_no_orientation']</l>
<c>* Normalization specific parameters.</c>
<l>ParamNamesPreprocessingOptional := ['mean_values_normalization','deviation_values_normalization']</l>
<c>* All parameters</c>
<l>ParamNamesAll := [ParamNamesGeneral,ParamNamesSegmentation,ParamNamesDetectionOptional,ParamNamesPreprocessingOptional]</l>
<l>ParamNames := ParamNamesGeneral</l>
<l>if (DLModelType == 'segmentation')</l>
<c>    * Extend ParamNames for models of type segmentation.</c>
<l>    ParamNames := [ParamNames,ParamNamesSegmentation]</l>
<l>endif</l>
<c>* </c>
<c>* Check if legacy parameter exist.</c>
<c>* Otherwise map it to the legal parameter.</c>
<l>replace_legacy_preprocessing_parameters (DLPreprocessParam)</l>
<c>* </c>
<c>* Check that all necessary parameters are included.</c>
<c>* </c>
<l>get_dict_param (DLPreprocessParam, 'key_exists', ParamNames, KeysExists)</l>
<l>if (sum(KeysExists [==] 0) &gt; 0)</l>
<l>    for I := 0 to |KeysExists| by 1</l>
<l>        Exists := KeysExists[I]</l>
<l>        if (not Exists)</l>
<l>            throw ('DLPreprocessParam needs the parameter: \'' + ParamNames[I] + '\'')</l>
<l>        endif</l>
<l>    endfor</l>
<l>endif</l>
<c>* </c>
<c>* Check the keys provided.</c>
<l>get_dict_param (DLPreprocessParam, 'keys', [], InputKeys)</l>
<l>for I := 0 to |InputKeys| - 1 by 1</l>
<l>    Key := InputKeys[I]</l>
<l>    get_dict_tuple (DLPreprocessParam, Key, Value)</l>
<c>    * Check that the key is known.</c>
<l>    tuple_find (ParamNamesAll, Key, Indices)</l>
<l>    if (Indices == -1)</l>
<l>        throw ('Unknown key for DLPreprocessParam: \'' + InputKeys[I] + '\'')</l>
<l>        return ()</l>
<l>    endif</l>
<c>    * Set expected values and types.</c>
<l>    ValidValues := []</l>
<l>    ValidTypes := []</l>
<l>    if (Key == 'normalization_type')</l>
<l>        ValidValues := ['all_channels','first_channel','constant_values','none']</l>
<l>    elseif (Key == 'domain_handling')</l>
<l>        if (DLModelType == 'anomaly_detection')</l>
<l>            ValidValues := ['full_domain','crop_domain','keep_domain']</l>
<l>        else</l>
<l>            ValidValues := ['full_domain','crop_domain']</l>
<l>        endif</l>
<l>    elseif (Key == 'model_type')</l>
<l>        ValidValues := ['anomaly_detection','classification','detection','segmentation']</l>
<l>    elseif (Key == 'set_background_id')</l>
<l>        ValidTypes := 'int'</l>
<l>    elseif (Key == 'class_ids_background')</l>
<l>        ValidTypes := 'int'</l>
<l>    endif</l>
<c>    * Check that type is valid.</c>
<l>    if (|ValidTypes| &gt; 0)</l>
<l>        for V := 0 to |ValidTypes| - 1 by 1</l>
<l>            T := ValidTypes[V]</l>
<l>            if (T == 'int')</l>
<l>                tuple_is_int (Value, IsInt)</l>
<l>                if (not IsInt)</l>
<l>                    ValidTypes := '\'' + ValidTypes + '\''</l>
<l>                    if (|ValidTypes| &lt; 2)</l>
<l>                        ValidTypesListing := ValidTypes</l>
<l>                    else</l>
<l>                        ValidTypesListing := sum(ValidTypes[0:max2(0,|ValidTypes| - 2)] + ', ' + ValidTypes[|ValidTypes| - 1])</l>
<l>                    endif</l>
<l>                    throw ('The value given in the key \'' + Key + '\' of DLPreprocessParam is invalid. Valid types are: ' + ValidTypesListing + '. The given value was \'' + Value + '\'.')</l>
<l>                    return ()</l>
<l>                endif</l>
<l>            else</l>
<l>                throw ('Internal error. Unknown valid type.')</l>
<l>            endif</l>
<l>        endfor</l>
<l>    endif</l>
<c>    * Check that value is valid.</c>
<l>    if (|ValidValues| &gt; 0)</l>
<l>        tuple_find_first (ValidValues, Value, Index)</l>
<l>        if (Index == -1)</l>
<l>            ValidValues := '\'' + ValidValues + '\''</l>
<l>            if (|ValidValues| &lt; 2)</l>
<l>                ValidValueListing := ValidValues</l>
<l>            else</l>
<l>                EmptyStrings := gen_tuple_const(|ValidValues| - 2,'')</l>
<l>                ValidValueListing := sum(ValidValues[0:max2(0,|ValidValues| - 2)] + ', ' + [EmptyStrings,ValidValues[|ValidValues| - 1]])</l>
<l>            endif</l>
<l>            throw ('The value given in the key \'' + Key + '\' of DLPreprocessParam is invalid. Valid values are: ' + ValidValueListing + '. The given value was \'' + Value + '\'.')</l>
<l>        endif</l>
<l>    endif</l>
<l>endfor</l>
<c>* </c>
<c>* Check the correct setting of ImageRangeMin and ImageRangeMax.</c>
<l>if (DLModelType == 'classification' or DLModelType == 'detection')</l>
<c>    * Check ImageRangeMin and ImageRangeMax.</c>
<l>    get_dict_param (DLPreprocessParam, 'key_exists', 'image_range_min', ImageRangeMinExists)</l>
<l>    get_dict_param (DLPreprocessParam, 'key_exists', 'image_range_max', ImageRangeMaxExists)</l>
<c>    * If they are present, check that they are set correctly.</c>
<l>    if (ImageRangeMinExists)</l>
<l>        get_dict_tuple (DLPreprocessParam, 'image_range_min', ImageRangeMin)</l>
<l>        if (ImageRangeMin != -127)</l>
<l>            throw ('For model type ' + DLModelType + ' ImageRangeMin has to be -127.')</l>
<l>        endif</l>
<l>    endif</l>
<l>    if (ImageRangeMaxExists)</l>
<l>        get_dict_tuple (DLPreprocessParam, 'image_range_max', ImageRangeMax)</l>
<l>        if (ImageRangeMax != 128)</l>
<l>            throw ('For model type ' + DLModelType + ' ImageRangeMax has to be 128.')</l>
<l>        endif</l>
<l>    endif</l>
<l>endif</l>
<c>* </c>
<c>* Check segmentation specific parameters.</c>
<l>if (DLModelType == 'segmentation')</l>
<c>    * Check if detection specific parameters are set.</c>
<l>    get_dict_param (DLPreprocessParam, 'key_exists', ParamNamesDetectionOptional, KeysExists)</l>
<c>    * If they are present, check that they are [].</c>
<l>    for IndexParam := 0 to |ParamNamesDetectionOptional| - 1 by 1</l>
<l>        if (KeysExists[IndexParam])</l>
<l>            get_dict_tuple (DLPreprocessParam, ParamNamesDetectionOptional[IndexParam], Value)</l>
<l>            if (Value != [])</l>
<l>                throw ('The preprocessing parameter \'' + ParamNamesDetectionOptional[IndexParam] + '\' was set to ' + Value + ' but for segmentation it should be set to [], as it is not used for this method.')</l>
<l>            endif</l>
<l>        endif</l>
<l>    endfor</l>
<c>    * Check 'set_background_id'.</c>
<l>    get_dict_tuple (DLPreprocessParam, 'set_background_id', SetBackgroundID)</l>
<l>    if (|SetBackgroundID| &gt; 1)</l>
<l>        throw ('Only one class_id as \'set_background_id\' allowed.')</l>
<l>    endif</l>
<c>    * Check 'class_ids_background'.</c>
<l>    get_dict_tuple (DLPreprocessParam, 'class_ids_background', ClassIDsBackground)</l>
<l>    if ((|SetBackgroundID| &gt; 0 and not (|ClassIDsBackground| &gt; 0)) or (|ClassIDsBackground| &gt; 0 and not (|SetBackgroundID| &gt; 0)))</l>
<l>        throw ('Both keys \'set_background_id\' and \'class_ids_background\' are required.')</l>
<l>    endif</l>
<c>    * Check that 'class_ids_background' and 'set_background_id' are disjoint.</c>
<l>    if (|SetBackgroundID| &gt; 0)</l>
<l>        tuple_intersection (SetBackgroundID, ClassIDsBackground, Intersection)</l>
<l>        if (|Intersection|)</l>
<l>            throw ('Class IDs in \'set_background_id\' and \'class_ids_background\' need to be disjoint.')</l>
<l>        endif</l>
<l>    endif</l>
<c>    * Check 'ignore_class_ids'.</c>
<l>    get_dict_tuple (DLPreprocessParam, 'ignore_class_ids', IgnoreClassIDs)</l>
<l>    KnownClasses := [SetBackgroundID,ClassIDsBackground]</l>
<l>    for I := 0 to |IgnoreClassIDs| - 1 by 1</l>
<l>        IgnoreClassID := IgnoreClassIDs[I]</l>
<l>        tuple_find_first (KnownClasses, IgnoreClassID, Index)</l>
<l>        if (|Index| &gt; 0 and Index != -1)</l>
<l>            throw ('The given \'ignore_class_ids\' must not be included in the \'class_ids_background\' or \'set_background_id\'.')</l>
<l>        endif</l>
<l>    endfor</l>
<l>elseif (DLModelType == 'detection')</l>
<c>    * Check if segmentation specific parameters are set.</c>
<l>    get_dict_param (DLPreprocessParam, 'key_exists', ParamNamesSegmentation, KeysExists)</l>
<c>    * If they are present, check that they are [].</c>
<l>    for IndexParam := 0 to |ParamNamesSegmentation| - 1 by 1</l>
<l>        if (KeysExists[IndexParam])</l>
<l>            get_dict_tuple (DLPreprocessParam, ParamNamesSegmentation[IndexParam], Value)</l>
<l>            if (Value != [])</l>
<l>                throw ('The preprocessing parameter \'' + ParamNamesSegmentation[IndexParam] + '\' was set to ' + Value + ' but for detection it should be set to [], as it is not used for this method.')</l>
<l>            endif</l>
<l>        endif</l>
<l>    endfor</l>
<c>    * Check optional parameters.</c>
<l>    get_dict_param (DLPreprocessParam, 'key_exists', ParamNamesDetectionOptional, OptionalKeysExist)</l>
<l>    if (OptionalKeysExist[0])</l>
<c>        * Check 'instance_type'.</c>
<l>        get_dict_tuple (DLPreprocessParam, ParamNamesDetectionOptional[0], InstanceType)</l>
<l>        if (find(['rectangle1','rectangle2'],InstanceType) == -1)</l>
<l>            throw ('Invalid generic parameter for \'instance_type\': ' + InstanceType + ', only \'rectangle1\' and \'rectangle2\' are allowed')</l>
<l>        endif</l>
<l>    endif</l>
<l>    get_dict_param (DLPreprocessParam, 'key_exists', ParamNamesDetectionOptional, OptionalKeysExist)</l>
<l>    if (OptionalKeysExist[1])</l>
<c>        * Check 'ignore_direction'.</c>
<l>        get_dict_tuple (DLPreprocessParam, ParamNamesDetectionOptional[1], IgnoreDirection)</l>
<l>        if (find([true,false],IgnoreDirection) == -1)</l>
<l>            throw ('Invalid generic parameter for \'ignore_direction\': ' + IgnoreDirection + ', only true and false are allowed')</l>
<l>        endif</l>
<l>    endif</l>
<l>    if (OptionalKeysExist[2])</l>
<c>        * Check 'class_ids_no_orientation'.</c>
<l>        get_dict_tuple (DLPreprocessParam, ParamNamesDetectionOptional[2], ClassIDsNoOrientation)</l>
<l>        tuple_sem_type_elem (ClassIDsNoOrientation, SemTypes)</l>
<l>        if (ClassIDsNoOrientation != [] and sum(SemTypes [==] 'integer') != |ClassIDsNoOrientation|)</l>
<l>            throw ('Invalid generic parameter for \'class_ids_no_orientation\': ' + ClassIDsNoOrientation + ', only integers are allowed')</l>
<l>        else</l>
<l>            if (ClassIDsNoOrientation != [] and sum(ClassIDsNoOrientation [&gt;=] 0) != |ClassIDsNoOrientation|)</l>
<l>                throw ('Invalid generic parameter for \'class_ids_no_orientation\': ' + ClassIDsNoOrientation + ', only non-negative integers are allowed')</l>
<l>            endif</l>
<l>        endif</l>
<l>    endif</l>
<l>endif</l>
<c>* </c>
<l>return ()</l>
</body>
<docu id="check_dl_preprocess_param">
<abstract lang="en_US">This procedure checks the content of the parameter dictionary DLPreprocessParam.
</abstract>
<chapters lang="de_DE">
<item>Deep Learning</item>
<item>Modell</item>
</chapters>
<chapters lang="en_US">
<item>Deep Learning</item>
<item>Model</item>
</chapters>
<library lang="en_US">MVTec Standard Procedures</library>
<short lang="en_US">Checks the content of the parameter dictionary DLPreprocessParam.
</short>
<parameters>
<parameter id="DLPreprocessParam">
<default_type>integer</default_type>
<description lang="en_US">Parameter dictionary to check.</description>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>dict</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
</parameters>
</docu>
</procedure>
<procedure name="check_find_box_3d_params" access="local">
<interface>
<ic>
<par name="WindowHandle" base_type="ctrl" dimension="0"/>
<par name="ObjectModel3DBox" base_type="ctrl" dimension="0"/>
<par name="ObjectModel3DScene" base_type="ctrl" dimension="0"/>
<par name="BoxInformation" base_type="ctrl" dimension="0"/>
</ic>
</interface>
<body>
<l>write_note (WindowHandle, 'none', 'Checking parameters for find_box_3d...')</l>
<l>new_line (WindowHandle)</l>
<c>* *****************************************************************</c>
<c>* Basic Parameter Checks</c>
<c>* *****************************************************************</c>
<l>get_dict_tuple (BoxInformation, 'results', BoxResultsDict)</l>
<l>get_dict_param (BoxResultsDict, 'keys', [], AllBoxResultsDictKeys)</l>
<l>NumScenePoints := 0</l>
<l>if (|ObjectModel3DBox| != |AllBoxResultsDictKeys| or |ObjectModel3DScene| != 1)</l>
<l>    write_note (WindowHandle, 'error', 'Invalid number of boxes or scenes.')</l>
<l>else</l>
<l>    for Index := 0 to |AllBoxResultsDictKeys| - 1 by 1</l>
<l>        try</l>
<l>            get_object_model_3d_params (ObjectModel3DBox[Index], 'has_xyz_mapping', SceneHasMapping)</l>
<l>            get_object_model_3d_params (ObjectModel3DBox[Index], 'num_points', NumScenePoints)</l>
<l>        catch (Exception)</l>
<l>            write_note (WindowHandle, 'error', 'Invalid box model at Index ' + Index + ' (not a valid 3D object model handle).')</l>
<l>        endtry</l>
<l>    endfor</l>
<l>    try</l>
<l>        get_object_model_3d_params (ObjectModel3DScene, 'has_xyz_mapping', SceneHasMapping)</l>
<l>        get_object_model_3d_params (ObjectModel3DScene, 'has_triangles', SceneHasTriangles)</l>
<l>        get_object_model_3d_params (ObjectModel3DScene, 'has_polygons', SceneHasPolygons)</l>
<l>        get_object_model_3d_params (ObjectModel3DScene, 'num_points', NumScenePoints)</l>
<l>    catch (Exception)</l>
<l>        write_note (WindowHandle, 'error', 'Invalid scene (not a valid 3D object model handle).')</l>
<l>    endtry</l>
<l>    write_note (WindowHandle, 'ok', 'Semantic types of parameters are OK.')</l>
<l>endif</l>
<c>* </c>
<l>try</l>
<l>    get_object_model_3d_params (ObjectModel3DScene, 'point_coord_x', PX)</l>
<l>    get_object_model_3d_params (ObjectModel3DScene, 'point_coord_y', PY)</l>
<l>    get_object_model_3d_params (ObjectModel3DScene, 'point_coord_z', PZ)</l>
<l>    get_object_model_3d_params (ObjectModel3DScene, 'bounding_box1', BBox)</l>
<l>    get_object_model_3d_params (ObjectModel3DScene, 'diameter', DiameterScene)</l>
<l>    get_object_model_3d_params (ObjectModel3DScene, 'center', CenterScene)</l>
<l>catch (Exception)</l>
<c>    * No points</c>
<l>    PX := []</l>
<l>    PY := []</l>
<l>    PZ := []</l>
<l>    BBox := [0,0,0,0,0,0]</l>
<l>    DiameterScene := 0</l>
<l>    CenterScene := [0,0,0]</l>
<l>endtry</l>
<c>* *****************************************************************</c>
<c>* Diameters</c>
<c>* *****************************************************************</c>
<l>SizesOK := true</l>
<l>get_object_model_3d_params (ObjectModel3DBox, 'diameter', DiameterModel)</l>
<c>* </c>
<l>for Index1 := 0 to |ObjectModel3DBox| - 1 by 1</l>
<l>    if (DiameterModel &gt; DiameterScene * 3)</l>
<l>        write_note (WindowHandle, 'warning', 'The diameter of model ' + Index + ' is very large (3 times the scene diameter).')</l>
<l>        SizesOK := false</l>
<l>    endif</l>
<l>    if (DiameterModel &lt; DiameterScene / 30)</l>
<l>        write_note (WindowHandle, 'warning', 'The diameter of model ' + Index + ' is very small (&lt;3% of the scene diameter).')</l>
<l>        SizesOK := false</l>
<l>    endif</l>
<l>endfor</l>
<l>if (SizesOK)</l>
<l>    write_note (WindowHandle, 'ok', 'Scene and model diameters seem to match.')</l>
<l>endif</l>
<c>* *****************************************************************</c>
<c>* Check for NaN, INF in the 3D data</c>
<c>* *****************************************************************</c>
<l>if (NumScenePoints &gt; 0)</l>
<c>    * NaNs are the only "numbers" that are not equal to themself</c>
<l>    IsNaN := (PX [!=] PX) or (PY [!=] PY) or (PZ [!=] PZ)</l>
<c>    * Inf is created by multiplying a large number a few times.</c>
<c>    * We cannot directly create it (with, for example, 1e500), since that</c>
<c>    * does not work in all language exports.</c>
<l>    LargeNum := 1e50</l>
<l>    tuple_mult (LargeNum, LargeNum, LargeNum)</l>
<l>    tuple_mult (LargeNum, LargeNum, LargeNum)</l>
<l>    tuple_mult (LargeNum, LargeNum, Inf)</l>
<l>    IsInf := (fabs(PX) [&gt;=] Inf) or (fabs(PY) [&gt;=] Inf) or (fabs(PZ) [&gt;=] Inf)</l>
<l>    if (sum(IsNaN or IsInf) &gt; 0)</l>
<l>        write_note (WindowHandle, 'warning', 'The scene contains ' + sum(IsNaN or IsInf) + ' point(s) with INF or NaN coordinates.')</l>
<l>    else</l>
<l>        write_note (WindowHandle, 'ok', 'No INF or NaN in data.')</l>
<l>    endif</l>
<l>endif</l>
<c>* *****************************************************************</c>
<c>* Check for other multiple points in the data</c>
<c>* *****************************************************************</c>
<l>get_aggregated_models_diameter (ObjectModel3DBox, ModelDiameterAggregated)</l>
<l>DistThreshold := ModelDiameterAggregated * 1e-7</l>
<l>if (NumScenePoints &gt; 0)</l>
<l>    get_object_model_3d_params (ObjectModel3DScene, 'num_neighbors_fast ' + DistThreshold, NumNeighbors)</l>
<l>    MaxNumNeighbors := max(NumNeighbors)</l>
<l>    if (MaxNumNeighbors &gt; 30)</l>
<l>        Pos := sort_index(NumNeighbors)[|NumNeighbors| - 1]</l>
<l>        write_note (WindowHandle, 'error', 'The scene point with the following coordinates seems to be duplicated around ' + MaxNumNeighbors + ' times: ' + '(' + PX[Pos] + ',' + PY[Pos] + ',' + PZ[Pos] + ').')</l>
<l>        write_note (WindowHandle, 'warning', 'Note that point duplication can generate several false positive ' + 'warnings and errors! It is recommended to first fix this problem, ' + 'then to re-run this procedure.')</l>
<l>        write_note (WindowHandle, 'warning', 'To remove duplicate points, consider reducing the domain of the XYZ images or using select_points_object_model_3d with \'num_neighbors_fast\'.')</l>
<l>        wait_continue_button (WindowHandle)</l>
<l>        return ()</l>
<l>    else</l>
<l>        write_note (WindowHandle, 'ok', 'No duplicate point(s) detected.')</l>
<l>    endif</l>
<l>endif</l>
<c>* *****************************************************************</c>
<c>* Check Mapping:</c>
<c>* </c>
<c>* Avoid duplicates in the mapping, which can happen when merging</c>
<c>* multiple scenes into one.</c>
<c>* *****************************************************************</c>
<l>if (SceneHasMapping == 'true')</l>
<l>    get_object_model_3d_params (ObjectModel3DScene, 'mapping_row', Rows)</l>
<l>    get_object_model_3d_params (ObjectModel3DScene, 'mapping_col', Cols)</l>
<l>    if (sum(Rows [&lt;] 0) &gt; 0 or sum(Cols [&lt;] 0) &gt; 0 or sum(Rows [&gt;] 100000) &gt; 0 or sum(Cols [&gt;] 1000000))</l>
<l>        write_note (WindowHandle, 'error', 'Mapping contains invalid values (smaller zero or very large).')</l>
<l>    else</l>
<c>        * Search for duplicates</c>
<l>        MappingAsString := Rows + '#' + Cols</l>
<l>        MappingAsString := union(MappingAsString,[])</l>
<l>        if (|MappingAsString| != |Rows|)</l>
<l>            write_note (WindowHandle, 'error', 'Mapping contains duplicates. Maybe two scenes were merged into one?')</l>
<l>        endif</l>
<l>    endif</l>
<l>endif</l>
<c>* *****************************************************************</c>
<c>* Scene contains a mesh?</c>
<c>* *****************************************************************</c>
<l>if (SceneHasTriangles == 'true' or SceneHasPolygons == 'true')</l>
<l>    write_note (WindowHandle, 'warning', 'Scene contains a mesh (triangles or polygons). ' + 'Meshes are ignored, and only the 3D points are used during finding boxes.')</l>
<l>else</l>
<l>    write_note (WindowHandle, 'ok', 'Scene contains no mesh (triangles or polygons).')</l>
<l>endif</l>
<c>* *****************************************************************</c>
<c>* Scene contains sparse data / points?</c>
<c>* A point is 'sparse' if it has very few neighbors</c>
<c>* *****************************************************************</c>
<l>if (NumScenePoints &gt; 0)</l>
<l>    DistThreshold := ModelDiameterAggregated * 0.05</l>
<l>    get_object_model_3d_params (ObjectModel3DScene, 'num_neighbors_fast ' + DistThreshold, NumNeighbors)</l>
<l>    NumSparsePoints := sum(MaxNumNeighbors [&lt;] 3)</l>
<l>    if (NumSparsePoints &gt; 20 or NumSparsePoints &gt; 0.05 * NumScenePoints)</l>
<l>        write_note (WindowHandle, 'warning', 'Scene contains ' + NumSparsePoints + ' isolated point(s) that are far away from the other points. ' + 'Consider removing them beforehand.')</l>
<l>    else</l>
<l>        write_note (WindowHandle, 'ok', 'Scene contains ' + NumSparsePoints + ' isolated point(s).')</l>
<l>    endif</l>
<l>endif</l>
<c>* *****************************************************************</c>
<c>* Does the scene contain a mapping?</c>
<c>* *****************************************************************</c>
<l>if (SceneHasMapping == 'false')</l>
<l>    write_note (WindowHandle, 'error', 'Scene does not contain XYZ-Mapping, which is required for ' + 'the box finder.  Create the scene with xyz_to_object_model_3d instead.')</l>
<l>else</l>
<l>    write_note (WindowHandle, 'ok', 'Scene contains XYZ-Mapping.')</l>
<l>endif</l>
<c>* *****************************************************************</c>
<c>* Is the mapping direction OK?</c>
<c>* *****************************************************************</c>
<l>object_model_3d_to_xyz (X, Y, Z, ObjectModel3DScene, 'from_xyz_map', [], [])</l>
<c>* Try to find the approximate direction in X</c>
<l>get_image_direction (X, MedianDirectionX)</l>
<l>if (sqrt(sum(MedianDirectionX * MedianDirectionX)) &gt; 1e-8)</l>
<l>    MedianDirectionXNorm := MedianDirectionX / sqrt(sum(MedianDirectionX * MedianDirectionX))</l>
<l>else</l>
<l>    MedianDirectionXNorm := [0,0]</l>
<l>endif</l>
<l>get_image_direction (Y, MedianDirectionY)</l>
<l>if (sqrt(sum(MedianDirectionY * MedianDirectionY)) &gt; 1e-8)</l>
<l>    MedianDirectionYNorm := MedianDirectionY / sqrt(sum(MedianDirectionY * MedianDirectionY))</l>
<l>else</l>
<l>    MedianDirectionYNorm := [0,0]</l>
<l>endif</l>
<c>* </c>
<l>ErrorX := MedianDirectionXNorm - [1,0]</l>
<l>ErrorY := MedianDirectionYNorm - [0,1]</l>
<c>* </c>
<l>if (sqrt(sum(ErrorX * ErrorX)) &gt; 0.2 or sqrt(sum(ErrorY * ErrorY)) &gt; 0.2)</l>
<l>    write_note (WindowHandle, 'error', 'X or Y image of scene is not aligned with coordinate axis. ' + 'This leads to incorrect edge directions and must be corrected. ' + 'The X image should have increasing coordinates from left to right, the Y image from top to bottom.')</l>
<l>else</l>
<l>    write_note (WindowHandle, 'ok', 'X- and Y-Directions of mapping seem good.')</l>
<l>endif</l>
<c>* *****************************************************************</c>
<c>* Check if the viewpoint is inside the data</c>
<c>* *****************************************************************</c>
<l>get_dict_tuple (BoxInformation, 'sampled_edges', OM3D3DEdges)</l>
<c>* Obtain the viewpoint</c>
<l>get_dict_tuple (BoxInformation, 'gen_param', GenParamDict)</l>
<l>get_dict_tuple (GenParamDict, 'viewpoint', Viewpoint)</l>
<l>ViewpointToCenter := Viewpoint - CenterScene</l>
<l>DistanceOriginRel := sqrt(sum(ViewpointToCenter * ViewpointToCenter)) / ModelDiameterAggregated</l>
<l>if (BBox[0] &lt; 0 and BBox[1] &lt; 0 and BBox[2] &lt; 0 and BBox[3] &gt; 0 and BBox[4] &gt; 0 and BBox[5] &gt; 0)</l>
<l>    write_note (WindowHandle, 'warning', 'The viewpoint is inside the scene data. This is problematic, since the edge viewing directions will probably be incorrect. The distance from scene center to the viewpoint is ~' + DistanceOriginRel$'.1f' + ' times the model diameter. ' + 'Consider moving the viewpoint origin to the original viewpoint of the sensor.')</l>
<l>else</l>
<l>    write_note (WindowHandle, 'ok', 'Viewpoint is not inside scene data. The distance from scene center to origin is ~' + DistanceOriginRel$'.1f' + ' times the model diameter. ')</l>
<l>endif</l>
<c>* *****************************************************************</c>
<c>* Check noise in Z-Direction</c>
<c>* *****************************************************************</c>
<l>if (SceneHasMapping == 'true')</l>
<l>    object_model_3d_to_xyz (X, Y, Z, ObjectModel3DScene, 'from_xyz_map', [], [])</l>
<l>    estimate_noise_real (Z, 0.05, ZSigmaAbs)</l>
<l>    ZSigmaRel := ZSigmaAbs / ModelDiameterAggregated</l>
<l>    ZSigmaPct := (ZSigmaRel * 100)$'.2' + '%'</l>
<l>    if (ZSigmaRel &gt; 0.2)</l>
<l>        write_note (WindowHandle, 'error', 'The noise in the data is very high (relative value: ' + ZSigmaPct + '). ' + 'Consider smoothing the Z-image with a median filter and using ' + 'the mls normal estimation method.')</l>
<l>    elseif (ZSigmaRel &gt; 0.1)</l>
<l>        write_note (WindowHandle, 'warning', 'The noise in the data seems rather high (relative value: ' + ZSigmaPct + '). ' + 'Consider smoothing the Z-image with a median filter and using ' + 'the mls normal estimation method.')</l>
<l>    else</l>
<l>        write_note (WindowHandle, 'ok', 'The noise in the data looks good (relative value: ' + ZSigmaPct + ').')</l>
<l>    endif</l>
<l>else</l>
<c>    * No suitable way of checking the noise (yet)</c>
<l>    write_note (WindowHandle, 'info', 'Noise was not checked (requires XYZ mapping).')</l>
<l>endif</l>
<c>* </c>
<c>* *****************************************************************</c>
<c>* DONE</c>
<c>* Wait for user to click continue</c>
<c>* *****************************************************************</c>
<l>wait_continue_button (WindowHandle)</l>
<c>* </c>
<l>return ()</l>
</body>
<docu id="check_find_box_3d_params">
<chapters lang="en_US">
<item>3D Matching</item>
<item>3D-Box</item>
</chapters>
<library lang="en_US">MVTec Standard Procedures</library>
<parameters>
<parameter id="BoxInformation">
<default_type>handle</default_type>
<description lang="en_US">Dictionary with results of the box finder.</description>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>dict</sem_type>
<type_list>
<item>handle</item>
</type_list>
</parameter>
<parameter id="ObjectModel3DBox">
<default_type>handle</default_type>
<description lang="en_US">3D object models of the found boxes.</description>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>object_model_3d</sem_type>
<type_list>
<item>handle</item>
</type_list>
</parameter>
<parameter id="ObjectModel3DScene">
<default_type>handle</default_type>
<description lang="en_US">The scene where the object is to be found, as passed to find_box_3d.</description>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>object_model_3d</sem_type>
<type_list>
<item>handle</item>
</type_list>
</parameter>
<parameter id="WindowHandle">
<default_type>integer</default_type>
<mixed_type>false</mixed_type>
<sem_type>window</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
</parameters>
</docu>
</procedure>
<procedure name="check_find_surface_model_params" access="local">
<interface>
<ic>
<par name="WindowHandle" base_type="ctrl" dimension="0"/>
<par name="SurfaceModel" base_type="ctrl" dimension="0"/>
<par name="ObjectModel3DScene" base_type="ctrl" dimension="0"/>
<par name="GenParamNames" base_type="ctrl" dimension="0"/>
<par name="GenParamValues" base_type="ctrl" dimension="0"/>
</ic>
</interface>
<body>
<l>write_note (WindowHandle, 'none', 'Checking parameters for find_surface_model[_image]...')</l>
<l>new_line (WindowHandle)</l>
<c></c>
<c>* *****************************************************************</c>
<c>* Basic Parameter Checks</c>
<c>* *****************************************************************</c>
<l>NumScenePoints := 0</l>
<l>if (|SurfaceModel| != 1 or |ObjectModel3DScene| != 1)</l>
<l>    write_note (WindowHandle, 'error', 'Invalid number of surface model or scenes')</l>
<l>else</l>
<l>    try</l>
<l>        get_surface_model_param (SurfaceModel, 'diameter', DiameterModel)</l>
<l>    catch (Exception)</l>
<l>        write_note (WindowHandle, 'error', 'Invalid surface model (nor a valid surface model handle)')</l>
<l>    endtry</l>
<l>    try</l>
<l>        get_object_model_3d_params (ObjectModel3DScene, 'num_points', NumScenePoints)</l>
<l>    catch (Exception)</l>
<l>        write_note (WindowHandle, 'error', 'Invalid scene (not a valid 3D object model handle)')</l>
<l>    endtry</l>
<l>    write_note (WindowHandle, 'ok', 'Semantic types of parameters are OK')</l>
<l>endif</l>
<c></c>
<l>if (NumScenePoints &lt; 20)</l>
<l>    write_note (WindowHandle, 'warning', 'The scene contains only ' + NumScenePoints + ' point(s). ' + 'Some tests might be disabled.')</l>
<l>else</l>
<l>    write_note (WindowHandle, 'ok', 'Number of scene points OK (Total number: ' + NumScenePoints + ')')</l>
<l>endif</l>
<c></c>
<c></c>
<l>get_object_model_3d_params (ObjectModel3DScene, 'has_triangles', HasTriangles)</l>
<l>get_object_model_3d_params (ObjectModel3DScene, 'has_polygons', HasPolygons)</l>
<l>get_object_model_3d_params (ObjectModel3DScene, 'has_xyz_mapping', HasMapping)</l>
<l>get_object_model_3d_params (ObjectModel3DScene, 'has_point_normals', HasPointNormals)</l>
<l>get_object_model_3d_params (ObjectModel3DScene, 'num_points', NumPointsScene)</l>
<l>try</l>
<l>    get_object_model_3d_params (ObjectModel3DScene, 'point_coord_x', PX)</l>
<l>    get_object_model_3d_params (ObjectModel3DScene, 'point_coord_y', PY)</l>
<l>    get_object_model_3d_params (ObjectModel3DScene, 'point_coord_z', PZ)</l>
<l>    get_object_model_3d_params (ObjectModel3DScene, 'bounding_box1', BBox)</l>
<l>    get_object_model_3d_params (ObjectModel3DScene, 'diameter', DiameterScene)</l>
<l>    get_object_model_3d_params (ObjectModel3DScene, 'center', CenterScene)</l>
<l>catch (Exception)</l>
<c>    * No points</c>
<l>    PX := []</l>
<l>    PY := []</l>
<l>    PZ := []</l>
<l>    BBox := [0,0,0,0,0,0]</l>
<l>    DiameterScene := 0</l>
<l>    CenterScene := [0,0,0]</l>
<l>endtry</l>
<c></c>
<l>get_surface_model_param (SurfaceModel, '3d_edges_trained', EdgesTrained)</l>
<l>get_surface_model_param (SurfaceModel, 'center', CenterModel)</l>
<c></c>
<l>HasCamPar := false</l>
<l>try</l>
<l>    get_surface_model_param (SurfaceModel, 'camera_parameter', CamPar)</l>
<l>    HasCamPar := true</l>
<l>catch (Exception)</l>
<l>endtry</l>
<c></c>
<l>if (HasCamPar)</l>
<l>    write_note (WindowHandle, 'warning', 'find_surface_model_images was used. Note that the parameters for image-based refinement (camera parameters, camera pose) are not checked by this version of the procedure.')</l>
<l>endif</l>
<c></c>
<c></c>
<c>* *****************************************************************</c>
<c>* Diameters</c>
<c>* *****************************************************************</c>
<l>SizesOK := true</l>
<l>get_surface_model_param (SurfaceModel, 'diameter', DiameterModel)</l>
<c></c>
<l>if (DiameterScene &lt; 0.3 * DiameterModel)</l>
<l>    write_note (WindowHandle, 'warning', 'The diameter of the scene is very small (&lt;30 % of model diameter)')</l>
<l>    SizesOK := false</l>
<l>endif</l>
<l>if (DiameterModel * 30 &lt; DiameterScene)</l>
<l>    write_note (WindowHandle, 'warning', 'The diameter of the scene is very large (more than 30 times the model diameter)')</l>
<l>    SizesOK := false</l>
<l>endif</l>
<l>if (SizesOK)</l>
<l>    write_note (WindowHandle, 'ok', 'Scene and model diameters seem to match')</l>
<l>endif</l>
<c></c>
<c></c>
<c>* *****************************************************************</c>
<c>* Check for NaN, INF in the 3D data</c>
<c>* *****************************************************************</c>
<l>if (NumScenePoints &gt; 0)</l>
<c>    * NaNs are the only "numbers" that are not equal to themself</c>
<l>    IsNaN := (PX [!=] PX) or (PY [!=] PY) or (PZ [!=] PZ)</l>
<c>    * Inf is created by multiplying a large number a few times.</c>
<c>    * We cannot directly create it (with, for example, 1e500), since that</c>
<c>    * does not work in all language exports.</c>
<l>    LargeNum := 1e50</l>
<l>    tuple_mult (LargeNum, LargeNum, LargeNum)</l>
<l>    tuple_mult (LargeNum, LargeNum, LargeNum)</l>
<l>    tuple_mult (LargeNum, LargeNum, Inf)</l>
<l>    IsInf := (fabs(PX) [&gt;=] Inf) or (fabs(PY) [&gt;=] Inf) or (fabs(PZ) [&gt;=] Inf)</l>
<l>    if (sum(IsNaN or IsInf) &gt; 0)</l>
<l>        write_note (WindowHandle, 'warning', 'The scene contains ' + sum(IsNaN or IsInf) + ' point(s) with INF or NaN coordinates')</l>
<l>    else</l>
<l>        write_note (WindowHandle, 'ok', 'No INF or NaN in data')</l>
<l>    endif</l>
<l>endif</l>
<c></c>
<c></c>
<c>* *****************************************************************</c>
<c>* Check for other multiple points in the data</c>
<c>* *****************************************************************</c>
<l>DistThreshold := DiameterModel * 1e-7</l>
<l>if (NumScenePoints &gt; 0)</l>
<l>    get_object_model_3d_params (ObjectModel3DScene, 'num_neighbors_fast ' + DistThreshold, NumNeighbors)</l>
<l>    MaxNumNeighbors := max(NumNeighbors)</l>
<l>    if (MaxNumNeighbors &gt; 30)</l>
<l>        Pos := sort_index(NumNeighbors)[|NumNeighbors| - 1]</l>
<l>        write_note (WindowHandle, 'error', 'The scene point with the following coordinates seems to be duplicated around ' + MaxNumNeighbors + ' times: ' + '(' + PX[Pos] + ',' + PY[Pos] + ',' + PZ[Pos] + ')')</l>
<l>        write_note (WindowHandle, 'warning', 'Note that point duplication can generate several false positive ' + 'warnings and errors! It is recommended to first fix this problem, ' + 'then to re-run this procedure')</l>
<l>        write_note (WindowHandle, 'warning', 'To remove duplicate points, consider reducing the domain of the XYZ images or using select_points_object_model_3d with \'num_neighbors_fast\'')</l>
<l>        wait_continue_button (WindowHandle)</l>
<l>        return ()</l>
<l>    else</l>
<l>        write_note (WindowHandle, 'ok', 'No duplicate point(s) detected')</l>
<l>    endif</l>
<l>endif</l>
<c></c>
<c></c>
<c></c>
<c>* *****************************************************************</c>
<c>* Density of scene points</c>
<c>* *****************************************************************</c>
<c>* Compute the approximate scene point density</c>
<c>* ATTENTION: If a point is contained multiple times in the scene,</c>
<c>*            the density can be reported to be very high</c>
<l>if (NumScenePoints &gt; 0)</l>
<l>    DistThreshold := DiameterModel * 0.05</l>
<l>    get_object_model_3d_params (ObjectModel3DScene, 'num_neighbors_fast ' + DistThreshold, NumNeighbors)</l>
<l>    MedianDensity := median(NumNeighbors * 1.0)</l>
<c></c>
<l>    if (MedianDensity &lt;= 1)</l>
<l>        write_note (WindowHandle, 'warning', 'The point density in the scene seems low')</l>
<l>    elseif (MedianDensity &gt; 350)</l>
<l>        write_note (WindowHandle, 'warning', 'The point density in the scene seems very high. ' + 'This is not necessarily a problem if the sensor has a ' + 'very high resolution')</l>
<l>    else</l>
<l>        write_note (WindowHandle, 'ok', 'The point density in the scene looks good')</l>
<l>    endif</l>
<l>endif</l>
<c></c>
<c>* *****************************************************************</c>
<c>* Check for Scene Normals</c>
<c>* </c>
<c>* Normals can come from:</c>
<c>* - Precomputed normal vectors (for example with surface_normals_object_model_3d)</c>
<c>* - A XYZ-Mapping, used to compute the normals</c>
<c>* - Setting 'scene_normal_computation' to 'mls', which is identical to using</c>
<c>*   surface_normals_object_model_3d, but faster</c>
<c>* *****************************************************************</c>
<l>NormalsGood := false</l>
<l>MLSNormals := false</l>
<l>NormalPos := find(GenParamNames,'scene_normal_computation')</l>
<l>if (NormalPos != -1 and NormalPos != [])</l>
<l>    MLSNormals := GenParamValues[NormalPos] == 'mls'</l>
<l>endif</l>
<c></c>
<l>CheckNormals := false</l>
<l>if (MLSNormals == 'true')</l>
<l>    write_note (WindowHandle, 'ok', 'Normals computed with MLS method')</l>
<l>elseif (HasPointNormals == 'true')</l>
<l>    write_note (WindowHandle, 'ok', 'Scene contains normals vectors')</l>
<l>    CheckNormals := true</l>
<l>elseif (HasMapping == 'true')</l>
<l>    write_note (WindowHandle, 'ok', 'Scene contains XYZ-Mapping, used for normal computation')</l>
<l>else</l>
<l>    write_note (WindowHandle, 'error', 'No suitable way for computing the scene normals found (no XYZ mapping and no precomputed normals found). ' + 'Please see the documentation of find_surface_model.')</l>
<l>endif</l>
<c></c>
<c></c>
<c>* *****************************************************************</c>
<c>* Check Normal Correctness</c>
<c>* *****************************************************************</c>
<l>if (CheckNormals)</l>
<l>    get_object_model_3d_params (ObjectModel3DScene, 'point_normal_x', NX)</l>
<l>    get_object_model_3d_params (ObjectModel3DScene, 'point_normal_y', NY)</l>
<l>    get_object_model_3d_params (ObjectModel3DScene, 'point_normal_z', NZ)</l>
<c></c>
<l>    Length := sqrt(NX * NX + NY * NY + NZ * NZ)</l>
<l>    LengthOne := sum(fabs(Length - 1) [&lt;] 0.05)</l>
<l>    LengthNotOne := |Length| - LengthOne</l>
<l>    if (LengthNotOne &gt; |Length| * 0.05 or LengthNotOne &gt; 10)</l>
<l>        write_note (WindowHandle, 'error', 'Scene normals do not have length 1. ' + '(' + LengthOne + ' have length ~ 1, ' + LengthNotOne + ' have not.)')</l>
<l>    else</l>
<l>        write_note (WindowHandle, 'ok', 'Scene normals have length 1. ' + '(' + LengthOne + ' have length ~ 1, ' + LengthNotOne + ' have not.)')</l>
<l>    endif</l>
<l>endif</l>
<c></c>
<c></c>
<c>* *****************************************************************</c>
<c>* Check Mapping</c>
<c>* </c>
<c>* Avoid duplicates in the mapping, which can happen when merging</c>
<c>* multiple scenes into one.</c>
<c>* *****************************************************************</c>
<l>if (HasMapping == 'true')</l>
<l>    get_object_model_3d_params (ObjectModel3DScene, 'mapping_row', Rows)</l>
<l>    get_object_model_3d_params (ObjectModel3DScene, 'mapping_col', Cols)</l>
<l>    if (sum(Rows [&lt;] 0) &gt; 0 or sum(Cols [&lt;] 0) &gt; 0 or sum(Rows [&gt;] 100000) &gt; 0 or sum(Cols [&gt;] 1000000))</l>
<l>        write_note (WindowHandle, 'error', 'Mapping contains invalid values (smaller zero or very large)')</l>
<l>    else</l>
<c>        * Search for duplicates</c>
<l>        MappingAsString := Rows + '#' + Cols</l>
<l>        MappingAsString := union(MappingAsString,[])</l>
<l>        if (|MappingAsString| != |Rows|)</l>
<l>            write_note (WindowHandle, 'error', 'Mapping contains duplicates. Maybe two scenes were merged into one?')</l>
<l>        endif</l>
<l>    endif</l>
<l>endif</l>
<c></c>
<c></c>
<c>* *****************************************************************</c>
<c>* Model Center</c>
<c>* The model center should not be too far away from the origin.</c>
<c>* Otherwise, numerical issues might worsen the result.</c>
<c>* *****************************************************************</c>
<l>CenterFromOrigin := sqrt(sum(CenterModel * CenterModel))</l>
<l>CenterToDiameter := CenterFromOrigin / DiameterModel</l>
<l>if (CenterToDiameter &gt; 10)</l>
<l>    write_note (WindowHandle, 'warning', 'The model center is far away from the origin (more than ' + CenterToDiameter$'.0' + ' times the diameter).')</l>
<l>else</l>
<l>    write_note (WindowHandle, 'ok', 'Model center is close to origin')</l>
<l>endif</l>
<c></c>
<c></c>
<c>* *****************************************************************</c>
<c>* Scene contains a mesh?</c>
<c>* *****************************************************************</c>
<l>if (HasTriangles == 'true' or HasPolygons == 'true')</l>
<l>    write_note (WindowHandle, 'warning', 'Scene contains a mesh (triangles or polygons). ' + 'Meshes are ignored, and only the 3D points are used during matching')</l>
<l>else</l>
<l>    write_note (WindowHandle, 'ok', 'Scene contains no mesh (triangles or polygons)')</l>
<l>endif</l>
<c></c>
<c></c>
<c>* *****************************************************************</c>
<c>* Scene contains sparse data / points?</c>
<c>* A point is 'sparse' if it has very few neighbors</c>
<c>* *****************************************************************</c>
<l>if (NumScenePoints &gt; 0)</l>
<l>    DistThreshold := DiameterModel * 0.05</l>
<l>    get_object_model_3d_params (ObjectModel3DScene, 'num_neighbors_fast ' + DistThreshold, NumNeighbors)</l>
<l>    NumSparsePoints := sum(MaxNumNeighbors [&lt;] 3)</l>
<l>    if (NumSparsePoints &gt; 20 or NumSparsePoints &gt; 0.05 * NumScenePoints)</l>
<l>        write_note (WindowHandle, 'warning', 'Scene contains ' + NumSparsePoints + ' isolated point(s) that are far away from the other points. ' + 'Consider removing them beforehand.')</l>
<l>    else</l>
<l>        write_note (WindowHandle, 'ok', 'Scene contains ' + NumSparsePoints + ' isolated point(s).')</l>
<l>    endif</l>
<l>endif</l>
<c></c>
<c>* *****************************************************************</c>
<c>* For edge-based matching, does the scene contain a mapping?</c>
<c>* *****************************************************************</c>
<l>if (EdgesTrained == 'false')</l>
<l>    write_note (WindowHandle, 'info', 'Surface model was not created for edge-supported matching, ' + 'skipping corresponding checks.')</l>
<l>else</l>
<l>    write_note (WindowHandle, 'info', 'Surface model was created for edge-supported matching')</l>
<l>endif</l>
<c></c>
<l>if (EdgesTrained == 'true')</l>
<l>    if (HasMapping == 'false')</l>
<l>        write_note (WindowHandle, 'error', 'Scene does not contain XYZ-Mapping, which is required for ' + 'edge-supported matching.  Create the scene with xyz_to_object_model_3d instead.')</l>
<l>    else</l>
<l>        write_note (WindowHandle, 'ok', 'Scene contains XYZ-Mapping')</l>
<l>    endif</l>
<l>endif</l>
<c></c>
<c></c>
<c>* *****************************************************************</c>
<c>* For edge-based matching, is the mapping direction OK?</c>
<c>* *****************************************************************</c>
<l>if (EdgesTrained == 'true' and HasMapping == 'true')</l>
<l>    object_model_3d_to_xyz (X, Y, Z, ObjectModel3DScene, 'from_xyz_map', [], [])</l>
<c>    * Try to find the approximate direction in X</c>
<l>    get_image_direction (X, MedianDirectionX)</l>
<l>    if (sqrt(sum(MedianDirectionX * MedianDirectionX)) &gt; 1e-8)</l>
<l>        MedianDirectionXNorm := MedianDirectionX / sqrt(sum(MedianDirectionX * MedianDirectionX))</l>
<l>    else</l>
<l>        MedianDirectionXNorm := [0,0]</l>
<l>    endif</l>
<l>    get_image_direction (Y, MedianDirectionY)</l>
<l>    if (sqrt(sum(MedianDirectionY * MedianDirectionY)) &gt; 1e-8)</l>
<l>        MedianDirectionYNorm := MedianDirectionY / sqrt(sum(MedianDirectionY * MedianDirectionY))</l>
<l>    else</l>
<l>        MedianDirectionYNorm := [0,0]</l>
<l>    endif</l>
<c></c>
<l>    ErrorX := MedianDirectionXNorm - [1,0]</l>
<l>    ErrorY := MedianDirectionYNorm - [0,1]</l>
<c></c>
<l>    if (sqrt(sum(ErrorX * ErrorX)) &gt; 0.2 or sqrt(sum(ErrorY * ErrorY)) &gt; 0.2)</l>
<l>        write_note (WindowHandle, 'error', 'X or Y image of scene is not aligned with coordinate axis. ' + 'This leads to incorrect edge directions and must be corrected. ' + 'The X image should have increasing coordinates from left to right, the Y image from top to bottom.')</l>
<l>    else</l>
<l>        write_note (WindowHandle, 'ok', 'X- and Y-Directions of mapping seem good')</l>
<l>    endif</l>
<l>endif</l>
<c></c>
<c></c>
<c></c>
<c></c>
<c>* *****************************************************************</c>
<c>* Check if the origin is inside the data AND we would compute</c>
<c>* the normals from the mapping</c>
<c>* *****************************************************************</c>
<l>if (HasPointNormals == 'false' and HasMapping == 'true')</l>
<l>    DistanceOriginRel := sqrt(sum(CenterScene * CenterScene)) / DiameterModel</l>
<l>    if (BBox[0] &lt; 0 and BBox[1] &lt; 0 and BBox[2] &lt; 0 and BBox[3] &gt; 0 and BBox[4] &gt; 0 and BBox[5] &gt; 0)</l>
<l>        write_note (WindowHandle, 'warning', 'The scene origin is inside the scene data. This is problematic, since normals ' + 'are computed from the mapping and oriented towards the origin. ' + 'The distance from scene center to origin is ~' + DistanceOriginRel$'.1f' + ' times the model diameter. ' + 'Consider moving the scene origin to the original viewpoint of the sensor.')</l>
<l>    else</l>
<l>        write_note (WindowHandle, 'ok', 'Origin is not inside scene data. The distance from scene center to origin is ~' + DistanceOriginRel$'.1f' + ' times the model diameter. ')</l>
<l>    endif</l>
<l>endif</l>
<c></c>
<c></c>
<c>* *****************************************************************</c>
<c>* Check if the viewpoint is inside the data AND we compute edges internally</c>
<c>* *****************************************************************</c>
<l>get_find_parameter (GenParamNames, GenParamValues, '3d_edges', [], OM3D3DEdges)</l>
<l>if (EdgesTrained == 'true' and OM3D3DEdges == [])</l>
<c>    * Obtain the viewpoint</c>
<l>    get_find_parameter (GenParamNames, GenParamValues, 'viewpoint', '0 0 0', ViewpointString)</l>
<l>    Viewpoint := number(split(ViewpointString,' '))</l>
<l>    ViewpointToCenter := Viewpoint - CenterScene</l>
<l>    DistanceOriginRel := sqrt(sum(ViewpointToCenter * ViewpointToCenter)) / DiameterModel</l>
<l>    if (BBox[0] &lt; 0 and BBox[1] &lt; 0 and BBox[2] &lt; 0 and BBox[3] &gt; 0 and BBox[4] &gt; 0 and BBox[5] &gt; 0)</l>
<l>        write_note (WindowHandle, 'warning', 'The viewpoint is inside the scene data. This is problematic, since the edge viewing directions will probably be incorrect. The distance from scene center to the viewpoint is ~' + DistanceOriginRel$'.1f' + ' times the model diameter. ' + 'Consider moving the viewpoint origin to the original viewpoint of the sensor.')</l>
<l>    else</l>
<l>        write_note (WindowHandle, 'ok', 'Viewpoint is not inside scene data. The distance from scene center to origin is ~' + DistanceOriginRel$'.1f' + ' times the model diameter. ')</l>
<l>    endif</l>
<l>endif</l>
<c></c>
<c></c>
<c>* *****************************************************************</c>
<c>* Check noise in Z-Direction</c>
<c>* *****************************************************************</c>
<l>if (HasMapping == 'true')</l>
<l>    object_model_3d_to_xyz (X, Y, Z, ObjectModel3DScene, 'from_xyz_map', [], [])</l>
<l>    estimate_noise_real (Z, 0.05, ZSigmaAbs)</l>
<l>    ZSigmaRel := ZSigmaAbs / DiameterModel</l>
<l>    ZSigmaPct := (ZSigmaRel * 100)$'.2' + '%'</l>
<l>    if (ZSigmaRel &gt; 0.2)</l>
<l>        write_note (WindowHandle, 'error', 'The noise in the data is very high (relative value: ' + ZSigmaPct + '). ' + 'Consider smoothing the Z-image with a median filter and using ' + 'the mls normal estimation method.')</l>
<l>    elseif (ZSigmaRel &gt; 0.1)</l>
<l>        write_note (WindowHandle, 'warning', 'The noise in the data seems rather high (relative value: ' + ZSigmaPct + '). ' + 'Consider smoothing the Z-image with a median filter and using ' + 'the mls normal estimation method.')</l>
<l>    else</l>
<l>        write_note (WindowHandle, 'ok', 'The noise in the data looks good (relative value: ' + ZSigmaPct + ')')</l>
<l>    endif</l>
<l>else</l>
<c>    * No suitable way of checking the noise (yet)</c>
<l>    write_note (WindowHandle, 'info', 'Noise was not checked (requires XYZ mapping)')</l>
<l>endif</l>
<c></c>
<c>* *****************************************************************</c>
<c>* DONE</c>
<c>* Wait for user to click continue</c>
<c>* *****************************************************************</c>
<l>wait_continue_button (WindowHandle)</l>
<c></c>
<l>return ()</l>
<c></c>
</body>
<docu id="check_find_surface_model_params">
<chapters lang="en_US">
<item>3D Matching</item>
<item>Surface-Based</item>
</chapters>
<library lang="en_US">MVTec Standard Procedures</library>
<parameters>
<parameter id="GenParamNames"/>
<parameter id="GenParamValues"/>
<parameter id="ObjectModel3DScene">
<default_type>integer</default_type>
<mixed_type>false</mixed_type>
<sem_type>object_model_3d</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="SurfaceModel">
<default_type>integer</default_type>
<mixed_type>false</mixed_type>
<sem_type>surface_model</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="WindowHandle">
<default_type>integer</default_type>
<mixed_type>false</mixed_type>
<sem_type>window</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
</parameters>
</docu>
</procedure>
<procedure name="check_hand_eye_calibration_input_poses">
<interface>
<ic>
<par name="CalibDataID" base_type="ctrl" dimension="0"/>
<par name="RotationTolerance" base_type="ctrl" dimension="0"/>
<par name="TranslationTolerance" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="Warnings" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c>* This procedure checks the hand-eye calibration input poses that are stored in</c>
<c>* the calibration data model CalibDataID for consistency.</c>
<c>* </c>
<c>* For this check, it is necessary to know the accuracy of the input poses.</c>
<c>* Therefore, the RotationTolerance and TranslationTolerance must be</c>
<c>* specified that approximately describe the error in the rotation and in the</c>
<c>* translation part of the input poses, respectively. The rotation tolerance must</c>
<c>* be passed in RotationTolerance in radians. The translation tolerance must be</c>
<c>* passed in TranslationTolerance in the same unit in which the input poses were</c>
<c>* given, i.e., typically in meters. Therefore, the more accurate the</c>
<c>* input poses are, the lower the values for RotationTolerance and</c>
<c>* TranslationTolerance should be chosen. If the accuracy of the robot's tool</c>
<c>* poses is different from the accuracy of the calibration object poses, the</c>
<c>* tolerance values of the poses with the lower accuracy (i.e., the higher</c>
<c>* tolerance values) should be passed.</c>
<c>* </c>
<c>* Typically, check_hand_eye_calibration_input_poses is called after all</c>
<c>* calibration poses have been set in the calibration data model and before the</c>
<c>* hand eye calibration is performed. The procedure checks all pairs of robot</c>
<c>* tool poses and compares them to the corresponding pair of calibration object</c>
<c>* poses. For each inconsistent pose pair, a string is returned in Warnings that</c>
<c>* indicates the inconsistent pose pair. For larger values for RotationTolerance</c>
<c>* or TranslationTolerance, i.e., for less accurate input poses, fewer warnings</c>
<c>* will be generated because the check is more tolerant, and vice versa. The</c>
<c>* procedure is also helpful if the errors that are returned by the hand-eye</c>
<c>* calibration are larger than expected to identify potentially erroneous poses.</c>
<c>* Note that it is not possible to check the consistency of a single pose but</c>
<c>* only of pose pairs. Nevertheless, if a certain pose occurs multiple times in</c>
<c>* different warning messages, it is likely that the pose is erroneous.</c>
<c>* Erroneous poses that result in inconsistent pose pairs should removed</c>
<c>* from the calibration data model by using remove_calib_data_observ and</c>
<c>* remove_calib_data before performing the hand-eye calibration.</c>
<c>* </c>
<c>* check_hand_eye_calibration_input_poses also checks whether enough calibration</c>
<c>* pose pairs are passed with a significant relative rotation angle, which</c>
<c>* is necessary for a robust hand-eye calibration.</c>
<c>* </c>
<c>* check_hand_eye_calibration_input_poses also verifies that the correct</c>
<c>* calibration model was chosen in create_calib_data. If a model of type</c>
<c>* 'hand_eye_stationary_cam' or 'hand_eye_moving_cam' was chosen, the calibration</c>
<c>* of an articulated robot is assumed. For 'hand_eye_scara_stationary_cam' or</c>
<c>* 'hand_eye_scara_moving_cam', the calibration of a SCARA robot is assumed.</c>
<c>* Therefore, if all input poses for an articulated robot are parallel or if some</c>
<c>* robot poses for a SCARA robot are tilted, a corresponding message is returned</c>
<c>* in Warnings. Furthermore, if the number of tilted input poses for articulated</c>
<c>* robots is below a certain value, a corresponding message in Warnings indicates</c>
<c>* that the accuracy of the result of the hand-eye calibration might be low.</c>
<c>* </c>
<c>* If no problems have been detected in the input poses, an empty tuple is</c>
<c>* returned in Warnings.</c>
<c>* </c>
<c>* </c>
<c>* Define the minimum fraction of pose pairs with a rotation angle exceeding</c>
<c>* 2*RotationTolerance.</c>
<l>MinLargeRotationFraction := 0.1</l>
<c>* Define the minimum fraction of screw axes pairs with an angle exceeding</c>
<c>* 2*RotationTolerance for articulated robots.</c>
<l>MinLargeAnglesFraction := 0.1</l>
<c>* Factor that is used to multiply the standard deviations to obtain an error</c>
<c>* threshold.</c>
<l>StdDevFactor := 3.0</l>
<c>* </c>
<c>* Check input control parameters.</c>
<l>if (|CalibDataID| != 1)</l>
<l>    throw ('Wrong number of values of control parameter: 1')</l>
<l>endif</l>
<l>if (|RotationTolerance| != 1)</l>
<l>    throw ('Wrong number of values of control parameter: 2')</l>
<l>endif</l>
<l>if (|TranslationTolerance| != 1)</l>
<l>    throw ('Wrong number of values of control parameter: 3')</l>
<l>endif</l>
<l>try</l>
<l>    get_calib_data (CalibDataID, 'model', 'general', 'type', Type)</l>
<l>catch (Exception)</l>
<l>    throw ('Wrong value of control parameter: 1')</l>
<l>endtry</l>
<l>if (RotationTolerance &lt; 0)</l>
<l>    throw ('Wrong value of control parameter: 2')</l>
<l>endif</l>
<l>if (TranslationTolerance &lt; 0)</l>
<l>    throw ('Wrong value of control parameter: 3')</l>
<l>endif</l>
<c>* </c>
<c>* Read out the calibration data model.</c>
<l>IsHandEyeScara := Type == 'hand_eye_scara_stationary_cam' or Type == 'hand_eye_scara_moving_cam'</l>
<l>IsHandEyeArticulated := Type == 'hand_eye_stationary_cam' or Type == 'hand_eye_moving_cam'</l>
<c>* This procedure only works for hand-eye calibration applications.</c>
<l>if (not IsHandEyeScara and not IsHandEyeArticulated)</l>
<l>    throw ('check_hand_eye_calibration_input_poses only works for hand-eye calibrations')</l>
<l>endif</l>
<l>get_calib_data (CalibDataID, 'model', 'general', 'num_cameras', NumCameras)</l>
<l>get_calib_data (CalibDataID, 'model', 'general', 'num_calib_objs', NumCalibObjs)</l>
<c>* </c>
<c>* Get all valid calibration pose indices.</c>
<l>query_calib_data_observ_indices (CalibDataID, 'camera', 0, I1, PosesIdx)</l>
<l>RefCalibDataID := CalibDataID</l>
<l>UseTemporaryCopy := false</l>
<c>* If necessary, calibrate the interior camera parameters.</c>
<l>if (IsHandEyeArticulated)</l>
<c>    * For articulated (non-SCARA) robots, we have to check whether the camera</c>
<c>    * is already calibrated. Otherwise, the queried poses might not be very</c>
<c>    * accurate.</c>
<l>    try</l>
<l>        get_calib_data (CalibDataID, 'calib_obj_pose', [0,PosesIdx[0]], 'pose', CamPoseCal)</l>
<l>    catch (Exception)</l>
<l>        if (NumCameras != 0 and NumCalibObjs != 0)</l>
<c>            * If the interior camera parameters are not calibrated yet, perform</c>
<c>            * the camera calibration by using a temporary copy of the calibration</c>
<c>            * data model.</c>
<l>            serialize_calib_data (CalibDataID, SerializedItemHandle)</l>
<l>            deserialize_calib_data (SerializedItemHandle, TmpCalibDataID)</l>
<l>            clear_serialized_item (SerializedItemHandle)</l>
<l>            RefCalibDataID := TmpCalibDataID</l>
<l>            UseTemporaryCopy := true</l>
<l>            calibrate_cameras (TmpCalibDataID, Error)</l>
<l>        endif</l>
<l>    endtry</l>
<l>endif</l>
<c>* Query all robot tool and calibration object poses.</c>
<l>for Index := 0 to |PosesIdx| - 1 by 1</l>
<l>    try</l>
<c>        * For an articulated robot with a camera and a calibration object,</c>
<c>        * a calibrated poses should always be available.</c>
<l>        get_calib_data (RefCalibDataID, 'calib_obj_pose', [0,PosesIdx[Index]], 'pose', CamPoseCal)</l>
<l>    catch (Exception)</l>
<c>        * For a SCARA robot or for an articulated robots with a general</c>
<c>        * sensor and no calibration object, directly use the observed poses.</c>
<l>        get_calib_data_observ_pose (RefCalibDataID, 0, 0, PosesIdx[Index], CamPoseCal)</l>
<l>    endtry</l>
<c>    * Transform the calibration object poses to dual quaternions.</c>
<l>    pose_to_dual_quat (CamPoseCal, CamDualQuatCal)</l>
<l>    CamDualQuatsCal.at(Index) := CamDualQuatCal</l>
<c>    * Transform the robot tool pose to dual quaternions.</c>
<l>    get_calib_data (RefCalibDataID, 'tool', PosesIdx[Index], 'tool_in_base_pose', BasePoseTool)</l>
<l>    pose_to_dual_quat (BasePoseTool, BaseDualQuatTool)</l>
<l>    BaseDualQuatsTool.at(Index) := BaseDualQuatTool</l>
<l>endfor</l>
<l>NumCalibrationPoses := |PosesIdx|</l>
<l>if (UseTemporaryCopy)</l>
<l>    clear_calib_data (TmpCalibDataID)</l>
<l>endif</l>
<c>* </c>
<c>* In the first test, check the poses for consistency. The principle of</c>
<c>* the hand-eye calibration is that the movement of the robot from time</c>
<c>* i to time j is represented by the relative pose of the calibration</c>
<c>* object from i to j in the camera coordinate system and also by the</c>
<c>* relative pose of the robot tool from i to j in the robot base</c>
<c>* coordinate system. Because both relative poses represent the same 3D</c>
<c>* rigid transformation, but only seen from two different coordinate</c>
<c>* systems, their screw axes differ but their screw angle and their</c>
<c>* screw translation should be identical. This knowledge can be used to</c>
<c>* check the consistency of the input poses. Furthermore, remember the</c>
<c>* screw axes for all robot movements to later check whether the</c>
<c>* correct calibration model (SCARA or articulated) was selected by the</c>
<c>* user.</c>
<l>Warnings := []</l>
<l>LX2s := []</l>
<l>LY2s := []</l>
<l>LZ2s := []</l>
<l>TranslationToleranceSquared := TranslationTolerance * TranslationTolerance</l>
<l>RotationToleranceSquared := RotationTolerance * RotationTolerance</l>
<l>for Index1 := 0 to NumCalibrationPoses - 2 by 1</l>
<l>    CamDualQuatCal1 := CamDualQuatsCal.at(Index1)</l>
<l>    dual_quat_conjugate (CamDualQuatCal1, Cal1DualQuatCam)</l>
<l>    BaseDualQuatTool1 := BaseDualQuatsTool.at(Index1)</l>
<l>    dual_quat_conjugate (BaseDualQuatTool1, Tool1DualQuatBase)</l>
<l>    for Index2 := Index1 + 1 to NumCalibrationPoses - 1 by 1</l>
<c>        * For two robot poses, ...</c>
<c>        * ... compute the movement of the calibration object in the</c>
<c>        * camera coordinate system.</c>
<l>        CamDualQuatCal2 := CamDualQuatsCal.at(Index2)</l>
<l>        dual_quat_compose (Cal1DualQuatCam, CamDualQuatCal2, DualQuat1)</l>
<c>        * </c>
<c>        * ... compute the movement of the tool in the robot base</c>
<c>        * coordinate system.</c>
<l>        BaseDualQuatTool2 := BaseDualQuatsTool.at(Index2)</l>
<l>        dual_quat_compose (Tool1DualQuatBase, BaseDualQuatTool2, DualQuat2)</l>
<c>        * </c>
<c>        * Check whether the two movements are consistent. If the two</c>
<c>        * movements are consistent, the scalar parts of the corresponding</c>
<c>        * dual quaternions should be equal. For the equality check, we</c>
<c>        * have to take the accuracy of the input poses into account, which</c>
<c>        * are given by RotationTolerance and TranslationTolerance.</c>
<l>        dual_quat_to_screw (DualQuat1, 'moment', LX1, LY1, LZ1, MX1, MY1, MZ1, Rot1, Trans1)</l>
<l>        dual_quat_to_screw (DualQuat2, 'moment', LX2, LY2, LZ2, MX2, MY2, MZ2, Rot2, Trans2)</l>
<l>        while (Rot1 &gt; rad(180.0))</l>
<l>            Rot1 := Rot1 - rad(360.0)</l>
<l>        endwhile</l>
<l>        while (Rot2 &gt; rad(180.0))</l>
<l>            Rot2 := Rot2 - rad(360.0)</l>
<l>        endwhile</l>
<c>        * </c>
<l>        Rot1 := fabs(Rot1)</l>
<l>        Trans1 := fabs(Trans1)</l>
<l>        Rot2 := fabs(Rot2)</l>
<l>        Trans2 := fabs(Trans2)</l>
<l>        MeanRot := 0.5 * (Rot1 + Rot2)</l>
<l>        MeanTrans := 0.5 * (Trans1 + Trans2)</l>
<l>        SinTheta2 := sin(0.5 * MeanRot)</l>
<l>        CosTheta2 := cos(0.5 * MeanRot)</l>
<l>        SinTheta2Squared := SinTheta2 * SinTheta2</l>
<l>        CosTheta2Squared := CosTheta2 * CosTheta2</l>
<c>        * </c>
<c>        * 1. Check the scalar part of the real part of the dual quaternion,</c>
<c>        * which encodes the rotation component of the screw:</c>
<c>        *   q[0] = cos(theta/2)</c>
<c>        * Here, theta is the screw rotation angle.</c>
<l>        ErrorRot := fabs(Rot1 - Rot2)</l>
<l>        while (ErrorRot &gt; rad(180.0))</l>
<l>            ErrorRot := ErrorRot - rad(360.0)</l>
<l>        endwhile</l>
<l>        ErrorRot := fabs(ErrorRot)</l>
<c>        * Compute the standard deviation of the scalar part of the real part</c>
<c>        * by applying the law of error propagation.</c>
<l>        StdDevQ0 := 0.5 * SinTheta2 * RotationTolerance</l>
<c>        * Multiply the standard deviation by a factor to increase the certainty.</c>
<l>        ToleranceDualQuat0 := StdDevFactor * StdDevQ0</l>
<l>        ErrorDualQuat0 := fabs(fabs(DualQuat2[0]) - fabs(DualQuat1[0]))</l>
<c>        * </c>
<c>        * 2. Check the scalar part of the dual part of the dual quaternion,</c>
<c>        * which encodes translation and rotation components of the screw:</c>
<c>        *   q[4] = -d/2*sin(theta/2)</c>
<c>        * Here, d is the screw translation.</c>
<c>        * </c>
<c>        * Compute the standard deviation of the scalar part of the dual part</c>
<c>        * by applying the law of error propagation.</c>
<l>        StdDevQ4 := sqrt(0.25 * SinTheta2Squared * TranslationToleranceSquared + 0.0625 * MeanTrans * MeanTrans * CosTheta2Squared * RotationToleranceSquared)</l>
<c>        * Multiply the standard deviation by a factor to increase the certainty.</c>
<l>        ToleranceDualQuat4 := StdDevFactor * StdDevQ4</l>
<l>        ErrorDualQuat4 := fabs(fabs(DualQuat2[4]) - fabs(DualQuat1[4]))</l>
<c>        * If one of the two errors exceeds the computed thresholds, return</c>
<c>        * a warning for the current pose pair.</c>
<l>        if (ErrorDualQuat0 &gt; ToleranceDualQuat0 or ErrorDualQuat4 &gt; ToleranceDualQuat4)</l>
<l>            Message := 'Inconsistent pose pair (' + PosesIdx[Index1]$'2d' + ',' + PosesIdx[Index2]$'2d' + ')'</l>
<l>            Warnings := [Warnings,Message]</l>
<l>        endif</l>
<c>        * </c>
<c>        * Remember the screw axes (of the robot tool movements) for screws</c>
<c>        * with a significant rotation part. For movements without rotation</c>
<c>        * the direction of the screw axis is determined by the translation</c>
<c>        * part only. Hence, the direction of the screw axis cannot be used</c>
<c>        * to decide whether an articulated or a SCARA robot is used.</c>
<l>        if (Rot2 &gt; StdDevFactor * RotationTolerance)</l>
<l>            LX2s := [LX2s,LX2]</l>
<l>            LY2s := [LY2s,LY2]</l>
<l>            LZ2s := [LZ2s,LZ2]</l>
<l>        endif</l>
<l>    endfor</l>
<l>endfor</l>
<c>* </c>
<c>* In the second test, we check whether enough calibration poses with a</c>
<c>* significant rotation part are available for calibration.</c>
<l>NumPairs := |LX2s|</l>
<l>NumPairsMax := NumCalibrationPoses * (NumCalibrationPoses - 1) / 2</l>
<l>if (NumPairs &lt; 2)</l>
<l>    Message := 'There are not enough rotated calibration poses available.'</l>
<l>    Warnings := [Warnings,Message]</l>
<c>    * In this case, we can skip further test.</c>
<l>    return ()</l>
<l>endif</l>
<l>LargeRotationFraction := real(NumPairs) / NumPairsMax</l>
<l>if (NumPairs &lt; 4 or LargeRotationFraction &lt; MinLargeRotationFraction)</l>
<l>    Message := 'Only few rotated robot poses available, which might result in a reduced accuracy of the calibration results.'</l>
<l>    Warnings := [Warnings,Message]</l>
<l>endif</l>
<c>* </c>
<c>* In the third test, we compute the angle between the screw axes with</c>
<c>* a significant rotation part. For SCARA robots, this angle must be 0 in</c>
<c>* all cases. For articulated robots, for a significant fraction of robot</c>
<c>* poses, this angle should exceed a certain threshold. For this test, we</c>
<c>* use the robot tool poses as they are assumed to be more accurate than the</c>
<c>* calibration object poses.</c>
<l>NumPairPairs := NumPairs * (NumPairs - 1) / 2</l>
<l>NumPairPairsMax := NumPairsMax * (NumPairsMax - 1) / 2</l>
<l>Angles := gen_tuple_const(NumPairPairs,0)</l>
<l>Idx := 0</l>
<l>for Index1 := 0 to NumPairs - 2 by 1</l>
<l>    LXA := LX2s[Index1]</l>
<l>    LYA := LY2s[Index1]</l>
<l>    LZA := LZ2s[Index1]</l>
<l>    for Index2 := Index1 + 1 to NumPairs - 1 by 1</l>
<l>        LXB := LX2s[Index2]</l>
<l>        LYB := LY2s[Index2]</l>
<l>        LZB := LZ2s[Index2]</l>
<c>        * Compute the scalar product, i.e. the cosine of the screw</c>
<c>        * axes. To obtain valid values, crop the cosine to the</c>
<c>        * interval [-1,1].</c>
<l>        ScalarProduct := max([min([LXA * LXB + LYA * LYB + LZA * LZB,1]),-1])</l>
<c>        * Compute the angle between the axes in the range [0,pi/2].</c>
<l>        Angles[Idx] := acos(fabs(ScalarProduct))</l>
<l>        Idx := Idx + 1</l>
<l>    endfor</l>
<l>endfor</l>
<c>* Large angles should significantly exceed the RotationTolerance.</c>
<l>LargeAngles := sum(Angles [&gt;] StdDevFactor * RotationTolerance)</l>
<c>* Calculate the fraction of pairs of movements, i.e., pairs of pose</c>
<c>* pairs, that have a large angle between their corresponding screw</c>
<c>* axes.</c>
<l>LargeAnglesFraction := real(LargeAngles) / NumPairPairsMax</l>
<c>* For SCARA robots, all screw axes should be parallel, i.e., no</c>
<c>* two screw axes should have a large angle.</c>
<l>if (IsHandEyeScara and LargeAngles &gt; 0)</l>
<l>    Message := 'The robot poses indicate that this might be an articulated robot, although a SCARA robot was selected in the calibration data model.'</l>
<l>    Warnings := [Warnings,Message]</l>
<l>endif</l>
<c>* For articulated robots, the screw axes should have a large</c>
<c>* angles.</c>
<l>if (IsHandEyeArticulated)</l>
<l>    if (LargeAngles == 0)</l>
<c>        * If there is no pair of movements with a large angle between</c>
<c>        * their corresponding screw axes, this might be a SCARA robot.</c>
<l>        Message := 'The robot poses indicate that this might be a SCARA robot (no tilted robot poses available), although an articulated robot was selected in the calibration data model.'</l>
<l>        Warnings := [Warnings,Message]</l>
<l>    elseif (LargeAngles &lt; 3)</l>
<c>        * If there are at most 2 movements with a large angle between</c>
<c>        * their corresponding screw axes, the calibration might be</c>
<c>        * unstable.</c>
<l>        Message := 'Not enough tilted robot poses available for an accurate calibration of an articulated robot.'</l>
<l>        Warnings := [Warnings,Message]</l>
<l>    elseif (LargeAnglesFraction &lt; MinLargeAnglesFraction)</l>
<c>        * If there is only a low fraction of pairs of movements with</c>
<c>        * a large angle between their corresponding screw axes, the</c>
<c>        * accuracy of the calibration might be low.</c>
<l>        Message := 'Only few tilted robot poses available, which might result in a reduced accuracy of the calibration results.'</l>
<l>        Warnings := [Warnings,Message]</l>
<l>    endif</l>
<l>endif</l>
<l>return ()</l>
</body>
<docu id="check_hand_eye_calibration_input_poses">
<abstract lang="en_US">check_hand_eye_calibration_input_poses checks the hand-eye calibration input poses that are stored in the calibration data model CalibDataID for consistency.

For this check, it is necessary to know the accuracy of the input poses. Therefore, in RotationTolerance and TranslationTolerance a tolerance must be specified that approximately describes the error in the rotation and in the translation part of the input poses, respectively. The rotation tolerance must be passed in RotationTolerance in radians. The translation tolerance must be passed in  TranslationTolerance in the same unit in which the input poses were given, i.e., typically in meters. Therefore, the more accurate the input poses are, the lower the values for RotationTolerance and TranslationTolerance should be chosen. If the accuracy of the robot's tool poses is different from the accuracy of the calibration object poses, the tolerance values of the poses with the lower accuracy (i.e., the higher tolerance values) should be passed.

Typically, check_hand_eye_calibration_input_poses is called after all calibration poses have been set in the calibration data model and before the hand eye calibration is performed. The procedure checks all pairs of robot tool poses and compares them to the corresponding pair of calibration object poses. For each inconsistent pose pair, in Warnings a string is returned that indicates the inconsistent pose pair. For larger values for RotationTolerance or TranslationTolerance, i.e., for less accurate input poses, fewer warnings will be generated because the check is more tolerant, and vice versa. The procedure is also helpful, if the errors that are returned by the hand-eye calibration are larger than expected to identify potentially erroneous poses.

Note that it is not possible to check the consistency of a single pose but only of pose pairs. Nevertheless, if a certain pose occurs multiple times in different warning messages, it is likely that the pose is erroneous. Erroneous poses that result in inconsistent pose pairs should be removed from the calibration data model by using remove_calib_data_observ and remove_calib_data before performing the hand-eye calibration.

check_hand_eye_calibration_input_poses also checks whether enough calibration pose pairs are passed with a significant relative rotation angle, which is necessary for a robust hand-eye calibration.

check_hand_eye_calibration_input_poses also verifies that the correct calibration model was chosen in create_calib_data. If a model of type 'hand_eye_stationary_cam' or 'hand_eye_moving_cam' was chosen, the calibration of an articulated robot is assumed. For 'hand_eye_scara_stationary_cam' or 'hand_eye_scara_moving_cam', the calibration of a SCARA robot is assumed. Therefore, if for an articulated robot all input poses are parallel or if for a SCARA robot some robot poses are tilted, a corresponding message is returned in Warnings. Furthermore, if for articulated robots, the number of tilted input poses is below a certain value, a corresponding message in Warnings indicates that the accuracy of the result of the hand-eye calibration might be low. 

If no problems have been detected in the input poses, an empty tuple is returned in Warnings.</abstract>
<chapters lang="de_DE">
<item>Kalibrierung</item>
<item>Hand-Auge</item>
</chapters>
<chapters lang="en_US">
<item>Calibration</item>
<item>Hand-Eye</item>
</chapters>
<example lang="en_US">check_hand_eye_calibration_input_poses (CalibDataID, 0.04, 0.002, Warnings)
if (|Warnings| != 0)
    * There are warnings that should be checked before performing
    * the hand-eye calibration
    stop ()
endif
calibrate_hand_eye (CalibDataID, Errors)</example>
<keywords lang="en_US">
<item>hand</item>
<item>eye</item>
<item>hand-eye</item>
<item>calibration</item>
<item>poses</item>
<item>error</item>
<item>errors</item>
</keywords>
<library lang="de_DE">MVTec Standard Procedures</library>
<library lang="en_US">MVTec Standard Procedures</library>
<predecessor>
<item>create_calib_data</item>
<item>set_calib_data</item>
<item>set_calib_data_cam_param</item>
<item>set_calib_data_calib_object</item>
<item>find_calib_object</item>
<item>read_calib_data</item>
</predecessor>
<see_also>
<item>remove_calib_data</item>
<item>remove_calib_data_observ</item>
</see_also>
<short lang="de_DE">Check the input poses for the hand-eye calibration for consistency</short>
<short lang="en_US">Check the input poses of the hand-eye calibration for consistency.</short>
<successor>
<item>calibrate_hand_eye</item>
</successor>
<parameters>
<parameter id="CalibDataID">
<default_type>integer</default_type>
<description lang="en_US">Handle of the calibration data model.</description>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>calib_data</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="RotationTolerance">
<default_type>real</default_type>
<default_value>0.05</default_value>
<description lang="en_US">Tolerance of the rotation part of the input poses [rad].</description>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>angle.rad</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
<value_min>0.000000</value_min>
<values>
<item>0.02</item>
<item>0.03</item>
<item>0.04</item>
<item>0.05</item>
<item>0.06</item>
<item>0.08</item>
<item>0.1</item>
</values>
</parameter>
<parameter id="TranslationTolerance">
<default_type>real</default_type>
<default_value>0.005</default_value>
<description lang="en_US">Tolerance of the translation part of the input poses [m].</description>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>real</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
<value_min>0.000000</value_min>
<values>
<item>[0.001,0.002,0.003,0.004,0.005,0.006,0.007,0.008,0.009,0.01]</item>
</values>
</parameter>
<parameter id="Warnings">
<default_type>string</default_type>
<description lang="en_US">Tuple of strings with warnings that contain the identified problems. If no inconsistencies or other problems have been detected, an empty tuple is returned.</description>
<mixed_type>false</mixed_type>
<multivalue>true</multivalue>
<sem_type>string</sem_type>
<type_list>
<item>string</item>
</type_list>
</parameter>
</parameters>
</docu>
</procedure>
<procedure name="check_model_edges" access="local">
<interface>
<ic>
<par name="SurfaceModelID" base_type="ctrl" dimension="0"/>
<par name="ObjectModel3D" base_type="ctrl" dimension="0"/>
<par name="WindowHandleViewpoint" base_type="ctrl" dimension="0"/>
<par name="WindowHandleVisualization" base_type="ctrl" dimension="0"/>
</ic>
</interface>
<body>
<l>get_surface_model_param (SurfaceModelID, 'diameter', GenParamValue)</l>
<c>* </c>
<l>Instructions[0] := 'Rotate: Left button'</l>
<l>Instructions[1] := 'Zoom:   Shift + left button'</l>
<l>Instructions[2] := 'Move:   Ctrl  + left button'</l>
<c>* </c>
<l>create_visualization_message_queues (MessageQueues1)</l>
<l>Buttons := ['Continue','right','bottom',-1,-1]</l>
<l>get_window_extents (WindowHandleViewpoint, Row, Column, Width, Height)</l>
<l>gen_cam_par_area_scan_division (0.008, 0, 5.2e-006, 5.2e-006, Width * 0.5 + 0.5, Height * 0.5 + 0.5, Width, Height, CameraParam)</l>
<l>par_start&lt;TI.at(0)&gt; : visualize_object_model_3d_ext (WindowHandleViewpoint, ObjectModel3D, CameraParam, [], ['disp_pose','color_0','alpha_0'], ['true','cyan',0.5], [], [], Instructions, MessageQueues1, Buttons, [], [], 'false', [])</l>
<l>CurrentState1 := []</l>
<c>* </c>
<l>get_surface_model_param (SurfaceModelID, 'diameter', DiameterModel)</l>
<l>get_surface_model_param (SurfaceModelID, 'center', CenterModel)</l>
<l>Viewpoint := CenterModel - [0,0,1] * DiameterModel</l>
<l>gen_camera_object_model_3d ([Viewpoint,0,0,0,0], DiameterModel * 0.05, OM3DCamera)</l>
<l>gen_object_model_3d_from_points ([Viewpoint[0],CenterModel[0]], [Viewpoint[1],CenterModel[1]], [Viewpoint[2],CenterModel[2]], OM3DLineSphereToModel)</l>
<l>set_object_model_3d_attrib_mod (OM3DLineSphereToModel, 'lines', [], [2,0,1])</l>
<c>* </c>
<c>* Find a pose for the second window such that both the model and the camer are visible,</c>
<c>* from the side.</c>
<l>get_object_models_center ([ObjectModel3D,OM3DCamera,OM3DLineSphereToModel], Center)</l>
<l>create_pose (-Center[0], -Center[1], -Center[2], 0, 0, 0, 'Rp+T', 'gba', 'point', PoseInT)</l>
<l>create_pose (0, 0, 0, -90, 0, 0, 'Rp+T', 'gba', 'point', PoseInR)</l>
<l>pose_compose (PoseInR, PoseInT, PoseIn)</l>
<l>get_window_extents (WindowHandleVisualization, Row, Column, Width, Height)</l>
<l>gen_cam_par_area_scan_division (0.06, 0, 8.5e-6, 8.5e-6, Width / 2, Height / 2, Width, Height, CamParamVis)</l>
<l>determine_optimum_pose_distance ([ObjectModel3D,OM3DCamera,OM3DLineSphereToModel], CamParamVis, 0.5, PoseIn, PoseEstimated)</l>
<c>* </c>
<l>create_visualization_message_queues (MessageQueues2)</l>
<l>Buttons := ['Hide Edge Directions','center','bottom',-1,-1]</l>
<l>DirectionsShown := true</l>
<l>par_start&lt;TI.at(1)&gt; : visualize_object_model_3d_ext (WindowHandleVisualization, [ObjectModel3D,ObjectModel3D,OM3DCamera,OM3DLineSphereToModel], CamParamVis, PoseEstimated, ['color_0','color_1','color_2','color_3','alpha_0','disp_normals_1'], ['cyan','red','gray','white',0.5,'true'], [], ['','','Viewpoint',''], [], MessageQueues2, Buttons, [], [], 'false', [])</l>
<l>CurrentState2 := []</l>
<c>* </c>
<l>repeat</l>
<l>    process_visualize_events_generic (WindowHandleViewpoint, MessageQueues1, CurrentState1, DidFinish1, CurrentState1, ButtonPressed, Pose)</l>
<l>    if (ButtonPressed == 0)</l>
<c>        * Exit button</c>
<l>        break</l>
<l>    endif</l>
<l>    if (Pose != [])</l>
<c>        * The pose of view 1 was updated</c>
<c>        * -&gt; Update the viewpoint in view 2</c>
<l>        pose_invert (Pose, PoseInvert)</l>
<l>        Viewpoint := PoseInvert[0:2]</l>
<c>        * Change the viewpoint such that its distance from the model is always about constant</c>
<l>        Direction := Viewpoint - CenterModel</l>
<l>        Length := sqrt(sum(Direction * Direction))</l>
<l>        Viewpoint := CenterModel + Direction * (DiameterModel / Length)</l>
<c>        * </c>
<l>        PoseInvert[0:2] := Viewpoint</l>
<c>        * </c>
<l>        gen_camera_object_model_3d (PoseInvert, DiameterModel * 0.05, OM3DSphere)</l>
<l>        gen_object_model_3d_from_points ([Viewpoint[0],CenterModel[0]], [Viewpoint[1],CenterModel[1]], [Viewpoint[2],CenterModel[2]], OM3DLineSphereToModel)</l>
<l>        set_object_model_3d_attrib_mod (OM3DLineSphereToModel, 'lines', [], [2,0,1])</l>
<l>        get_surface_model_param (SurfaceModelID, 'edges ' + sum((Viewpoint - CenterModel) + ' '), OM3DModelEdges)</l>
<c>        * </c>
<l>        get_object_model_3d_params (OM3DModelEdges, 'edge_dir_' + ['x','y','z'], EdgeDirs)</l>
<l>        if (|EdgeDirs| &gt; 0)</l>
<l>            set_object_model_3d_attrib_mod (OM3DModelEdges, 'point_normal_' + ['x','y','z'], [], EdgeDirs)</l>
<l>        endif</l>
<c>        * </c>
<l>        create_message (MessageHandle)</l>
<l>        set_message_tuple (MessageHandle, 'type', 'replace_object_model')</l>
<l>        set_message_tuple (MessageHandle, 'index', [1,2,3])</l>
<l>        set_message_tuple (MessageHandle, 'model', [OM3DModelEdges,OM3DSphere,OM3DLineSphereToModel])</l>
<l>        enqueue_message (MessageQueues2[1], MessageHandle, [], [])</l>
<l>    endif</l>
<c></c>
<l>    process_visualize_events_generic (WindowHandleVisualization, MessageQueues2, CurrentState2, DidFinish2, CurrentState2, ButtonPressed, Pose)</l>
<l>    if (ButtonPressed == 0)</l>
<l>        DirectionsShown := not DirectionsShown</l>
<c>        * Toggle edge direction, using the normal vectors of the edge</c>
<l>        create_message (MessageHandle)</l>
<l>        set_message_tuple (MessageHandle, 'type', 'toggle_param')</l>
<l>        set_message_tuple (MessageHandle, 'param', 'disp_normals_1')</l>
<l>        enqueue_message (MessageQueues2[1], MessageHandle, [], [])</l>
<l>        create_message (MessageHandle)</l>
<l>        set_message_tuple (MessageHandle, 'type', 'change_button_text')</l>
<l>        set_message_tuple (MessageHandle, 'index', 0)</l>
<l>        if (DirectionsShown)</l>
<l>            set_message_tuple (MessageHandle, 'text', 'Hide Edge Directions')</l>
<l>        else</l>
<l>            set_message_tuple (MessageHandle, 'text', 'Show Edge Directions')</l>
<l>        endif</l>
<l>        enqueue_message (MessageQueues2[1], MessageHandle, [], [])</l>
<l>    endif</l>
<l>until (DidFinish1 or DidFinish2)</l>
<c></c>
<c>* Send termination message to all subthreads</c>
<l>create_message (MessageHandle)</l>
<l>set_message_tuple (MessageHandle, 'type', 'exit')</l>
<l>enqueue_message (MessageQueues1[1], MessageHandle, [], [])</l>
<l>create_message (MessageHandle)</l>
<l>set_message_tuple (MessageHandle, 'type', 'exit')</l>
<l>enqueue_message (MessageQueues2[1], MessageHandle, [], [])</l>
<c></c>
<c>* Wait for all subthreads to finish</c>
<l>convert_vector_to_tuple (TI, TIT)</l>
<l>par_join (TIT)</l>
<l>return ()</l>
</body>
<docu id="check_model_edges">
<chapters lang="en_US">
<item>3D Matching</item>
<item>Surface-Based</item>
</chapters>
<library lang="en_US">MVTec Standard Procedures</library>
<parameters>
<parameter id="ObjectModel3D">
<default_type>integer</default_type>
<mixed_type>false</mixed_type>
<sem_type>object_model_3d</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="SurfaceModelID">
<default_type>integer</default_type>
<mixed_type>false</mixed_type>
<sem_type>surface_model</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="WindowHandleViewpoint">
<default_type>integer</default_type>
<mixed_type>false</mixed_type>
<sem_type>window</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="WindowHandleVisualization">
<default_type>integer</default_type>
<mixed_type>false</mixed_type>
<sem_type>window</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
</parameters>
</docu>
</procedure>
<procedure name="check_mouse_over_button" access="local">
<interface>
<ic>
<par name="Parameters" base_type="ctrl" dimension="0"/>
<par name="GraphButtonRow" base_type="ctrl" dimension="0"/>
<par name="GraphButtonColumn" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="FoundButton" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<l>get_message_tuple (Parameters, 'gButtons', gButtons)</l>
<l>FoundButton := -1</l>
<l>for idx := 0 to |gButtons| - 1 by 5</l>
<l>    if (GraphButtonRow &gt;= gButtons[idx + 2] - 1 and GraphButtonRow &lt;= gButtons[idx + 4] + 1 and GraphButtonColumn &gt;= gButtons[idx + 1] - 1 and GraphButtonColumn &lt;= gButtons[idx + 3] + 1)</l>
<l>        FoundButton := idx</l>
<l>    endif</l>
<l>endfor</l>
<l>return ()</l>
</body>
<docu id="check_mouse_over_button">
<chapters lang="en_US">
<item>Graphics</item>
<item>Mouse</item>
</chapters>
<library lang="en_US">MVTec Standard Procedures</library>
<parameters>
<parameter id="FoundButton"/>
<parameter id="GraphButtonColumn"/>
<parameter id="GraphButtonRow"/>
<parameter id="Parameters">
<default_type>integer</default_type>
<mixed_type>false</mixed_type>
<sem_type>message</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
</parameters>
</docu>
</procedure>
<procedure name="check_train_dl_model_params" access="local">
<interface>
<ic>
<par name="DLDataset" base_type="ctrl" dimension="0"/>
<par name="DLModelHandle" base_type="ctrl" dimension="0"/>
<par name="NumTrainSamples" base_type="ctrl" dimension="0"/>
<par name="StartEpoch" base_type="ctrl" dimension="0"/>
<par name="TrainParam" base_type="ctrl" dimension="0"/>
</ic>
</interface>
<body>
<c>* </c>
<c>* This procedure checks the parameters used in the procedure train_dl_model for consistency.</c>
<c>* </c>
<l>get_dl_model_param (DLModelHandle, 'type', ModelType)</l>
<c>* </c>
<c>* Check the NumEpochs parameter.</c>
<l>if (StartEpoch &lt; 0.0)</l>
<l>    throw ('Error: StartEpoch &lt; 0 is not allowed.')</l>
<l>endif</l>
<c>* </c>
<c>* Check if the dataset is already preprocessed.</c>
<l>PreprocessedDataset := false</l>
<l>try</l>
<l>    get_dict_tuple (DLDataset, 'preprocess_param', PreprocessParam)</l>
<l>    PreprocessedDataset := true</l>
<l>catch (Exception)</l>
<l>endtry</l>
<l>if (not PreprocessedDataset)</l>
<l>    throw ('Error: The supplied dataset needs to be preprocessed already. Use the standard procedure preprocess_dl_dataset.')</l>
<l>endif</l>
<c>* </c>
<c>* Check parameters for anomaly detection models.</c>
<l>if (ModelType == 'anomaly_detection')</l>
<l>    get_dict_tuple (TrainParam, 'anomaly_param', TrainParamAnomaly)</l>
<l>    get_dict_tuple (TrainParamAnomaly, 'domain_ratio', DomainRatio)</l>
<l>    if (DomainRatio &lt;= 0 or DomainRatio &gt; 1.0)</l>
<l>        throw ('Error: The anomaly detection parameter \'domain_ratio\' must be between 0 and 1.')</l>
<l>    endif</l>
<l>    get_dict_tuple (TrainParamAnomaly, 'error_threshold', ErrorThreshold)</l>
<l>    if (ErrorThreshold &lt; 0 or ErrorThreshold &gt; 1)</l>
<l>        throw ('Error: The anomaly detection parameter \'error_threshold\' must be between 0 and 1.')</l>
<l>    endif</l>
<l>    get_dict_tuple (TrainParamAnomaly, 'regularization_noise', RegularizationNoise)</l>
<l>    if (RegularizationNoise &lt; 0)</l>
<l>        throw ('Error: The anomaly detection parameter \'regularization_noise\' must be greater than or equal to 0.')</l>
<l>    endif</l>
<l>    return ()</l>
<l>endif</l>
<c>* </c>
<c>* Check parameters for other models.</c>
<c>* </c>
<c>* Check the NumEpochs parameter.</c>
<l>get_dict_tuple (TrainParam, 'num_epochs', NumEpochs)</l>
<l>if (StartEpoch &gt; NumEpochs)</l>
<l>    throw ('Error: StartEpoch &gt; NumEpochs is not allowed.')</l>
<l>endif</l>
<c>* </c>
<c>* Check that the number of training samples is at least as big as the total batch size.</c>
<l>get_dl_model_param (DLModelHandle, 'batch_size', BatchSizeDevice)</l>
<l>get_dl_model_param (DLModelHandle, 'batch_size_multiplier', BatchSizeMultiplier)</l>
<l>BatchSize := BatchSizeDevice * BatchSizeMultiplier</l>
<l>if (NumTrainSamples &lt; BatchSize)</l>
<l>    throw ('Error: Number of training samples is smaller than the batch size.')</l>
<l>endif</l>
<c>* </c>
<c>* Check that all model class IDs are a part of the DLDataset class IDs.</c>
<l>get_dl_model_param (DLModelHandle, 'class_ids', ClassIDsModel)</l>
<l>get_dict_tuple (DLDataset, 'class_ids', ClassIDsDataset)</l>
<l>for Index := 0 to |ClassIDsModel| - 1 by 1</l>
<l>    tuple_find_first (ClassIDsDataset, ClassIDsModel[Index], IndexFind)</l>
<l>    if (IndexFind &lt; 0)</l>
<l>        ClassIDsModelStr := sum(' ' + ClassIDsModel)</l>
<l>        ClassIDsDatasetStr := sum(' ' + ClassIDsDataset)</l>
<l>        throw ('Error: A model class ID is not part of the DLDataset class IDs. DLModelHandle class ID: ' + ClassIDsModelStr + '. ' + 'DLDataset class IDs: ' + ClassIDsDatasetStr + '.')</l>
<l>    endif</l>
<l>endfor</l>
<c>* </c>
<c>* Initialize change and serialization strategies in order to test for valid values.</c>
<l>copy_dict (TrainParam, [], [], TrainParamCopy)</l>
<l>init_train_dl_model_change_strategies (TrainParamCopy, _)</l>
<l>init_train_dl_model_serialization_strategies (TrainParamCopy, _)</l>
<c>* </c>
<l>return ()</l>
</body>
<docu id="check_train_dl_model_params">
<abstract lang="en_US">Check the parameters used in the procedure train_dl_model for consistency.</abstract>
<chapters lang="de_DE">
<item>Deep Learning</item>
<item>Modell</item>
</chapters>
<chapters lang="en_US">
<item>Deep Learning</item>
<item>Model</item>
</chapters>
<library lang="en_US">MVTec Standard Procedures</library>
<parameters>
<parameter id="DLDataset">
<default_type>integer</default_type>
<description lang="en_US">DLDataset used in training.</description>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>dict</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="DLModelHandle">
<default_type>integer</default_type>
<description lang="en_US">DLModelHandle used in training.</description>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>dl_model</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="NumTrainSamples">
<default_type>integer</default_type>
<description lang="en_US">Number of training samples.</description>
<multivalue>false</multivalue>
<sem_type>integer</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="StartEpoch">
<default_type>integer</default_type>
<description lang="en_US">Starting epoch.</description>
<multivalue>false</multivalue>
<sem_type>integer</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="TrainParam">
<default_type>integer</default_type>
<description lang="en_US">Dictionary containing the training parameters.</description>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>dict</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
</parameters>
</docu>
</procedure>
<procedure name="check_visibility" access="local">
<interface>
<ic>
<par name="WindowHandle1" base_type="ctrl" dimension="0"/>
<par name="WindowHandle2" base_type="ctrl" dimension="0"/>
<par name="SurfaceModelID" base_type="ctrl" dimension="0"/>
<par name="ObjectModel3DScene" base_type="ctrl" dimension="0"/>
<par name="ObjectModel3DModel" base_type="ctrl" dimension="0"/>
<par name="SurfaceMatchingResultID" base_type="ctrl" dimension="0"/>
<par name="ViewpointIn" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="Viewpoint" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c>* </c>
<l>get_object_model_3d_params (ObjectModel3DScene, 'center', CenterScene)</l>
<l>get_object_model_3d_params (ObjectModel3DScene, 'diameter', DiameterScene)</l>
<l>get_object_model_3d_params (ObjectModel3DScene, 'num_points', NumPointsScene)</l>
<c>* </c>
<l>get_surface_model_param (SurfaceModelID, 'diameter', DiameterModel)</l>
<l>Viewpoint := ViewpointIn</l>
<l>ViewpointStr := Viewpoint[0] + ' ' + Viewpoint[1] + ' ' + Viewpoint[2]</l>
<c>* With this method, the viewpoint would be very far away in view 2, leading to not-so-nice</c>
<c>* visualization. Adapt the distance to be always &lt;= SceneDiameter.</c>
<l>Direction := Viewpoint - CenterScene</l>
<l>Length := sqrt(sum(Direction * Direction))</l>
<l>LengthRel := Length / DiameterScene</l>
<l>if (LengthRel &gt; 1)</l>
<l>    Direction := Direction / LengthRel</l>
<l>endif</l>
<l>ViewpointViz := CenterScene + Direction</l>
<c>* </c>
<l>try</l>
<l>    get_surface_matching_result (SurfaceMatchingResultID, 'sampled_scene', 0, ObjectModel3DSceneSampled)</l>
<c>    * Visualize the sampled scene if the number of scene points</c>
<c>    * exceeds half a million to speed-up the visualization.</c>
<l>    if (NumPointsScene &gt; 5e5)</l>
<l>        copy_object_model_3d (ObjectModel3DSceneSampled, 'all', ObjectModel3DSceneVis)</l>
<l>    else</l>
<l>        copy_object_model_3d (ObjectModel3DScene, 'all', ObjectModel3DSceneVis)</l>
<l>    endif</l>
<l>    get_surface_model_param (SurfaceModelID, 'sampled_model', ObjectModel3DModelSampled)</l>
<c>    * Get the center of the model and correct the found pose to be consistent with the internal poses</c>
<l>    get_object_model_3d_params (ObjectModel3DModel, 'center', CenterModel)</l>
<l>    create_pose (CenterModel[0], CenterModel[1], CenterModel[2], 0, 0, 0, 'Rp+T', 'gba', 'point', PoseTranslate)</l>
<l>    get_surface_matching_result (SurfaceMatchingResultID, 'pose', 0, PoseResult)</l>
<l>    pose_compose (PoseResult, PoseTranslate, PoseResultTranslate)</l>
<c>    * Take the translation part</c>
<l>    PoseTrans := PoseResultTranslate[0:2]</l>
<c>    * Calculate inverse pose</c>
<l>    pose_invert (PoseResultTranslate, PoseInvert)</l>
<c>    * We only need the rotation part of the pose</c>
<l>    PoseInverOnlyRot := PoseInvert</l>
<l>    PoseInverOnlyRot[0:2] := 0.0</l>
<l>    pose_to_hom_mat3d (PoseInverOnlyRot, HomMat3DOnlyRot)</l>
<c>    * Calculate the viewing direction in the scene</c>
<l>    ViewDirScene := PoseTrans - Viewpoint</l>
<c>    * Get the viewing direction in the model</c>
<l>    affine_trans_point_3d (HomMat3DOnlyRot, ViewDirScene[0], ViewDirScene[1], ViewDirScene[2], ViewDirModelX, ViewDirModelY, ViewDirModelZ)</l>
<c>    * Normalize the viewing direction</c>
<l>    norm := sqrt(ViewDirModelX * ViewDirModelX + ViewDirModelY * ViewDirModelY + ViewDirModelZ * ViewDirModelZ)</l>
<l>    ViewDirModel[0] := ViewDirModelX / norm</l>
<l>    ViewDirModel[1] := ViewDirModelY / norm</l>
<l>    ViewDirModel[2] := ViewDirModelZ / norm</l>
<l>    ViewDirStr := ViewDirModel[0] + ' ' + ViewDirModel[1] + ' ' + ViewDirModel[2]</l>
<l>    get_surface_model_param (SurfaceModelID, 'visible_reference_points ' + ViewDirStr, VisibleReferencePoints)</l>
<l>    rigid_trans_object_model_3d (VisibleReferencePoints, PoseResult, ObjectModel3DVisible)</l>
<l>    rigid_trans_object_model_3d (ObjectModel3DModelSampled, PoseResult, ObjectModel3DModelSampled)</l>
<l>    rigid_trans_object_model_3d (ObjectModel3DModel, PoseResult, ObjectModel3DModelInPose)</l>
<l>catch (Exception)</l>
<c>    * Unable to get the visible points -&gt; create a dummy 3D object model instead</c>
<l>    gen_empty_object_model_3d (ObjectModel3DSceneSampled)</l>
<l>    gen_empty_object_model_3d (ObjectModel3DVisible)</l>
<l>    gen_empty_object_model_3d (ObjectModel3DModelSampled)</l>
<l>    gen_empty_object_model_3d (ObjectModel3DModelInPose)</l>
<l>endtry</l>
<c>* </c>
<c>* We only define a viewpoint, not a full camera. "Fake" a camera that looks towards the center of</c>
<c>* gravity of the scene. Do not point it towards the center of the bounding box, since that is rather</c>
<c>* unstable (a single outlier point would distort it).</c>
<l>moments_object_model_3d (ObjectModel3DScene, 'mean_points', CenterSceneGravity)</l>
<l>gen_camera_facing_scene (ViewpointViz, CenterSceneGravity, DiameterModel * 2, OM3DCamera)</l>
<l>gen_object_model_3d_from_points ([ViewpointViz[0],CenterScene[0]], [ViewpointViz[1],CenterScene[1]], [ViewpointViz[2],CenterScene[2]], OM3DLineSphereToScene)</l>
<l>set_object_model_3d_attrib_mod (OM3DLineSphereToScene, 'lines', [], [2,0,1])</l>
<c>* </c>
<c>* Convert input viewpoint into initial pose</c>
<l>Direction := Viewpoint - CenterScene</l>
<l>DirectionLength := sqrt(sum(Direction * Direction))</l>
<l>if (DirectionLength &lt; 1e-1 * DiameterModel)</l>
<c>    * The viewpoint is in the center of the scene.</c>
<c>    * We cannot build a camera pose that looks "onto" the scene when we</c>
<c>    * are in its center. Look into the Z-direction instead.</c>
<l>    Direction := [0,0,1]</l>
<l>    DirectionLength := sqrt(sum(Direction * Direction))</l>
<l>endif</l>
<c></c>
<c>* Create a rotation such that the camera faces the center of gravity of the scene</c>
<l>DirNorm := Direction / DirectionLength</l>
<l>if (sum(DirNorm * [0,0,-1]) &gt; 0.99999)</l>
<c>    * We are already looking into the right direction</c>
<l>    ViewpointAsPoseIn := [0,0,0,0,0,0,0]</l>
<l>    AngleToX := 0</l>
<l>else</l>
<l>    if (sum(DirNorm * [0,0,-1]) &gt; -0.99999)</l>
<c>        * Angle between the vectors is &gt; 0.25°</c>
<l>        Axis := DirNorm + [0,0,-1]</l>
<l>        AxisNorm := Axis / sqrt(sum(Axis * Axis))</l>
<l>        tuple_vector_cross_product (DirNorm, [0,0,1], OrthogonalDirection)</l>
<l>        OrthogonalDirection := OrthogonalDirection / sqrt(sum(OrthogonalDirection * OrthogonalDirection))</l>
<l>    else</l>
<l>        Axis := [0,1,0]</l>
<l>        OrthogonalDirection := [1,0,0]</l>
<l>    endif</l>
<c>    * </c>
<l>    tuple_vector_cross_product ([0,0,1], OrthogonalDirection, RotationAxis)</l>
<l>    tuple_vector_cross_product ([0,0,1], RotationAxis, DirectionProjected)</l>
<l>    AngleToX := atan2(DirectionProjected[0],DirectionProjected[1])</l>
<l>    hom_mat3d_identity (HomMat3DIdentity)</l>
<l>    hom_mat3d_rotate_local (HomMat3DIdentity, rad(180), Axis, HomMat3DRotate)</l>
<l>    hom_mat3d_to_pose (HomMat3DRotate, ViewpointAsPoseIn)</l>
<l>endif</l>
<c>* </c>
<l>ViewpointAsPoseIn[0:2] := Viewpoint</l>
<l>pose_invert (ViewpointAsPoseIn, ViewpointAsPoseIn)</l>
<c>* </c>
<c>* Start the first 3D visualization window</c>
<c>* In this window, one can set the viewpoint position</c>
<l>Instructions[0] := 'Rotate: Left button'</l>
<l>Instructions[1] := 'Zoom:   Shift + left button'</l>
<l>Instructions[2] := 'Move:   Ctrl  + left button'</l>
<c>* </c>
<l>get_window_extents (WindowHandle1, Row, Column, Width, Height)</l>
<l>gen_cam_par_area_scan_division (0.005, 0, 5.2e-06, 5.2e-06, Width * 0.5 + 0.5, Height * 0.5 + 0.5, Width, Height, CameraParam)</l>
<l>Buttons := ['Continue','right','bottom',-1,-1,'Reset','left','bottom',-1,-1]</l>
<l>create_visualization_message_queues (MessageQueues1)</l>
<l>par_start&lt;TI.at(0)&gt; : visualize_object_model_3d_ext (WindowHandle1, [ObjectModel3DVisible,ObjectModel3DSceneVis], CameraParam, ViewpointAsPoseIn, ['color_0','color_1','disp_pose'], ['green','gray','true'], 'Define Viewpoint', [], Instructions, MessageQueues1, Buttons, [], [], 'false', [])</l>
<l>PreviousState1 := []</l>
<l>DidFinish1 := false</l>
<c></c>
<c>* </c>
<c>* Start the second 3D visualization window</c>
<c>* Here, the visible points are visualized</c>
<c>* Find a viewpoint such that we see the scene and the camera "from the side".</c>
<c>* This makes it easier to see what is going on.</c>
<c>* To keep the scene upright, we first rotate around the x-axis, then around the</c>
<c>* (original) z-axis.</c>
<l>get_object_models_center ([ObjectModel3DScene,OM3DCamera], VizCenter)</l>
<l>hom_mat3d_identity (HomMat3DIdentity1)</l>
<l>hom_mat3d_rotate (HomMat3DIdentity1, rad(-90), [1,0,0], VizCenter[0], VizCenter[1], VizCenter[2], HomMat3DRotate)</l>
<l>hom_mat3d_rotate_local (HomMat3DRotate, AngleToX, [0,0,1], HomMat3DRotate)</l>
<l>hom_mat3d_to_pose (HomMat3DRotate, PoseIn)</l>
<l>determine_optimum_pose_distance ([ObjectModel3DScene,OM3DCamera,ObjectModel3DModelInPose], CameraParam, 0.5, PoseIn, VizposeIn)</l>
<c>* </c>
<l>Buttons := ['Hide Visible Points','left','bottom',-1,-1,'Hide Trained Model','right','bottom',-1,-1]</l>
<l>ShowVisiblePoints := true</l>
<l>ShowTrainedModel := true</l>
<l>create_visualization_message_queues (MessageQueues2)</l>
<l>par_start&lt;TI.at(1)&gt; : visualize_object_model_3d_ext (WindowHandle2, [ObjectModel3DVisible,ObjectModel3DModelInPose,ObjectModel3DSceneVis,OM3DCamera,OM3DLineSphereToScene], CameraParam, VizposeIn, ['color_0','color_1','color_2','color_3','color_4','alpha_1','disp_pose','disp_normals_1','disp_normals_2'], ['green','red','gray','gray','white',0.5,'true','false','true'], 'Inspect Visible Points', ['','','','Viewpoint',''], [], MessageQueues2, Buttons, [], [], 'false', [])</l>
<l>PreviousState2 := []</l>
<c>* </c>
<l>while (not DidFinish1)</l>
<l>    process_visualize_events_generic (WindowHandle1, MessageQueues1, PreviousState1, DidFinish1, PreviousState1, ButtonPressed, Pose)</l>
<l>    if (ButtonPressed == 0 or DidFinish1)</l>
<c>        * Exit button pressed</c>
<l>        break</l>
<l>    elseif (ButtonPressed == 1)</l>
<c>        * Reset button pressed</c>
<l>        Viewpoint := [0,0,0]</l>
<l>        create_message (MessageHandle)</l>
<l>        set_message_tuple (MessageHandle, 'type', 'set_pose')</l>
<l>        set_message_tuple (MessageHandle, 'poses', ViewpointAsPoseIn)</l>
<l>        enqueue_message (MessageQueues1[1], MessageHandle, [], [])</l>
<c>        * Also update the second view below</c>
<l>        Pose := ViewpointAsPoseIn</l>
<l>    endif</l>
<l>    if (Pose != [])</l>
<c>        * The pose of view 1 was updated</c>
<c>        * -&gt; Update the viewpoint in view 2</c>
<l>        pose_to_hom_mat3d (Pose[0:6], HomMat3D)</l>
<l>        hom_mat3d_invert (HomMat3D, HomMat3DInvert)</l>
<l>        affine_trans_point_3d (HomMat3DInvert, 0, 0, 0, Qx, Qy, Qz)</l>
<l>        Viewpoint := [Qx,Qy,Qz]</l>
<l>        ViewpointStr := Viewpoint[0] + ' ' + Viewpoint[1] + ' ' + Viewpoint[2]</l>
<c>        * With this method, the viewpoint would be very far away in view 2, leading to not-so-nice</c>
<c>        * visualization. Adapt the distance to be always &lt;= SceneDiameter.</c>
<l>        Direction := Viewpoint - CenterScene</l>
<l>        Length := sqrt(sum(Direction * Direction))</l>
<l>        LengthRel := Length / DiameterScene</l>
<l>        if (LengthRel &gt; 1)</l>
<l>            Direction := Direction / LengthRel</l>
<l>        endif</l>
<l>        ViewpointViz := CenterScene + Direction</l>
<c>        * </c>
<c>        * Update title of left visualization window</c>
<l>        create_message (MessageHandle)</l>
<l>        set_message_tuple (MessageHandle, 'type', 'change_title')</l>
<l>        set_message_tuple (MessageHandle, 'title', ['Define Viewpoint','Current Viewpoint: [' + Viewpoint[0] + ',' + Viewpoint[1] + ',' + Viewpoint[2] + ']'])</l>
<l>        enqueue_message (MessageQueues1[1], MessageHandle, [], [])</l>
<l>        set_message_tuple (MessageHandle, 'type', 'replace_object_model')</l>
<l>        set_message_tuple (MessageHandle, 'index', 0)</l>
<l>        set_message_tuple (MessageHandle, 'model', ObjectModel3DVisible)</l>
<l>        enqueue_message (MessageQueues1[1], MessageHandle, [], [])</l>
<c>        * </c>
<l>        gen_camera_facing_scene (ViewpointViz, CenterSceneGravity, DiameterModel * 2, OM3DCamera)</l>
<c></c>
<l>        gen_object_model_3d_from_points ([ViewpointViz[0],CenterScene[0]], [ViewpointViz[1],CenterScene[1]], [ViewpointViz[2],CenterScene[2]], OM3DLineSphereToScene)</l>
<l>        set_object_model_3d_attrib_mod (OM3DLineSphereToScene, 'lines', [], [2,0,1])</l>
<l>        try</l>
<l>            get_object_model_3d_params (ObjectModel3DModel, 'center', CenterModel)</l>
<l>            create_pose (CenterModel[0], CenterModel[1], CenterModel[2], 0, 0, 0, 'Rp+T', 'gba', 'point', PoseTranslate)</l>
<l>            get_surface_matching_result (SurfaceMatchingResultID, 'pose', 0, PoseResult)</l>
<l>            pose_compose (PoseResult, PoseTranslate, PoseResultTranslate)</l>
<c>            * Take the translation part</c>
<l>            PoseTrans := PoseResultTranslate[0:2]</l>
<c>            * Calculate inverse pose</c>
<l>            pose_invert (PoseResultTranslate, PoseInvert)</l>
<c>            * We only need the rotation part of the pose</c>
<l>            PoseInverOnlyRot := PoseInvert</l>
<l>            PoseInverOnlyRot[0:2] := 0.0</l>
<l>            pose_to_hom_mat3d (PoseInverOnlyRot, HomMat3DOnlyRot)</l>
<c>            * Calculate the viewing direction in the scene</c>
<l>            ViewDirScene := PoseTrans - Viewpoint</l>
<c>            * Get the viewing direction in the model</c>
<l>            affine_trans_point_3d (HomMat3DOnlyRot, ViewDirScene[0], ViewDirScene[1], ViewDirScene[2], ViewDirModelX, ViewDirModelY, ViewDirModelZ)</l>
<c>            * Normalize the viewing direction</c>
<l>            norm := sqrt(ViewDirModelX * ViewDirModelX + ViewDirModelY * ViewDirModelY + ViewDirModelZ * ViewDirModelZ)</l>
<l>            ViewDirModel[0] := ViewDirModelX / norm</l>
<l>            ViewDirModel[1] := ViewDirModelY / norm</l>
<l>            ViewDirModel[2] := ViewDirModelZ / norm</l>
<l>            ViewDirStr := ViewDirModel[0] + ' ' + ViewDirModel[1] + ' ' + ViewDirModel[2]</l>
<l>            get_surface_model_param (SurfaceModelID, 'visible_reference_points ' + ViewDirStr, VisibleReferencePoints)</l>
<l>            rigid_trans_object_model_3d (VisibleReferencePoints, PoseResult, ObjectModel3DVisible)</l>
<l>        catch (Exception)</l>
<c>            * Unable to get the visible points -&gt; create a dummy 3D object model instead</c>
<l>            gen_empty_object_model_3d (ObjectModel3DScene)</l>
<l>            gen_empty_object_model_3d (ObjectModel3DVisible)</l>
<l>        endtry</l>
<c>        * </c>
<l>        create_message (MessageHandle)</l>
<l>        set_message_tuple (MessageHandle, 'type', 'replace_object_model')</l>
<l>        set_message_tuple (MessageHandle, 'index', [0,3,4])</l>
<l>        set_message_tuple (MessageHandle, 'model', [ObjectModel3DVisible,OM3DCamera,OM3DLineSphereToScene])</l>
<l>        enqueue_message (MessageQueues2[1], MessageHandle, [], [])</l>
<l>    endif</l>
<c></c>
<l>    process_visualize_events_generic (WindowHandle2, MessageQueues2, PreviousState2, DidFinish2, PreviousState2, ButtonPressed, Poses)</l>
<l>    if (DidFinish2)</l>
<l>        break</l>
<l>    endif</l>
<l>    if (ButtonPressed == 0)</l>
<l>        ShowVisiblePoints := not ShowVisiblePoints</l>
<c>        * Toggle visible points</c>
<l>        create_message (MessageHandle)</l>
<l>        set_message_tuple (MessageHandle, 'type', 'replace_object_model')</l>
<l>        set_message_tuple (MessageHandle, 'index', 0)</l>
<l>        if (ShowVisiblePoints)</l>
<l>            set_message_tuple (MessageHandle, 'model', ObjectModel3DVisible)</l>
<l>        else</l>
<l>            gen_empty_object_model_3d (ObjectModel3DNoPoints)</l>
<l>            set_message_tuple (MessageHandle, 'model', ObjectModel3DNoPoints)</l>
<l>        endif</l>
<l>        enqueue_message (MessageQueues2[1], MessageHandle, [], [])</l>
<l>        create_message (MessageHandle)</l>
<l>        set_message_tuple (MessageHandle, 'type', 'change_button_text')</l>
<l>        set_message_tuple (MessageHandle, 'index', 0)</l>
<l>        if (ShowVisiblePoints)</l>
<l>            set_message_tuple (MessageHandle, 'text', 'Hide Visible Points')</l>
<l>        else</l>
<l>            set_message_tuple (MessageHandle, 'text', 'Show Visible Points')</l>
<l>        endif</l>
<l>        enqueue_message (MessageQueues2[1], MessageHandle, [], [])</l>
<l>    elseif (ButtonPressed == 1)</l>
<l>        ShowTrainedModel := not ShowTrainedModel</l>
<c>        * Toggle viewing direction</c>
<l>        create_message (MessageHandle)</l>
<l>        set_message_tuple (MessageHandle, 'type', 'replace_object_model')</l>
<l>        set_message_tuple (MessageHandle, 'index', 1)</l>
<l>        if (ShowTrainedModel)</l>
<l>            set_message_tuple (MessageHandle, 'model', ObjectModel3DModelInPose)</l>
<l>        else</l>
<l>            gen_empty_object_model_3d (ObjectModel3DNoPoints)</l>
<l>            set_message_tuple (MessageHandle, 'model', ObjectModel3DNoPoints)</l>
<l>        endif</l>
<l>        enqueue_message (MessageQueues2[1], MessageHandle, [], [])</l>
<l>        create_message (MessageHandle)</l>
<l>        set_message_tuple (MessageHandle, 'type', 'change_button_text')</l>
<l>        set_message_tuple (MessageHandle, 'index', 1)</l>
<l>        if (ShowTrainedModel)</l>
<l>            set_message_tuple (MessageHandle, 'text', 'Hide Trained Model')</l>
<l>        else</l>
<l>            set_message_tuple (MessageHandle, 'text', 'Show Trained Model')</l>
<l>        endif</l>
<l>        enqueue_message (MessageQueues2[1], MessageHandle, [], [])</l>
<l>    endif</l>
<l>endwhile</l>
<c></c>
<l>create_message (MessageHandle)</l>
<l>set_message_tuple (MessageHandle, 'type', 'exit')</l>
<l>enqueue_message (MessageQueues1[1], MessageHandle, [], [])</l>
<l>create_message (MessageHandle)</l>
<l>set_message_tuple (MessageHandle, 'type', 'exit')</l>
<l>enqueue_message (MessageQueues2[1], MessageHandle, [], [])</l>
<c>* </c>
<l>convert_vector_to_tuple (TI, TIT)</l>
<l>par_join (TIT)</l>
<c></c>
<l>return ()</l>
</body>
<docu id="check_visibility">
<parameters>
<parameter id="ObjectModel3DModel"/>
<parameter id="ObjectModel3DScene"/>
<parameter id="SurfaceMatchingResultID"/>
<parameter id="SurfaceModelID"/>
<parameter id="Viewpoint"/>
<parameter id="ViewpointIn"/>
<parameter id="WindowHandle1"/>
<parameter id="WindowHandle2"/>
</parameters>
</docu>
</procedure>
<procedure name="cluster_dl_detection_param" access="local">
<interface>
<ic>
<par name="Values" base_type="ctrl" dimension="0"/>
<par name="K" base_type="ctrl" dimension="0"/>
<par name="MinRatio" base_type="ctrl" dimension="0"/>
<par name="MinDiff" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="ClusteredValues" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c>* This procedure performs clustering on the given input data using</c>
<c>* a simplified 1D k-means algorithm in order to find a small number</c>
<c>* of values which represent the data well.</c>
<c>* </c>
<c>* </c>
<c>* The number of clusters may be changed, set the initial number given</c>
<c>* by the input parameter K.</c>
<l>KCurrent := K</l>
<c>* Stop the clustering iteration if the cluster centers do not change</c>
<c>* more than MaxDelta or after MaxIteration iterations.</c>
<l>MinDelta := 1e-5</l>
<l>MaxIteration := 100</l>
<c>* </c>
<c>* Sort the values in order to generate cluster centers.</c>
<l>Points := sort(Values)</l>
<l>NumPoints := |Points|</l>
<c>* </c>
<c>* Check the inputs.</c>
<l>if (K &lt; 1)</l>
<l>    throw ('K has to be at least 1.')</l>
<l>endif</l>
<l>if (NumPoints &lt; 1)</l>
<l>    throw ('No data to cluster.')</l>
<l>endif</l>
<c>* </c>
<l>Repeat := true</l>
<c>* Repeat as long as the number of clusters is reduced during the iteration.</c>
<l>while (Repeat)</l>
<l>    Repeat := false</l>
<c>    * </c>
<c>    * Initializie the cluster centers by taking points from the input data</c>
<c>    * in equal distances.</c>
<l>    InitialClusterCenters := []</l>
<l>    if (KCurrent &gt; 1)</l>
<l>        Step := NumPoints / (KCurrent - 1)</l>
<l>        for Index := 0 to KCurrent - 2 by 1</l>
<l>            InitialClusterCenters[Index] := Points[Index * Step]</l>
<l>        endfor</l>
<l>        InitialClusterCenters[KCurrent - 1] := Points[NumPoints - 1]</l>
<l>    elseif (KCurrent == 1)</l>
<l>        InitialClusterCenters := Points[NumPoints / 2]</l>
<l>    else</l>
<l>        throw ('Invalid value for K.')</l>
<l>    endif</l>
<c>    * </c>
<c>    * Perform k-means clustering with the given initial cluster centers.</c>
<l>    cluster_kmeans_1d (Points, InitialClusterCenters, MaxIteration, MinDelta, PointClusters, ClusterCenters)</l>
<c>    * It is possible that the number of centers is reduced after the clustering,</c>
<c>    * so read it after the process.</c>
<l>    KCurrent := |ClusterCenters|</l>
<c>    * </c>
<c>    * Check the clusters for the restrictions.</c>
<c>    * </c>
<c>    * Each cluster should contain at least a ratio (MinRatio) of the total number</c>
<c>    * of data points. If at least one cluster does not fulfill this restriction,</c>
<c>    * reduce the number of clusters and redo the clustering.</c>
<l>    MinMembers := MinRatio * NumPoints</l>
<l>    for Index := 0 to PointClusters.length() - 1 by 1</l>
<l>        if (|PointClusters.at(Index)| &lt; MinMembers)</l>
<l>            KCurrent := KCurrent - 1</l>
<l>            Repeat := true</l>
<l>            break</l>
<l>        endif</l>
<l>    endfor</l>
<c>    * </c>
<l>    if (Repeat)</l>
<l>        continue</l>
<l>    endif</l>
<c>    * </c>
<c>    * The cluster centers should have a certain distance from each other</c>
<c>    * (specified with MinDiff). If the centers do not fulfill this restriction,</c>
<c>    * also reduce the number of clusters and redo the clustering.</c>
<l>    ClusterCentersSorted := sort(ClusterCenters)</l>
<l>    Diffs := ClusterCentersSorted[1:|ClusterCentersSorted| - 1] - ClusterCentersSorted[0:|ClusterCentersSorted| - 2]</l>
<l>    if (sum(Diffs [&lt;] MinDiff) &gt; 0)</l>
<l>        KCurrent := KCurrent - 1</l>
<l>        Repeat := true</l>
<l>    endif</l>
<c>    * </c>
<l>endwhile</l>
<c>* </c>
<l>ClusteredValues := ClusterCentersSorted</l>
<c>* </c>
<l>return ()</l>
</body>
<docu id="cluster_dl_detection_param">
<abstract lang="en_US">This procedure performs clustering on the given bounding box parameter values using a simplified 1D k-means algorithm in order to find values which represent the data well. It iterates multiple times over the data tuple and tries to find a good cluster representation for the data. The returned ClusteredValues are the centers of each of the found clusters and therefore the representatives for the given input data.

The data values to be clustered are given by Values. The parameter K specifies the initial number of cluster centers. During the algorithm, it is possible that small clusters are fused together, so the resulting number of clusters is always a value equal to or less than K. The minimum number of data points each cluster needs to at least have is specified by MinRatio. This value is given as a ratio of the total number of data points in the input tuple. If a cluster does not have enough data points, the number of clusters is reduced. Furthermore, the cluster centers need to have a minimum distance between each other which is specified by MinDiff. If the distance of two centers is less than MinDiff, the number of clusters is reduced.
</abstract>
<chapters lang="en_US">
<item>Deep Learning</item>
<item>Object Detection</item>
</chapters>
<library lang="en_US">MVTec Standard Procedures</library>
<short lang="en_US">This procedure performs k-means clustering on the given parameter values.</short>
<parameters>
<parameter id="ClusteredValues">
<default_type>real</default_type>
<description lang="en_US">Resulting cluster centers.</description>
<mixed_type>false</mixed_type>
<multivalue>optional</multivalue>
<sem_type>real</sem_type>
<type_list>
<item>real</item>
</type_list>
</parameter>
<parameter id="K">
<default_type>integer</default_type>
<description lang="en_US">Number of initial clusters.</description>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>integer</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="MinDiff">
<default_type>real</default_type>
<default_value>0.2</default_value>
<description lang="en_US">Minimum distance between two cluster centers.</description>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>real</sem_type>
<type_list>
<item>real</item>
</type_list>
</parameter>
<parameter id="MinRatio">
<default_type>real</default_type>
<default_value>0.01</default_value>
<description lang="en_US">Relative number of data points a cluster needs to have to be regarded as representative.</description>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>real</sem_type>
<type_list>
<item>real</item>
</type_list>
</parameter>
<parameter id="Values">
<default_type>real</default_type>
<description lang="en_US">Input parameter values to be clustered.</description>
<mixed_type>false</mixed_type>
<multivalue>optional</multivalue>
<sem_type>real</sem_type>
<type_list>
<item>real</item>
</type_list>
</parameter>
</parameters>
</docu>
</procedure>
<procedure name="cluster_kmeans_1d" access="local">
<interface>
<ic>
<par name="Points" base_type="ctrl" dimension="0"/>
<par name="InitialClusterCenters" base_type="ctrl" dimension="0"/>
<par name="MaxIteration" base_type="ctrl" dimension="0"/>
<par name="MinDelta" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="PointClusters" base_type="ctrl" dimension="1"/>
<par name="ClusterCenters" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c>* This procedure performs clustering on the given</c>
<c>* data points with the specified initial cluster centers.</c>
<c>* </c>
<l>ClusterCenters := InitialClusterCenters</l>
<l>NumClusters := |ClusterCenters|</l>
<l>NumPoints := |Points|</l>
<c>* </c>
<l>for Iteration := 0 to MaxIteration - 1 by 1</l>
<c>    * Initialize new cluster vector to store clustered points.</c>
<l>    for CIdx := 0 to NumClusters - 1 by 1</l>
<l>        Clusters.at(CIdx) := []</l>
<l>    endfor</l>
<c>    * Assign each point to the closest cluster center.</c>
<l>    for PIdx := 0 to NumPoints - 1 by 1</l>
<l>        CurrentPoint := Points[PIdx]</l>
<l>        Distances := abs(ClusterCenters - CurrentPoint)</l>
<l>        ClusterIndex := find_first(Distances,min(Distances))</l>
<l>        Clusters.at(ClusterIndex) := [Clusters.at(ClusterIndex),CurrentPoint]</l>
<l>    endfor</l>
<c>    * Check that all clusters have at least one data point.</c>
<c>    * If not -&gt; remove the cluster and the corresponding center.</c>
<l>    for CIdx := NumClusters - 1 to 0 by -1</l>
<l>        if (|Clusters.at(CIdx)| == 0)</l>
<l>            Clusters.remove(CIdx)</l>
<l>            ClusterCenters := remove(ClusterCenters,CIdx)</l>
<l>            NumClusters := NumClusters - 1</l>
<l>        endif</l>
<l>    endfor</l>
<c>    * Update cluster centers based on point clusters.</c>
<l>    ClusterChanged := false</l>
<l>    for CIdx := 0 to NumClusters - 1 by 1</l>
<l>        ClusterCenterNew := mean(Clusters.at(CIdx))</l>
<l>        if (abs(ClusterCenterNew - ClusterCenters[CIdx]) &gt; MinDelta)</l>
<l>            ClusterCenters[CIdx] := ClusterCenterNew</l>
<l>            ClusterChanged := true</l>
<l>        endif</l>
<l>    endfor</l>
<c>    * If clusters did not change, exit early.</c>
<l>    if (not ClusterChanged)</l>
<l>        break</l>
<l>    endif</l>
<l>endfor</l>
<c>* </c>
<l>PointClusters := Clusters</l>
<c>* </c>
<l>return ()</l>
</body>
<docu id="cluster_kmeans_1d">
<abstract lang="en_US">This procedure clusters the given data Points with the specified initial cluster centers InitialClusterCenters. It returns the optimized cluster centers ClusterCenters and the clustered data points PointClusters.

To do so, the algorithm iterates over the following steps:

1. The data points are assigned to the cluster with the closest center value.
2. After the points are clustered, a new center is calculated for each cluster and the points are clustered again.

These steps are repeated until the center values remain stable (which means that they change less than MinDelta) or the maximum number of iterations MaxIteration is reached.</abstract>
<chapters lang="en_US">
<item>Deep Learning</item>
<item>Object Detection</item>
</chapters>
<library lang="en_US">MVTec Standard Procedures</library>
<short lang="en_US">This procedure clusters the given data Points with the specified initial cluster centers InitialClusterCenters. It returns the optimized cluster centers ClusterCenters and the clustered data points PointClusters.</short>
<parameters>
<parameter id="ClusterCenters">
<default_type>real</default_type>
<description lang="en_US">Centers of the result clusters. </description>
<mixed_type>false</mixed_type>
<multivalue>optional</multivalue>
<sem_type>real</sem_type>
<type_list>
<item>real</item>
</type_list>
</parameter>
<parameter id="InitialClusterCenters">
<default_type>real</default_type>
<description lang="en_US">Initial values for the cluster centers.</description>
<mixed_type>false</mixed_type>
<multivalue>optional</multivalue>
<sem_type>real</sem_type>
<type_list>
<item>real</item>
</type_list>
</parameter>
<parameter id="MaxIteration">
<default_type>integer</default_type>
<description lang="en_US">Maximum number of iterations.</description>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>integer</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="MinDelta">
<default_type>real</default_type>
<description lang="en_US">Minimum difference between an old and a new cluster center value to consider it to be a new center for a new iteration.</description>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>real</sem_type>
<type_list>
<item>real</item>
</type_list>
</parameter>
<parameter id="PointClusters">
<default_type>real</default_type>
<description lang="en_US">Clustered data points.</description>
<mixed_type>false</mixed_type>
<multivalue>optional</multivalue>
<sem_type>real</sem_type>
<type_list>
<item>real</item>
</type_list>
</parameter>
<parameter id="Points">
<default_type>real</default_type>
<description lang="en_US">Data points to be clustered.</description>
<mixed_type>false</mixed_type>
<multivalue>optional</multivalue>
<sem_type>real</sem_type>
<type_list>
<item>real</item>
</type_list>
</parameter>
</parameters>
</docu>
</procedure>
<procedure name="collect_single_image_calibration_data">
<interface>
<ic>
<par name="ImageCaltabFileName" base_type="ctrl" dimension="0"/>
<par name="CalPlateDescr" base_type="ctrl" dimension="0"/>
<par name="CalPlateThickness" base_type="ctrl" dimension="0"/>
<par name="StartCamParam" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="CalibObjectData" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c>* </c>
<c>* Read an image of the calibration plate</c>
<c>* that is placed in the measurement plane of the robot.</c>
<l>read_image (ImageCaltab, ImageCaltabFileName)</l>
<l>dev_disp_calibration_data_instructions (ImageCaltab)</l>
<l>stop ()</l>
<c>* </c>
<c>* Specify the finder pattern of the calibration plate you used.</c>
<c>* The information can usually be found in the used description file.</c>
<l>FinderRow := [13,6,6,20,20]</l>
<l>FinderColumn := [15,6,24,6,24]</l>
<c>* Specify the number of marks per row.</c>
<l>MarksPerRow := 31</l>
<c>* </c>
<c>* Create output dict.</c>
<l>create_dict (CalibObjectData)</l>
<l>set_dict_object (ImageCaltab, CalibObjectData, 'ImageCaltab')</l>
<l>set_dict_tuple (CalibObjectData, 'CalPlateDescr', CalPlateDescr)</l>
<l>set_dict_tuple (CalibObjectData, 'CalPlateThickness', CalPlateThickness)</l>
<l>set_dict_tuple (CalibObjectData, 'StartCamParam', StartCamParam)</l>
<l>set_dict_tuple (CalibObjectData, 'FinderRow', FinderRow)</l>
<l>set_dict_tuple (CalibObjectData, 'FinderColumn', FinderColumn)</l>
<l>set_dict_tuple (CalibObjectData, 'MarksPerRow', MarksPerRow)</l>
<l>return ()</l>
</body>
<docu id="collect_single_image_calibration_data">
<abstract lang="en_US">This procedure helps you collect the data for the procedure calibrate_camera_and_plane_single_image. The collected data is stored in the output dict CalibObjectData.

The parameter ImageCaltabFileName is the image of the observed calibration plate. The corresponding description file has to be specified in the parameter CalPlateDescr. The starting parameters of the camera have to be passed in the parameter StartCamParam. In order to compensate a potential thickness of the calibration plate, the parameter CalPlateThickness has to be set to a value greater 0.0.</abstract>
<chapters lang="de_DE">
<item>Kalibrierung</item>
<item>Monokular</item>
</chapters>
<chapters lang="en_US">
<item>Calibration</item>
<item>Monocular</item>
</chapters>
<library lang="en_US">MVTec Standard Procedures</library>
<short lang="en_US">Collect the data to calibrate a camera with a single image.</short>
<successor>
<item>calibrate_camera_and_plane_single_image</item>
<item>get_dict_tuple</item>
</successor>
<parameters>
<parameter id="CalPlateDescr">
<default_type>string</default_type>
<description lang="en_US"> Description file of the used calibration plate.</description>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>string</sem_type>
<type_list>
<item>string</item>
</type_list>
</parameter>
<parameter id="CalPlateThickness">
<description lang="en_US">Thickness of the used calibration plate.</description>
</parameter>
<parameter id="CalibObjectData">
<default_type>integer</default_type>
<description lang="en_US">Calibration data.</description>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>dict</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="ImageCaltabFileName">
<default_type>string</default_type>
<description lang="en_US">Image of the observed calibration plate.</description>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>string</sem_type>
<type_list>
<item>string</item>
</type_list>
</parameter>
<parameter id="StartCamParam">
<description lang="en_US">Starting parameters of the camera.</description>
</parameter>
</parameters>
</docu>
</procedure>
<procedure name="collect_train_dl_model_info" access="local">
<interface>
<ic>
<par name="DLModelHandle" base_type="ctrl" dimension="0"/>
<par name="TrainResults" base_type="ctrl" dimension="0"/>
<par name="EvaluationInfos" base_type="ctrl" dimension="0"/>
<par name="EvaluationComparisonKeys" base_type="ctrl" dimension="0"/>
<par name="Iteration" base_type="ctrl" dimension="0"/>
<par name="NumIterations" base_type="ctrl" dimension="0"/>
<par name="NumIterationsPerEpoch" base_type="ctrl" dimension="0"/>
<par name="NumSamplesMeanLoss" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="TrainInfo" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c>* </c>
<c>* This procedure computes training information for the given iteration.</c>
<c>* </c>
<l>create_dict (TrainInfo)</l>
<c>* </c>
<c>* General iteration and epoch status.</c>
<l>EpochReal := (Iteration + 1) / real(NumIterationsPerEpoch)</l>
<c>* Important note:</c>
<c>* Inside of this procedure, we compute iterations like that:</c>
<c>* *  IterationTmp := int(round(EpochReal * (NumIterationsPerEpoch))-1)</c>
<c>* If a caller of this procedure supplies a value we should use:</c>
<c>* *  IterationTmp := int(floor(EpochReal * NumIterationsPerEpoch))</c>
<c>* </c>
<l>NumEpochs := int(NumIterations / real(NumIterationsPerEpoch))</l>
<c>* </c>
<c>* Note, iterations depend on a specific batch size,</c>
<c>* hence only epochs are expressive.</c>
<l>set_dict_tuple (TrainInfo, 'epoch', EpochReal)</l>
<l>set_dict_tuple (TrainInfo, 'num_epochs', NumEpochs)</l>
<c>* </c>
<l>try</l>
<l>    TrainResultsStored := TrainResults[find(TrainResults [!=] -1,true)]</l>
<l>catch (Exception)</l>
<l>    TrainResultsStored := []</l>
<l>endtry</l>
<c>* </c>
<c>* Collect all model parameters.</c>
<l>get_dl_model_param (DLModelHandle, 'type', ModelType)</l>
<l>get_param_info ('get_dl_model_param', 'GenParamName', 'value_list', PossibleParamNames)</l>
<l>create_dict (ModelParams)</l>
<l>set_dict_tuple (TrainInfo, 'model_params', ModelParams)</l>
<l>ParamNamesGettable := []</l>
<l>for Index := 0 to |PossibleParamNames| - 1 by 1</l>
<l>    ParamName := PossibleParamNames[Index]</l>
<c>    * Do not collect summary as it cannot change during training and consumes much space.</c>
<l>    if (ParamName == 'summary')</l>
<l>        continue</l>
<l>    endif</l>
<l>    try</l>
<l>        get_dl_model_param (DLModelHandle, ParamName, GenParamValue)</l>
<l>    catch (Exception)</l>
<l>        continue</l>
<l>    endtry</l>
<l>    ParamNamesGettable := ParamName</l>
<l>    set_dict_tuple (ModelParams, ParamName, GenParamValue)</l>
<l>endfor</l>
<c>* </c>
<c>* Calculate a mean loss value.</c>
<l>set_dict_tuple (TrainInfo, 'mean_loss', [])</l>
<l>set_dict_tuple (TrainInfo, 'mean_loss_samples', 0)</l>
<c>* </c>
<l>LossSamplesTrainResults := []</l>
<l>tuple_find (TrainResults [!=] -1, 1, Indices)</l>
<l>if (Indices != -1)</l>
<l>    TrainResultsUsed := TrainResults[Indices]</l>
<l>else</l>
<l>    TrainResultsUsed := []</l>
<l>endif</l>
<l>if (|TrainResultsUsed| &gt; 0)</l>
<l>    get_dl_model_param (DLModelHandle, 'batch_size', BatchSizeDevice)</l>
<l>    get_dl_model_param (DLModelHandle, 'batch_size_multiplier', BatchSizeMultiplier)</l>
<l>    BatchSize := BatchSizeDevice * BatchSizeMultiplier</l>
<l>    NumIterationsMean := int(ceil(NumSamplesMeanLoss / real(BatchSize)))</l>
<c>    * </c>
<l>    if (NumIterationsMean == 0)</l>
<l>        TrainResultsUsed := TrainResultsUsed[|TrainResultsUsed| - 1]</l>
<l>    else</l>
<l>        TrainResultsUsed := TrainResultsUsed[max2(|TrainResultsUsed| - NumIterationsMean,0):|TrainResultsUsed| - 1]</l>
<l>    endif</l>
<c>    * </c>
<l>    LossParam := 'total_loss'</l>
<l>    tuple_gen_const (|TrainResultsUsed|, -1, LossValues)</l>
<l>    for Index := 0 to |TrainResultsUsed| - 1 by 1</l>
<l>        TrainResult := TrainResultsUsed[Index]</l>
<l>        get_dict_tuple (TrainResult, LossParam, LossValue)</l>
<l>        LossValues[Index] := LossValue</l>
<l>    endfor</l>
<l>    LossMean := mean(LossValues)</l>
<l>    set_dict_tuple (TrainInfo, 'mean_loss', LossMean)</l>
<l>    set_dict_tuple (TrainInfo, 'mean_loss_samples', |LossValues|)</l>
<l>endif</l>
<c>* </c>
<c>* Collect the best evaluation infos.</c>
<l>BestEvaluationInfo := []</l>
<l>BestEvaluationInfoTrain := []</l>
<l>BestEvaluationValue := []</l>
<l>BestEvaluationValueTrain := []</l>
<l>BestEvaluationKeys := []</l>
<l>BestEvaluationKeysTrain := []</l>
<l>for Index := 0 to |EvaluationInfos| - 1 by 1</l>
<l>    EvaluationInfo := EvaluationInfos[Index]</l>
<c>    * Ignore missing infos</c>
<l>    if (EvaluationInfo == -1)</l>
<l>        continue</l>
<l>    endif</l>
<c>    * </c>
<l>    get_dict_tuple (EvaluationInfo, 'result', ValidationEvaluationResult)</l>
<l>    get_dict_tuple (EvaluationInfo, 'result_train', TrainEvaluationResult)</l>
<c>    * </c>
<c>    * Reduce the result to a single (mean) value.</c>
<l>    reduce_dl_evaluation_result (ValidationEvaluationResult, EvaluationComparisonKeys, Value, ValidEvaluationKeys)</l>
<l>    reduce_dl_evaluation_result (TrainEvaluationResult, EvaluationComparisonKeys, ValueTrain, ValidEvaluationKeysTrain)</l>
<c>    * </c>
<c>    * Compare current evaluation result with the best one.</c>
<l>    if (ModelType == 'classification')</l>
<c>        * Validation.</c>
<l>        if (|BestEvaluationInfo| == 0 or Value &lt;= BestEvaluationValue)</l>
<l>            BestEvaluationInfo := EvaluationInfo</l>
<l>            BestEvaluationValue := Value</l>
<l>            BestEvaluationKeys := ValidEvaluationKeys</l>
<l>        endif</l>
<c>        * Training.</c>
<l>        if (|BestEvaluationInfoTrain| == 0 or ValueTrain &lt;= BestEvaluationValueTrain)</l>
<l>            BestEvaluationInfoTrain := EvaluationInfo</l>
<l>            BestEvaluationValueTrain := ValueTrain</l>
<l>            BestEvaluationKeysTrain := ValidEvaluationKeysTrain</l>
<l>        endif</l>
<l>    else</l>
<c>        * Validation.</c>
<l>        if (|BestEvaluationInfo| == 0 or Value &gt;= BestEvaluationValue)</l>
<l>            BestEvaluationInfo := EvaluationInfo</l>
<l>            BestEvaluationValue := Value</l>
<l>            BestEvaluationKeys := ValidEvaluationKeys</l>
<l>        endif</l>
<c>        * Training.</c>
<l>        if (|BestEvaluationInfoTrain| == 0 or ValueTrain &gt;= BestEvaluationValueTrain)</l>
<l>            BestEvaluationInfoTrain := EvaluationInfo</l>
<l>            BestEvaluationValueTrain := ValueTrain</l>
<l>            BestEvaluationKeysTrain := ValidEvaluationKeysTrain</l>
<l>        endif</l>
<l>    endif</l>
<l>endfor</l>
<c>* </c>
<c>* Store best evaluation information.</c>
<l>if (|BestEvaluationInfo| &gt; 0)</l>
<l>    create_dict (BestEvaluationData)</l>
<l>    set_dict_tuple (BestEvaluationData, 'comparison_keys', BestEvaluationKeys)</l>
<l>    set_dict_tuple (BestEvaluationData, 'best_info', BestEvaluationInfo)</l>
<l>    set_dict_tuple (BestEvaluationData, 'best_value', BestEvaluationValue)</l>
<l>    set_dict_tuple (BestEvaluationData, 'comparison_keys_train', BestEvaluationKeysTrain)</l>
<l>    set_dict_tuple (BestEvaluationData, 'best_info_train', BestEvaluationInfoTrain)</l>
<l>    set_dict_tuple (BestEvaluationData, 'best_value_train', BestEvaluationValueTrain)</l>
<l>    set_dict_tuple (TrainInfo, 'best_evaluation', BestEvaluationData)</l>
<l>else</l>
<l>    set_dict_tuple (TrainInfo, 'best_evaluation', [])</l>
<l>endif</l>
<c>* </c>
<l>return ()</l>
</body>
<docu id="collect_train_dl_model_info">
<abstract lang="en_US">This procedure collects the important information related to the training progress.

The collected information can be used by other procedures for example to generate visualizations.
Thereby, a mean loss can be calculated using NumSamplesMeanLoss. Calculating a mean loss value is helpful in stochastic gradient descent, because each iteration only covers a small portion of the training data.
</abstract>
<chapters lang="de_DE">
<item>Deep Learning</item>
<item>Modell</item>
</chapters>
<chapters lang="en_US">
<item>Deep Learning</item>
<item>Model</item>
</chapters>
<library lang="en_US">MVTec Standard Procedures</library>
<short lang="en_US">Collect the information required for displaying the training progress update.</short>
<parameters>
<parameter id="DLModelHandle">
<default_type>integer</default_type>
<description lang="en_US">Handle of the deep-learning-based model.</description>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>dl_model</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="EvaluationComparisonKeys"/>
<parameter id="EvaluationInfos"/>
<parameter id="Iteration"/>
<parameter id="NumIterations"/>
<parameter id="NumIterationsPerEpoch">
<default_type>integer</default_type>
<default_value>[]</default_value>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>integer</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="NumSamplesMeanLoss">
<default_type>integer</default_type>
<default_value>100</default_value>
<description lang="en_US">Number of samples to use for the mean loss. </description>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>integer</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="TrainInfo">
<default_type>integer</default_type>
<description lang="en_US">Dictionary or tuple of dictionaries with the summarized training status information.</description>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>dict</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="TrainResults"/>
</parameters>
</docu>
</procedure>
<procedure name="color_string_to_rgb">
<interface>
<ic>
<par name="Color" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="RGB" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<l>open_window (0, 0, 1, 1, 0, 'buffer', '', WindowHandleBuffer)</l>
<l>set_part (WindowHandleBuffer, 0, 0, -1, -1)</l>
<l>gen_rectangle1 (Rectangle, 0, 0, 0, 0)</l>
<l>try</l>
<l>    set_color (WindowHandleBuffer, Color)</l>
<l>catch (Exception)</l>
<l>    Exception := 'Wrong value of control parameter Color (must be a valid color string)'</l>
<l>    throw (Exception)</l>
<l>endtry</l>
<l>disp_obj (Rectangle, WindowHandleBuffer)</l>
<l>dump_window_image (Image, WindowHandleBuffer)</l>
<l>close_window (WindowHandleBuffer)</l>
<l>get_grayval (Image, 0, 0, RGB)</l>
<l>RGB := RGB + [0,0,0]</l>
<l>return ()</l>
</body>
<docu id="color_string_to_rgb">
<chapters lang="de_DE">
<item>Graphik</item>
<item>Parameter</item>
</chapters>
<chapters lang="en_US">
<item>Graphics</item>
<item>Parameters</item>
</chapters>
<library lang="en_US">MVTec Standard Procedures</library>
<parameters>
<parameter id="Color"/>
<parameter id="RGB"/>
</parameters>
</docu>
</procedure>
<procedure name="compute_dl_anomaly_thresholds">
<interface>
<ic>
<par name="DLModelHandle" base_type="ctrl" dimension="0"/>
<par name="DLDataset" base_type="ctrl" dimension="0"/>
<par name="GenParam" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="AnomalySegmentationThreshold" base_type="ctrl" dimension="0"/>
<par name="AnomalyClassificationThresholds" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c>* This procedure estimates two different thresholds used in deep-learning-based anomaly detection.</c>
<c>* These thresholds are used for:</c>
<c>* 1) Region segmentation: AnomalySegmentationThreshold can be used as threshold</c>
<c>*     whether a pixel within the anomaly image belongs to a region of an anomaly.</c>
<c>*    The threshold is estimated based on the samples in the validation split of DLDataset.</c>
<c>* 2) Image classification: AnomalyClassificationThresholds can be used as threshold</c>
<c>*    whether the image is counted as containing an anomaly.</c>
<c>*    It consists of a tuple with the following values:</c>
<c>*  - the maximal anomaly score obtianed for the ok test samples</c>
<c>*  - the minimal anomaly score obtained for the nok test samples</c>
<c>*  - an intermediate threshold for the anomaly scores that minimizes</c>
<c>*      the sum of the false negative rate and the false positive rate.</c>
<c>*    Note, the latter two values are only calculated if nok test samples are available.</c>
<c>* </c>
<c>* Check model type.</c>
<l>get_dl_model_param (DLModelHandle, 'type', ModelType)</l>
<l>if (ModelType != 'anomaly_detection')</l>
<l>    throw ('This procedure can only be used for models of type \'anomaly_detection\'.')</l>
<l>endif</l>
<c>* </c>
<c>* Get sample entries in DLDataset.</c>
<l>get_dict_tuple (DLDataset, 'samples', DLSamples)</l>
<c>* </c>
<c>* Check whether the dataset is split.</c>
<l>get_dict_param (DLSamples[0], 'key_exists', 'split', SplitExists)</l>
<l>if (not SplitExists)</l>
<l>    throw ('This procedure can only be used if DLDataset has already been split.')</l>
<l>endif</l>
<c>* </c>
<c>* Test GenParam whether 'nok' samples should be processed.</c>
<l>UseOkSamplesOnly := false</l>
<l>if (GenParam != [])</l>
<l>    get_dict_param (GenParam, 'key_exists', 'use_ok_samples_only', UseOkSamplesOnlyExists)</l>
<l>    if (UseOkSamplesOnlyExists)</l>
<l>        get_dict_tuple (GenParam, 'use_ok_samples_only', UseOkSamplesOnlyKey)</l>
<l>        if (UseOkSamplesOnlyKey == 'true' or UseOkSamplesOnlyKey == true)</l>
<l>            UseOkSamplesOnly := true</l>
<l>        endif</l>
<l>    endif</l>
<l>endif</l>
<c>* </c>
<c>* Determine the threshold for region segmentation: AnomalySegmentationThreshold.</c>
<c>* </c>
<c>* Get the samples in the validation split.</c>
<l>find_dl_samples (DLSamples, 'split', 'validation', 'or', ValidationIndices)</l>
<c>* If the validation split is empty, the segmentation threshold cannot be estimated.</c>
<l>if (|ValidationIndices| == 0)</l>
<l>    throw ('This procedure can only be used with at least one validation image.')</l>
<l>endif</l>
<c>* </c>
<l>read_dl_samples (DLDataset, ValidationIndices, ValidationSamples)</l>
<c>* </c>
<c>* Get the gray values of the anomaly images for the validation split.</c>
<l>apply_dl_model (DLModelHandle, ValidationSamples, [], ValidationResults)</l>
<l>Values := []</l>
<l>for Index := 0 to |ValidationResults| - 1 by 1</l>
<l>    get_dict_object (AnomalyImage, ValidationResults[Index], 'anomaly_image')</l>
<l>    get_domain (AnomalyImage, Domain)</l>
<l>    get_region_points (Domain, Rows, Columns)</l>
<l>    get_grayval (AnomalyImage, Rows, Columns, Grayval)</l>
<l>    Values := [Values,Grayval]</l>
<l>endfor</l>
<c>* </c>
<c>* Compute the estimated threshold.</c>
<c>* We take the mean of the anomaly images plus four times their standard deviation.</c>
<c>* This ensures that almost all gray values in the anomaly images</c>
<c>* of the validation samples are below threshold, while the estimate</c>
<c>* is still robust against unexpected outliers.</c>
<l>StandardDeviationFactor := 4.0</l>
<l>AnomalySegmentationThreshold := mean(Values) + StandardDeviationFactor * deviation(Values)</l>
<c>* </c>
<c>* Determine the thresholds for anomaly image classification: AnomalyClassificationThresholds.</c>
<c>* </c>
<c>* Get the indices of the ok and nok test samples.</c>
<l>find_dl_samples (DLSamples, 'split', 'test', 'or', TestIndices)</l>
<l>find_dl_samples (DLSamples, 'anomaly_label', 'nok', 'or', TestIndicesNOK)</l>
<l>TestIndicesOK := difference(TestIndices,TestIndicesNOK)</l>
<c>* </c>
<l>if (|TestIndicesOK| == 0)</l>
<c>    * No thresholds are computed.</c>
<l>    throw ('This procedure requires at least one test image labeled as \'ok\'.')</l>
<l>endif</l>
<c>* </c>
<c>* Compute the anomaly scores of the ok test samples</c>
<l>read_dl_samples (DLDataset, TestIndicesOK, TestSamplesOK)</l>
<l>apply_dl_model (DLModelHandle, TestSamplesOK, [], TestResultsOK)</l>
<l>AnomalyScoresOK := gen_tuple_const(|TestResultsOK|,0.0)</l>
<l>for Index := 0 to |TestResultsOK| - 1 by 1</l>
<l>    get_dict_tuple (TestResultsOK[Index], 'anomaly_score', AnomalyScore)</l>
<l>    AnomalyScoresOK[Index] := AnomalyScore</l>
<l>endfor</l>
<c>* </c>
<c>* In case only test samples labeled as ok are used,</c>
<c>* only one anomaly image classification threshold is returned.</c>
<l>if (|TestIndicesNOK| == 0 or UseOkSamplesOnly)</l>
<l>    AnomalyClassificationThresholds := max(AnomalyScoresOK)</l>
<l>else</l>
<c>    * Compute the anomaly scores of the nok test samples.</c>
<l>    read_dl_samples (DLDataset, TestIndicesNOK, TestSamplesNOK)</l>
<l>    apply_dl_model (DLModelHandle, TestSamplesNOK, [], TestResultsNOK)</l>
<l>    AnomalyScoresNOK := gen_tuple_const(|TestResultsNOK|,0.0)</l>
<l>    for Index := 0 to |TestResultsNOK| - 1 by 1</l>
<l>        get_dict_tuple (TestResultsNOK[Index], 'anomaly_score', AnomalyScore)</l>
<l>        AnomalyScoresNOK[Index] := AnomalyScore</l>
<l>    endfor</l>
<c>    * Get minimum and maximum values of the anomaly scores.</c>
<l>    MinScoreOK := min(AnomalyScoresOK)</l>
<l>    MaxScoreOK := max(AnomalyScoresOK)</l>
<l>    MinScoreNOK := min(AnomalyScoresNOK)</l>
<l>    MaxScoreNOK := max(AnomalyScoresNOK)</l>
<l>    if (MaxScoreOK &lt;= MinScoreNOK)</l>
<c>        * In this case the ok and nok samples can be perfectly separated</c>
<c>        * by a threshold.</c>
<l>        IntermediateThreshold := (MaxScoreOK + MinScoreNOK) / 2</l>
<l>    else</l>
<c>        * In this case there will be false positives or false negatives</c>
<c>        * for any threshold.</c>
<c>        * </c>
<c>        * Compute the histograms of the ok and nok scores.</c>
<l>        MinScore := min2(MinScoreOK,MinScoreNOK)</l>
<l>        MaxScore := max2(MaxScoreOK,MaxScoreNOK)</l>
<l>        tuple_histo_range (AnomalyScoresOK, MinScore, MaxScore, |TestIndices|, HistoOK, BinSizeOK)</l>
<l>        tuple_histo_range (AnomalyScoresNOK, MinScore, MaxScore, |TestIndices|, HistoNOK, BinSizeNOK)</l>
<c>        * </c>
<c>        * Normalize and cumulate the histograms by the number of samples.</c>
<l>        HistoOKNormalized := real(HistoOK) / real(|AnomalyScoresOK|)</l>
<l>        HistoOKCumul := cumul(HistoOKNormalized)</l>
<l>        HistoNOKNormalized := real(HistoNOK) / real(|AnomalyScoresNOK|)</l>
<l>        HistoNOKCumul := cumul(HistoNOKNormalized)</l>
<c>        * </c>
<c>        * Entries of HistoOKCumul and HistoNOKCumul with the same index correspond</c>
<c>        * to the true negative rate and the false negative rate for a fixed threshold.</c>
<c>        * We search a threshold for which the sum of the false positive rate and</c>
<c>        * the false negative rate is minimized. This yields the same threshold</c>
<c>        * as minimizing the difference of the false negative rate and the true negative rate.</c>
<c>        * </c>
<c>        * We prepend a 0 to both tuples to include the lower boundary of the</c>
<c>        * histograms (zero false negatives and zero true negatives).</c>
<l>        FnrTnrDiff := [0,HistoNOKCumul] - [0,HistoOKCumul]</l>
<l>        MinFnrTnrDiff := min(FnrTnrDiff)</l>
<c>        * </c>
<c>        * As the minimum is not necessarily unique, we select the point for which</c>
<c>        * the false negative rate is the lowest.</c>
<l>        ThresholdIndex := find_first(FnrTnrDiff,MinFnrTnrDiff)</l>
<l>        IntermediateThreshold := MinScore + ThresholdIndex * BinSizeOK</l>
<c>        * </c>
<c>        * In some cases IntermediateThreshold may be smaller than MinScoreNOK.</c>
<c>        * We set it to at least that value.</c>
<l>        IntermediateThreshold := max2(IntermediateThreshold,MinScoreNOK)</l>
<c>        * </c>
<l>    endif</l>
<c>    * Set the tuple of anomaly classification thresholds.</c>
<l>    AnomalyClassificationThresholds := [MaxScoreOK,MinScoreNOK,IntermediateThreshold]</l>
<l>endif</l>
<c></c>
<l>return ()</l>
</body>
<docu id="compute_dl_anomaly_thresholds">
<abstract lang="en_US">This procedure estimates two different thresholds used in deep-learning-based anomaly detection.
To do so, the anomaly detection model given in DLModelHandle uses the preprocessed data given in DLDataset.

These thresholds are:
- AnomalySegmentationThreshold - Region segmentation.
   This threshold value can be used to determine whether a pixel within the anomaly image belongs to a region of an anomaly.
   The threshold is estimated based on the samples in the validation split of DLDataset.
   Some gray values above the threshold are allowed in order to make the estimate more robust with respect to outliers.
- AnomalyClassificationThresholds - Image classification.
   Each of these threshold values can be used to determine whether the image is counted as containing an anomaly.
   The tuple contains the following values (sorted by their index):
   0: the maximal anomaly score obtained for the 'ok' test samples.
      Using this threshold to separate 'ok' and 'nok' samples ensures that there are no 'ok' samples in the test set that are falsely classified as 'nok' (false positives).
   1: the minimal anomaly score obtained for the 'nok' test samples.
       Using this threshold to separate 'ok' and 'nok' samples ensures that there are no 'nok' samples in the test set that are falsely classified as 'ok' (false negatives).
   2: an intermediate threshold seeking to find a tradeoff between the false negative rate and the false positive rate.
      It is chosen such that the sum of these is minimal. If there are several thresholds that fulfill this condition, the one yielding the lowest false negative rate is chosen.
   Note, the latter two values are only calculated if 'nok' test samples are available.

The optional dictionary GenParam can be used for further specifications. For this purpose, the following entry can be set:
- 'use_ok_samples_only' (default: false): Determine whether only 'ok' samples in the test split are processed when determining AnomalyClassificationThresholds (true). Doing so, only the first entry is returned in AnomalyClassificationThresholds.</abstract>
<chapters lang="en_US">
<item>Deep Learning</item>
<item>Anomaly Detection</item>
</chapters>
<library lang="en_US">MVTec Standard Procedures</library>
<short lang="en_US">Compute thresholds for DL Anomaly Detection.</short>
<parameters>
<parameter id="AnomalyClassificationThresholds">
<default_type>real</default_type>
<description lang="en_US">The computed thresholds for the separation of 'ok' and 'nok' samples based on their anomaly scores.</description>
<multivalue>optional</multivalue>
<sem_type>real</sem_type>
<type_list>
<item>real</item>
</type_list>
</parameter>
<parameter id="AnomalySegmentationThreshold">
<default_type>real</default_type>
<description lang="en_US">Estimated threshold that can be used for the segmentation of the anomaly images.</description>
<sem_type>real</sem_type>
<type_list>
<item>real</item>
</type_list>
<value_max>1.000000</value_max>
<value_min>0.000000</value_min>
</parameter>
<parameter id="DLDataset">
<default_type>integer</default_type>
<description lang="en_US">Dictionary containing information about the dataset.</description>
<mixed_type>false</mixed_type>
<sem_type>dict</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="DLModelHandle">
<default_type>integer</default_type>
<description lang="en_US">Handle of the anomaly detection model.</description>
<mixed_type>false</mixed_type>
<sem_type>dl_model</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="GenParam">
<default_type>integer</default_type>
<default_value>[]</default_value>
<description lang="en_US">Dictionary containing the generic parameters.</description>
<mixed_type>false</mixed_type>
<sem_type>dict</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
</parameters>
</docu>
</procedure>
<procedure name="compute_top_k_error" access="local">
<interface>
<ic>
<par name="DLClassifierHandle" base_type="ctrl" dimension="0"/>
<par name="DLClassifierResultID" base_type="ctrl" dimension="0"/>
<par name="GroundTruthLabels" base_type="ctrl" dimension="0"/>
<par name="Indices" base_type="ctrl" dimension="0"/>
<par name="K" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="TopKError" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c>* This procedure compares the GroundtruthLabels</c>
<c>* with the K inferred classes of highest probability,</c>
<c>* stored in DLClassifierResultID, and returns the TopKError.</c>
<c>* Indices defines which images (and thus GroundTruthLabels</c>
<c>* as well as inference results) are considered.</c>
<l>NumMatches := 0</l>
<c>* </c>
<c>* Select the chosen GroundTruthLabels.</c>
<l>GroundTruthLabelsSelected := GroundTruthLabels[Indices]</l>
<c>* </c>
<c>* Get the batch size from the classifier handle.</c>
<l>get_dl_classifier_param (DLClassifierHandle, 'batch_size', BatchSize)</l>
<c>* </c>
<c>* Loop through all selected ground truth labels.</c>
<l>for IndexLabel := 0 to |GroundTruthLabelsSelected| - 1 by 1</l>
<c>    * Get ground truth label.</c>
<l>    CurrentLabel := GroundTruthLabelsSelected[IndexLabel]</l>
<l>    ResultHandleIndex := int(floor(Indices[IndexLabel] / BatchSize))</l>
<l>    ResultIndex := Indices[IndexLabel] % BatchSize</l>
<l>    get_dl_classifier_result (DLClassifierResultID[ResultHandleIndex], ResultIndex, 'predicted_classes', PredictedClasses)</l>
<c>    * Get the K best results.</c>
<l>    PredictedClasses := PredictedClasses[0:K - 1]</l>
<c>    * Count how often the ground truth label</c>
<c>    * and K predicted classes match.</c>
<l>    if (find(PredictedClasses,CurrentLabel) != -1)</l>
<l>        NumMatches := NumMatches + 1</l>
<l>    endif</l>
<l>endfor</l>
<l>TopKError := 1.0 - (real(NumMatches) / |GroundTruthLabelsSelected|)</l>
<l>return ()</l>
</body>
<docu id="compute_top_k_error">
<abstract lang="en_US">This procedure compares the GroundtruthLabels with the K inferred classes of highest probability, stored in DLClassifierResultID, and returns the TopKError. Indices defines which images (and thus GroundTruthLabels as well as inference results) are considered. The DLClassifierHandle is used to retrieve the batch size.</abstract>
<chapters lang="en_US">
<item>Legacy</item>
<item>DL Classification</item>
</chapters>
<library lang="en_US">MVTec Standard Procedures</library>
<short lang="en_US">Compute the TopK error.</short>
<warning lang="en_US">compute_top_k_error is obsolete and is only provided for reasons of backward compatibility.</warning>
<parameters>
<parameter id="DLClassifierHandle">
<default_type>integer</default_type>
<description lang="en_US">Handle of the deep-learning-based classifier.</description>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>dl_classifier</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="DLClassifierResultID">
<default_type>integer</default_type>
<description lang="en_US">Result handle as returned by apply_dl_classifier and apply_dl_classifier_batchwise.</description>
<mixed_type>false</mixed_type>
<multivalue>optional</multivalue>
<sem_type>dl_classifier_result</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="GroundTruthLabels">
<default_type>string</default_type>
<description lang="en_US">Ground truth labels of your images.</description>
<multivalue>optional</multivalue>
<sem_type>string</sem_type>
<type_list>
<item>string</item>
</type_list>
</parameter>
<parameter id="Indices">
<default_type>integer</default_type>
<description lang="en_US">The indices determine which are labels are compared with the classification results.</description>
<mixed_type>false</mixed_type>
<multivalue>optional</multivalue>
<sem_type>integer</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="K">
<default_type>integer</default_type>
<description lang="en_US">The number of predicted classes that are compared with the ground truth label.</description>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>integer</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="TopKError">
<default_type>real</default_type>
<description lang="en_US">The computed TopK error.</description>
<multivalue>false</multivalue>
<sem_type>real</sem_type>
<type_list>
<item>real</item>
</type_list>
</parameter>
</parameters>
</docu>
</procedure>
<procedure name="convert_decoded_string_code39_to_code32">
<interface>
<ic>
<par name="DecodedDataStringCode39" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="ConvertedDataStringCode32" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c>* This procedure converts a decoded string of a 'Code 32'</c>
<c>* barcode that was read with the bar code reader for 'Code 39'</c>
<c>* to the 'Code 32' decoding.</c>
<c>* </c>
<c>* Basically a 'Code 32' bar code corresponds to a 'Code 39' with</c>
<c>* 8 digits and a checksum digit % 10 whereas even positions are</c>
<c>* weighted twice.</c>
<c>* The 9-digit number is represented to the base 32 and written</c>
<c>* with chars (via the symbol table) analogous to a hexadecimal number.</c>
<c>* </c>
<c>* Initialize symbol table</c>
<l>Symbols := ['0','1','2','3','4','5','6','7','8','9','B','C','D','F','G','H','J','K','L','M','N','P','Q','R','S','T','U','V','W','X','Y','Z']</l>
<c>* Check the chars in the decoded 'Code 39' string.</c>
<c>* It must consist of exactly 6 chars and must not</c>
<c>* contain any invalid chars. If these conditions are</c>
<c>* fulfilled, convert the string to 'Code 32', else</c>
<c>* return an empty string.</c>
<l>if (DecodedDataStringCode39 =~ '^[' + sum(Symbols) + ']{6}$')</l>
<c>    * </c>
<c>    * Convert the value of each digit in the decoded 'Code 39' string</c>
<l>    ConvertedDataStringCode32 := 0</l>
<l>    for Digit := 0 to 5 by 1</l>
<l>        ConvertedDataStringCode32 := ConvertedDataStringCode32 + find(Symbols,DecodedDataStringCode39{Digit})</l>
<l>        if (Digit &lt; 5)</l>
<l>            ConvertedDataStringCode32 := ConvertedDataStringCode32 * 32</l>
<l>        endif</l>
<l>    endfor</l>
<c>    * Write the converted string as 9 digit string with leading zeros</c>
<l>    ConvertedDataStringCode32 := ConvertedDataStringCode32$'9.9d'</l>
<c>    * </c>
<c>    * Verify the checksum (last digit)</c>
<l>    CheckDigit := number(ConvertedDataStringCode32{8})</l>
<l>    CheckSum := 0</l>
<l>    for Digit := 0 to 7 by 1</l>
<c>        * Sum first 8 digits, but even digits have weight 2</c>
<l>        Value := (1 + Digit % 2) * number(ConvertedDataStringCode32{Digit})</l>
<c>        * But actually we only want the cross digit sum,</c>
<c>        * This 'formula' works for 0-19</c>
<l>        if (Value &gt;= 10)</l>
<l>            Value := Value - 9</l>
<l>        endif</l>
<l>        CheckSum := CheckSum + Value</l>
<l>    endfor</l>
<l>    CheckSum := CheckSum % 10</l>
<c>    * </c>
<c>    * If the checksum fits, return the converted 'Code 32' string,</c>
<c>    * else return an empty string</c>
<l>    if (CheckDigit != CheckSum)</l>
<c>        * Bad checksum</c>
<l>        ConvertedDataStringCode32 := ''</l>
<l>    else</l>
<c>        * Always printed with leading A</c>
<l>        ConvertedDataStringCode32 := 'A' + ConvertedDataStringCode32</l>
<l>    endif</l>
<l>else</l>
<c>    * Wrong number of chars or invalid chars</c>
<l>    ConvertedDataStringCode32 := ''</l>
<l>endif</l>
<l>return ()</l>
<c>* </c>
</body>
<docu id="convert_decoded_string_code39_to_code32">
<abstract lang="en_US">This procedure converts the decoded data string of a bar code of type 'Code 32' that was read with the bar code reader for 'Code 39'.

In case a bar code of type 'Code 32' is read with the bar code reader find_bar_code with code type 'Code 39' the resulting data string has to be converted to the 'Code 32' decoding. This procedure can be used to perform this conversion.

1. Step: Find and decode the 'Code 32' bar code with the HALCON bar code reader for type 'Code 39'.
2. Step: Convert the decoded data string from type 'Code 39' to the corresponding 'Code 32' decoding using the procedure convert_decoded_string_code39_to_code32.

Note that only one data string can be passed to the input parameter 'DecodedStringCode39' for conversion.</abstract>
<chapters lang="de_DE">
<item>Identifizierung</item>
<item>Barcode</item>
</chapters>
<chapters lang="en_US">
<item>Identification</item>
<item>Bar Code</item>
</chapters>
<example lang="en_US">create_bar_code_model ([], [], BarCodeHandle)
find_bar_code (Image, SymbolRegions, BarCodeHandle, 'Code 39', DecodedDataStrings)
convert_code39_to_code32 (DecodedDataStrings, ConvertedDataStringsCode32)</example>
<keywords lang="en_US">
<item>convert decoded string of bar code type 'Code 39' to 'Code 32'</item>
</keywords>
<library lang="en_US">MVTec Standard Procedures</library>
<predecessor>
<item>find_bar_code</item>
</predecessor>
<short lang="en_US">Convert a decoded string of a bar code of type 'Code 39' to the type 'Code 32'.</short>
<successor>
<item>disp_message</item>
</successor>
<parameters>
<parameter id="ConvertedDataStringCode32">
<default_type>string</default_type>
<description lang="en_US">The converted data string of bar code type 'Code 32'</description>
<multivalue>false</multivalue>
<sem_type>string</sem_type>
<type_list>
<item>string</item>
</type_list>
</parameter>
<parameter id="DecodedDataStringCode39">
<default_type>string</default_type>
<description lang="en_US">The decoded data string of bar code type 'Code 39' to be converted</description>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>string</sem_type>
<type_list>
<item>string</item>
</type_list>
</parameter>
</parameters>
</docu>
</procedure>
<procedure name="convert_rect2_5to8param" access="local">
<interface>
<ic>
<par name="Row" base_type="ctrl" dimension="0"/>
<par name="Col" base_type="ctrl" dimension="0"/>
<par name="Length1" base_type="ctrl" dimension="0"/>
<par name="Length2" base_type="ctrl" dimension="0"/>
<par name="Phi" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="Row1" base_type="ctrl" dimension="0"/>
<par name="Col1" base_type="ctrl" dimension="0"/>
<par name="Row2" base_type="ctrl" dimension="0"/>
<par name="Col2" base_type="ctrl" dimension="0"/>
<par name="Row3" base_type="ctrl" dimension="0"/>
<par name="Col3" base_type="ctrl" dimension="0"/>
<par name="Row4" base_type="ctrl" dimension="0"/>
<par name="Col4" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c>* This procedure takes the parameters for a rectangle of type 'rectangle2'</c>
<c>* and returns the coordinates of the four corners.</c>
<c>* </c>
<l>Co1 := cos(Phi) * Length1</l>
<l>Co2 := cos(Phi) * Length2</l>
<l>Si1 := sin(Phi) * Length1</l>
<l>Si2 := sin(Phi) * Length2</l>
<c></c>
<l>Col1 := Co1 - Si2 + Col</l>
<l>Row1 := -Si1 - Co2 + Row</l>
<l>Col2 := -Co1 - Si2 + Col</l>
<l>Row2 := Si1 - Co2 + Row</l>
<l>Col3 := -Co1 + Si2 + Col</l>
<l>Row3 := Si1 + Co2 + Row</l>
<l>Col4 := Co1 + Si2 + Col</l>
<l>Row4 := -Si1 + Co2 + Row</l>
<c></c>
<l>return ()</l>
</body>
<docu id="convert_rect2_5to8param">
<abstract lang="en_US">This procedure takes the parameters for a tuple of rectangles of type 'rectangle2' (Row, Column, Phi, Length1, and Length2)
and returns the coordinates of the four corners for each rectangle.

Using the orientation of rectangle2, the four output corners are ordered such that for an angle of phi=0 they would be at:
- (Row1, Col1): top-right corner
- (Row2, Col2): top-left corner
- (Row3, Col3): bottom-left corner
- (Row4, Col4): bottom-right corner.</abstract>
<chapters lang="en_US">
<item>Tools</item>
<item>Geometry</item>
</chapters>
<library lang="en_US">MVTec Standard Procedures</library>
<short lang="en_US">Convert the parameters of rectangles with format rectangle2 to the coordinates of its 4 corner-points.</short>
<parameters>
<parameter id="Col"/>
<parameter id="Col1"/>
<parameter id="Col2"/>
<parameter id="Col3"/>
<parameter id="Col4"/>
<parameter id="Length1"/>
<parameter id="Length2"/>
<parameter id="Phi"/>
<parameter id="Row"/>
<parameter id="Row1"/>
<parameter id="Row2"/>
<parameter id="Row3"/>
<parameter id="Row4"/>
</parameters>
</docu>
</procedure>
<procedure name="convert_rect2_8to5param" access="local">
<interface>
<ic>
<par name="Row1" base_type="ctrl" dimension="0"/>
<par name="Col1" base_type="ctrl" dimension="0"/>
<par name="Row2" base_type="ctrl" dimension="0"/>
<par name="Col2" base_type="ctrl" dimension="0"/>
<par name="Row3" base_type="ctrl" dimension="0"/>
<par name="Col3" base_type="ctrl" dimension="0"/>
<par name="Row4" base_type="ctrl" dimension="0"/>
<par name="Col4" base_type="ctrl" dimension="0"/>
<par name="ForceL1LargerL2" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="Row" base_type="ctrl" dimension="0"/>
<par name="Col" base_type="ctrl" dimension="0"/>
<par name="Length1" base_type="ctrl" dimension="0"/>
<par name="Length2" base_type="ctrl" dimension="0"/>
<par name="Phi" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c>* This procedure takes the corners of four-sided figures</c>
<c>* and returns the parameters of type 'rectangle2'.</c>
<c>* </c>
<c>* Calculate center row and column.</c>
<l>Row := (Row1 + Row2 + Row3 + Row4) / 4.0</l>
<l>Col := (Col1 + Col2 + Col3 + Col4) / 4.0</l>
<c>* Length1 and Length2.</c>
<l>Length1 := sqrt((Row1 - Row2) * (Row1 - Row2) + (Col1 - Col2) * (Col1 - Col2)) / 2.0</l>
<l>Length2 := sqrt((Row2 - Row3) * (Row2 - Row3) + (Col2 - Col3) * (Col2 - Col3)) / 2.0</l>
<c>* Calculate the angle phi.</c>
<l>Hor := Col1 - Col2</l>
<l>Vert := Row2 - Row1</l>
<l>if (ForceL1LargerL2)</l>
<c>    * Swap length1 and length2 if necessary.</c>
<l>    IdxSwap := find((Length2 - Length1) [&gt;] 1e-9,1)</l>
<l>    if (IdxSwap != -1)</l>
<l>        Tmp := Length1[IdxSwap]</l>
<l>        Length1[IdxSwap] := Length2[IdxSwap]</l>
<l>        Length2[IdxSwap] := Tmp</l>
<l>        Hor[IdxSwap] := Col2[IdxSwap] - Col3[IdxSwap]</l>
<l>        Vert[IdxSwap] := Row3[IdxSwap] - Row2[IdxSwap]</l>
<l>    endif</l>
<l>endif</l>
<l>Phi := atan2(Vert,Hor)</l>
<c>* </c>
<l>return ()</l>
</body>
<docu id="convert_rect2_8to5param">
<abstract lang="en_US">This procedure takes the corners of four-sided figures,
assumes that they belong to rectangles, and returns the parameters of type 'rectangle2' (Row, Column, Phi, Length1, and Length2).

Thereby, for each figure the four input corners are assumed to be ordered such that for an angle of phi=0 they would be at:
- (Row1, Col1): top-right corner
- (Row2, Col2): top-left corner
- (Row3, Col3): bottom-left corner
- (Row4, Col4): bottom-right corner.

ForceL1LargerL2 determines, if the output parameters are given such that Length1 is always larger or equal to Length2 ('true') or that Length1 is half the length of the edge from corner 1 to 2.</abstract>
<chapters lang="en_US">
<item>Tools</item>
<item>Geometry</item>
</chapters>
<library lang="en_US">MVTec Standard Procedures</library>
<short lang="en_US">Convert for four-sided figures the coordinates of the 4 corner-points to the parameters of format rectangle2.</short>
<parameters>
<parameter id="Col"/>
<parameter id="Col1"/>
<parameter id="Col2"/>
<parameter id="Col3"/>
<parameter id="Col4"/>
<parameter id="ForceL1LargerL2"/>
<parameter id="Length1"/>
<parameter id="Length2"/>
<parameter id="Phi"/>
<parameter id="Row"/>
<parameter id="Row1"/>
<parameter id="Row2"/>
<parameter id="Row3"/>
<parameter id="Row4"/>
</parameters>
</docu>
</procedure>
<procedure name="create_dl_preprocess_param">
<interface>
<ic>
<par name="DLModelType" base_type="ctrl" dimension="0"/>
<par name="ImageWidth" base_type="ctrl" dimension="0"/>
<par name="ImageHeight" base_type="ctrl" dimension="0"/>
<par name="ImageNumChannels" base_type="ctrl" dimension="0"/>
<par name="ImageRangeMin" base_type="ctrl" dimension="0"/>
<par name="ImageRangeMax" base_type="ctrl" dimension="0"/>
<par name="NormalizationType" base_type="ctrl" dimension="0"/>
<par name="DomainHandling" base_type="ctrl" dimension="0"/>
<par name="IgnoreClassIDs" base_type="ctrl" dimension="0"/>
<par name="SetBackgroundID" base_type="ctrl" dimension="0"/>
<par name="ClassIDsBackground" base_type="ctrl" dimension="0"/>
<par name="GenParam" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="DLPreprocessParam" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c>* </c>
<c>* This procedure creates a dictionary with all parameters needed for preprocessing.</c>
<c>* </c>
<l>create_dict (DLPreprocessParam)</l>
<l>set_dict_tuple (DLPreprocessParam, 'model_type', DLModelType)</l>
<l>set_dict_tuple (DLPreprocessParam, 'image_width', ImageWidth)</l>
<l>set_dict_tuple (DLPreprocessParam, 'image_height', ImageHeight)</l>
<l>set_dict_tuple (DLPreprocessParam, 'image_num_channels', ImageNumChannels)</l>
<l>if (ImageRangeMin == [])</l>
<l>    set_dict_tuple (DLPreprocessParam, 'image_range_min', -127)</l>
<l>else</l>
<l>    set_dict_tuple (DLPreprocessParam, 'image_range_min', ImageRangeMin)</l>
<l>endif</l>
<l>if (ImageRangeMax == [])</l>
<l>    set_dict_tuple (DLPreprocessParam, 'image_range_max', 128)</l>
<l>else</l>
<l>    set_dict_tuple (DLPreprocessParam, 'image_range_max', ImageRangeMax)</l>
<l>endif</l>
<l>set_dict_tuple (DLPreprocessParam, 'normalization_type', NormalizationType)</l>
<c>* Replace possible legacy parameters.</c>
<l>replace_legacy_preprocessing_parameters (DLPreprocessParam)</l>
<l>set_dict_tuple (DLPreprocessParam, 'domain_handling', DomainHandling)</l>
<c>* </c>
<c>* Set segmentation specific parameters.</c>
<l>if (DLModelType == 'segmentation')</l>
<l>    set_dict_tuple (DLPreprocessParam, 'ignore_class_ids', IgnoreClassIDs)</l>
<l>    set_dict_tuple (DLPreprocessParam, 'set_background_id', SetBackgroundID)</l>
<l>    set_dict_tuple (DLPreprocessParam, 'class_ids_background', ClassIDsBackground)</l>
<l>endif</l>
<c>* </c>
<c>* Set generic parameters.</c>
<l>if (GenParam != [])</l>
<l>    get_dict_param (GenParam, 'keys', [], GenParamNames)</l>
<l>    for GenParamIndex := 0 to |GenParamNames| - 1 by 1</l>
<l>        get_dict_tuple (GenParam, GenParamNames[GenParamIndex], GenParamValue)</l>
<l>        set_dict_tuple (DLPreprocessParam, GenParamNames[GenParamIndex], GenParamValue)</l>
<l>    endfor</l>
<l>endif</l>
<c>* </c>
<c>* Set necessary default values.</c>
<l>if (DLModelType == 'detection')</l>
<l>    get_dict_param (DLPreprocessParam, 'key_exists', ['instance_type','ignore_direction'], KeysExist)</l>
<l>    if (not KeysExist[0])</l>
<l>        set_dict_tuple (DLPreprocessParam, 'instance_type', 'rectangle1')</l>
<l>    endif</l>
<c>    * Set default for 'ignore_direction' only if instance_type is 'rectangle2'.</c>
<l>    get_dict_tuple (DLPreprocessParam, 'instance_type', InstanceType)</l>
<l>    if (InstanceType == 'rectangle2' and not KeysExist[1])</l>
<l>        set_dict_tuple (DLPreprocessParam, 'ignore_direction', false)</l>
<l>    endif</l>
<l>endif</l>
<c>* </c>
<c>* Check the validity of the preprocessing parameters.</c>
<l>check_dl_preprocess_param (DLPreprocessParam)</l>
<c>* </c>
<l>return ()</l>
</body>
<docu id="create_dl_preprocess_param">
<abstract lang="en_US">This procedure creates a dictionary with parameters used for preprocessing samples of a deep learning dataset.

The output dictionary DLPreprocessParam can be used for procedures like preprocess_dl_samples or preprocess_dl_dataset.

General preprocessing parameters (as dictionary key/procedure parameter):
- 'image_width'/'ImageWidth': See the documentation of get_dl_model_param.
- 'image_height'/'ImageHeight': See the documentation of get_dl_model_param.
- 'image_num_channels'/'ImageNumChannels': See the documentation of get_dl_model_param.
- 'image_range_min'/'ImageRangeMin': See the documentation of get_dl_model_param.
- 'image_range_max'/'ImageRangeMax': See the documentation of get_dl_model_param.
- 'normalization_type'/'NormalizationType': Parameter of preprocess_dl_samples, see the respective documentation for details.
- 'domain_handling'/'DomainHandling': Parameter of preprocess_dl_samples, see the respective documentation for details.

Segmentation specific preprocessing parameters (as dictionary key/procedure parameter):
- 'set_background_id'/'SetBackgroundID': Class ID of the background class. This parameter can only be set for segmentation.
  See the documentation of preprocess_dl_samples for details. The default value is [].
- 'class_ids_background'/'ClassIDsBackground': Class IDs that should additionally be set to the Background Class ID given through 'set_background_id'.
  See documentation of preprocess_dl_samples for details. The default value is [].
- 'ignore_class_ids'/'IgnoreClassIDs': See the documentation of get_dl_model_param.

Additional parameters can be given via the dictionary GenParam.
Thereby, the following values are supported depending on the model type:
- for models of type 'detection':
  -- 'instance_type': Determines the instance type of the detection model. Possible values: 'rectangle1', 'rectangle2'.
     If not set by the user, by default the value 'rectangle1' is set.
  -- 'ignore_direction': Only applicable for detection models of instance_type 'rectangle2'.
     If set to true, directions of bounding boxes are ignored and the smallest fitting oriented bounding boxes are used.
     If not set by the user, by default the value false is set.
  -- 'class_ids_no_orientation': Only applicable for detection models of instance_type 'rectangle2'.
     This array contains all class IDs that have no orientation. To ensure that the ground truth bounding boxes of these classes are
     axis-aligned, the labels are replaced by the smallest enclosing axis-aligned bounding boxes.
     If not set by the user, by default an empty tuple [] is set.</abstract>
<chapters lang="de_DE">
<item>Deep Learning</item>
<item>Modell</item>
</chapters>
<chapters lang="en_US">
<item>Deep Learning</item>
<item>Model</item>
</chapters>
<library lang="en_US">MVTec Standard Procedures</library>
<short lang="en_US">Creates a dictionary with preprocessing parameters.</short>
<parameters>
<parameter id="ClassIDsBackground">
<default_type>integer</default_type>
<default_value>[]</default_value>
<description lang="en_US">Class IDs set to background class ID.</description>
<mixed_type>false</mixed_type>
<multivalue>optional</multivalue>
<sem_type>integer</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="DLModelType">
<default_type>string</default_type>
<default_value>'segmentation'</default_value>
<description lang="en_US">The DL model type used for preprocessing.</description>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>string</sem_type>
<type_list>
<item>string</item>
</type_list>
<values>
<item>'segmentation'</item>
<item>'detection'</item>
</values>
</parameter>
<parameter id="DLPreprocessParam">
<default_type>integer</default_type>
<description lang="en_US">Dictionary containing the preprocessing parameters.</description>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>dict</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="DomainHandling">
<default_type>string</default_type>
<default_value>'full_domain'</default_value>
<description lang="en_US">Handling of domains if present.</description>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>string</sem_type>
<type_list>
<item>string</item>
</type_list>
<values>
<item>'full_domain'</item>
<item>'crop_domain'</item>
</values>
</parameter>
<parameter id="GenParam">
<default_value>[]</default_value>
<description lang="en_US">Dictionary of generic parameters.</description>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>any</sem_type>
</parameter>
<parameter id="IgnoreClassIDs">
<default_type>integer</default_type>
<default_value>[]</default_value>
<description lang="en_US">Class IDs that should be ignored during training.</description>
<mixed_type>false</mixed_type>
<multivalue>optional</multivalue>
<sem_type>integer</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="ImageHeight">
<default_type>integer</default_type>
<description lang="en_US">Height the images are rescaled to.</description>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>integer</sem_type>
<type_list>
<item>integer</item>
</type_list>
<value_min>1</value_min>
</parameter>
<parameter id="ImageNumChannels">
<default_type>integer</default_type>
<description lang="en_US">Number of channels the images are rescaled to.</description>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>integer</sem_type>
<type_list>
<item>integer</item>
</type_list>
<value_min>1</value_min>
</parameter>
<parameter id="ImageRangeMax">
<default_type>integer</default_type>
<default_value>128</default_value>
<description lang="en_US">Maximum gray value range of the pixels.</description>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>integer</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="ImageRangeMin">
<default_type>integer</default_type>
<default_value>-127</default_value>
<description lang="en_US">Minimum gray value range of the pixels.</description>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>integer</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="ImageWidth">
<default_type>integer</default_type>
<description lang="en_US">Width the images are rescaled to.</description>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>integer</sem_type>
<type_list>
<item>integer</item>
</type_list>
<value_min>1</value_min>
</parameter>
<parameter id="NormalizationType">
<default_type>string</default_type>
<default_value>'none'</default_value>
<description lang="en_US">Parameter for normalization type for preprocessing.</description>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>string</sem_type>
<type_list>
<item>string</item>
</type_list>
<values>
<item>'all_channels'</item>
<item>'first_channel'</item>
<item>'constant_values'</item>
<item>'none'</item>
</values>
</parameter>
<parameter id="SetBackgroundID">
<default_type>integer</default_type>
<default_value>[]</default_value>
<description lang="en_US">Class ID of background class.</description>
<mixed_type>false</mixed_type>
<multivalue>optional</multivalue>
<sem_type>integer</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
</parameters>
</docu>
</procedure>
<procedure name="create_dl_preprocess_param_from_model">
<interface>
<ic>
<par name="DLModelHandle" base_type="ctrl" dimension="0"/>
<par name="NormalizationType" base_type="ctrl" dimension="0"/>
<par name="DomainHandling" base_type="ctrl" dimension="0"/>
<par name="SetBackgroundID" base_type="ctrl" dimension="0"/>
<par name="ClassIDsBackground" base_type="ctrl" dimension="0"/>
<par name="GenParam" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="DLPreprocessParam" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c>* </c>
<c>* This procedure creates a dictionary with all parameters needed for preprocessing</c>
<c>* according to a model provided through DLModelHandle.</c>
<c>* </c>
<c>* Get the relevant model parameters.</c>
<l>get_dl_model_param (DLModelHandle, 'type', ModelType)</l>
<l>get_dl_model_param (DLModelHandle, 'image_width', ImageWidth)</l>
<l>get_dl_model_param (DLModelHandle, 'image_height', ImageHeight)</l>
<l>get_dl_model_param (DLModelHandle, 'image_num_channels', ImageNumChannels)</l>
<l>get_dl_model_param (DLModelHandle, 'image_range_min', ImageRangeMin)</l>
<l>get_dl_model_param (DLModelHandle, 'image_range_max', ImageRangeMax)</l>
<l>IgnoreClassIDs := []</l>
<c>* </c>
<c>* Get model specific parameters.</c>
<l>if (ModelType == 'anomaly_detection')</l>
<c>    * No anomaly detection specific parameters.</c>
<l>elseif (ModelType == 'classification')</l>
<c>    * No classification specific parameters.</c>
<l>elseif (ModelType == 'detection')</l>
<c>    * Get detection specific parameters.</c>
<c>    * If GenParam has not been created yet, create it to add new generic parameters.</c>
<l>    if (|GenParam| == 0)</l>
<l>        create_dict (GenParam)</l>
<l>    endif</l>
<c>    * Add instance_type.</c>
<l>    get_dl_model_param (DLModelHandle, 'instance_type', InstanceType)</l>
<l>    set_dict_tuple (GenParam, 'instance_type', InstanceType)</l>
<c>    * For instance_type 'rectangle2', add the boolean ignore_direction and class IDs without orientation.</c>
<l>    if (InstanceType == 'rectangle2')</l>
<l>        get_dl_model_param (DLModelHandle, 'ignore_direction', IgnoreDirection)</l>
<l>        if (IgnoreDirection == 'true')</l>
<l>            set_dict_tuple (GenParam, 'ignore_direction', true)</l>
<l>        elseif (IgnoreDirection == 'false')</l>
<l>            set_dict_tuple (GenParam, 'ignore_direction', false)</l>
<l>        endif</l>
<l>        get_dl_model_param (DLModelHandle, 'class_ids_no_orientation', ClassIDsNoOrientation)</l>
<l>        set_dict_tuple (GenParam, 'class_ids_no_orientation', ClassIDsNoOrientation)</l>
<l>    endif</l>
<l>elseif (ModelType == 'segmentation')</l>
<c>    * Get segmentation specific parameters.</c>
<l>    get_dl_model_param (DLModelHandle, 'ignore_class_ids', IgnoreClassIDs)</l>
<l>endif</l>
<c>* </c>
<c>* Create the dictionary with the preprocessing parameters returned by this procedure.</c>
<l>create_dl_preprocess_param (ModelType, ImageWidth, ImageHeight, ImageNumChannels, ImageRangeMin, ImageRangeMax, NormalizationType, DomainHandling, IgnoreClassIDs, SetBackgroundID, ClassIDsBackground, GenParam, DLPreprocessParam)</l>
<c>* </c>
<l>return ()</l>
</body>
<docu id="create_dl_preprocess_param_from_model">
<abstract lang="en_US">This procedure creates a dictionary with the preprocessing parameters based on a given DL model.</abstract>
<chapters lang="de_DE">
<item>Deep Learning</item>
<item>Modell</item>
</chapters>
<chapters lang="en_US">
<item>Deep Learning</item>
<item>Model</item>
</chapters>
<library lang="en_US">MVTec Standard Procedures</library>
<short lang="en_US">Creates a dictionary with the preprocessing parameters based on a given DL model.</short>
<parameters>
<parameter id="ClassIDsBackground">
<default_type>integer</default_type>
<default_value>[]</default_value>
<description lang="en_US">Class IDs set to background class ID.</description>
<mixed_type>false</mixed_type>
<multivalue>optional</multivalue>
<sem_type>integer</sem_type>
<type_list>
<item>integer</item>
</type_list>
<value_min>0</value_min>
</parameter>
<parameter id="DLModelHandle">
<default_type>integer</default_type>
<description lang="en_US">The DL model type used for preprocessing.</description>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>dl_model</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="DLPreprocessParam">
<default_type>integer</default_type>
<description lang="en_US">Dictionary containing the preprocessing parameters.</description>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>dict</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="DomainHandling">
<default_type>string</default_type>
<default_value>'full_domain'</default_value>
<description lang="en_US">Handling of domains if present.</description>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>string</sem_type>
<type_list>
<item>string</item>
</type_list>
<values>
<item>'full_domain'</item>
<item>'crop_domain'</item>
</values>
</parameter>
<parameter id="GenParam">
<default_value>[]</default_value>
<description lang="en_US">Dictionary of generic parameters.</description>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>any</sem_type>
</parameter>
<parameter id="NormalizationType">
<default_type>string</default_type>
<default_value>'none'</default_value>
<description lang="en_US">Parameter for normalization type for preprocessing.</description>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>string</sem_type>
<type_list>
<item>string</item>
</type_list>
<values>
<item>'all_channels'</item>
<item>'first_channel'</item>
<item>'constant_values'</item>
<item>'none'</item>
</values>
</parameter>
<parameter id="SetBackgroundID">
<default_type>integer</default_type>
<default_value>[]</default_value>
<description lang="en_US">Class ID of background class.</description>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>integer</sem_type>
<type_list>
<item>integer</item>
</type_list>
<value_min>0</value_min>
</parameter>
</parameters>
</docu>
</procedure>
<procedure name="create_dl_train_param">
<interface>
<ic>
<par name="DLModelHandle" base_type="ctrl" dimension="0"/>
<par name="NumEpochs" base_type="ctrl" dimension="0"/>
<par name="EvaluationIntervalEpochs" base_type="ctrl" dimension="0"/>
<par name="EnableDisplay" base_type="ctrl" dimension="0"/>
<par name="RandomSeed" base_type="ctrl" dimension="0"/>
<par name="GenParamName" base_type="ctrl" dimension="0"/>
<par name="GenParamValue" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="TrainParam" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c>* </c>
<c>* This procedure creates a dictionary with all needed training parameters,</c>
<c>* as required by train_dl_model as input.</c>
<c>* </c>
<c>* Check length of input GenParam tuple.</c>
<l>if (|GenParamName| != |GenParamValue|)</l>
<l>    throw ('GenParamName and GenParamValue have to have the same length.')</l>
<l>endif</l>
<c>* </c>
<c>* Some default parameters depend on model type.</c>
<l>get_dl_model_param (DLModelHandle, 'type', ModelType)</l>
<l>if (ModelType != 'classification' and ModelType != 'detection' and ModelType != 'segmentation' and ModelType != 'anomaly_detection')</l>
<l>    throw ('Current model type is not supported: "' + ModelType + '"')</l>
<l>endif</l>
<c>* </c>
<c>* Check if the given GenParamName strings are available.</c>
<l>if (ModelType != 'anomaly_detection')</l>
<l>    AvailableGenParam := ['evaluate','augment','change','serialize','display']</l>
<l>else</l>
<l>    AvailableGenParam := 'anomaly'</l>
<l>endif</l>
<l>for IndexGenParam := 0 to |GenParamName| - 1 by 1</l>
<l>    IndexFind := find(AvailableGenParam,GenParamName[IndexGenParam])</l>
<l>    if (IndexFind == -1)</l>
<l>        throw ('The provided GenParamName ' + GenParamName[IndexGenParam] + ' is invalid.')</l>
<l>    endif</l>
<l>endfor</l>
<c>* </c>
<c>* Check if display is enabled.</c>
<l>tuple_is_string (EnableDisplay, IsString)</l>
<l>if (IsString)</l>
<l>    EnableDisplay := EnableDisplay == 'true'</l>
<l>else</l>
<l>    EnableDisplay := EnableDisplay == true</l>
<l>endif</l>
<c>* </c>
<c>* Initialize the dictionary holding the training parameters.</c>
<l>create_dict (TrainParam)</l>
<c>* </c>
<c>* ** User supplied parameters: ***</c>
<c>* </c>
<c>* Set training parameters for anomaly detection models.</c>
<l>if (ModelType == 'anomaly_detection')</l>
<l>    get_genparam_single_value (GenParamName, GenParamValue, 'anomaly', TrainParamAnomaly)</l>
<c>    * Set default values in case no values are provided.</c>
<l>    if (TrainParamAnomaly == [])</l>
<l>        create_dict (TrainParamAnomaly)</l>
<l>    endif</l>
<l>    get_dict_param (TrainParamAnomaly, 'key_exists', 'domain_ratio', DomainRatioKeyExists)</l>
<l>    if (not DomainRatioKeyExists)</l>
<l>        set_dict_tuple (TrainParamAnomaly, 'domain_ratio', 0.1)</l>
<l>    endif</l>
<l>    get_dict_param (TrainParamAnomaly, 'key_exists', 'error_threshold', ErrorThresholdKeyExists)</l>
<l>    if (not ErrorThresholdKeyExists)</l>
<l>        set_dict_tuple (TrainParamAnomaly, 'error_threshold', 0.001)</l>
<l>    endif</l>
<l>    get_dict_param (TrainParamAnomaly, 'key_exists', 'regularization_noise', RegularizationNoiseKeyExists)</l>
<l>    if (not RegularizationNoiseKeyExists)</l>
<l>        set_dict_tuple (TrainParamAnomaly, 'regularization_noise', 0.0001)</l>
<l>    endif</l>
<c>    * </c>
<l>    set_dict_tuple (TrainParamAnomaly, 'max_num_epochs', NumEpochs)</l>
<l>    set_dict_tuple (TrainParam, 'anomaly_param', TrainParamAnomaly)</l>
<l>    create_dict (DisplayParam)</l>
<l>    set_dict_tuple (DisplayParam, 'enabled', EnableDisplay)</l>
<l>    set_dict_tuple (TrainParam, 'display_param', DisplayParam)</l>
<l>    return ()</l>
<l>endif</l>
<c>* </c>
<c>* Set training parameters for non-anomaly models.</c>
<c>* </c>
<c>* Number of epochs to train the model on the train split of the dataset.</c>
<l>set_dict_tuple (TrainParam, 'num_epochs', NumEpochs)</l>
<c>* </c>
<c>* Interval (in epochs) to evaluate the model on the validation split of the dataset.</c>
<l>set_dict_tuple (TrainParam, 'evaluation_interval_epochs', EvaluationIntervalEpochs)</l>
<c>* </c>
<c>* Transfer evaluation parameters used in further steps.</c>
<l>get_genparam_single_value (GenParamName, GenParamValue, 'evaluate', EvaluationParam)</l>
<l>set_dict_tuple (TrainParam, 'evaluation_param', EvaluationParam)</l>
<c>* </c>
<c>* Transfer augmentation parameters used in further steps.</c>
<l>get_genparam_single_value (GenParamName, GenParamValue, 'augment', AugmentationParam)</l>
<l>if (ModelType == 'detection')</l>
<c>    * In addition, add class IDs without orientation, since these classes require</c>
<c>    * special treatment during the augmentation.</c>
<l>    try</l>
<l>        get_dl_model_param (DLModelHandle, 'class_ids_no_orientation', ClassIDsNoOrientation)</l>
<l>    catch (Exception)</l>
<l>        ClassIDsNoOrientation := []</l>
<l>    endtry</l>
<l>    if (|ClassIDsNoOrientation| &gt; 0)</l>
<l>        if (AugmentationParam == [])</l>
<l>            create_dict (AugmentationParam)</l>
<l>        endif</l>
<l>        set_dict_tuple (AugmentationParam, 'class_ids_no_orientation', ClassIDsNoOrientation)</l>
<l>    endif</l>
<l>endif</l>
<l>set_dict_tuple (TrainParam, 'augmentation_param', AugmentationParam)</l>
<c>* </c>
<c>* Change strategies for any parameters that need to be changed during training.</c>
<l>Indices := find(GenParamName,'change')</l>
<l>if (|Indices| == 0 or Indices == -1)</l>
<c>    * Set a default in case no value is provided.</c>
<l>    ChangeStrategies := []</l>
<l>else</l>
<c>    * Set user provided values.</c>
<l>    ChangeStrategies := GenParamValue[Indices]</l>
<l>endif</l>
<l>set_dict_tuple (TrainParam, 'change_strategies', ChangeStrategies)</l>
<c>* </c>
<c>* Serialization strategies used during training.</c>
<l>Indices := find(GenParamName,'serialize')</l>
<l>if (|Indices| == 0 or Indices == -1)</l>
<c>    * Set a default in case no value is provided.</c>
<l>    create_dict (SerializationStrategy)</l>
<l>    set_dict_tuple (SerializationStrategy, 'type', 'best')</l>
<l>    set_dict_tuple (SerializationStrategy, 'basename', 'model_best')</l>
<l>    SerializationStrategies := SerializationStrategy</l>
<l>else</l>
<c>    * Set user provided values.</c>
<l>    SerializationStrategies := GenParamValue[Indices]</l>
<l>endif</l>
<l>set_dict_tuple (TrainParam, 'serialization_strategies', SerializationStrategies)</l>
<c>* </c>
<c>* Get random seed or set a useful default value.</c>
<l>if (|RandomSeed| &gt; 0)</l>
<l>    set_dict_tuple (TrainParam, 'seed_rand', RandomSeed)</l>
<l>else</l>
<c>    * If no random seed is given we will use system time as a default.</c>
<l>    count_seconds (Seconds)</l>
<l>    RandomSeed := int(Seconds)</l>
<l>    set_dict_tuple (TrainParam, 'seed_rand', RandomSeed)</l>
<l>endif</l>
<c>* </c>
<c>* ** Display parameters: ***</c>
<c>* </c>
<c>* Create display parameter dictionary and set default of settable parameters.</c>
<l>create_dict (DisplayParam)</l>
<c>* </c>
<c>* List of settable parameters and the default values.</c>
<l>SettableDisplayParam := 'selected_percentage_train_samples'</l>
<l>SelectedPercentageTrainSamples := 0</l>
<l>DefaultDisplayParam := SelectedPercentageTrainSamples</l>
<c>* </c>
<l>for SetableDisplayParamIndex := 0 to |SettableDisplayParam| - 1 by 1</l>
<l>    set_dict_tuple (DisplayParam, SettableDisplayParam[SetableDisplayParamIndex], DefaultDisplayParam[SetableDisplayParamIndex])</l>
<l>endfor</l>
<c>* </c>
<c>* Transfer display parameters used in further steps.</c>
<l>get_genparam_single_value (GenParamName, GenParamValue, 'display', DisplayParamTmp)</l>
<l>if (|DisplayParamTmp| != 0)</l>
<c>    * Check display parameter keys.</c>
<l>    get_dict_param (DisplayParam, 'keys', [], DisplayParamKeys)</l>
<l>    for IndexDisplayParam := 0 to |DisplayParamKeys| - 1 by 1</l>
<l>        IndexFind := find(SettableDisplayParam,DisplayParamKeys[IndexDisplayParam])</l>
<l>        if (IndexFind == -1)</l>
<l>            throw ('The provided key ' + DisplayParamKeys[IndexDisplayParam] + ' for \'display\' is invalid.')</l>
<l>        endif</l>
<c>        * </c>
<c>        * Check and set value to display parameter dictionary.</c>
<l>        if (IndexFind == 0)</l>
<c>            * 'selected_percentage_train_samples'.</c>
<l>            get_dict_tuple (DisplayParamTmp, SettableDisplayParam[IndexFind], SelectedPercentageTrainSamples)</l>
<l>            if (not (is_int(SelectedPercentageTrainSamples) or is_real(SelectedPercentageTrainSamples)))</l>
<l>                throw ('The value of \'selected_percentage_train_samples\' has to be of type integer or real')</l>
<l>            endif</l>
<l>            if (SelectedPercentageTrainSamples &lt; 0 or SelectedPercentageTrainSamples &gt; 100)</l>
<l>                throw ('The value of \'selected_percentage_train_samples\' has to be in [0,100]')</l>
<l>            endif</l>
<l>            set_dict_tuple (DisplayParam, SettableDisplayParam[IndexFind], SelectedPercentageTrainSamples)</l>
<l>        endif</l>
<l>    endfor</l>
<l>else</l>
<c>    * Create display parameter dictionary.</c>
<l>    create_dict (DisplayParam)</l>
<c>    * Set default values.</c>
<l>    set_dict_tuple (DisplayParam, 'selected_percentage_train_samples', SelectedPercentageTrainSamples)</l>
<l>endif</l>
<c>* </c>
<l>if (EnableDisplay)</l>
<c>    * Set default values. You might want to change them after this procedure call.</c>
<l>    if (ModelType == 'classification')</l>
<l>        NumImagesPreview := 6</l>
<l>    elseif (ModelType == 'detection')</l>
<l>        NumImagesPreview := 2</l>
<l>    elseif (ModelType == 'segmentation')</l>
<l>        NumImagesPreview := 4</l>
<l>    endif</l>
<c>    * </c>
<c>    * Number of images to display in the images preview.</c>
<l>    set_dict_tuple (DisplayParam, 'num_images', NumImagesPreview)</l>
<c>    * </c>
<c>    * If true, at each update new random images from validation set are chosen.</c>
<l>    set_dict_tuple (DisplayParam, 'randomize_images', true)</l>
<c>    * </c>
<c>    * Set the interval (in epochs) for the preview update</c>
<c>    * depending on the model type.</c>
<l>    if (ModelType == 'classification')</l>
<l>        set_dict_tuple (DisplayParam, 'update_images_interval_epochs', 4)</l>
<l>    else</l>
<l>        set_dict_tuple (DisplayParam, 'update_images_interval_epochs', 0.5)</l>
<l>    endif</l>
<c>    * </c>
<c>    * Interval (in seconds) to switch between plots.</c>
<l>    set_dict_tuple (DisplayParam, 'change_plot_interval_seconds', 10)</l>
<c>    * </c>
<c>    * These model parameters are displayed in the text window if available.</c>
<l>    StatusModelParamNames := ['learning_rate','batch_size','batch_size_multiplier','momentum','weight_prior','image_dimensions']</l>
<l>    set_dict_tuple (DisplayParam, 'status_model_params', StatusModelParamNames)</l>
<c>    * </c>
<c>    * Set user specified parameters used for the display of tiled images in</c>
<c>    * a further step.</c>
<l>    create_dict (TiledParamDict)</l>
<l>    set_dict_tuple (DisplayParam, 'tiled_param', TiledParamDict)</l>
<l>endif</l>
<c>* </c>
<l>set_dict_tuple (DisplayParam, 'enabled', EnableDisplay)</l>
<l>set_dict_tuple (TrainParam, 'display_param', DisplayParam)</l>
<c>* </c>
<c>* ** Generic internal defaults: ***</c>
<c>* </c>
<c>* Default update interval (in seconds) of TrainInfo calculation and text/plot updates</c>
<c>* in case display is enabled.</c>
<l>set_dict_tuple (TrainParam, 'update_interval_seconds', 2)</l>
<c>* </c>
<c>* Evaluation comparison keys. Note, that internally only those keys apply which</c>
<c>* are really available. No error is thrown as long as a valid key is given.</c>
<c>* Hence, we use the major defaults here for classification ('top1_error'),</c>
<c>* for detection ('mean_ap'), and for segmentation ('mean_iou').</c>
<l>EvaluationComparisonKeys := []</l>
<l>if (ModelType == 'classification')</l>
<l>    EvaluationComparisonKeys := 'top1_error'</l>
<l>elseif (ModelType == 'segmentation')</l>
<l>    EvaluationComparisonKeys := 'mean_iou'</l>
<l>elseif (ModelType == 'detection')</l>
<l>    EvaluationComparisonKeys := 'mean_ap'</l>
<l>endif</l>
<l>set_dict_tuple (TrainParam, 'evaluation_comparison_keys', EvaluationComparisonKeys)</l>
<c>* </c>
<c>* Number of samples used to average the loss during training. Note, this is used for display</c>
<c>* and information calculation only and does not have an effect on training the model.</c>
<l>set_dict_tuple (TrainParam, 'num_samples_mean_loss', 1000)</l>
<c>* </c>
<l>return ()</l>
</body>
<docu id="create_dl_train_param">
<abstract lang="en_US">This procedure creates the dictionary TrainParam, in which the parameters for training and training visualization are stored.
Such a dictionary is needed by the procedure train_dl_model. Here, we will explain what the parameters you can set in this procedure signify when using train_dl_model.
NumEpochs defines, over how many epochs the training will run.
EvaluationIntervalEpochs defines how many epochs will pass to the next model evaluation in order to identify the best model using evaluate_dl_model. With a value of 0, the model will not be evaluated.
EnableDisplay is used to define, if the training progress shall be displayed ('true') or not ('false'). In the first case, a dictionary DisplayParam is created and added to TrainParam with the key 'display_param'. As visualization consumes CPU processing time, it should be disabled for maximum training speed.
SeedRand sets the seed used for random number generation. For reproducibility, this should be kept fix.
If DLModelHandle is of type 'anomaly_detection', the values of EvaluationIntervalEpochs and SeedRand are not applicable and are therefore ignored.

Using GenParamName and GenParamValue, you can provide additional parameters influencing the training (See also the two examples below):
Thereby, GenParamName can be a string or a tuple of strings and GenParamValue is the corresponding dictionary or the tuple of corresponding dictionaries.
The following entries are possible for GenParamName:
- 'evaluation': The corresponding dictionary provided in GenParamValue is passed to evaluate_dl_model. For further information, see the documentation of evaluate_dl_model.
- 'augment': The corresponding dictionary provided in GenParamValue is passed to augment_dl_samples. For further information, see the documentation of augment_dl_samples.
- 'change': The corresponding dictionary provided in GenParamValue specifies a parameter that changes during training. You may specify multiple dictionaries with a GenParamName 'change' to change multiple parameters during training. Thereby, each of these GenParamValue dictionaries has the following entries:
   -- 'model_param': Specifies which parameter is changed in the model to be trained (e.g. 'learning_rate').
   -- 'initial_value': Indicates the initial value of the parameter. 
   -- 'epochs': A tuple which indicates at which epoch the corresponding value of the parameter in 'model_param' is changed to the value in 'values'. The tuple has to be of same length as 'values' and can be empty.
   -- 'values': A tuple which specifies the parameter value at each epoch in 'epochs'.
   -- 'scale_momentum_threshold' (only for model parameter 'learning_rate', optional): Defines the threshold for the ratio of old and new learning rate. If for a change of learning rate the ratio is higher than this threshold, the momentum of the model is adapted by scaling it accordingly. If not specified, no adaptation of the momentum is done.
-  'serialize': The corresponding dictionary provided in GenParamValue specifies when to serialize the model during training. You may specify multiple dictionaries with a GenParamName 'serialize'.  Thereby, each dictionary has the following entries:
   -- 'type': Specifies which type of serialization strategy is meant. Values: ['best', 'final', 'epochs'].
   -- 'basename': An optional parameter. It specifies the basename which is used to write the model and metadata information. The default value depends on the strategy type: 
       Default for type 'best' is 'best'.
       Default for type 'final' is 'final'.
       Default for type 'epochs' is 'model_at_epoch_' + Epoch$'0.2f', where Epoch is the current epoch.
   -- 'epochs': In case this dictionary key 'type' has the value 'epochs', this parameter defines at which epochs to serialize the model. All other types ignore this parameter.
- 'display': The corresponding dictionary provided in GenParamValues can be used to set the following display parameters:
   -- 'selected_percentage_train_samples' (default: 0): Select a certain percentage of the training samples used to evaluate the model during training. A lower percentage helps to speed up the evaluation. If the evaluation measure for the training split shall not be displayed, set this value to 0.

For models of type 'anomaly_detection', the aforementioned generic parameters cannot be set. Instead, there are different parameters that are only valid for this kind of model:
- 'anomaly': The corresponding dictionary provided in GenParamValues can be used to set the following training parameters for anomaly detection models (for information, see the documentation of train_dl_model_anomaly_dataset):
   -- 'domain_ratio'
   -- 'error_threshold'
   -- 'regularization_noise'

In the following we show three examples:
1) A very common use-case are learning rate changes.
    This example code shows how to specify that the learning rate should change at epochs 5 and 10 :
       create_dict(ChangeStrategy)
       set_dict_tuple (ChangeStrategy, 'model_param', 'learning_rate')
       set_dict_tuple (ChangeStrategy, 'initial_value', 0.01)
       set_dict_tuple (ChangeStrategy, 'epochs', [5, 10])
       set_dict_tuple (ChangeStrategy, 'values', [0.001, 0.0001])
2) This example code shows how to specify that the model should be saved at epochs 5 and 10 with the prefix 'mymodel'. The 'serialize' dictionary can be created with this code:
    create_dict (SerializationStrategy)
    set_dict_tuple (SerializationStrategy, 'type', 'epochs')
    set_dict_tuple (SerializationStrategy, 'basename', 'mymodel')
    set_dict_tuple (SerializationStrategy, 'epochs', [5,10])
3) This example code shows a possible parameter setting for models of type 'anomaly_detection':
       create_dict (TrainParamAnomaly)
       set_dict_tuple (TrainParamAnomaly, 'domain_ratio', 0.1)
       set_dict_tuple (TrainParamAnomaly, 'error_threshold', 0.0005)
       set_dict_tuple (TrainParamAnomaly, 'regularization_noise', 0.1)</abstract>
<chapters lang="de_DE">
<item>Deep Learning</item>
<item>Modell</item>
</chapters>
<chapters lang="en_US">
<item>Deep Learning</item>
<item>Model</item>
</chapters>
<library lang="en_US">MVTec Standard Procedures</library>
<short lang="en_US">Create a training parameter dictionary which is used in train_dl_model.</short>
<successor>
<item>train_dl_model</item>
</successor>
<parameters>
<parameter id="DLModelHandle">
<default_type>integer</default_type>
<description lang="en_US">The dl model, which is used during training.</description>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>dl_model</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="EnableDisplay">
<default_type>integer</default_type>
<default_value>'true'</default_value>
<description lang="en_US">EnableDisplay is used to define, if the training progress shall be displayed ('true') or not ('false').</description>
<multivalue>false</multivalue>
<sem_type>integer</sem_type>
<type_list>
<item>integer</item>
<item>string</item>
</type_list>
<values>
<item>1</item>
<item>0</item>
<item>true</item>
<item>false</item>
<item>'true'</item>
<item>'false'</item>
</values>
</parameter>
<parameter id="EvaluationIntervalEpochs">
<default_type>integer</default_type>
<default_value>1</default_value>
<description lang="en_US">Defines how many epochs will pass to the next model evaluation in order to identify the best model. If 0 is given, the model will not be evaluated.</description>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>integer</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
<value_min>0.000000</value_min>
</parameter>
<parameter id="GenParamName">
<default_type>string</default_type>
<default_value>[]</default_value>
<description lang="en_US">Name of the parameter whose value is provided by GenParamValue. The corresponding entry in GenParamValue can also be a dictionary including several parameters.</description>
<mixed_type>false</mixed_type>
<multivalue>optional</multivalue>
<sem_type>string</sem_type>
<type_list>
<item>string</item>
</type_list>
<values>
<item>'augment'</item>
<item>'evaluate'</item>
<item>'change'</item>
<item>'serialize'</item>
</values>
</parameter>
<parameter id="GenParamValue">
<default_type>integer</default_type>
<default_value>[]</default_value>
<description lang="en_US">Dictionary with the value for the parameter with the name given in GenParamName.</description>
<mixed_type>optional</mixed_type>
<multivalue>optional</multivalue>
<sem_type>any</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="NumEpochs">
<default_type>integer</default_type>
<description lang="en_US">Number of epochs the model will be trained.</description>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>integer</sem_type>
<type_list>
<item>integer</item>
</type_list>
<value_min>0</value_min>
</parameter>
<parameter id="RandomSeed">
<default_type>integer</default_type>
<default_value>42</default_value>
<description lang="en_US">Sets the random seed. With this you can set a specific random seed to ensure the reproducibility or you can set [] to indicate that no random seed should be set.</description>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>integer</sem_type>
<type_list>
<item>integer</item>
</type_list>
<value_min>0</value_min>
</parameter>
<parameter id="TrainParam">
<default_type>integer</default_type>
<description lang="en_US">Output parameter that can be used in train_dl_model.</description>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>dict</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
</parameters>
</docu>
</procedure>
<procedure name="create_evaluation_default_param">
<interface>
<ic>
<par name="EvaluationType" base_type="ctrl" dimension="0"/>
<par name="ClassIDsModel" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="EvalParams" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c>* </c>
<c>* This procedure generates a dictionary EvalParams,</c>
<c>* which contains default values for evaluation parameters.</c>
<c>* Depending on the evaluation type, the corresponding default parameters and values are set.</c>
<c>* The class IDs that the model can predict must be given via ClassIDsModel.</c>
<c>* </c>
<c>* Check inputs.</c>
<l>AvailableEvaluationTypes := ['anomaly_detection','classification','detection','segmentation']</l>
<l>tuple_gen_const (2 * |AvailableEvaluationTypes| - 1, '\',\'', EvaluationTypesStr)</l>
<l>EvaluationTypesStr[0:2:|EvaluationTypesStr|] := AvailableEvaluationTypes</l>
<l>EvaluationTypesStr := sum(EvaluationTypesStr)</l>
<l>tuple_find (AvailableEvaluationTypes, EvaluationType, Indices)</l>
<l>if (Indices == -1 or Indices == [])</l>
<l>    throw ('Unknown evaluation_type: ' + EvaluationType + '. Choose one of [\'' + EvaluationTypesStr + '\']')</l>
<l>endif</l>
<l>if (|ClassIDsModel| &lt; 1)</l>
<l>    throw ('ClassIDsModel should have at least one entry')</l>
<l>endif</l>
<c>* </c>
<c>* Initialize EvalParams.</c>
<l>create_dict (EvalParams)</l>
<l>set_dict_tuple (EvalParams, 'evaluation_type', EvaluationType)</l>
<c>* </c>
<c>* Set the class IDs.</c>
<l>set_dict_tuple (EvalParams, 'class_ids', ClassIDsModel)</l>
<l>set_dict_tuple (EvalParams, 'num_classes', |ClassIDsModel|)</l>
<c>* </c>
<c>* Set specific parameters depending on the evaluation type.</c>
<l>EvaluateInstances := false</l>
<l>if (EvaluationType == 'anomaly_detection')</l>
<c>    * </c>
<c>    * Set default image level measures.</c>
<l>    Measures := 'anomaly_score_histogram'</l>
<c>    * </c>
<c>    * Create dictionary for anomaly score histogram and set default</c>
<c>    * values. -1 means that the parameter is estimated during evaluation.</c>
<l>    create_dict (AnomalyScoreHistogram)</l>
<l>    set_dict_tuple (AnomalyScoreHistogram, 'min', 0.0)</l>
<l>    set_dict_tuple (AnomalyScoreHistogram, 'max', 1.0)</l>
<l>    set_dict_tuple (AnomalyScoreHistogram, 'num_bins', -1)</l>
<c>    * </c>
<l>    set_dict_tuple (EvalParams, 'anomaly_score_histogram', AnomalyScoreHistogram)</l>
<l>elseif (EvaluationType == 'classification')</l>
<c>    * </c>
<c>    * Set default classification measures.</c>
<l>    Measures := 'top1_error'</l>
<c>    * </c>
<c>    * Per default all classes are used for evaluation.</c>
<l>    set_dict_tuple (EvalParams, 'class_ids_to_evaluate', 'global')</l>
<l>elseif (EvaluationType == 'detection')</l>
<c>    * </c>
<c>    * Set default detection measures.</c>
<l>    Measures := 'mean_ap'</l>
<c>    * </c>
<c>    * Set detection-specific default values.</c>
<l>    EvaluateInstances := true</l>
<l>    set_dict_tuple (EvalParams, 'instance_type', 'rectangle1')</l>
<c>    * Generate ten IoU-thresholds from 0.5 to 0.95 in steps of 0.05.</c>
<l>    set_dict_tuple (EvalParams, 'iou_threshold', [0.5:0.05:0.96])</l>
<c>    * Set maximal number of detections to -1, i.e. all results per image will be evaluated.</c>
<l>    set_dict_tuple (EvalParams, 'max_num_detections', -1)</l>
<c>    * Set default area range named 'all', thus areas from 0 to a value larger than all likely occurring values.</c>
<l>    create_dict (AreaRanges)</l>
<l>    set_dict_tuple (AreaRanges, 'name', 'all')</l>
<l>    set_dict_tuple (AreaRanges, 'min', 0)</l>
<l>    set_dict_tuple (AreaRanges, 'max', 2e8)</l>
<l>    set_dict_tuple (EvalParams, 'area_ranges', AreaRanges)</l>
<c>    * Some tuples are changing their length during the evaluation. As this slows down the</c>
<c>    * evaluation process they are allocated in blocks of AllocationBlockLength.</c>
<l>    AllocationBlockLength := 200</l>
<l>    set_dict_tuple (EvalParams, 'allocation_block_length', AllocationBlockLength)</l>
<c>    * Detailed evaluation is not switched on per default, as it slows down the evaluation-process.</c>
<l>    set_dict_tuple (EvalParams, 'detailed_evaluation', false)</l>
<l>elseif (EvaluationType == 'segmentation')</l>
<c>    * </c>
<c>    * Set default pixel measures.</c>
<l>    Measures := ['pixel_accuracy','mean_accuracy','mean_iou']</l>
<c>    * </c>
<c>    * Per default there are no ignored classes.</c>
<l>    set_dict_tuple (EvalParams, 'ignore_class_ids', [])</l>
<l>endif</l>
<c>* </c>
<l>set_dict_tuple (EvalParams, 'evaluate_instances', EvaluateInstances)</l>
<l>set_dict_tuple (EvalParams, 'measures', Measures)</l>
<c>* </c>
<l>return ()</l>
</body>
<docu id="create_evaluation_default_param">
<abstract lang="en_US">This procedure generates a dictionary EvalParams, containing the default values of the applicable evaluation parameters.
The EvaluationType determines the type of the evaluation, which corresponds to the type of the model to be evaluated. Therefore, EvaluationType can have the values 'anomaly_detection', 'classification', 'detection', or 'segmentation'.
ClassIDsModel passes the class IDs the model can predict.
Note that this procedure is intended to be used within evaluate_dl_model.

Depending on the evaluation type, different dictionary entries are set:
- for all types:
   -- 'evaluation_type': Type of evaluation, set to EvaluationType.
   -- 'evaluate_instances': Determines if the evaluation is done instance-based. This parameter has the following values:
      --- 'true': For EvaluationType 'detection'.
      --- 'false': For EvaluationType 'anomaly_detection', 'classification' and 'segmentation'.
   -- 'class_ids': Class IDs of the classes that are used during the evaluation. Set to ClassIDsModel, i.e. the class IDs that the model can predict.
   -- 'num_classes': Number of classes that the model can predict, i.e., |ClassIDsModel|.
   -- 'measures': Measures to be calculated. For information, which measures can be set, please see evaluate_dl_model.
       The default value depends on the type of evaluation
       --- ['top1_error']: for type 'classification'.
       --- ['mean_ap']: for type 'detection'.
       --- ['pixel_accuracy', 'mean_accuracy', 'mean_iou']: for type 'segmentation'.

- for EvaluationType 'anomaly_detection':
  -- 'anomaly_score_histogram': Parameters that control the calculation of the score histogram.
     The parameters are defined in a dictionary with the following entries:
      --- 'min': Minimum value in the histogram. The default value is -1.
      --- 'max': Maximum value in the histogram. The default value is -1.
      --- 'num_bins': Number of bins. The default value is -1.
      Note that -1 indicates that the value is estimated during the evaluation.

- for EvaluationType 'classification':
  -- 'class_ids_to_evaluate': IDs of the classes to be evaluated.

- for EvaluationType 'detection':
   -- 'iou_threshold': Intersection over union (IoU) thresholds to be used.
      A result instance is a true positive if it has the correct class and the highest confidence of all results that have
      an IoU&gt;threshold with one of the ground truth instances.
      The default value is [0.5, 0.55, 0.6, 0.65, 0.7, 0.75, 0.8, 0.85, 0.9, 0.95].
   -- 'max_num_detections': Maximal number of detections (result instances) per image and class.
      Only those with the highest confidence will be used.
      -1 corresponds to using all available result instances. The default value is -1.
   -- 'area_ranges': Only evaluate ground truth instances within the given area ranges.
      Thereby, false positive result instances that are outside the area range are ignored.
      The areas are defined within this dictionary over the tuples:
      --- 'name': Name of the area_range. The default value is ['all'].
      --- 'min': Minimal area. The default value is [0].
      --- 'max': Maximal area. The default value is [2e8].
   -- 'instance_type': Type of the instances. Possible values: 'rectangle1': axis-aligned boxes, 'rectangle2': oriented boxes.
      The default value is 'rectangle1'.
   -- 'allocation_block_length': Determines the block length for allocation of tuples.
      This block allocation is done for certain instance RunningMeasures, where the tuple changes its length, due to speed up. The default value is 200.
   -- 'detailed_evaluation': Optional parameter. You can set the following values:
      --- 'true': The evaluation will additionally return the number of true positive (TP), false positive (FP), and false negative (FN) detections. 
          It will also give back the image IDs of samples where FP or FN occur and subdivides the FP group (see the documentation of calculate_evaluation_measures).
          Note that setting this parameter to true significantly slows down the evaluation process.
      --- 'false' (default): The detailed evaluation is not performed.

- for EvaluationType 'segmentation':
   -- 'ignore_class_ids': Class IDs of regions that should be ignored during the evaluation.
      Pixels assigned to a 'ignore' class are ignored by the loss as well as for all measures and evaluations. 
      The default value is [].

For further information to the different evaluation measures, see also the corresponding chapter references.</abstract>
<chapters lang="de_DE">
<item>Deep Learning</item>
<item>Evaluierung</item>
</chapters>
<chapters lang="en_US">
<item>Deep Learning</item>
<item>Evaluation</item>
</chapters>
<library lang="en_US">MVTec Standard Procedures</library>
<short lang="en_US">Generate a dictionary EvalParams, which contains default values for evaluation parameters.</short>
<parameters>
<parameter id="ClassIDsModel">
<default_type>integer</default_type>
<default_value>ClassIDsModel</default_value>
<description lang="en_US">The IDs of the classes the model can predict.</description>
<mixed_type>false</mixed_type>
<multivalue>optional</multivalue>
<sem_type>any</sem_type>
<type_list>
<item>integer</item>
</type_list>
<value_min>0</value_min>
</parameter>
<parameter id="EvalParams">
<default_type>integer</default_type>
<description lang="en_US">Dictionary with the evaluation parameters.</description>
<mixed_type>false</mixed_type>
<sem_type>dict</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="EvaluationType">
<default_type>string</default_type>
<default_value>EvaluationType</default_value>
<description lang="en_US">Determines the type of the evaluation, thus for 'detection' the evaluation is instance-wise, while for 'segmentation' it is pixel-wise.</description>
<sem_type>string</sem_type>
<type_list>
<item>string</item>
</type_list>
<values>
<item>'segmentation'</item>
<item>'detection'</item>
</values>
</parameter>
</parameters>
</docu>
</procedure>
<procedure name="create_visualization_message_queues" access="local">
<interface>
<oc>
<par name="MessageQueues" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<l>create_message_queue (QueueHandleInMouse)</l>
<l>create_message_queue (QueueHandleInEvents)</l>
<l>create_message_queue (QueueHandleOut)</l>
<l>set_message_queue_param (QueueHandleInMouse, 'max_message_num', 1)</l>
<l>MessageQueues := [QueueHandleInMouse,QueueHandleInEvents,QueueHandleOut]</l>
<l>return ()</l>
<c></c>
</body>
<docu id="create_visualization_message_queues">
<abstract lang="en_US">Create the message queues used by visualize_object_model_3d_ext.</abstract>
<chapters lang="en_US">
<item>System</item>
<item>Multithreading</item>
</chapters>
<library lang="en_US">MVTec Standard Procedures</library>
<parameters>
<parameter id="MessageQueues">
<default_type>integer</default_type>
<mixed_type>false</mixed_type>
<sem_type>message_queue</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
</parameters>
</docu>
</procedure>
<procedure name="debug_find_box_3d">
<interface>
<ic>
<par name="ObjectModel3DBox" base_type="ctrl" dimension="0"/>
<par name="ObjectModel3DScene" base_type="ctrl" dimension="0"/>
<par name="BoxInformation" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="FindBox3DGenParam" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c>* Please adjust the WindowScaling parameter in order to zoom the window size as desired.</c>
<l>WindowScaling := 1.2</l>
<c>* </c>
<l>WindowSize := int(512 * WindowScaling)</l>
<l>FontSize := 13.5 * WindowScaling</l>
<c>* </c>
<l>WidthMenu := WindowSize * 2</l>
<l>HeightMenu := WindowSize / 3</l>
<c>* </c>
<l>dev_open_window (0, 0, WidthMenu, HeightMenu, 'black', WindowHandleMenu)</l>
<l>WindowHandle1 := []</l>
<l>WindowHandle2 := []</l>
<c>* </c>
<l>get_window_extents (WindowHandleMenu, Row, Column, Width, Height)</l>
<l>set_display_font (WindowHandleMenu, FontSize, 'mono', 'true', 'false')</l>
<c>* </c>
<c>* Define the entries in the menu.</c>
<l>MenuText := 'Automatic Value Check'</l>
<l>MenuCode := 'check'</l>
<c>* Add Edge menu items.</c>
<l>MenuText := [MenuText,'3D Edge Extraction','3D Edge Directions']</l>
<l>MenuCode := [MenuCode,'scene_edge_params','scene_edge_dirs']</l>
<c>* Add Results inspection.</c>
<l>MenuText := [MenuText,'FindBox Results']</l>
<l>MenuCode := [MenuCode,'results']</l>
<c>* Add Exit menu item.</c>
<l>MenuText := [MenuText,'Exit']</l>
<l>MenuCode := [MenuCode,'exit']</l>
<c>* </c>
<c>* Generate the menu buttons.</c>
<l>TopBottom := 'top'</l>
<l>NumCols := 4</l>
<l>NumRows := 1 + (|MenuText| - 1) / NumCols</l>
<l>PercentageHeight := 20 * NumRows</l>
<l>CheckedCase := NumCols + 1</l>
<l>Case := NumCols + 1</l>
<l>gen_menu_regions_ext (MenuRegions, TopBottom, WindowHandleMenu, PercentageHeight, NumRows, NumCols)</l>
<c>* </c>
<l>smallest_rectangle1 (MenuRegions, RowButtons0, ColumnButtons0, RowButtons1, ColumnButtons1)</l>
<l>MenuBottom := max(RowButtons1)</l>
<l>set_tposition (WindowHandleMenu, MenuBottom + 6, 1)</l>
<c>* </c>
<c>* Fetch poses and scores: This acts as a sanity check for input data, too.</c>
<l>get_dict_tuple (BoxInformation, 'results', BoxResultsDict)</l>
<l>get_dict_param (BoxResultsDict, 'keys', [], AllBoxResultsDictKeys)</l>
<l>if (|AllBoxResultsDictKeys| &gt; 0)</l>
<l>    try</l>
<l>        Pose := []</l>
<l>        Score := []</l>
<l>        for Index := 0 to |AllBoxResultsDictKeys| - 1 by 1</l>
<l>            get_dict_tuple (BoxResultsDict, Index, CurrResultDict)</l>
<l>            get_dict_tuple (CurrResultDict, 'box_pose', CurrPose)</l>
<l>            Pose := [Pose,CurrPose]</l>
<l>            get_dict_tuple (CurrResultDict, 'score', CurrScore)</l>
<l>            Score := [Score,CurrScore]</l>
<l>        endfor</l>
<l>    catch (Exception)</l>
<c>        * Result handle is invalid, or we are in an unsupported HALCON version.</c>
<l>        dev_set_window (WindowHandleMenu)</l>
<l>        dev_clear_window ()</l>
<l>        disp_message (WindowHandleMenu, 'Error: This version of HALCON is not supported by this procedure, or the given result handle\n was not created with find_box_3d', 'window', 12, 12, 'red', 'false')</l>
<l>        wait_continue_button (WindowHandleMenu)</l>
<l>        dev_close_window ()</l>
<l>        return ()</l>
<l>    endtry</l>
<l>endif</l>
<c>* </c>
<l>CasesDone := []</l>
<l>CurrentCase := []</l>
<l>LastException := []</l>
<c>* </c>
<c>* Find the parameters used for the edge extraction.</c>
<l>get_dict_tuple (BoxInformation, 'gen_param', GenParamDict)</l>
<l>get_dict_tuple (GenParamDict, 'viewpoint', Viewpoint)</l>
<l>ViewpointStr := Viewpoint[0] + ' ' + Viewpoint[1] + ' ' + Viewpoint[2]</l>
<l>get_dict_tuple (GenParamDict, 'max_gap', MaxGap)</l>
<l>get_dict_tuple (GenParamDict, '3d_edge_min_amplitude', MinAmplitude)</l>
<c>* </c>
<l>while (true)</l>
<l>    clear_window (WindowHandleMenu)</l>
<l>    disp_menu_ext (MenuRegions, WindowHandleMenu, MenuText, CasesDone, [], WindowScaling)</l>
<l>    set_tposition (WindowHandleMenu, MenuBottom + 6, 1)</l>
<l>    write_note (WindowHandleMenu, 'info', 'Please consider the limitations of this procedure as described in its documentation.')</l>
<l>    write_note (WindowHandleMenu, 'instruction', 'Select a test from above. It is recommended to start with the Automatic Value Check.')</l>
<l>    if (|AllBoxResultsDictKeys| == 0)</l>
<l>        write_note (WindowHandleMenu, 'warning', 'No box was found in this run of find_box_3d. Therefore, not all tests are available.')</l>
<l>    endif</l>
<l>    if (LastException != [])</l>
<l>        dev_get_exception_data (LastException, 'error_message', ErrorMessage)</l>
<l>        write_note (WindowHandleMenu, 'warning', ['Exception while running tool: ' + ErrorMessage,'The scene, model or edges might be empty. Try the Automatic Value Check first.'])</l>
<l>        LastException := []</l>
<l>    endif</l>
<l>    select_case (MenuRegions, WindowHandleMenu, MenuText, CurrentCase)</l>
<l>    if (CurrentCase == -1)</l>
<c>        * Window was closed -&gt; abort.</c>
<l>        break</l>
<l>    endif</l>
<l>    if (MenuCode[CurrentCase] == 'exit')</l>
<l>        break</l>
<l>    endif</l>
<l>    tuple_union (CasesDone, CurrentCase, CasesDone)</l>
<l>    disp_menu_ext (MenuRegions, WindowHandleMenu, MenuText, CasesDone, CurrentCase, WindowScaling)</l>
<c>    * </c>
<l>    try</l>
<c>        * ***************************</c>
<c>        * Check the data structure. *</c>
<c>        * ***************************</c>
<c>        * </c>
<l>        if (MenuCode[CurrentCase] == 'check')</l>
<c>            * Update the visualization of the menu.</c>
<l>            dev_set_window (WindowHandleMenu)</l>
<l>            set_tposition (WindowHandleMenu, MenuBottom + 6, 1)</l>
<l>            write_note (WindowHandleMenu, 'instruction', 'Please wait while an automatic check of parameters and values is performed.')</l>
<c>            * </c>
<l>            dev_open_window (HeightMenu + 50, 0, WindowSize * 2, WindowSize, 'black', WindowHandle1)</l>
<l>            set_display_font (WindowHandle1, FontSize, 'mono', 'true', 'false')</l>
<c>            * </c>
<l>            check_find_box_3d_params (WindowHandle1, ObjectModel3DBox, ObjectModel3DScene, BoxInformation)</l>
<c>            * </c>
<l>            dev_close_window_if_open (WindowHandle1)</l>
<l>        endif</l>
<c>        * </c>
<c>        * *********************</c>
<c>        * 3D Edge Extraction. *</c>
<c>        * *********************</c>
<c>        * </c>
<l>        if (MenuCode[CurrentCase] == 'scene_edge_params')</l>
<l>            dev_set_window (WindowHandleMenu)</l>
<l>            set_tposition (WindowHandleMenu, MenuBottom + 6, 1)</l>
<l>            Message := 'Find the 3D edges by adjusting the MinAmplitude and the MaxGap accordingly'</l>
<l>            write_note (WindowHandleMenu, 'instruction', Message)</l>
<c>            * </c>
<l>            dev_open_window (HeightMenu + 50, 0, WindowSize, WindowSize, 'black', WindowHandle1)</l>
<l>            dev_open_window (HeightMenu + 50, WindowSize, WindowSize, WindowSize, 'black', WindowHandle2)</l>
<l>            set_display_font (WindowHandle1, FontSize, 'mono', 'true', 'false')</l>
<l>            set_display_font (WindowHandle2, FontSize, 'mono', 'true', 'false')</l>
<c>            * </c>
<l>            inspect_scene_edge_parameters_find_box_3d (WindowHandle1, WindowHandle2, ObjectModel3DBox, ObjectModel3DScene, BoxInformation, MaxGap, MinAmplitude)</l>
<l>            EdgeParamsSet := true</l>
<c>            * </c>
<l>            dev_close_window_if_open (WindowHandle1)</l>
<l>            dev_close_window_if_open (WindowHandle2)</l>
<l>        endif</l>
<c>        * </c>
<c>        * ********************</c>
<c>        * 3D Edge Direction. *</c>
<c>        * ********************</c>
<c>        * </c>
<l>        if (MenuCode[CurrentCase] == 'scene_edge_dirs')</l>
<l>            dev_set_window (WindowHandleMenu)</l>
<l>            set_tposition (WindowHandleMenu, MenuBottom + 6, 1)</l>
<l>            Message := 'Move the left view such that you see the scene from the direction of the sensor (viewpoint, default is [0,0,0]). ' + 'The right view shows the extracted edges, viewing directions (green) and edge directions (red). The viewing directions show away from the viewpoint. ' + 'The edge directions should be perpendicular to the edges and point outward.'</l>
<l>            write_note (WindowHandleMenu, 'instruction', Message)</l>
<c>            * </c>
<l>            dev_open_window (HeightMenu + 50, 0, WindowSize, WindowSize, 'black', WindowHandle1)</l>
<l>            dev_open_window (HeightMenu + 50, WindowSize, WindowSize, WindowSize, 'black', WindowHandle2)</l>
<l>            set_display_font (WindowHandle1, FontSize, 'mono', 'true', 'false')</l>
<l>            set_display_font (WindowHandle2, FontSize, 'mono', 'true', 'false')</l>
<c>            * </c>
<l>            inspect_scene_edge_directions_find_box_3d (WindowHandle1, WindowHandle2, ObjectModel3DBox, ObjectModel3DScene, BoxInformation, Viewpoint)</l>
<c>            * </c>
<l>            dev_close_window_if_open (WindowHandle1)</l>
<l>            dev_close_window_if_open (WindowHandle2)</l>
<l>        endif</l>
<c>        * </c>
<c>        * *****************************</c>
<c>        * Inspect Box Finder Results. *</c>
<c>        * *****************************</c>
<c>        * </c>
<l>        if (MenuCode[CurrentCase] == 'results')</l>
<c>            * Update the visualization of the menu.</c>
<l>            dev_set_window (WindowHandleMenu)</l>
<l>            set_tposition (WindowHandleMenu, MenuBottom + 6, 1)</l>
<l>            write_note (WindowHandleMenu, 'instruction', 'Inspect the box finder results below.')</l>
<c>            * </c>
<l>            dev_open_window (HeightMenu + 50, 0, WindowSize, WindowSize, 'black', WindowHandle1)</l>
<l>            set_display_font (WindowHandle1, FontSize, 'mono', 'true', 'false')</l>
<c>            * </c>
<l>            dev_display_find_box_3d_results (WindowHandle1, BoxInformation, ObjectModel3DBox, ObjectModel3DScene, Score, Pose)</l>
<c>            * </c>
<l>            dev_close_window_if_open (WindowHandle1)</l>
<l>        endif</l>
<l>    catch (Exception)</l>
<l>        LastException := Exception</l>
<l>        dev_close_window_if_open (WindowHandle1)</l>
<l>        dev_close_window_if_open (WindowHandle2)</l>
<l>    endtry</l>
<l>endwhile</l>
<c>* </c>
<l>dev_close_window_if_open (WindowHandleMenu)</l>
<c>* </c>
<c>* Construct the parameters.</c>
<l>create_dict (FindBox3DGenParam)</l>
<c>* Copy the old parameters, but without lengths and min_score.</c>
<l>get_dict_param (GenParamDict, 'keys', [], AllParamKeys)</l>
<l>for Index := 0 to |AllParamKeys| - 1 by 1</l>
<l>    Key := AllParamKeys[Index]</l>
<l>    if (Key == 'lengths' or Key == 'min_score')</l>
<l>        continue</l>
<l>    else</l>
<l>        get_dict_tuple (GenParamDict, Key, OldParamValue)</l>
<l>        set_dict_tuple (FindBox3DGenParam, Key, OldParamValue)</l>
<l>    endif</l>
<l>endfor</l>
<c>* Set the new parameters.</c>
<l>set_dict_tuple (FindBox3DGenParam, '3d_edge_min_amplitude', MinAmplitude)</l>
<l>set_dict_tuple (FindBox3DGenParam, 'max_gap', MaxGap)</l>
<l>set_dict_tuple (FindBox3DGenParam, 'viewpoint', Viewpoint[0] + ' ' + Viewpoint[1] + ' ' + Viewpoint[2])</l>
</body>
<docu id="debug_find_box_3d">
<abstract lang="en_US">This procedure allows to visualize and debug various parameters for the generic box finder. For it to be used, perform one call to find_box_3d. Then pass the resulting 3D object models of the found boxes, the 3D object model of the scene and the dictionary containing the box information to this procedure.

Note that this procedure is mainly meant for debugging the parameters of an application of the generic box finder. Since the root causes for potential issues can vary greatly, this procedure can not always recommend appropriate steps for resolving those issues. However, it will often at least indicate that such issues exist and what their nature are.

Note that the procedure must be run with F5 and cannot be stepped through, as it uses multiple threads.

Further note that this procedure does not check all parameters passed to find_box_3d.

The procedure first opens a menu window, in which further instructions are noted. After selecting one of the menu items, an additional window will open that is used for inspecting, debugging or modifying the parameters. To adapt the window sizes to different monitor resolutions, change the WindowScaling variable at the very beginning of the procedure.

Once complete, the parameters set within the procedures will be returned by the procedure in FindBox3DGenParam. This dictionary can be used to adapt the generic box finder accordingly.</abstract>
<chapters lang="en_US">
<item>3D Matching</item>
<item>3D-Box</item>
</chapters>
<example lang="en_US">find_box_3d (ObjectModel3DScene, SideLen1, SideLen2, -1, GenParam, GrippingPose, Length1, Length2, Length3, Score, ObjectModel3DBox, BoxInformation)
debug_find_box_3d (ObjectModel3DBox, ObjectModel3DScene, BoxInformation, FindBox3DParamName, FindBox3DModelParamValue)</example>
<library lang="en_US">MVTec Standard Procedures</library>
<predecessor>
<item>find_box_3d</item>
</predecessor>
<see_also>
<item>find_box_3d</item>
</see_also>
<short lang="en_US">Inspect the parameters for the generic box finder.</short>
<parameters>
<parameter id="BoxInformation">
<default_type>handle</default_type>
<description lang="en_US">Dictionary with results of the box finder.</description>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>dict</sem_type>
<type_list>
<item>handle</item>
</type_list>
</parameter>
<parameter id="FindBox3DGenParam">
<default_type>handle</default_type>
<description lang="en_US">Parameter to be passed to find_box_3d.</description>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>dict</sem_type>
<type_list>
<item>handle</item>
</type_list>
</parameter>
<parameter id="ObjectModel3DBox">
<default_type>handle</default_type>
<description lang="en_US">3D object models of the found boxes.</description>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>object_model_3d</sem_type>
<type_list>
<item>handle</item>
</type_list>
</parameter>
<parameter id="ObjectModel3DScene">
<default_type>handle</default_type>
<description lang="en_US">The scene where the object is to be found, as passed to find_box_3d.</description>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>object_model_3d</sem_type>
<type_list>
<item>handle</item>
</type_list>
</parameter>
</parameters>
</docu>
</procedure>
<procedure name="debug_find_surface_model">
<interface>
<ic>
<par name="SurfaceModelID" base_type="ctrl" dimension="0"/>
<par name="ObjectModel3DModel" base_type="ctrl" dimension="0"/>
<par name="ObjectModel3DScene" base_type="ctrl" dimension="0"/>
<par name="SurfaceMatchingResultID" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="CreateSurfaceModelParamName" base_type="ctrl" dimension="0"/>
<par name="CreateSurfaceModelParamValue" base_type="ctrl" dimension="0"/>
<par name="FindSurfaceModelParamName" base_type="ctrl" dimension="0"/>
<par name="FindSurfaceModelParamValue" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c>* Please adjust the WindowScaling parameter in order to zoom the window size as desired</c>
<l>WindowScaling := 1.2</l>
<c>* </c>
<l>WindowSize := int(512 * WindowScaling)</l>
<l>FontSize := 13.5 * WindowScaling</l>
<c>* </c>
<l>WidthMenu := WindowSize * 2</l>
<l>HeightMenu := WindowSize / 3</l>
<c>* </c>
<l>dev_open_window (0, 0, WidthMenu, HeightMenu, 'black', WindowHandleMenu)</l>
<l>WindowHandle1 := []</l>
<l>WindowHandle2 := []</l>
<c>* </c>
<l>get_window_extents (WindowHandleMenu, Row, Column, Width, Height)</l>
<l>set_display_font (WindowHandleMenu, FontSize, 'mono', 'true', 'false')</l>
<c>* </c>
<c>* Define the entries in the menu</c>
<l>get_surface_model_param (SurfaceModelID, '3d_edges_trained', HasEdges)</l>
<l>get_surface_model_param (SurfaceModelID, 'view_based_trained', HasViewBased)</l>
<l>MenuText := 'Automatic Value Check'</l>
<l>MenuCode := 'check'</l>
<c>* Add Normals menu item</c>
<l>if (|SurfaceMatchingResultID| &gt; 0)</l>
<l>    MenuText := [MenuText,'Normal Directions']</l>
<l>    MenuCode := [MenuCode,'normals']</l>
<l>endif</l>
<c>* Add Edge menu items</c>
<l>if (HasEdges == 'true')</l>
<l>    MenuText := [MenuText,'Inspect Model Edges']</l>
<l>    MenuCode := [MenuCode,'model_edges']</l>
<c></c>
<l>    if (|SurfaceMatchingResultID| &gt; 0)</l>
<l>        MenuText := [MenuText,'3D Edge Extraction','3D Edge Directions']</l>
<l>        MenuCode := [MenuCode,'scene_edge_params','scene_edge_dirs']</l>
<l>    endif</l>
<l>endif</l>
<c>* Add view-based menu items</c>
<l>if (HasViewBased == 'true')</l>
<l>    if (|SurfaceMatchingResultID| &gt;= 0)</l>
<l>        MenuText := [MenuText,'View-Based Check']</l>
<l>        MenuCode := [MenuCode,'scene_visibility']</l>
<l>    endif</l>
<l>endif</l>
<c>* Add Results inspection</c>
<l>if (|SurfaceMatchingResultID| &gt; 0)</l>
<l>    MenuText := [MenuText,'Matching Results']</l>
<l>    MenuCode := [MenuCode,'results']</l>
<l>endif</l>
<c>* Add Exit menu item</c>
<l>MenuText := [MenuText,'Exit']</l>
<l>MenuCode := [MenuCode,'exit']</l>
<c>* </c>
<c>* Generate the menu buttons</c>
<l>TopBottom := 'top'</l>
<l>NumCols := 4</l>
<l>NumRows := 1 + (|MenuText| - 1) / NumCols</l>
<l>PercentageHeight := 20 * NumRows</l>
<l>CheckedCase := NumCols + 1</l>
<l>Case := NumCols + 1</l>
<l>gen_menu_regions_ext (MenuRegions, TopBottom, WindowHandleMenu, PercentageHeight, NumRows, NumCols)</l>
<c>* </c>
<l>smallest_rectangle1 (MenuRegions, RowButtons0, ColumnButtons0, RowButtons1, ColumnButtons1)</l>
<l>MenuBottom := max(RowButtons1)</l>
<l>set_tposition (WindowHandleMenu, MenuBottom + 6, 1)</l>
<l>write_note (WindowHandleMenu, 'instruction', 'Handlungsanweisung')</l>
<c>* </c>
<l>if (|SurfaceMatchingResultID| &gt; 0)</l>
<l>    try</l>
<l>        get_surface_matching_result (SurfaceMatchingResultID, 'sampling_rate', 0, RelSamplingDistance)</l>
<l>        get_surface_matching_result (SurfaceMatchingResultID, 'refpt_rate', 0, KeyPointFraction)</l>
<l>        get_surface_matching_result (SurfaceMatchingResultID, 'min_score', 0, MinScore)</l>
<l>        get_surface_matching_result (SurfaceMatchingResultID, 'param_names', 0, GenParamNames)</l>
<l>        get_surface_matching_result (SurfaceMatchingResultID, 'param_values', 0, GenParamValues)</l>
<l>        get_surface_matching_result (SurfaceMatchingResultID, 'num_poses', 0, NumPoses)</l>
<l>        Pose := []</l>
<l>        Score := []</l>
<l>        for Index := 0 to NumPoses - 1 by 1</l>
<l>            get_surface_matching_result (SurfaceMatchingResultID, 'pose', Index, CurrPose)</l>
<l>            Pose := [Pose,CurrPose]</l>
<l>            get_surface_matching_result (SurfaceMatchingResultID, 'score', Index, CurrScore)</l>
<l>            Score := [Score,CurrScore]</l>
<l>        endfor</l>
<l>    catch (Exception)</l>
<c>        * Result handle is invalid, or we are in an unsupported HALCON version</c>
<l>        dev_set_window (WindowHandleMenu)</l>
<l>        dev_clear_window ()</l>
<l>        disp_message (WindowHandleMenu, 'Error: This version of HALCON is not supported by this procedure, or the given result handle\n was not created with find_surface_model', 'window', 12, 12, 'red', 'false')</l>
<l>        wait_continue_button (WindowHandleMenu)</l>
<l>        dev_close_window ()</l>
<l>        return ()</l>
<l>    endtry</l>
<l>    if (RelSamplingDistance == 0)</l>
<l>        dev_set_window (WindowHandleMenu)</l>
<l>        dev_clear_window ()</l>
<l>        disp_message (WindowHandleMenu, 'Error: The given result handle was not created with find_surface_model. Please pass a result handle\n created by find_surface_model.', 'window', 12, 12, 'red', 'false')</l>
<l>        wait_continue_button (WindowHandleMenu)</l>
<l>        dev_close_window ()</l>
<l>        return ()</l>
<l>    endif</l>
<l>else</l>
<l>    GenParamNames := []</l>
<l>    GenParamValues := []</l>
<l>endif</l>
<c>* </c>
<l>CasesDone := []</l>
<l>CurrentCase := []</l>
<c>* </c>
<c>* Find the parameters used for the edge extraction</c>
<l>MaxGap := []</l>
<l>MinAmplitudeAbs := []</l>
<l>Viewpoint := []</l>
<l>LastException := []</l>
<l>UserProvidedEdges := false</l>
<l>if (HasEdges == 'true' and |SurfaceMatchingResultID| &gt; 0)</l>
<l>    get_surface_model_param (SurfaceModelID, 'diameter', ModelDiameter)</l>
<l>    get_find_parameter (GenParamNames, GenParamValues, 'viewpoint', '0 0 0', ViewpointStr)</l>
<l>    Viewpoint := number(split(ViewpointStr,' '))</l>
<l>    get_find_parameter (GenParamNames, GenParamValues, 'max_gap', 30, MaxGap)</l>
<l>    get_find_parameter (GenParamNames, GenParamValues, '3d_edge_min_amplitude_rel', [], MinAmplitudeRel)</l>
<l>    if (MinAmplitudeRel != [])</l>
<l>        MinAmplitudeAbs := MinAmplitudeRel * ModelDiameter</l>
<l>    else</l>
<l>        get_find_parameter (GenParamNames, GenParamValues, '3d_edge_min_amplitude_abs', 0.05 * ModelDiameter, MinAmplitudeAbs)</l>
<l>    endif</l>
<c>    * </c>
<l>    get_find_parameter (GenParamNames, GenParamValues, '3d_edges', [], OM3DProvidedEdges)</l>
<l>    UserProvidedEdges := |OM3DProvidedEdges| &gt; 0</l>
<l>elseif (HasViewBased == 'true' and |SurfaceMatchingResultID| &gt; 0)</l>
<l>    get_surface_model_param (SurfaceModelID, 'diameter', ModelDiameter)</l>
<l>    get_find_parameter (GenParamNames, GenParamValues, 'viewpoint', '0 0 0', ViewpointStr)</l>
<l>    Viewpoint := number(split(ViewpointStr,' '))</l>
<l>endif</l>
<l>NormalParamsSet := false</l>
<c>* </c>
<l>while (true)</l>
<l>    clear_window (WindowHandleMenu)</l>
<l>    disp_menu_ext (MenuRegions, WindowHandleMenu, MenuText, CasesDone, [], WindowScaling)</l>
<l>    set_tposition (WindowHandleMenu, MenuBottom + 6, 1)</l>
<l>    write_note (WindowHandleMenu, 'info', 'Please consider the limitations of this procedure as described in its documentation.')</l>
<l>    write_note (WindowHandleMenu, 'instruction', 'Select a test from above. It is recommended to start with the Automatic Value Check.')</l>
<l>    if (|SurfaceMatchingResultID| == 0)</l>
<l>        write_note (WindowHandleMenu, 'warning', 'No result handle was provided. To enable more tests, run find_surface_model() with \'ReturnResultHandle\' set to \'true\' beforehand and pass the result handle to this procedure.')</l>
<l>    endif</l>
<l>    if (UserProvidedEdges)</l>
<l>        write_note (WindowHandleMenu, 'warning', 'Edges were passed to find_surface_model manually with the \'3d_edges\' parameter. Some checks of scene edges might be incorrect, since they assume that edges are extracted by find_surface_model.')</l>
<l>    endif</l>
<l>    if (LastException != [])</l>
<l>        dev_get_exception_data (LastException, 'error_message', ErrorMessage)</l>
<l>        write_note (WindowHandleMenu, 'warning', ['Exception while running tool: ' + ErrorMessage,'The scene, model or edges might be empty. Try the Automatic Value Check first.'])</l>
<l>        LastException := []</l>
<l>    endif</l>
<l>    select_case (MenuRegions, WindowHandleMenu, MenuText, CurrentCase)</l>
<l>    if (CurrentCase == -1)</l>
<c>        * Window was closed -&gt; abort</c>
<l>        break</l>
<l>    endif</l>
<l>    if (MenuCode[CurrentCase] == 'exit')</l>
<l>        break</l>
<l>    endif</l>
<l>    tuple_union (CasesDone, CurrentCase, CasesDone)</l>
<l>    disp_menu_ext (MenuRegions, WindowHandleMenu, MenuText, CasesDone, CurrentCase, WindowScaling)</l>
<c>    * </c>
<l>    try</l>
<c>        * ****************************</c>
<c>        * Inspect Normal Directions *</c>
<c>        * ****************************</c>
<l>        if (MenuCode[CurrentCase] == 'normals')</l>
<l>            dev_set_window (WindowHandleMenu)</l>
<l>            set_tposition (WindowHandleMenu, MenuBottom + 6, 1)</l>
<l>            Message := 'Check visually, if the normals of the model point approximately in the same direction as the normals of the scene by moving the model and the scene accordingly'</l>
<l>            write_note (WindowHandleMenu, 'instruction', Message)</l>
<c>            * </c>
<l>            dev_open_window (HeightMenu + 50, 0, WindowSize, WindowSize, 'black', WindowHandle1)</l>
<l>            dev_open_window (HeightMenu + 50, WindowSize, WindowSize, WindowSize, 'black', WindowHandle2)</l>
<l>            set_display_font (WindowHandle1, FontSize, 'mono', 'true', 'false')</l>
<l>            set_display_font (WindowHandle2, FontSize, 'mono', 'true', 'false')</l>
<c>            * </c>
<l>            inspect_normal_direction (MenuRegions, WindowHandle1, WindowHandle2, WindowHandleMenu, SurfaceModelID, ObjectModel3DScene, RelSamplingDistance, KeyPointFraction, MinScore, GenParamNames, GenParamValues, SurfaceMatchingResultID, MenuText, CurrentCase, CasesDone, FontSize, WindowScaling, CreateName, CreateValue, FindNames, FindValues)</l>
<l>            NormalParamsSet := true</l>
<c>            * </c>
<l>            dev_close_window_if_open (WindowHandle1)</l>
<l>            dev_close_window_if_open (WindowHandle2)</l>
<l>        endif</l>
<c>        * </c>
<c>        * ***************************</c>
<c>        * Check the data structure *</c>
<c>        * ***************************</c>
<c>        * </c>
<l>        if (MenuCode[CurrentCase] == 'check')</l>
<c>            * Update the visualization of the menu</c>
<l>            dev_set_window (WindowHandleMenu)</l>
<l>            set_tposition (WindowHandleMenu, MenuBottom + 6, 1)</l>
<l>            write_note (WindowHandleMenu, 'instruction', 'Please wait while an automatic check of parameters and values is performed')</l>
<c>            * </c>
<l>            dev_open_window (HeightMenu + 50, 0, WindowSize * 2, WindowSize, 'black', WindowHandle1)</l>
<l>            set_display_font (WindowHandle1, FontSize, 'mono', 'true', 'false')</l>
<c>            * </c>
<l>            check_find_surface_model_params (WindowHandle1, SurfaceModelID, ObjectModel3DScene, GenParamNames, GenParamValues)</l>
<c>            * </c>
<l>            dev_close_window_if_open (WindowHandle1)</l>
<l>        endif</l>
<c>        * </c>
<c>        * ****************</c>
<c>        * Prepare edges *</c>
<c>        * ****************</c>
<c>        * </c>
<l>        if (MenuCode[CurrentCase] == 'scene_edge_params')</l>
<l>            dev_set_window (WindowHandleMenu)</l>
<l>            set_tposition (WindowHandleMenu, MenuBottom + 6, 1)</l>
<l>            Message := 'Find the 3D edges by adjusting the MinAmplitude and the MaxGap accordingly'</l>
<l>            write_note (WindowHandleMenu, 'instruction', Message)</l>
<c>            * </c>
<l>            dev_open_window (HeightMenu + 50, 0, WindowSize, WindowSize, 'black', WindowHandle1)</l>
<l>            dev_open_window (HeightMenu + 50, WindowSize, WindowSize, WindowSize, 'black', WindowHandle2)</l>
<l>            set_display_font (WindowHandle1, FontSize, 'mono', 'true', 'false')</l>
<l>            set_display_font (WindowHandle2, FontSize, 'mono', 'true', 'false')</l>
<c>            * </c>
<l>            inspect_scene_edge_parameters (WindowHandle1, WindowHandle2, SurfaceModelID, ObjectModel3DScene, SurfaceMatchingResultID, MaxGap, MinAmplitudeAbs, Viewpoint, MaxGap, MinAmplitudeAbs)</l>
<l>            EdgeParamsSet := true</l>
<c>            * </c>
<l>            dev_close_window_if_open (WindowHandle1)</l>
<l>            dev_close_window_if_open (WindowHandle2)</l>
<l>        endif</l>
<c>        * </c>
<c>        * ******************</c>
<c>        * Edge Directions *</c>
<c>        * ******************</c>
<c>        * </c>
<l>        if (MenuCode[CurrentCase] == 'scene_edge_dirs')</l>
<l>            dev_set_window (WindowHandleMenu)</l>
<l>            set_tposition (WindowHandleMenu, MenuBottom + 6, 1)</l>
<l>            Message := 'Move the left view such that you see the scene from the direction of the sensor (viewpoint, default is [0,0,0]). ' + 'The right view shows the extracted edges, viewing directions (green) and edge directions (red). The viewing directions show away from the viewpoint. ' + 'The edge directions should be perpendicular to the edges and point outward.'</l>
<l>            write_note (WindowHandleMenu, 'instruction', Message)</l>
<c>            * </c>
<l>            dev_open_window (HeightMenu + 50, 0, WindowSize, WindowSize, 'black', WindowHandle1)</l>
<l>            dev_open_window (HeightMenu + 50, WindowSize, WindowSize, WindowSize, 'black', WindowHandle2)</l>
<l>            set_display_font (WindowHandle1, FontSize, 'mono', 'true', 'false')</l>
<l>            set_display_font (WindowHandle2, FontSize, 'mono', 'true', 'false')</l>
<c>            * </c>
<l>            inspect_scene_edge_directions (WindowHandle1, WindowHandle2, SurfaceModelID, ObjectModel3DScene, SurfaceMatchingResultID, MaxGap, MinAmplitudeAbs, Viewpoint, Viewpoint)</l>
<c>            * </c>
<l>            dev_close_window_if_open (WindowHandle1)</l>
<l>            dev_close_window_if_open (WindowHandle2)</l>
<l>        endif</l>
<c>        * </c>
<c>        * ***************************</c>
<c>        * Inspect Model Edges      *</c>
<c>        * ***************************</c>
<c>        * </c>
<l>        if (MenuCode[CurrentCase] == 'model_edges')</l>
<c>            * Update the visualization of the menu</c>
<l>            dev_set_window (WindowHandleMenu)</l>
<l>            set_tposition (WindowHandleMenu, MenuBottom + 6, 1)</l>
<l>            write_note (WindowHandleMenu, 'info', 'This tool allows to inspect the edges that create_surface_model found in the object.')</l>
<l>            write_note (WindowHandleMenu, 'instruction', 'Use the left window to move the viewpoint and the right window to inspect the edges.')</l>
<l>            write_note (WindowHandleMenu, 'info', 'The visualized "edge directions" should be perpendicular to the direction of the model edges and point outward.')</l>
<c>            * </c>
<l>            dev_open_window (HeightMenu + 50, 0, WindowSize, WindowSize, 'black', WindowHandle1)</l>
<l>            dev_open_window (HeightMenu + 50, WindowSize, WindowSize, WindowSize, 'black', WindowHandle2)</l>
<l>            set_display_font (WindowHandle1, FontSize, 'mono', 'true', 'false')</l>
<l>            set_display_font (WindowHandle2, FontSize, 'mono', 'true', 'false')</l>
<c>            * </c>
<l>            check_model_edges (SurfaceModelID, ObjectModel3DModel, WindowHandle1, WindowHandle2)</l>
<c>            * </c>
<l>            dev_close_window_if_open (WindowHandle1)</l>
<l>            dev_close_window_if_open (WindowHandle2)</l>
<l>        endif</l>
<c>        * </c>
<c>        * ***************************</c>
<c>        * Inspect Visibility        *</c>
<c>        * ***************************</c>
<c>        * </c>
<l>        if (MenuCode[CurrentCase] == 'scene_visibility')</l>
<c>            * Update the visualization of the menu</c>
<l>            dev_set_window (WindowHandleMenu)</l>
<l>            set_tposition (WindowHandleMenu, MenuBottom + 6, 1)</l>
<l>            write_note (WindowHandleMenu, 'info', 'This tool allows to inspect the scene visibility.')</l>
<l>            write_note (WindowHandleMenu, 'instruction', 'Use the left window to move the viewpoint and the right window to inspect the visibility.')</l>
<c>            * </c>
<l>            dev_open_window (HeightMenu + 50, 0, WindowSize, WindowSize, 'black', WindowHandle1)</l>
<l>            dev_open_window (HeightMenu + 50, WindowSize, WindowSize, WindowSize, 'black', WindowHandle2)</l>
<l>            set_display_font (WindowHandle1, FontSize, 'mono', 'true', 'false')</l>
<l>            set_display_font (WindowHandle2, FontSize, 'mono', 'true', 'false')</l>
<c>            * </c>
<l>            check_visibility (WindowHandle1, WindowHandle2, SurfaceModelID, ObjectModel3DScene, ObjectModel3DModel, SurfaceMatchingResultID, Viewpoint, Viewpoint)</l>
<c>            * </c>
<l>            dev_close_window_if_open (WindowHandle1)</l>
<l>            dev_close_window_if_open (WindowHandle2)</l>
<l>        endif</l>
<c>        * </c>
<c>        * ***************************</c>
<c>        * Inspect Matching Results *</c>
<c>        * ***************************</c>
<c>        * </c>
<l>        if (MenuCode[CurrentCase] == 'results')</l>
<c>            * Update the visualization of the menu</c>
<l>            dev_set_window (WindowHandleMenu)</l>
<l>            set_tposition (WindowHandleMenu, MenuBottom + 6, 1)</l>
<l>            write_note (WindowHandleMenu, 'instruction', 'Inspect the matching results below.')</l>
<c>            * </c>
<l>            dev_open_window (HeightMenu + 50, 0, WindowSize, WindowSize, 'black', WindowHandle1)</l>
<l>            set_display_font (WindowHandle1, FontSize, 'mono', 'true', 'false')</l>
<c>            * </c>
<l>            dev_display_surface_matching_results (WindowHandle1, SurfaceMatchingResultID, ObjectModel3DModel, ObjectModel3DScene, Score, Pose, HasEdges, HasViewBased)</l>
<c>            * </c>
<l>            dev_close_window_if_open (WindowHandle1)</l>
<l>        endif</l>
<l>    catch (Exception)</l>
<l>        LastException := Exception</l>
<l>        dev_close_window_if_open (WindowHandle1)</l>
<l>        dev_close_window_if_open (WindowHandle2)</l>
<l>    endtry</l>
<l>endwhile</l>
<c>* </c>
<l>dev_close_window_if_open (WindowHandleMenu)</l>
<c>* </c>
<c>* Construct the parameters</c>
<l>CreateSurfaceModelParamName := []</l>
<l>CreateSurfaceModelParamValue := []</l>
<l>FindSurfaceModelParamName := []</l>
<l>FindSurfaceModelParamValue := []</l>
<c></c>
<l>if (NormalParamsSet)</l>
<l>    CreateSurfaceModelParamName := [CreateSurfaceModelParamName,CreateName]</l>
<l>    CreateSurfaceModelParamValue := [CreateSurfaceModelParamValue,CreateValue]</l>
<l>    FindSurfaceModelParamName := [FindSurfaceModelParamName,FindNames]</l>
<l>    FindSurfaceModelParamValue := [FindSurfaceModelParamValue,FindValues]</l>
<l>endif</l>
<c></c>
<l>if (MaxGap != [])</l>
<l>    FindSurfaceModelParamName := [FindSurfaceModelParamName,'3d_edge_min_amplitude_abs','max_gap']</l>
<l>    FindSurfaceModelParamValue := [FindSurfaceModelParamValue,MinAmplitudeAbs,MaxGap]</l>
<l>endif</l>
<c></c>
<l>if (Viewpoint != [])</l>
<l>    FindSurfaceModelParamName := [FindSurfaceModelParamName,'viewpoint']</l>
<l>    FindSurfaceModelParamValue := [FindSurfaceModelParamValue,Viewpoint[0] + ' ' + Viewpoint[1] + ' ' + Viewpoint[2]]</l>
<l>endif</l>
<c></c>
</body>
<docu id="debug_find_surface_model">
<abstract lang="en_US">This procedure allows to visualize and debug various parameters for surface-based matching. For it to be used, first create a surface model with create_surface_model and perform one call to find_surface_model with CreateResultHandle set to 'true'. Then pass the surface model, the 3D object model of the object, the 3D object model of the scene and the result handle to this procedure.

Note that this procedure is mainly meant for debugging the parameters of a surface-based matching application. Since the root causes for potential issues can vary greatly, this procedure can not always recommend appropriate steps for resolving those issues. However, it will often at least indicate that such issues exist and what their nature are.

Note that the procedure must be run with F5 and cannot be stepped through, as it uses multiple threads.

Further note that this procedure does not check all parameters passed to create_surface_model and find_surface_model. Most notably, the sampling distances and the keypoint rate are not checked.

The procedure first opens a menu window, in which further instructions are noted. After selecting one of the menu items, an additional window will open that is used for inspecting, debugging or modifying the parameters. To adapt the window sizes to different monitor resolutions, change the WindowScaling variable at the very beginning of the procedure.

Once complete, the parameters set within the procedures will be returned by the procedure in CreateSurfaceModelParamName, CreateSurfaceModelParamValue, FindSurfaceModelParamName, and FindSurfaceModelParamValue. Those can be used to adapt the surface-based matching accordingly.</abstract>
<chapters lang="en_US">
<item>3D Matching</item>
<item>Surface-Based</item>
</chapters>
<example lang="en_US">create_surface_model (OM3DModel, 0.03, [], [], SurfaceModel)
find_surface_model (SurfaceModel, OM3DScene, 0.05, 0.2, 0, 'true', [], [], Poses, Scores, ResultHandle)
debug_find_surface_model (SurfaceModel, OM3DModel, OM3DScene, ResultHandle, CreateNames, CreateValkues, FindNames, FindValues)</example>
<library lang="en_US">MVTec Standard Procedures</library>
<predecessor>
<item>create_surface_model</item>
<item>find_surface_model</item>
</predecessor>
<see_also>
<item>create_surface_model</item>
<item>find_surface_model</item>
</see_also>
<short lang="en_US">Inspect the parameters for surface-based matching.</short>
<parameters>
<parameter id="CreateSurfaceModelParamName">
<default_type>string</default_type>
<description lang="en_US">Parameter to be passed to create_surface_model.</description>
<mixed_type>false</mixed_type>
<multivalue>optional</multivalue>
<sem_type>attribute.name</sem_type>
<type_list>
<item>string</item>
</type_list>
</parameter>
<parameter id="CreateSurfaceModelParamValue">
<default_type>integer</default_type>
<description lang="en_US">Parameter to be passed to create_surface_model.</description>
<mixed_type>optional</mixed_type>
<multivalue>optional</multivalue>
<sem_type>attribute.value</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
<item>string</item>
</type_list>
</parameter>
<parameter id="FindSurfaceModelParamName">
<default_type>string</default_type>
<description lang="en_US">Parameter to be passed to find_surface_model.</description>
<mixed_type>false</mixed_type>
<multivalue>optional</multivalue>
<sem_type>attribute.name</sem_type>
<type_list>
<item>string</item>
</type_list>
</parameter>
<parameter id="FindSurfaceModelParamValue">
<default_type>real</default_type>
<description lang="en_US">Parameter to be passed to find_surface_model.</description>
<mixed_type>optional</mixed_type>
<multivalue>optional</multivalue>
<sem_type>attribute.value</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
<item>string</item>
</type_list>
</parameter>
<parameter id="ObjectModel3DModel">
<default_type>integer</default_type>
<description lang="en_US">Original 3D object model of the object, as passed to create_surface_model.</description>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>object_model_3d</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="ObjectModel3DScene">
<default_type>integer</default_type>
<description lang="en_US">The scene where the object is to be found, as passed to find_surface_model.</description>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>object_model_3d</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="SurfaceMatchingResultID">
<default_type>integer</default_type>
<description lang="en_US">The result handle returned by find_surface_model.</description>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>surface_matching_result</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="SurfaceModelID">
<default_type>integer</default_type>
<description lang="en_US">The surface model that shall be inspected.</description>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>surface_model</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
</parameters>
</docu>
</procedure>
<procedure name="determine_dl_model_detection_param">
<interface>
<ic>
<par name="DLDataset" base_type="ctrl" dimension="0"/>
<par name="ImageWidthTarget" base_type="ctrl" dimension="0"/>
<par name="ImageHeightTarget" base_type="ctrl" dimension="0"/>
<par name="GenParam" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="DLDetectionModelParam" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c>* This procedure analyzes the input DLDataset for object detection</c>
<c>* in order to find good values for parameters which control the</c>
<c>* generation of anchor bounding boxes.</c>
<c>* </c>
<c>* </c>
<c>* Set default values for generic parameters.</c>
<l>ImageWidthRaw := []</l>
<l>ImageHeightRaw := []</l>
<l>MinLevel := 2</l>
<l>MaxLevel := 6</l>
<l>AnchorNumSubscales := 3</l>
<l>DomainHandling := 'full_domain'</l>
<l>DatasetSplit := 'all'</l>
<l>DisplayHistogram := false</l>
<l>PreprocessedPath := ''</l>
<c>* </c>
<c>* Read generic parameters and check the provided values.</c>
<l>if (GenParam != [])</l>
<l>    get_dict_param (GenParam, 'keys', [], GenParamName)</l>
<l>    for GenParamIndex := 0 to |GenParamName| - 1 by 1</l>
<l>        if (GenParamName[GenParamIndex] == 'raw_width')</l>
<l>            get_dict_tuple (GenParam, 'raw_width', ImageWidthRaw)</l>
<l>            if (not is_int(ImageWidthRaw))</l>
<l>                throw (GenParamName[GenParamIndex] + ' should be of type int')</l>
<l>            endif</l>
<l>            if (ImageWidthRaw &lt; 1)</l>
<l>                throw ('Invalid value for parameter \'raw_width\': ' + ImageWidthRaw + '.')</l>
<l>            endif</l>
<l>        elseif (GenParamName[GenParamIndex] == 'raw_height')</l>
<l>            get_dict_tuple (GenParam, 'raw_height', ImageHeightRaw)</l>
<l>            if (not is_int(ImageHeightRaw))</l>
<l>                throw (GenParamName[GenParamIndex] + ' should be of type int')</l>
<l>            endif</l>
<l>            if (ImageHeightRaw &lt; 1)</l>
<l>                throw ('Invalid value for parameter \'raw_height\': ' + ImageHeightRaw + '.')</l>
<l>            endif</l>
<l>        elseif (GenParamName[GenParamIndex] == 'min_level')</l>
<l>            get_dict_tuple (GenParam, 'min_level', MinLevel)</l>
<l>            if (not is_int(MinLevel))</l>
<l>                throw (GenParamName[GenParamIndex] + ' should be of type int')</l>
<l>            endif</l>
<l>            if (MinLevel &lt; 2)</l>
<l>                throw ('Invalid value for parameter \'min_level\': ' + MinLevel + '. The minimum value is 2.')</l>
<l>            endif</l>
<l>        elseif (GenParamName[GenParamIndex] == 'max_level')</l>
<l>            get_dict_tuple (GenParam, 'max_level', MaxLevel)</l>
<l>            if (not is_int(MaxLevel))</l>
<l>                throw (GenParamName[GenParamIndex] + ' should be of type int')</l>
<l>            endif</l>
<l>            if (MaxLevel &lt; 2)</l>
<l>                throw ('Invalid value for parameter \'max_level\': ' + MaxLevel + '. The minimum value is 2.')</l>
<l>            endif</l>
<l>        elseif (GenParamName[GenParamIndex] == 'anchor_num_subscales')</l>
<l>            get_dict_tuple (GenParam, 'anchor_num_subscales', AnchorNumSubscales)</l>
<l>            if (not is_int(AnchorNumSubscales))</l>
<l>                throw (GenParamName[GenParamIndex] + ' should be of type int')</l>
<l>            endif</l>
<l>            if (AnchorNumSubscales &lt; 1)</l>
<l>                throw ('Invalid value for parameter \'anchor_num_subscales\': ' + AnchorNumSubscales + '. The minimum value is 1.')</l>
<l>            endif</l>
<l>        elseif (GenParamName[GenParamIndex] == 'domain_handling')</l>
<l>            get_dict_tuple (GenParam, 'domain_handling', DomainHandling)</l>
<l>            if (DomainHandling != 'full_domain' and DomainHandling != 'crop_domain')</l>
<l>                throw ('Invalid value for parameter \'domain_handling\': ' + DomainHandling + '.')</l>
<l>            endif</l>
<l>        elseif (GenParamName[GenParamIndex] == 'display_histogram')</l>
<l>            get_dict_tuple (GenParam, 'display_histogram', DisplayBool)</l>
<l>            DisplayHistogram := DisplayBool == 'true' or DisplayBool == true</l>
<l>        elseif (GenParamName[GenParamIndex] == 'split')</l>
<l>            get_dict_tuple (GenParam, 'split', DatasetSplit)</l>
<l>            if (not is_string(DatasetSplit))</l>
<l>                throw (GenParamName[GenParamIndex] + ' should be of type string')</l>
<l>            endif</l>
<l>        elseif (GenParamName[GenParamIndex] == 'preprocessed_path')</l>
<l>            get_dict_tuple (GenParam, 'preprocessed_path', PreprocessedPath)</l>
<l>            if (not is_string(PreprocessedPath))</l>
<l>                throw (GenParamName[GenParamIndex] + ' should be of type string')</l>
<l>            endif</l>
<l>        else</l>
<l>            throw ('Unsupported generic parameter: \'' + GenParamName[GenParamIndex] + '\'')</l>
<l>        endif</l>
<l>    endfor</l>
<l>endif</l>
<c>* </c>
<c>* Check that all necessary keys (for this procedure) exist in the input dataset.</c>
<l>DatasetKeys := ['image_dir','samples']</l>
<l>for KeyIndex := 0 to |DatasetKeys| - 1 by 1</l>
<l>    get_dict_param (DLDataset, 'key_exists', DatasetKeys[KeyIndex], DatasetKeyExists)</l>
<l>    if (not DatasetKeyExists)</l>
<l>        throw ('Missing key in DLDataset: \'' + DatasetKeys[KeyIndex] + '\'.')</l>
<l>    endif</l>
<l>endfor</l>
<c>* Check that MaxLevel &gt;= MinLevel</c>
<l>if (MaxLevel &lt; MinLevel)</l>
<l>    throw ('Value for parameter \'max_level\' should not be smaller than \'min_level\'.')</l>
<l>endif</l>
<c>* </c>
<c>* Get instance type of the dataset.</c>
<c>* </c>
<c>* Keys defining bounding boxes of instance type rectangle1 and rectangle2, respectively.</c>
<l>Rect1Keys := ['bbox_row1','bbox_col1','bbox_row2','bbox_col2']</l>
<l>Rect2Keys := ['bbox_row','bbox_col','bbox_length1','bbox_length2','bbox_phi']</l>
<c>* </c>
<l>get_dict_tuple (DLDataset, 'samples', DLSamples)</l>
<l>get_dict_param (DLSamples[0], 'key_exists', Rect1Keys, Rect1KeysExist)</l>
<l>get_dict_param (DLSamples[0], 'key_exists', Rect2Keys, Rect2KeysExist)</l>
<l>if (sum(Rect1KeysExist) == |Rect1Keys|)</l>
<l>    InstanceType := 'rectangle1'</l>
<l>elseif (sum(Rect2KeysExist) == |Rect2Keys|)</l>
<l>    InstanceType := 'rectangle2'</l>
<l>else</l>
<l>    throw ('Please provide the data labeled for an object detection model of either instance type rectangle1 or rectangle2.')</l>
<l>endif</l>
<c>* </c>
<c>* Check whether the DLDataset is already preprocessed.</c>
<l>PreprocessedKey := 'dlsample_dir'</l>
<l>get_dict_param (DLDataset, 'key_exists', PreprocessedKey, PreprocessedKeyExists)</l>
<l>if (PreprocessedKeyExists)</l>
<l>    if (PreprocessedPath == '')</l>
<l>        get_dict_tuple (DLDataset, PreprocessedKey, PreprocessedPath)</l>
<l>    else</l>
<l>        PreprocessedPath := PreprocessedPath + '/samples'</l>
<l>    endif</l>
<l>else</l>
<l>    if (PreprocessedPath != '')</l>
<l>        throw ('The given dataset is not preprocessed but a preprocessing path is given.                  Please either use a preprocessed dataset as input or remove the specification for                  \'preprocessed_path\' from the generic parameter dictionary GenParam.')</l>
<l>    endif</l>
<l>endif</l>
<c>* </c>
<c>* Create output param dictionary.</c>
<l>create_dict (DLDetectionModelParam)</l>
<c>* </c>
<c>* Create relevant information collections from the dataset.</c>
<l>analyze_dl_dataset_detection (DLDataset, InstanceType, ImageWidthRaw, ImageHeightRaw, ImageWidthTarget, ImageHeightTarget, DomainHandling, PreprocessedPath, DatasetSplit, Areas, AspectRatios, Angles)</l>
<c>* </c>
<c>* Remove outliers in the data which could potentially have a big impact on the results</c>
<c>* of this procedure. If you wish not to do so, comment out the following procedure calls</c>
<c>* and set the variables AreasReduce, AspectRatiosReduced and AnglesReduced accordingly.</c>
<l>remove_dl_data_outliers (Areas, AreasReduced)</l>
<l>remove_dl_data_outliers (AspectRatios, AspectRatiosReduced)</l>
<l>remove_dl_data_outliers (Angles, AnglesReduced)</l>
<c>* </c>
<c>* Select min_level, max_level and anchor_num_subscales based on the retrieved ground truth</c>
<c>* bounding box areas.</c>
<l>select_dl_detection_levels (AreasReduced, MinLevel, MaxLevel, AnchorNumSubscales, MinLevelToUse, MaxLevelToUse, AnchorNumSubscalesToUse)</l>
<l>set_dict_tuple (DLDetectionModelParam, 'min_level', MinLevelToUse)</l>
<l>set_dict_tuple (DLDetectionModelParam, 'max_level', MaxLevelToUse)</l>
<l>set_dict_tuple (DLDetectionModelParam, 'anchor_num_subscales', AnchorNumSubscalesToUse)</l>
<c>* </c>
<c>* Determine values for anchor aspect ratios and angles using k-means clustering.</c>
<c>* </c>
<c>* Minimum ratio of members each cluster should at least have.</c>
<l>MinRatio := 0.01</l>
<c>* Minimum distance between the cluster centers.</c>
<l>MinDiff := 0.1</l>
<c>* Number of centers to start k-means with. For aspect ratios, set K to 4.</c>
<l>K := 4</l>
<c>* Perform clustering of collected aspect ratios.</c>
<l>cluster_dl_detection_param (AspectRatiosReduced, K, MinRatio, MinDiff, ClusteredAspectRatios)</l>
<l>set_dict_tuple (DLDetectionModelParam, 'anchor_aspect_ratios', ClusteredAspectRatios)</l>
<c>* </c>
<c>* For rectangle2, also perform clustering on the angles.</c>
<l>if (InstanceType == 'rectangle2')</l>
<c>    * Since the variance for the angles is usually greater,</c>
<c>    * adapt K and MinDiff accordingly.</c>
<l>    K := 8</l>
<l>    MinDiff := 0.4</l>
<c>    * Perform clustering of collected angles.</c>
<l>    cluster_dl_detection_param (AnglesReduced, K, MinRatio, MinDiff, ClusteredAngles)</l>
<l>    set_dict_tuple (DLDetectionModelParam, 'anchor_angles', ClusteredAngles)</l>
<l>endif</l>
<c>* </c>
<c>* Display the histograms calculated from the data collections.</c>
<l>WindowBGColor := 'light gray'</l>
<l>SplitText := ''</l>
<l>if (DatasetSplit != 'all')</l>
<l>    SplitText := ' (' + DatasetSplit + ')'</l>
<l>endif</l>
<l>if (DisplayHistogram)</l>
<c>    * Plot histogram of bounding box areas.</c>
<l>    dev_open_window (0, 0, 512, 400, WindowBGColor, WindowHandle)</l>
<l>    plot_dl_detection_histogram (Areas, '#ff6384', ['title','label_x'], ['Histogram of bounding box areas' + SplitText,'Bounding box area'], WindowHandle)</l>
<c>    * Plot histogram of aspect ratios.</c>
<l>    dev_open_window (0, 520, 512, 400, WindowBGColor, WindowHandle2)</l>
<l>    plot_dl_detection_histogram (AspectRatios, '#66ff92', ['title','label_x'], ['Histogram of aspect ratios' + SplitText,'Aspect ratio'], WindowHandle2)</l>
<l>    if (InstanceType == 'rectangle2')</l>
<c>        * Plot histogram of anchor angles.</c>
<l>        dev_open_window (450, 0, 512, 400, WindowBGColor, WindowHandle3)</l>
<l>        plot_dl_detection_histogram (Angles, '#36a2eb', ['title','label_x'], ['Histogram of angles' + SplitText,'Angle (rad)'], WindowHandle3)</l>
<l>    endif</l>
<l>endif</l>
<c>* </c>
<l>return ()</l>
</body>
<docu id="determine_dl_model_detection_param">
<abstract lang="en_US">This procedure determines good parameters for the generation of an object detection model based on the specific DLDataset.
The resulting DLDetectionParam is a dictionary containing suggested values for the following parameters:
- 'min_level'
- 'max_level'
- 'anchor_num_subscales'
- 'anchor_aspect_ratios'
- 'anchor_angles' (rectangle2 only)

The parameters are determined in order to:
- improve the detection performance using such data
- to prevent unnecessarily created anchors, which improves the model runtime (both for training and inference).

Please note that the returned values are not necessarily the 'best' parameters but approximations and often a compromise between model runtime and detection performance, e.g., 'anchor_num_subscales' is rather too high than too low, so you may also experiment with smaller values.

Note also, that the returned values for 'min_level' and 'max_level' are only based on the dataset but may not be suitable for the backbone of your choice.

Since only the original dataset is used to determine the model parameters, the parameter suggestions might not be suitable in case a data augmentation method is used during training which creates bounding boxes of different shapes. This means that for the following combinations of object detection instance type and augmentation method, the generated parameters should only be used with care:
- 'rectangle1'
  -- 'mirror'
- 'rectangle2'
  -- 'mirror'
  -- 'rotate'

To determine the parameter values, the data of the ground truth bounding boxes is accumulated over all samples in DLDataset. Out of the bounding box areas the values for 'min_level', 'max_level', and 'anchor_num_subscales' are determined. Using the k-means clustering technique, the aspect ratios and (for instance type rectangle2) orientation angles are clustered and the representatives returned as suggested 'anchor_aspect_ratios' and 'anchor_angles'.

Using the input dictionary GenParam, you can further influence the parameter determination. The following keys and corresponding values are possible:
- 'anchor_num_subscales': Integer value (&gt;0) determining the upper bound value for the search of the number of anchor subscales. The default value is: 3.
- 'display_histogram': Determines whether to display the data histograms for a visual analysis of the dataset. Possible values are: 'true', 'false' (default).
- 'domain_handling': Specifies the handling of the image domain. Possible values are:
  -- 'full_domain' (default): Images are not cropped.
  -- 'crop_domain': Images are reduced to their domain definitions.
- 'max_level': Integer value (&gt;1) determining the upper bound value for the search of the maximum level. The default value is: 6.
- 'min_level': Integer value (&gt;1) determining the lower bound value for the search of the minimum level. The default value is: 2.
- 'preprocessed_path': Specifies the path to the preprocessing directory. The preprocessing directory is the one containing the dictionary DLDataset (.hdict file) as well as a subdirectory named 'samples' with the preprocessed samples (as generated, e.g. by the procedure preprocess_dl_dataset). For an already preprocessed dataset the input parameters ImageWidthTarget and ImageHeightTarget are ignored and thus can be set to []. This parameter only applies if your dataset is already proprocessed for your application.
- 'raw_width' and 'raw_height': With and height of the raw images. They can be passed in order to speed up the process. Condition: All raw images have the same size.
- 'split': Determines which split of the dataset is used for the analysis. If the specified split is invalid or there are no splits created for the dataset, all samples are used. Possible values are: 'all' (default), 'test', 'train', 'validation'.</abstract>
<chapters lang="en_US">
<item>Deep Learning</item>
<item>Object Detection</item>
</chapters>
<library lang="en_US">MVTec Standard Procedures</library>
<short lang="en_US">Analyze the provided DLDataset for object detection to find model parameters relevant for anchor generation.</short>
<parameters>
<parameter id="DLDataset">
<default_type>integer</default_type>
<description lang="en_US">Dictionary of the DLDataset for object detection.</description>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>dict</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="DLDetectionModelParam">
<default_type>integer</default_type>
<description lang="en_US">Output dictionary containing the suggested model parameters.</description>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>dict</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="GenParam">
<default_type>integer</default_type>
<default_value>[]</default_value>
<description lang="en_US">Dictionary containing generic input parameters.</description>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>dict</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="ImageHeightTarget">
<default_type>integer</default_type>
<default_value>[]</default_value>
<description lang="en_US">Target image height to use as model input (image height after preprocessing).</description>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>integer</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="ImageWidthTarget">
<default_type>integer</default_type>
<default_value>[]</default_value>
<description lang="en_US">Target image width to use as model input (image width after preprocessing).</description>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>integer</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
</parameters>
</docu>
</procedure>
<procedure name="determine_optimum_pose_distance">
<interface>
<ic>
<par name="ObjectModel3DID" base_type="ctrl" dimension="0"/>
<par name="CamParam" base_type="ctrl" dimension="0"/>
<par name="ImageCoverage" base_type="ctrl" dimension="0"/>
<par name="PoseIn" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="PoseOut" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c>* Determine the optimum distance of the object to obtain</c>
<c>* a reasonable visualization</c>
<c>* </c>
<l>Rows := []</l>
<l>Cols := []</l>
<l>MinMinZ := 1e30</l>
<l>BB := []</l>
<l>for Index := 0 to |ObjectModel3DID| - 1 by 1</l>
<l>    try</l>
<l>        get_object_model_3d_params (ObjectModel3DID[Index], 'bounding_box1', CurrBB)</l>
<l>        BB := [BB,CurrBB]</l>
<l>    catch (Exception)</l>
<c>        * 3D object model is empty / has no bounding box -&gt; ignore it</c>
<l>    endtry</l>
<l>endfor</l>
<l>if (sum([abs(BB),0]) == 0.0)</l>
<l>    BB := [-abs(rand(3) * 1e-20),abs(rand(3) * 1e-20)]</l>
<l>endif</l>
<c>* Calculate diameter over all objects to be visualized</c>
<l>Seq := [0:6:|BB| - 1]</l>
<l>DXMax := max(BB[Seq + 3]) - min(BB[Seq])</l>
<l>DYMax := max(BB[Seq + 4]) - min(BB[Seq + 1])</l>
<l>DZMax := max(BB[Seq + 5]) - min(BB[Seq + 2])</l>
<l>Diameter := sqrt(DXMax * DXMax + DYMax * DYMax + DZMax * DZMax)</l>
<c>* Allow the visualization of single points or extremely small objects</c>
<l>ZAdd := 0.0</l>
<l>if (max(Diameter) &lt; 1e-10)</l>
<l>    ZAdd := 0.01</l>
<l>endif</l>
<c>* Set extremely small diameters to 1e-10 to avoid CZ == 0.0, which would lead</c>
<c>* to projection errors</c>
<l>if (min(Diameter) &lt; 1e-10)</l>
<l>    Diameter := Diameter - sgn(sgn(Diameter - 1e-10) - 1) * 1e-10</l>
<l>endif</l>
<c>* Move all points infront of the camera</c>
<l>BBX0 := BB[Seq + 0]</l>
<l>BBX1 := BB[Seq + 3]</l>
<l>BBY0 := BB[Seq + 1]</l>
<l>BBY1 := BB[Seq + 4]</l>
<l>BBZ0 := BB[Seq + 2]</l>
<l>BBZ1 := BB[Seq + 5]</l>
<l>X := [BBX0,BBX0,BBX0,BBX0,BBX1,BBX1,BBX1,BBX1]</l>
<l>Y := [BBY0,BBY0,BBY1,BBY1,BBY0,BBY0,BBY1,BBY1]</l>
<l>Z := [BBZ0,BBZ1,BBZ0,BBZ1,BBZ0,BBZ1,BBZ0,BBZ1]</l>
<l>pose_to_hom_mat3d (PoseIn, HomMat3DIn)</l>
<l>affine_trans_point_3d (HomMat3DIn, X, Y, Z, QX_In, QY_In, QZ_In)</l>
<l>pose_compose ([0,0,-min(QZ_In) + 2 * max(Diameter),0,0,0,0], PoseIn, PoseInter)</l>
<l>pose_to_hom_mat3d (PoseInter, HomMat3D)</l>
<c>* Determine the maximum extension of the projection</c>
<l>affine_trans_point_3d (HomMat3D, X, Y, Z, QX, QY, QZ)</l>
<l>project_3d_point (QX, QY, QZ, CamParam, Rows, Cols)</l>
<l>MinMinZ := min(QZ)</l>
<l>get_cam_par_data (CamParam, 'cx', Cx)</l>
<l>get_cam_par_data (CamParam, 'cy', Cy)</l>
<l>DR := Rows - Cy</l>
<l>DC := Cols - Cx</l>
<l>DR := max(DR) - min(DR)</l>
<l>DC := max(DC) - min(DC)</l>
<l>MaxDist := sqrt(DR * DR + DC * DC)</l>
<c>* </c>
<l>if (MaxDist &lt; 1e-10)</l>
<c>    * If the object has no extension in the above projection (looking along</c>
<c>    * a line), we determine the extension of the object in a rotated view</c>
<l>    hom_mat3d_rotate_local (HomMat3D, rad(90), 'x', HomMat3DRotate)</l>
<l>    affine_trans_point_3d (HomMat3DRotate, X, Y, Z, QX, QY, QZ)</l>
<l>    project_3d_point (QX, QY, QZ, CamParam, Rows, Cols)</l>
<l>    DR := Rows - Cy</l>
<l>    DC := Cols - Cx</l>
<l>    DR := max(DR) - min(DR)</l>
<l>    DC := max(DC) - min(DC)</l>
<l>    MaxDist := max([MaxDist,sqrt(DR * DR + DC * DC)])</l>
<l>endif</l>
<c>* </c>
<l>get_cam_par_data (CamParam, 'image_width', ImageWidth)</l>
<l>get_cam_par_data (CamParam, 'image_height', ImageHeight)</l>
<l>MinImageSize := min([ImageWidth,ImageHeight])</l>
<c>* </c>
<l>Z := PoseInter[2]</l>
<l>Zs := MinMinZ</l>
<l>ZDiff := Z - Zs</l>
<l>ScaleZ := MaxDist / (0.5 * MinImageSize * ImageCoverage * 2.0)</l>
<l>ZNew := ScaleZ * Zs + ZDiff + ZAdd</l>
<l>PoseOut := replace(PoseInter,2,ZNew)</l>
<c>* </c>
<l>return ()</l>
</body>
<docu id="determine_optimum_pose_distance">
<abstract lang="en_US">determine_optimum_pose_distance determines the optimum translation in z direction to obtain a reasonable visualization of the given 3D object models, e.g., with disp_object_model_3d.

Based on the given camera parameters (CamParam), which also define the size of the image into which the 3D object models are to be projected and the requested image coverage, the necessary translation of the 3D object models in z direction, i.e., the third element of the pose, is calculated.

</abstract>
<chapters lang="de_DE">
<item>Graphik</item>
<item>Ausgabe</item>
</chapters>
<chapters lang="en_US">
<item>Graphics</item>
<item>Output</item>
</chapters>
<example lang="en_US">read_object_model_3d ('pipe_joint', 'm', [], [], ObjectModel3D, Status)
CamParam := [0.1,0,6e-6,6e-6,256,256,512,512]
dev_resize_window_fit_size (0, 0, CamParam[6]-1, CamParam[7]-1, -1, -1)
get_object_models_center (ObjectModel3D, Center)
create_pose (-Center[0], -Center[1], -Center[2], 135, 0, 0, \
             'Rp+T', 'gba', 'point', PoseIn)
determine_optimum_pose_distance (ObjectModel3D, CamParam, 0.9, PoseIn, \
                                 PoseEstimated)
dev_get_window (WindowHandle)
disp_object_model_3d (WindowHandle, ObjectModel3D, \
                      CamParam, PoseEstimated, [], [])</example>
<library lang="en_US">MVTec Standard Procedures</library>
<predecessor>
<item>get_object_models_center</item>
<item>create_pose</item>
</predecessor>
<short lang="en_US">Determine the optimum distance of the object to obtain a reasonable visualization</short>
<successor>
<item>disp_object_model_3d</item>
<item>render_object_model_3d</item>
</successor>
<parameters>
<parameter id="CamParam">
<default_type>real</default_type>
<description lang="en_US">Camera parameters of the scene.</description>
<mixed_type>optional</mixed_type>
<multivalue>true</multivalue>
<sem_type>number</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
<parameter id="ImageCoverage">
<default_type>real</default_type>
<default_value>0.9</default_value>
<description lang="en_US">Desired image coverage of the 3D object models to be displayed.</description>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>real</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
<parameter id="ObjectModel3DID">
<default_type>integer</default_type>
<description lang="en_US">Handles of the 3D object models.</description>
<mixed_type>false</mixed_type>
<multivalue>optional</multivalue>
<sem_type>object_model_3d</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="PoseIn">
<default_type>real</default_type>
<description lang="en_US">3D pose of the objects.</description>
<mixed_type>optional</mixed_type>
<multivalue>true</multivalue>
<sem_type>pose</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
<parameter id="PoseOut">
<default_type>real</default_type>
<description lang="en_US">Pose with adapted translation in z direction.</description>
<mixed_type>optional</mixed_type>
<multivalue>true</multivalue>
<sem_type>pose</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
</parameters>
</docu>
</procedure>
<procedure name="determine_visualization_pose_distance_aligned_with_y_axis" access="local">
<interface>
<ic>
<par name="ObjectModel3DRigidTrans5Tmp" base_type="ctrl" dimension="0"/>
<par name="WindowHandle1" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="PoseEstimatedDistance" base_type="ctrl" dimension="0"/>
<par name="Center" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<l>get_object_models_center (ObjectModel3DRigidTrans5Tmp, Center)</l>
<l>create_pose (-Center[0], -Center[1], -Center[2], 0, 0, 0, 'Rp+T', 'gba', 'point', PoseCenterScene)</l>
<l>rigid_trans_object_model_3d (ObjectModel3DRigidTrans5Tmp, PoseCenterScene, ObjectModel3DRigidTrans4)</l>
<l>PoseRot := [0,0,0,90,0,0,0]</l>
<l>rigid_trans_object_model_3d (ObjectModel3DRigidTrans4, PoseRot, ObjectModel3DRigidTrans5)</l>
<l>PoseTrans := [Center[0],Center[2],Center[1],0,0,0,0]</l>
<l>rigid_trans_object_model_3d (ObjectModel3DRigidTrans5, PoseTrans, ObjectModel3DRigidTrans6)</l>
<l>gen_object_model_3d_from_points (0, 0, 0, ObjectModel3D0)</l>
<l>union_object_model_3d ([ObjectModel3D0,ObjectModel3DRigidTrans6], 'points_surface', UnionObjectModel3D1)</l>
<c>* </c>
<l>get_window_extents (WindowHandle1, RowNotUsed, ColumnNotUsed, Width, Height)</l>
<l>gen_cam_par_area_scan_division (0.06, 0, 8.5e-6, 8.5e-6, Width / 2, Height / 2, Width, Height, CamParam)</l>
<l>determine_optimum_pose_distance (UnionObjectModel3D1, CamParam, 0.9, PoseCenterScene, PoseEstimatedDistance)</l>
<l>return ()</l>
</body>
<docu id="determine_visualization_pose_distance_aligned_with_y_axis">
<chapters lang="en_US">
<item>3D Object Model</item>
<item>Transformations</item>
</chapters>
<library lang="en_US">MVTec Standard Procedures</library>
<parameters>
<parameter id="Center"/>
<parameter id="ObjectModel3DRigidTrans5Tmp"/>
<parameter id="PoseEstimatedDistance"/>
<parameter id="WindowHandle1"/>
</parameters>
</docu>
</procedure>
<procedure name="dev_close_window_dict">
<interface>
<ic>
<par name="WindowHandleDict" base_type="ctrl" dimension="0"/>
</ic>
</interface>
<body>
<c>* </c>
<c>* This procedure closes all window handles</c>
<c>* that are contained in the dictionary WindowHandleDict.</c>
<c>* </c>
<l>get_dict_param (WindowHandleDict, 'keys', [], WindowHandleKeys)</l>
<l>for Index := 0 to |WindowHandleKeys| - 1 by 1</l>
<l>    try</l>
<l>        get_dict_tuple (WindowHandleDict, WindowHandleKeys[Index], WindowHandles)</l>
<l>    catch (Exception)</l>
<l>        continue</l>
<l>    endtry</l>
<l>    RemovedWindowIndices := []</l>
<l>    for WindowHandleIndex := 0 to |WindowHandles| - 1 by 1</l>
<c>        * Not every entry has to be a window handle, therefore use try-catch.</c>
<l>        try</l>
<c>            * Call set_window_param to check if the handle is a window handle.</c>
<l>            set_window_param (WindowHandles[WindowHandleIndex], 'flush', 'false')</l>
<l>            dev_set_window (WindowHandles[WindowHandleIndex])</l>
<l>            dev_close_window ()</l>
<l>            RemovedWindowIndices := [RemovedWindowIndices,WindowHandleIndex]</l>
<l>        catch (Exception)</l>
<l>        endtry</l>
<l>    endfor</l>
<l>    tuple_remove (WindowHandles, RemovedWindowIndices, WindowHandles)</l>
<c>    * If some entries remained, set reduced tuple. Otherwise, remove whole key entry.</c>
<l>    if (|WindowHandles| &gt; 0)</l>
<l>        set_dict_tuple (WindowHandleDict, WindowHandleKeys[Index], WindowHandles)</l>
<l>    else</l>
<l>        remove_dict_key (WindowHandleDict, WindowHandleKeys[Index])</l>
<l>    endif</l>
<l>endfor</l>
<c>* </c>
<l>return ()</l>
</body>
<docu id="dev_close_window_dict">
<abstract lang="en_US">This procedure closes all windows whose handle is contained in the dictionary WindowHandleDict and removes the entries in the dictionary.</abstract>
<chapters lang="en_US">
<item>Graphics</item>
<item>Window</item>
</chapters>
<library lang="en_US">MVTec Standard Procedures</library>
<short lang="en_US">Close all window handles contained in a dictionary.</short>
<parameters>
<parameter id="WindowHandleDict">
<default_type>integer</default_type>
<default_value>WindowHandleDict</default_value>
<description lang="en_US">Dictionary containing window handles.</description>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>dict</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
</parameters>
</docu>
</procedure>
<procedure name="dev_close_window_if_open" access="local">
<interface>
<ic>
<par name="WindowHandle" base_type="ctrl" dimension="0"/>
</ic>
</interface>
<body>
<l>try</l>
<l>    dev_set_window (WindowHandle)</l>
<l>    dev_get_window (CurrWindowHandle)</l>
<l>    if (CurrWindowHandle == WindowHandle)</l>
<l>        dev_close_window ()</l>
<l>    endif</l>
<l>catch (Exception)</l>
<c>    * Window might already be closed -&gt; ignore errors</c>
<l>endtry</l>
<l>return ()</l>
</body>
<docu id="dev_close_window_if_open">
<abstract lang="en_US">Close the passed window with dev_close_window if it is still open. Otherwise, do nothing.</abstract>
<chapters lang="en_US">
<item>Graphics</item>
<item>Window</item>
</chapters>
<library lang="en_US">MVTec Standard Procedures</library>
<short lang="en_US">Closes the window if it is still open.</short>
<parameters>
<parameter id="WindowHandle">
<default_type>integer</default_type>
<mixed_type>false</mixed_type>
<sem_type>window</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
</parameters>
</docu>
</procedure>
<procedure name="dev_disp_approach_pose_touching_point_instructions" access="local">
<interface>
<ic>
<par name="WindowHandle" base_type="ctrl" dimension="0"/>
<par name="WindowHandleGraphics" base_type="ctrl" dimension="0"/>
<par name="Index" base_type="ctrl" dimension="0"/>
</ic>
</interface>
<body>
<c>* </c>
<l>dev_set_window (WindowHandle)</l>
<l>dev_clear_window ()</l>
<l>Text := 'Calibrate touching point'</l>
<l>Text[1] := ''</l>
<l>Text[2] := 'General workflow'</l>
<l>Text[3] := '----------------'</l>
<l>Text[4] := 'Approach a fixed point in the plane with your gripper, and read the'</l>
<l>Text[5] := 'pose as ToolInBasePoseTouchingPoint.'</l>
<l>Text[6] := 'Then, approach the same point at least twice again, rotating the tool'</l>
<l>Text[7] := 'around at least two axis and reading the corresponding '</l>
<l>Text[8] := 'ToolInBasePoseTouchingPoint.'</l>
<l>Text[9] := ''</l>
<l>Text[10] := 'Read ToolInBasePoseTouchingPoint ' + Index + '/3, then press F5.'</l>
<l>dev_disp_text (Text, 'window', 'top', 'left', 'white', 'box', 'false')</l>
<l>dev_disp_text ('Press Run (F5) to continue', 'window', 'bottom', 'right', 'black', [], [])</l>
<l>Color := gen_tuple_const(3,'gray')</l>
<l>Color[Index - 1] := '#fbba00'</l>
<l>dev_disp_text ('   1   ', 'window', 255, 12, 'black', ['box_color','shadow'], [Color[0],'false'])</l>
<l>dev_disp_text ('   2   ', 'window', 255, 112, 'black', ['box_color','shadow'], [Color[1],'false'])</l>
<l>dev_disp_text ('   3   ', 'window', 255, 212, 'black', ['box_color','shadow'], [Color[2],'false'])</l>
<c>* </c>
<l>dev_set_window (WindowHandleGraphics)</l>
<l>dev_clear_window ()</l>
<l>read_image (Image, '3d_machine_vision/hand_eye/instruction_images/tool_in_base_pose_touching_point')</l>
<l>dev_display (Image)</l>
<l>HighlighColumn := 255 + (Index * 200)</l>
<l>gen_rectangle1 (Rectangle, 320, HighlighColumn - 100, 630, HighlighColumn + 100)</l>
<l>dev_set_line_width (4)</l>
<l>dev_set_draw ('margin')</l>
<l>dev_set_color ('#fbba00')</l>
<l>dev_display (Rectangle)</l>
<l>dev_disp_text ('Read this pose', 'image', 6350, HighlighColumn - 105, 'black', 'box_color', '#fbba00')</l>
<l>return ()</l>
</body>
<docu id="dev_disp_approach_pose_touching_point_instructions">
<chapters lang="de_DE">
<item>Graphik</item>
<item>Text</item>
</chapters>
<chapters lang="en_US">
<item>Graphics</item>
<item>Text</item>
</chapters>
<library lang="en_US">MVTec Standard Procedures</library>
<parameters>
<parameter id="Index">
<default_type>integer</default_type>
<multivalue>false</multivalue>
<sem_type>integer</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="WindowHandle">
<default_type>integer</default_type>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>window</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="WindowHandleGraphics">
<default_type>integer</default_type>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>window</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
</parameters>
</docu>
</procedure>
<procedure name="dev_disp_button">
<interface>
<ic>
<par name="String" base_type="ctrl" dimension="0"/>
<par name="Row" base_type="ctrl" dimension="0"/>
<par name="Column" base_type="ctrl" dimension="0"/>
<par name="Width" base_type="ctrl" dimension="0"/>
<par name="Height" base_type="ctrl" dimension="0"/>
<par name="ColorString" base_type="ctrl" dimension="0"/>
<par name="ColorBackground" base_type="ctrl" dimension="0"/>
<par name="ColorBackgroundActive" base_type="ctrl" dimension="0"/>
<par name="WindowHandle" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="SelectedButton" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c>* </c>
<c>* This procedure displays one or more interactive buttons.</c>
<c>* It is possible to customize the size, position, and color of the buttons.</c>
<c>* The index of the clicked button is returned.</c>
<c>* </c>
<l>get_system ('clip_region', ClipRegion)</l>
<l>set_system ('clip_region', 'false')</l>
<l>dev_get_preferences ('suppress_handled_exceptions_dlg', SuppressHandledExceptionsDlg)</l>
<l>dev_set_preferences ('suppress_handled_exceptions_dlg', 'true')</l>
<l>get_window_param (WindowHandle, 'flush', Flush)</l>
<l>set_window_param (WindowHandle, 'flush', 'false')</l>
<c>* </c>
<c>* Get the scaling factor for window/image coordinate conversion.</c>
<l>get_window_extents (WindowHandle, _, _, WindowWidth, WindowHeight)</l>
<l>get_part (WindowHandle, _, _, PartHeight, PartWidth)</l>
<l>WindowImageWidthRatio := WindowWidth / (1.0 * PartWidth)</l>
<l>WindowImageHeightRatio := WindowHeight / (1.0 * PartHeight)</l>
<c>* </c>
<c>* Scale the button coordinates.</c>
<l>ButtonRowScaled := Row / WindowImageHeightRatio</l>
<l>ButtonColumnScaled := Column / WindowImageWidthRatio</l>
<l>ButtonHeightScaled := Height / WindowImageHeightRatio</l>
<l>ButtonWidthScaled := Width / WindowImageWidthRatio</l>
<c>* </c>
<l>gen_rectangle1 (ButtonRect, ButtonRowScaled, ButtonColumnScaled, ButtonRowScaled + ButtonHeightScaled, ButtonColumnScaled + ButtonWidthScaled)</l>
<l>if (|ColorBackground| == 1)</l>
<l>    ColorBackground := gen_tuple_const(|String|,ColorBackground)</l>
<l>endif</l>
<l>HighlightColors := ColorBackground</l>
<c>* </c>
<c>* We want to place the text centered in the button.</c>
<l>Ascents := []</l>
<l>Descents := []</l>
<l>TextWidths := []</l>
<l>for Index := 0 to |String| - 1 by 1</l>
<l>    get_string_extents (WindowHandle, String[Index], Ascent, Descent, TextWidth, TextHeight)</l>
<l>    Ascents := [Ascents,Ascent]</l>
<l>    Descents := [Descents,Descent]</l>
<l>    TextWidths := [TextWidths,TextWidth]</l>
<l>endfor</l>
<c>* </c>
<l>TextRow := Row + ((Height - TextHeight) / 2) - Descent</l>
<l>TextColumn := Column + ((Width - TextWidths) / 2)</l>
<l>SelectedButton := 0</l>
<l>Button := 0</l>
<c>* </c>
<l>while (SelectedButton == 0 or Button != 1)</l>
<l>    dev_set_color (HighlightColors)</l>
<l>    dev_display (ButtonRect)</l>
<l>    dev_disp_text (String, 'window', TextRow, TextColumn, ColorString, 'box', 'false')</l>
<c>    * Actual display.</c>
<l>    flush_buffer (WindowHandle)</l>
<l>    try</l>
<l>        get_mposition (WindowHandle, Row, Column, Button)</l>
<l>        SelectedButton := 0</l>
<l>        for ButtonIndex := 1 to |ButtonRowScaled| by 1</l>
<l>            select_obj (ButtonRect, ObjectSelected, ButtonIndex)</l>
<l>            test_region_point (ObjectSelected, Row, Column, IsInside)</l>
<l>            if (IsInside)</l>
<l>                SelectedButton := ButtonIndex</l>
<l>                break</l>
<l>            endif</l>
<l>        endfor</l>
<l>    catch (Exception)</l>
<l>    endtry</l>
<l>    if (SelectedButton &gt; 0)</l>
<l>        tuple_replace (ColorBackground, SelectedButton - 1, ColorBackgroundActive, HighlightColors)</l>
<l>    else</l>
<l>        HighlightColors := ColorBackground</l>
<l>    endif</l>
<l>endwhile</l>
<c>* Return index.</c>
<l>SelectedButton := SelectedButton - 1</l>
<c>* </c>
<l>set_system ('clip_region', ClipRegion)</l>
<l>dev_set_preferences ('suppress_handled_exceptions_dlg', SuppressHandledExceptionsDlg)</l>
<l>set_window_param (WindowHandle, 'flush', Flush)</l>
<c>* </c>
<l>return ()</l>
</body>
<docu id="dev_disp_button">
<abstract lang="en_US">This procedure displays one or more interactive buttons. It is possible to customize the size, position, and color of the buttons. The index of the clicked button is returned.

The parameter String contains the string that is displayed centered in the button.
The parameter Row contains the row coordinate of the upper left corner of the button.
The parameter Col contains the column coordinate of the upper left corner of the button.
The parameter Width contains the width of the button.
The parameter Height contains the height of the button.
The color of the string is set by ColorString.
The background color of the button is set by ColorBackground.
The color the button shall be switched to when the mouse points on it is set by ColorBackgroundActive.
The window handle the buttons are displayed on is set by WindowHandle.

SelectedButton contains the index of the button that has been selected by the user.</abstract>
<chapters lang="en_US">
<item>Graphics</item>
<item>Output</item>
</chapters>
<library lang="en_US">MVTec Standard Procedures</library>
<short lang="en_US">Display an interactive button.</short>
<parameters>
<parameter id="ColorBackground">
<default_type>string</default_type>
<description lang="en_US">Color of the (inactive) background.</description>
<multivalue>false</multivalue>
<sem_type>color</sem_type>
<type_list>
<item>string</item>
</type_list>
</parameter>
<parameter id="ColorBackgroundActive">
<default_type>string</default_type>
<description lang="en_US">Color the button shall be switched to when the mouse points on it</description>
<multivalue>false</multivalue>
<sem_type>color</sem_type>
<type_list>
<item>string</item>
</type_list>
</parameter>
<parameter id="ColorString">
<default_type>string</default_type>
<description lang="en_US">Color of the displayed string.</description>
<multivalue>false</multivalue>
<sem_type>color</sem_type>
<type_list>
<item>string</item>
</type_list>
</parameter>
<parameter id="Column">
<default_type>integer</default_type>
<description lang="en_US">Column coordinate of the upper left corner of the button.</description>
<multivalue>optional</multivalue>
<sem_type>point.x</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="Height">
<default_type>integer</default_type>
<description lang="en_US">Height of the button.</description>
<multivalue>false</multivalue>
<sem_type>integer</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="Row">
<default_type>integer</default_type>
<description lang="en_US">Row coordinate of the upper left corner of the button.</description>
<multivalue>optional</multivalue>
<sem_type>point.y</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="SelectedButton">
<description lang="en_US">Index of the clicked button.</description>
<sem_type>integer</sem_type>
</parameter>
<parameter id="String">
<default_type>string</default_type>
<description lang="en_US">String that is displayed on the button.</description>
<multivalue>optional</multivalue>
<sem_type>string</sem_type>
<type_list>
<item>string</item>
</type_list>
</parameter>
<parameter id="Width">
<default_type>integer</default_type>
<description lang="en_US">Width of the button.</description>
<multivalue>false</multivalue>
<sem_type>integer</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="WindowHandle">
<default_type>integer</default_type>
<description lang="en_US">Handle of the graphics windows.</description>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>window</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
</parameters>
</docu>
</procedure>
<procedure name="dev_disp_calibration_data_instructions" access="local">
<interface>
<io>
<par name="Image" base_type="iconic" dimension="0"/>
</io>
</interface>
<body>
<l>dev_display (Image)</l>
<l>Text := 'In the code, please'</l>
<l>Text[1] := '- read an image of a calibration plate in the measurement plane,'</l>
<l>Text[2] := '- specify the location of the calibration plate description file,'</l>
<l>Text[3] := '- specify the thickness of the calibration plate (in meters) and'</l>
<l>Text[4] := '- specify initial camera parameters.'</l>
<l>Text[5] := ''</l>
<l>Text[6] := ' (If you did NOT use a standard HALCON calibration plate, '</l>
<l>Text[7] := '  but used create_caltab to create your own calibration plate,'</l>
<l>Text[8] := '  you also need to adapt the parameters FinderRow, FinderColumn,'</l>
<l>Text[9] := '  and MarksPerRow accordingly.)'</l>
<c>* </c>
<l>dev_disp_text (Text, 'window', 'top', 'left', 'black', [], [])</l>
<l>dev_disp_text ('Press Run (F5) to continue', 'window', 'bottom', 'right', 'black', [], [])</l>
<l>return ()</l>
</body>
<docu id="dev_disp_calibration_data_instructions">
<chapters lang="de_DE">
<item>Graphik</item>
<item>Text</item>
</chapters>
<chapters lang="en_US">
<item>Graphics</item>
<item>Text</item>
</chapters>
<library lang="en_US">MVTec Standard Procedures</library>
<parameters>
<parameter id="Image">
<multivalue>false</multivalue>
<sem_type>image</sem_type>
</parameter>
</parameters>
</docu>
</procedure>
<procedure name="dev_disp_calibration_data_instructions2" access="local">
<interface>
<io>
<par name="Image" base_type="iconic" dimension="0"/>
</io>
</interface>
<body>
<l>dev_display (Image)</l>
<l>Text := 'If you did NOT use a standard HALCON calibration plate, '</l>
<l>Text[1] := 'but used create_caltab to create your own calibration plate,'</l>
<l>Text[2] := 'please adapt the parameters FinderRow, FinderColumn, and MarksPerRow'</l>
<l>Text[3] := 'in the code.'</l>
<l>dev_disp_text (Text, 'window', 'top', 'left', 'black', [], [])</l>
<l>dev_disp_text ('Press Run (F5) to continue', 'window', 'bottom', 'right', 'black', [], [])</l>
<l>return ()</l>
</body>
<docu id="dev_disp_calibration_data_instructions2">
<chapters lang="de_DE">
<item>Graphik</item>
<item>Text</item>
</chapters>
<chapters lang="en_US">
<item>Graphics</item>
<item>Text</item>
</chapters>
<library lang="en_US">MVTec Standard Procedures</library>
<parameters>
<parameter id="Image">
<multivalue>false</multivalue>
<sem_type>image</sem_type>
</parameter>
</parameters>
</docu>
</procedure>
<procedure name="dev_disp_introduction" access="local">
<interface>
<ic>
<par name="WindowHandle" base_type="ctrl" dimension="0"/>
<par name="WindowHandleGraphics" base_type="ctrl" dimension="0"/>
</ic>
</interface>
<body>
<c>* </c>
<l>dev_set_window (WindowHandle)</l>
<l>dev_clear_window ()</l>
<l>Text := 'With this procedure, we calibrate the coordinates of the touching point'</l>
<l>Text[1] := 'of a robot with respect to the robot\'s tool.'</l>
<l>Text[2] := ''</l>
<l>Text[3] := 'The touching point is a point that has to be fixed with respect to'</l>
<l>Text[4] := 'the tool coordinate system, but does not have to be located on the'</l>
<l>Text[5] := 'surface of the gripper. It can, for example, lie halfway between'</l>
<l>Text[6] := 'two fingers of a gripper.'</l>
<l>Text[7] := ''</l>
<l>Text[8] := 'The touching point should be chosen such that it can approach '</l>
<l>Text[9] := 'a point in the plane easily and accurately.'</l>
<l>Text[10] := ''</l>
<l>Text[11] := 'The coordinates of this point (RobotTouchingPointInToolCoordinates)'</l>
<l>Text[12] := 'are necessary, for example, to perform a hand-eye calibration of a robot'</l>
<l>Text[13] := 'with a stationary camera.'</l>
<l>Text[14] := ''</l>
<l>Text[15] := 'This procedure is used in the example'</l>
<l>Text[16] := 'calibrate_hand_eye_stationary_cam_approx.hdev.'</l>
<l>dev_disp_text (Text, 'window', 'top', 'left', 'white', 'box', 'false')</l>
<l>dev_disp_text ('Press Run (F5) to continue', 'window', 'bottom', 'right', 'black', [], [])</l>
<c>* </c>
<l>dev_set_window (WindowHandleGraphics)</l>
<l>read_image (InstructionImage, '3d_machine_vision/hand_eye/instruction_images/robot_touching_point_in_tool_coordinates')</l>
<l>get_window_extents (WindowHandle, Row, Column, Width, Height)</l>
<l>dev_resize_window_fit_image (InstructionImage, 0, Width + 10, 600, -1)</l>
<l>dev_display (InstructionImage)</l>
<l>return ()</l>
<c></c>
</body>
<docu id="dev_disp_introduction">
<chapters lang="de_DE">
<item>Graphik</item>
<item>Text</item>
</chapters>
<chapters lang="en_US">
<item>Graphics</item>
<item>Text</item>
</chapters>
<library lang="de_DE">MVTec Standard Procedures</library>
<library lang="en_US">MVTec Standard Procedures</library>
<short lang="en_US">Display the introduction for the procedure calibrate_robot_touching_point.</short>
<parameters>
<parameter id="WindowHandle">
<default_type>integer</default_type>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>window</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="WindowHandleGraphics">
<default_type>integer</default_type>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>window</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
</parameters>
</docu>
</procedure>
<procedure name="dev_display_anomaly_detection_evaluation">
<interface>
<ic>
<par name="EvaluationResult" base_type="ctrl" dimension="0"/>
<par name="EvalParam" base_type="ctrl" dimension="0"/>
<par name="GenParam" base_type="ctrl" dimension="0"/>
<par name="WindowHandleDict" base_type="ctrl" dimension="0"/>
</ic>
</interface>
<body>
<c>* </c>
<c>* This procedure visualizes the evaluation results for a model of type anomaly detection.</c>
<c>* </c>
<c>* Set the default values.</c>
<l>BackgroundColor := 'light gray'</l>
<l>PlotNOK := false</l>
<l>DisplayEstimatedThresholds := false</l>
<l>OKColor := 'cornflower blue'</l>
<l>OKColorPlot := '#6495ed80'</l>
<l>NOKColor := 'orange red'</l>
<l>NOKColorPlot := '#ff450080'</l>
<l>ThresholdColors := [OKColor,NOKColor,'black']</l>
<l>EstimatedThresholds := []</l>
<l>LegendVerticalOffset := 50</l>
<l>NumXTicks := 10</l>
<c>* </c>
<c>* Handle the generic parameters.</c>
<l>if (|GenParam| &gt; 0)</l>
<l>    GenParamKeys := 'estimated_thresholds'</l>
<l>    get_dict_param (GenParam, 'keys', [], Keys)</l>
<l>    for KeyIndex := 0 to |Keys| - 1 by 1</l>
<l>        if (find(GenParamKeys,Keys[KeyIndex]) == -1)</l>
<l>            throw ('Invalid GenParam key \'' + Keys[KeyIndex] + '\'')</l>
<l>        endif</l>
<l>    endfor</l>
<l>    get_dict_param (GenParam, 'key_exists', GenParamKeys, KeyExists)</l>
<c>    * Set EstimatedThresholds.</c>
<l>    if (KeyExists[0])</l>
<l>        get_dict_tuple (GenParam, GenParamKeys[0], Value)</l>
<l>        if (|Value| != 1 and |Value| != 3)</l>
<l>            throw ('GenParam \'estimated_thresholds\' must be of length 1 or 3')</l>
<l>        endif</l>
<c>        * </c>
<l>        DisplayEstimatedThresholds := true</l>
<l>        EstimatedThresholds := Value</l>
<l>    endif</l>
<l>endif</l>
<c>* </c>
<c>* Check if anomaly score bins are given.</c>
<l>try</l>
<l>    get_dict_tuple (EvaluationResult, 'anomaly_score_bins', AnomalyScoreBins)</l>
<l>catch (Exception)</l>
<l>    throw ('EvaluationResult must contain anomaly score bins.')</l>
<l>endtry</l>
<c>* </c>
<c>* Check if the anomaly score histogram is given.</c>
<l>try</l>
<l>    get_dict_tuple (EvaluationResult, 'anomaly_score_histogram', AnomalyScoreHistogram)</l>
<l>catch (Exception)</l>
<l>    throw ('EvaluationResult must contain the anomaly score histogram.')</l>
<l>endtry</l>
<c>* </c>
<c>* Check if OK score bins exist.</c>
<l>try</l>
<l>    get_dict_tuple (AnomalyScoreHistogram, 'ok', NumAnomalyScoresOK)</l>
<l>catch (Exception)</l>
<l>    throw ('AnomalyScoreHistogram must contain OK score bins.')</l>
<l>endtry</l>
<c>* </c>
<c>* Check if NOK score bins exist.</c>
<l>try</l>
<l>    get_dict_tuple (AnomalyScoreHistogram, 'nok', NumAnomalyScoresNOK)</l>
<l>catch (Exception)</l>
<l>    throw ('AnomalyScoreHistogram must contain NOK score bins.')</l>
<l>endtry</l>
<c>* </c>
<c>* Validate the histogram content.</c>
<l>if (|NumAnomalyScoresOK| != |AnomalyScoreBins|)</l>
<l>    throw ('Number of bins does not match number of OK bins in the score histogram.')</l>
<l>endif</l>
<c>* </c>
<l>if (|NumAnomalyScoresNOK| != 0 and |NumAnomalyScoresNOK| == |AnomalyScoreBins|)</l>
<l>    PlotNOK := true</l>
<l>else</l>
<l>    throw ('Number of bins does not match number of NOK bins in the score histogram.')</l>
<l>endif</l>
<c>* </c>
<c>* Create drawing window for histogram.</c>
<l>get_dict_param (WindowHandleDict, 'key_exists', 'window_score_histogram', WindowScoreHistogramExists)</l>
<l>if (not WindowScoreHistogramExists)</l>
<l>    dev_open_window (0, 0, 512, 512, BackgroundColor, WindowHandleScoreHistogram)</l>
<l>    set_dict_tuple (WindowHandleDict, 'window_score_histogram', WindowHandleScoreHistogram)</l>
<c>    * </c>
<l>else</l>
<l>    get_dict_tuple (WindowHandleDict, 'window_score_histogram', WindowHandleScoreHistogram)</l>
<l>endif</l>
<l>get_window_param (WindowHandleScoreHistogram, 'flush', FlushStateScoreHistogram)</l>
<l>set_window_param (WindowHandleScoreHistogram, 'flush', 'false')</l>
<c>* </c>
<c>* Create drawing window for legend.</c>
<l>get_dict_param (WindowHandleDict, 'key_exists', 'window_score_legend', WindowScoreLegendExists)</l>
<l>if (not WindowScoreLegendExists)</l>
<l>    dev_open_window (0, 520, 300, 512, BackgroundColor, WindowHandleScoreLegend)</l>
<l>    set_dict_tuple (WindowHandleDict, 'window_score_legend', WindowHandleScoreLegend)</l>
<l>else</l>
<l>    get_dict_tuple (WindowHandleDict, 'window_score_legend', WindowHandleScoreLegend)</l>
<l>endif</l>
<c>* </c>
<c>* Adapt fonts and background colors in the histogram.</c>
<l>dev_set_window (WindowHandleScoreLegend)</l>
<l>get_window_param (WindowHandleScoreLegend, 'flush', FlushStateScoreLegend)</l>
<l>set_window_param (WindowHandleScoreLegend, 'flush', 'false')</l>
<l>set_display_font (WindowHandleScoreHistogram, 14, 'default', 'true', 'false')</l>
<l>set_window_param (WindowHandleScoreHistogram, 'background_color', BackgroundColor)</l>
<c>* </c>
<c>* The evaluation contains NOK samples.</c>
<l>TicksX := real((AnomalyScoreBins[|AnomalyScoreBins| - 1] - AnomalyScoreBins[0]) / NumXTicks)</l>
<l>if (PlotNOK)</l>
<l>    maxY := max([max(NumAnomalyScoresOK),max(NumAnomalyScoresNOK)]) + 0.05</l>
<l>    plot_tuple (WindowHandleScoreHistogram, AnomalyScoreBins, [NumAnomalyScoresOK,NumAnomalyScoresNOK], 'Score', 'Fraction of wrongly classified images', [OKColorPlot,NOKColorPlot], ['start_x','end_x','start_y','end_y','style','ticks_x','ticks_y','axes_color','format_y','style'], [AnomalyScoreBins[0],AnomalyScoreBins[|AnomalyScoreBins| - 1],0,maxY,'step',TicksX,0.1,'black','.1f','filled'])</l>
<l>else</l>
<l>    maxY := max(NumAnomalyScoresOK) + 0.05</l>
<l>    plot_tuple (WindowHandleScoreHistogram, AnomalyScoreBins, NumAnomalyScoresOK, 'Score', 'Fraction of wrongly classified images', OKColorPlot, ['start_x','end_x','start_y','end_y','style','ticks_x','ticks_y','axes_color','format_y'], [AnomalyScoreBins[0],AnomalyScoreBins[|AnomalyScoreBins| - 1],0,maxY,'step',TicksX,0.1,'black','.1f'])</l>
<l>endif</l>
<c>* </c>
<c>* Plot Legend</c>
<l>dev_set_window (WindowHandleScoreLegend)</l>
<l>set_window_param (WindowHandleScoreLegend, 'background_color', BackgroundColor)</l>
<l>set_display_font (WindowHandleScoreLegend, 14, 'default', 'true', 'false')</l>
<l>dev_disp_text ('Curves', 'image', 10 + LegendVerticalOffset, 5, 'black', 'box', 'false')</l>
<l>dev_disp_text ('OK', 'image', 35 + LegendVerticalOffset, 20, OKColor, 'box', 'false')</l>
<l>dev_disp_text ('NOK', 'image', 60 + LegendVerticalOffset, 20, NOKColor, 'box', 'false')</l>
<c>* </c>
<c>* Plot estimated thresholds if given.</c>
<l>if (DisplayEstimatedThresholds)</l>
<l>    dev_disp_text ('Thresholds', 'image', 85 + LegendVerticalOffset, 5, 'black', 'box', 'false')</l>
<l>    get_dict_tuple (GenParam, 'estimated_thresholds', EstimatedThresholds)</l>
<l>    if (|EstimatedThresholds| == 1)</l>
<l>        Color := ThresholdColors[1]</l>
<l>        plot_tuple (WindowHandleScoreHistogram, [EstimatedThresholds,EstimatedThresholds], [0,max(NumAnomalyScoresOK)], [], [], Color, ['start_x','end_x','start_y','end_y','ticks_x','ticks_y','axes_color'], [AnomalyScoreBins[0],AnomalyScoreBins[|AnomalyScoreBins| - 1],0,maxY,'none','none','none'])</l>
<l>        dev_disp_text (ThresholdCaptions[Index], 'image', 110 + LegendVerticalOffset, 20, Color, 'box', 'false')</l>
<l>    elseif (|EstimatedThresholds| == 3)</l>
<l>        ThresholdCaptions := ['No wrongly classified OK images','No wrongly classified NOK images','Minimal sum of OK and NOK fractions']</l>
<l>        Offset := 25</l>
<l>        for Index := 0 to 2 by 1</l>
<l>            Color := ThresholdColors[Index]</l>
<l>            plot_tuple (WindowHandleScoreHistogram, [EstimatedThresholds[Index],EstimatedThresholds[Index]], [0,max(NumAnomalyScoresOK)], [], [], Color, ['start_x','end_x','start_y','end_y','ticks_x','ticks_y','axes_color'], [AnomalyScoreBins[0],AnomalyScoreBins[|AnomalyScoreBins| - 1],0,maxY,'none','none','none'])</l>
<l>            dev_disp_text (ThresholdCaptions[Index], 'image', 110 + LegendVerticalOffset + Index * Offset, 20, Color, 'box', 'false')</l>
<l>        endfor</l>
<l>    endif</l>
<l>endif</l>
<l>flush_buffer (WindowHandleScoreLegend)</l>
<l>flush_buffer (WindowHandleScoreHistogram)</l>
<c>* </c>
<l>set_window_param (WindowHandleScoreHistogram, 'flush', FlushStateScoreHistogram)</l>
<l>set_window_param (WindowHandleScoreLegend, 'flush', FlushStateScoreLegend)</l>
<c>* </c>
<l>return ()</l>
</body>
<docu id="dev_display_anomaly_detection_evaluation">
<abstract lang="en_US">This procedure visualizes the results of an evaluation for a model of type anomaly detection.

The optional dictionary GenParam can be used to configure the visualization. For this purpose, the following entries can be set:
- 'estimated_thresholds' (default: []): Display the given values as vertical lines in the plot. Usually these values are the image level classification thresholds. This parameter allows a single value or a tuple of length 3.

For information on the evaluation parameters, see also the procedure evaluate_dl_model.</abstract>
<chapters lang="en_US">
<item>Deep Learning</item>
<item>Anomaly Detection</item>
</chapters>
<library lang="en_US">MVTec Standard Procedures</library>
<short lang="en_US">Display evaluation results of an evaluated DL model of type 'anomaly_detection'.</short>
<parameters>
<parameter id="EvalParam"/>
<parameter id="EvaluationResult"/>
<parameter id="GenParam"/>
<parameter id="WindowHandleDict"/>
</parameters>
</docu>
</procedure>
<procedure name="dev_display_classification_evaluation">
<interface>
<ic>
<par name="EvaluationResult" base_type="ctrl" dimension="0"/>
<par name="EvalParam" base_type="ctrl" dimension="0"/>
<par name="GenParam" base_type="ctrl" dimension="0"/>
<par name="WindowHandleDict" base_type="ctrl" dimension="0"/>
</ic>
</interface>
<body>
<c>* </c>
<c>* This procedure visualizes the evaluation results for a model of type classification.</c>
<c>* </c>
<c>* Set the default values.</c>
<l>DisplayMeasures := true</l>
<l>DisplayConfusionAbsolute := false</l>
<l>DisplayConfusionRelative := false</l>
<l>DisplayPieChartPrecision := false</l>
<l>DisplayPieChartRecall := false</l>
<l>MeasureColor := 'white'</l>
<l>RowColNameColor := 'light gray'</l>
<l>DisplayColumnWidth := 'equal'</l>
<l>DisplayColor := true</l>
<l>Font := 'mono'</l>
<l>FontSize := 14</l>
<c>* </c>
<c>* Handle the generic parameters.</c>
<l>if (|GenParam| &gt; 0)</l>
<l>    GenParamKeys := ['display_mode','measure_color','row_col_names_color','display_column_width','display_color','font','font_size']</l>
<l>    get_dict_param (GenParam, 'keys', [], Keys)</l>
<l>    for KeyIndex := 0 to |Keys| - 1 by 1</l>
<l>        if (find(GenParamKeys,Keys[KeyIndex]) == -1)</l>
<l>            throw ('Invalid GenParam key \'' + Keys[KeyIndex] + '\'')</l>
<l>        endif</l>
<l>    endfor</l>
<l>    get_dict_param (GenParam, 'key_exists', GenParamKeys, KeyExists)</l>
<c>    * Set display mode.</c>
<l>    if (KeyExists[0])</l>
<l>        get_dict_tuple (GenParam, GenParamKeys[0], Value)</l>
<l>        if (|Value| == 0)</l>
<l>            throw ('GenParam key \'display_mode\' cannot be an empty tuple')</l>
<l>        else</l>
<c>            * Display measures.</c>
<l>            DisplayMeasures := find(Value,'measures')</l>
<l>            DisplayMeasures := |DisplayMeasures| &gt; 0 and DisplayMeasures != -1</l>
<c>            * Display absolute confusion matrix.</c>
<l>            DisplayConfusionAbsolute := find(Value,'absolute_confusion_matrix')</l>
<l>            DisplayConfusionAbsolute := |DisplayConfusionAbsolute| &gt; 0 and DisplayConfusionAbsolute != -1</l>
<c>            * Display relative confusion matrix.</c>
<l>            DisplayConfusionRelative := find(Value,'relative_confusion_matrix')</l>
<l>            DisplayConfusionRelative := |DisplayConfusionRelative| &gt; 0 and DisplayConfusionRelative != -1</l>
<c>            * Display pie charts precision.</c>
<l>            DisplayPieChartPrecision := find(Value,'pie_charts_precision')</l>
<l>            DisplayPieChartPrecision := |DisplayPieChartPrecision| &gt; 0 and DisplayPieChartPrecision != -1</l>
<c>            * Display pie charts recall.</c>
<l>            DisplayPieChartRecall := find(Value,'pie_charts_recall')</l>
<l>            DisplayPieChartRecall := |DisplayPieChartRecall| &gt; 0 and DisplayPieChartRecall != -1</l>
<c>            * </c>
<l>            if (sum([DisplayMeasures,DisplayConfusionAbsolute,DisplayConfusionRelative,DisplayPieChartPrecision,DisplayPieChartRecall]) != |Value|)</l>
<l>                throw ('\'display_mode\' not supported.')</l>
<l>            endif</l>
<l>        endif</l>
<l>    endif</l>
<c>    * Set MeasureColor (only for display_mode 'measures').</c>
<l>    if (KeyExists[1])</l>
<l>        get_dict_tuple (GenParam, GenParamKeys[1], Value)</l>
<l>        if (|Value| != 1)</l>
<l>            throw ('GenParam \'measure_color\' must be a single value')</l>
<l>        endif</l>
<l>        try</l>
<l>            color_string_to_rgb (Value, RGB)</l>
<l>        catch (Exception)</l>
<l>            throw ('GenParam \'measure_color\' must be a valid color string')</l>
<l>        endtry</l>
<l>        MeasureColor := Value</l>
<l>    endif</l>
<c>    * Set color for row and column names.</c>
<l>    if (KeyExists[2])</l>
<l>        get_dict_tuple (GenParam, GenParamKeys[2], Value)</l>
<l>        if (|Value| != 1)</l>
<l>            throw ('GenParam \'row_col_names_color\' must be a single value')</l>
<l>        endif</l>
<l>        try</l>
<l>            color_string_to_rgb (Value, RGB)</l>
<l>        catch (Exception)</l>
<l>            throw ('GenParam \'row_col_names_color\' must be a valid color string')</l>
<l>        endtry</l>
<l>        RowColNameColor := Value</l>
<l>    endif</l>
<c>    * Set value for displaying column width.</c>
<l>    if (KeyExists[3])</l>
<l>        get_dict_tuple (GenParam, 'display_column_width', DisplayColumnWidthTmp)</l>
<l>        if (|DisplayColumnWidthTmp| != 1 or find(['equal','minimal'],DisplayColumnWidthTmp) == -1)</l>
<l>            throw ('Invalid value for \'display_column_width\'')</l>
<l>        else</l>
<l>            DisplayColumnWidth := DisplayColumnWidthTmp</l>
<l>        endif</l>
<l>    endif</l>
<c>    * Set display_color (only for confusion matrix).</c>
<l>    if (KeyExists[4])</l>
<l>        get_dict_tuple (GenParam, 'display_color', DisplayColor)</l>
<l>        if (|DisplayColor| != 1 or find(['true','false'],DisplayColor) == -1)</l>
<l>            throw ('Invalid value for \'display_color\'')</l>
<l>        else</l>
<l>            if (DisplayColor == 'true')</l>
<l>                DisplayColor := true</l>
<l>            else</l>
<l>                DisplayColor := false</l>
<l>            endif</l>
<l>        endif</l>
<l>    endif</l>
<c>    * Set font (only available for 'measures' and confusion matrices).</c>
<l>    if (KeyExists[5])</l>
<l>        get_dict_tuple (GenParam, 'font', Font)</l>
<l>    endif</l>
<c>    * Set font size (only available for 'measures' and confusion matrices).</c>
<l>    if (KeyExists[6])</l>
<l>        get_dict_tuple (GenParam, 'font_size', FontSize)</l>
<l>        if (FontSize &lt; 8 or FontSize &gt; 64)</l>
<l>            throw ('Font size has to be in range of [8,64]')</l>
<l>        endif</l>
<l>    endif</l>
<l>endif</l>
<c>* </c>
<c>* Check EvalParam and get the class names.</c>
<l>try</l>
<l>    get_dict_param (EvalParam, 'key_exists', ['class_names','class_ids'], KeysExist)</l>
<l>catch (Exception)</l>
<l>    throw ('EvalParam has to be a dictionary')</l>
<l>endtry</l>
<l>if (not sum(KeysExist))</l>
<l>    throw ('EvalParam must contain at least one of the keys \'class_names\' or \'class_ids\'')</l>
<l>elseif (not KeysExist[0])</l>
<c>    * If class names are not given, use class IDs instead.</c>
<l>    get_dict_tuple (EvalParam, 'class_ids', ClassIDs)</l>
<l>    ClassNames := 'class_id_' + ClassIDs</l>
<l>else</l>
<c>    * Get the class names from the EvalParam dict.</c>
<l>    get_dict_tuple (EvalParam, 'class_names', ClassNames)</l>
<l>endif</l>
<c>* </c>
<c>* Cut class names for better visualization and get mapping between class IDs and class names.</c>
<l>if (ClassNames != [])</l>
<c>    * Cut class names.</c>
<l>    MaxChars := 14</l>
<l>    for Index := 0 to |ClassNames| - 1 by 1</l>
<l>        Str := ClassNames[Index]</l>
<l>        tuple_is_string (Str, IsString)</l>
<l>        if (IsString)</l>
<l>            tuple_strlen (Str, Length)</l>
<l>            if (Length &gt; MaxChars)</l>
<l>                SubStr := Str{0:MaxChars - 3} + '...'</l>
<l>                ClassNames[Index] := SubStr</l>
<l>            endif</l>
<l>        endif</l>
<l>    endfor</l>
<c>    * Generate mapping.</c>
<l>    get_dict_tuple (EvalParam, 'class_ids', ClassIDs)</l>
<l>    tuple_gen_const (max(ClassIDs), -1, ClassIDsToNamesMapping)</l>
<l>    ClassIDsToNamesMapping[ClassIDs] := [0:|ClassIDs| - 1]</l>
<l>endif</l>
<c>* </c>
<c>* Sanity check for EvaluationResult.</c>
<l>try</l>
<l>    get_dict_param (EvaluationResult, 'keys', [], Keys)</l>
<l>catch (Exception)</l>
<l>    throw ('EvaluationResult has to be a dictionary')</l>
<l>endtry</l>
<l>AllowedKeyEntries := 'class_id_' + ClassIDs</l>
<l>AllowedKeyEntries := [AllowedKeyEntries,'absolute_confusion_matrix','relative_confusion_matrix','global','evaluated_samples']</l>
<l>if (difference(Keys,AllowedKeyEntries) != [])</l>
<l>    throw ('EvaluationResult only supports the following key entries: ' + AllowedKeyEntries)</l>
<l>endif</l>
<c>* </c>
<c>* Check if requested display modes are available.</c>
<l>get_dict_param (EvaluationResult, 'key_exists', ['absolute_confusion_matrix','relative_confusion_matrix'], KeysExist)</l>
<l>if (DisplayConfusionAbsolute and not KeysExist[0])</l>
<l>    throw ('Key \'absolute_confusion_matrix\' in EvaluationResult is needed to display absolute confusion matrix.\n Please run evaluate_dl_model with this key.')</l>
<l>endif</l>
<l>if (DisplayConfusionRelative and not KeysExist[1])</l>
<l>    throw ('Key \'relative_confusion_matrix\' in EvaluationResult is needed to display relative confusion matrix.\n Please run evaluate_dl_model with this key.')</l>
<l>endif</l>
<c>* </c>
<c>* Display measures.</c>
<l>if (DisplayMeasures)</l>
<c>    * </c>
<c>    * For each entry in EvaluationResult except *_confusion_matrix, a row containing the measures is displayed.</c>
<l>    get_dict_param (EvaluationResult, 'keys', [], KeyClasses)</l>
<l>    KeyClasses := difference(KeyClasses,['absolute_confusion_matrix','relative_confusion_matrix','evaluated_samples'])</l>
<l>    if (|KeyClasses| == 0)</l>
<l>        throw ('To display \'measures\' an evaluation for at least one class is needed')</l>
<l>    endif</l>
<l>    if (ClassNames != [])</l>
<c>        * Match class names for better readability.</c>
<l>        tuple_gen_const (|KeyClasses|, 'global', RowNames)</l>
<l>        Indices := find(KeyClasses [!=] 'global',1)</l>
<l>        if (Indices != -1)</l>
<l>            tuple_regexp_match (KeyClasses[Indices], 'class_id_(.*)', Matches)</l>
<l>            Matches := number(Matches)</l>
<l>            RowNames[Indices] := ClassNames[ClassIDsToNamesMapping[int(Matches)]]</l>
<l>        endif</l>
<l>    else</l>
<l>        tuple_regexp_replace (KeyClasses, ['_','replace_all'], ' ', RowNames)</l>
<l>    endif</l>
<c>    * </c>
<c>    * Get all measures that can be displayed.</c>
<l>    get_dict_tuple (EvaluationResult, KeyClasses[0], EvaluatedClass)</l>
<l>    get_dict_param (EvaluatedClass, 'keys', [], KeyEvaluations)</l>
<l>    tuple_regexp_replace (KeyEvaluations, ['mean_','replace_all'], '', KeyEvaluations)</l>
<c>    * Throw away unneeded keys.</c>
<l>    tuple_regexp_select (KeyEvaluations, 'top([0-9]{1,2})_error', TopKErrors)</l>
<l>    KeyEvaluations := intersection(KeyEvaluations,[TopKErrors,'precision','recall','f_score'])</l>
<c>    * Sort the entries as follows: ['topK_error', 'precision', 'recall', 'f_score']</c>
<l>    tuple_regexp_match (KeyEvaluations, 'top.*', Matches)</l>
<l>    tuple_strlen (Matches, MatchesLength)</l>
<l>    Indices := find(MatchesLength [&gt;] 0,1)</l>
<l>    if (Indices != -1)</l>
<l>        OffSet := difference([0:|KeyEvaluations| - 1],Indices)</l>
<l>        KeyEvaluations := [KeyEvaluations[Indices],KeyEvaluations[OffSet]]</l>
<l>    endif</l>
<l>    FScoreIndex := find(KeyEvaluations [==] 'f_score',1)</l>
<l>    if (FScoreIndex != -1)</l>
<l>        tuple_remove (KeyEvaluations, FScoreIndex, KeyEvaluations)</l>
<l>        KeyEvaluations := [KeyEvaluations,'f_score']</l>
<l>    endif</l>
<c>    * Check if any valid keys are still available.</c>
<l>    if (|KeyEvaluations| == 0)</l>
<l>        throw ('To display \'measures\' at least one evaluation measure is needed')</l>
<l>    endif</l>
<l>    ColumnNames := KeyEvaluations</l>
<c>    * </c>
<c>    * Fill matrix</c>
<l>    create_matrix (|KeyClasses|, |KeyEvaluations|, 0, MatrixID)</l>
<l>    for RowIndex := 0 to |KeyClasses| - 1 by 1</l>
<l>        get_dict_tuple (EvaluationResult, KeyClasses[RowIndex], Dict)</l>
<l>        for ColumnIndex := 0 to |KeyEvaluations| - 1 by 1</l>
<l>            try</l>
<l>                get_dict_tuple (Dict, KeyEvaluations[ColumnIndex], Value)</l>
<l>            catch (Exception)</l>
<l>                get_dict_tuple (Dict, 'mean_' + KeyEvaluations[ColumnIndex], Value)</l>
<l>            endtry</l>
<l>            set_value_matrix (MatrixID, RowIndex, ColumnIndex, Value)</l>
<l>        endfor</l>
<l>    endfor</l>
<c>    * </c>
<c>    * Set generic parameters for dev_display_matrix.</c>
<l>    create_dict (GenParam)</l>
<l>    set_dict_tuple (GenParam, 'title', 'Measures')</l>
<l>    set_dict_tuple (GenParam, 'number_format', '0.3f')</l>
<l>    set_dict_tuple (GenParam, 'display_column_width', DisplayColumnWidth)</l>
<l>    set_dict_tuple (GenParam, 'value_colors', MeasureColor)</l>
<l>    set_dict_tuple (GenParam, 'display_color', true)</l>
<l>    set_dict_tuple (GenParam, 'row_col_names_color', RowColNameColor)</l>
<c>    * </c>
<c>    * Check if there is already a window handle.</c>
<l>    get_dict_param (WindowHandleDict, 'key_exists', 'window_measures', WindowExists)</l>
<l>    if (WindowExists)</l>
<l>        get_dict_tuple (WindowHandleDict, 'window_measures', WindowHandleMeasures)</l>
<l>        dev_set_window (WindowHandleMeasures)</l>
<l>    else</l>
<l>        dev_open_window (0, 0, 512, 512, 'black', WindowHandleMeasures)</l>
<l>        set_dict_tuple (WindowHandleDict, 'window_measures', WindowHandleMeasures)</l>
<l>    endif</l>
<c>    * </c>
<c>    * Display.</c>
<l>    set_display_font (WindowHandleMeasures, FontSize, Font, 'false', 'false')</l>
<l>    dev_display_matrix (MatrixID, ColumnNames, RowNames, WindowHandleMeasures, GenParam)</l>
<l>endif</l>
<c>* </c>
<c>* Visualize confusion matrix.</c>
<l>if (DisplayConfusionAbsolute or DisplayConfusionRelative)</l>
<c>    * </c>
<c>    * Set general generic parameters for dev_display_matrix.</c>
<l>    create_dict (GenParam)</l>
<l>    set_dict_tuple (GenParam, 'display_column_with', DisplayColumnWidth)</l>
<l>    set_dict_tuple (GenParam, 'display_color', DisplayColor)</l>
<l>    set_dict_tuple (GenParam, 'row_col_names_color', RowColNameColor)</l>
<l>    set_dict_tuple (GenParam, 'axis_titles', ['Ground truth','Predicted'])</l>
<l>    if (DisplayColor)</l>
<c>        * Display off-diagonal values in red.</c>
<l>        ValueColors := gen_tuple_const(|ClassIDs| * |ClassIDs|,'#ff4500')</l>
<c>        * Display diagonal values in green.</c>
<l>        DiagonalColor := '#00ff00'</l>
<l>        tuple_gen_sequence (0, |ClassIDs| - 1, 1, Seq)</l>
<l>        DiagonalIndices := |ClassIDs| * Seq + Seq</l>
<l>        ValueColors[DiagonalIndices] := DiagonalColor</l>
<l>        set_dict_tuple (GenParam, 'value_colors', ValueColors)</l>
<l>    endif</l>
<c>    * </c>
<c>    * Set row and column names.</c>
<l>    if (ClassNames != [])</l>
<l>        RowColumnNames := ClassNames</l>
<l>    else</l>
<l>        RowColumnNames := 'class_id_' + ClassIDs</l>
<l>    endif</l>
<c>    * </c>
<c>    * Display confusion matrix.</c>
<l>    Booleans := [DisplayConfusionAbsolute,DisplayConfusionRelative]</l>
<l>    Strings := ['absolute','relative']</l>
<l>    KapitalStrings := ['Absolute','Relative']</l>
<l>    for Index := 0 to |Booleans| - 1 by 1</l>
<l>        if (not Booleans[Index])</l>
<l>            continue</l>
<l>        endif</l>
<l>        get_dict_tuple (EvaluationResult, Strings[Index] + '_confusion_matrix', ConfusionMatrix)</l>
<l>        set_dict_tuple (GenParam, 'title', KapitalStrings[Index] + ' confusion matrix')</l>
<c>        * Convert relative matrix values to percent.</c>
<l>        if (Strings[Index] == 'relative')</l>
<l>            copy_matrix (ConfusionMatrix, ConfusionMatrix)</l>
<l>            get_full_matrix (ConfusionMatrix, ValuesRelative)</l>
<l>            set_full_matrix (ConfusionMatrix, 100 * ValuesRelative)</l>
<l>        endif</l>
<c>        * Calculate proper number format.</c>
<l>        max_matrix (ConfusionMatrix, 'full', MatrixMaxID)</l>
<l>        get_full_matrix (MatrixMaxID, MaxValue)</l>
<l>        if (MaxValue &gt; 0)</l>
<l>            NumberFormat := int(ceil(log10(MaxValue))) + '.0f'</l>
<l>        else</l>
<l>            NumberFormat := '1.0f'</l>
<l>        endif</l>
<l>        set_dict_tuple (GenParam, 'number_format', NumberFormat)</l>
<c>        * </c>
<c>        * Check if there is already a window handle.</c>
<l>        get_dict_param (WindowHandleDict, 'key_exists', 'window_' + Strings[Index] + '_confusion_matrix', WindowExists)</l>
<l>        if (not WindowExists)</l>
<l>            dev_open_window (0, 0, 512, 512, 'black', WindowHandleConfusion)</l>
<l>            set_dict_tuple (WindowHandleDict, 'window_' + Strings[Index] + '_confusion_matrix', WindowHandleConfusion)</l>
<l>        else</l>
<l>            get_dict_tuple (WindowHandleDict, 'window_' + Strings[Index] + '_confusion_matrix', WindowHandleConfusion)</l>
<l>        endif</l>
<c>        * </c>
<c>        * Display.</c>
<l>        set_display_font (WindowHandleConfusion, FontSize, Font, 'false', 'false')</l>
<l>        dev_display_matrix (ConfusionMatrix, RowColumnNames, RowColumnNames, WindowHandleConfusion, GenParam)</l>
<l>    endfor</l>
<l>endif</l>
<c>* </c>
<c>*  Visualization of precision pie charts.</c>
<l>if (DisplayPieChartPrecision)</l>
<c>    * </c>
<c>    * Check if there is already a window handle.</c>
<l>    get_dict_param (WindowHandleDict, 'key_exists', 'window_pie_charts_precision', WindowExists)</l>
<l>    if (not WindowExists)</l>
<l>        dev_open_window (0, 0, 512, 512, 'black', WindowHandlePrecision)</l>
<l>        set_dict_tuple (WindowHandleDict, 'window_pie_charts_precision', WindowHandlePrecision)</l>
<l>    else</l>
<l>        get_dict_tuple (WindowHandleDict, 'window_pie_charts_precision', WindowHandlePrecision)</l>
<l>    endif</l>
<c>    * Display.</c>
<l>    dev_display_classification_evaluation_class_pie_chart (WindowHandlePrecision, EvaluationResult, ClassIDs, 'precision')</l>
<l>endif</l>
<c>* </c>
<c>*  Visualization of recall pie charts.</c>
<l>if (DisplayPieChartRecall)</l>
<c>    * </c>
<c>    * Check if there is already a window handle.</c>
<l>    get_dict_param (WindowHandleDict, 'key_exists', 'window_pie_charts_recall', WindowExists)</l>
<l>    if (not WindowExists)</l>
<l>        dev_open_window (0, 0, 512, 512, 'black', WindowHandlePrecision)</l>
<l>        set_dict_tuple (WindowHandleDict, 'window_pie_charts_recall', WindowHandlePrecision)</l>
<l>    else</l>
<l>        get_dict_tuple (WindowHandleDict, 'window_pie_charts_recall', WindowHandlePrecision)</l>
<l>    endif</l>
<c>    * Display.</c>
<l>    dev_display_classification_evaluation_class_pie_chart (WindowHandlePrecision, EvaluationResult, ClassIDs, 'recall')</l>
<l>endif</l>
<c>* </c>
<c>* Rearrange windows.</c>
<c>* Pie charts (if present) are plotted at the left, the rest at the right side.</c>
<l>get_dict_param (WindowHandleDict, 'keys', [], WindowKeys)</l>
<l>DisplayBooleans := [DisplayPieChartPrecision,DisplayPieChartRecall,DisplayMeasures,DisplayConfusionAbsolute,DisplayConfusionRelative]</l>
<l>WindowHandleKeyNames := ['window_pie_charts_precision','window_pie_charts_recall','window_measures','window_absolute_confusion_matrix','window_relative_confusion_matrix']</l>
<l>Row := 0</l>
<l>Column := 0</l>
<l>MaxColumn := 0</l>
<l>if (|WindowKeys| &gt;= 1)</l>
<l>    for Index := 0 to |DisplayBooleans| - 1 by 1</l>
<l>        if (Index == 2)</l>
<l>            Row := 0</l>
<l>            Column := MaxColumn + 8</l>
<l>        endif</l>
<l>        if (DisplayBooleans[Index])</l>
<l>            get_dict_tuple (WindowHandleDict, WindowHandleKeyNames[Index], WindowHandle)</l>
<l>            get_window_extents (WindowHandle, _, _, Width, Height)</l>
<l>            dev_set_window (WindowHandle)</l>
<l>            dev_set_window_extents (Row, Column, Width, Height)</l>
<l>            Row := Row + Height + 55</l>
<l>            MaxColumn := max2(MaxColumn,Width)</l>
<l>        endif</l>
<l>    endfor</l>
<l>endif</l>
<c>* </c>
<l>return ()</l>
</body>
<docu id="dev_display_classification_evaluation">
<abstract lang="en_US">This procedure visualizes the results of a evaluation for a model of type classification.

The optional dictionary GenParam can be used to configure the visualization. For this purpose, the following entries can be set:
- 'display_color' (default: 'true', only available for display_mode absolute_confusion_matrix or relative_confusion_matrix): Display values in confusion matrix colored in green (diagonal) and red (off-diagonal).
- 'display_mode': You can set the following values to determine the display mode:
   -- 'measures' (default): For each evaluated class, all available measures in EvaluationResult are shown in a tabular.
   -- 'pie_charts_precision': Pie-charts showing the precision for each evaluated class and the mean over all evaluated classes are displayed.
   -- 'pie_charts_recall': Pie-charts showing the recall for each evaluated class and the mean over all evaluated classes are displayed.
   -- 'abolute_confusion_matrix': Confusion matrix of size (number of class IDs, number of class IDs), where entry (i,j) is the number of images with ground truth class_ids[j] predicted as class_ids[i].
   -- 'relative_confusion_matrix': Confusion matrix, but every entry (i,j) is normalized by the number of ground truth labels of the class in column j.
- 'font' (default: 'mono'):  Font used when displaying 'measures' or confusion matrices.
- 'font_size' (default: 14): Font size used when displaying 'measures' or confusion matrices. The font size has to be in the range [8,64].
- 'measure_color' (default: 'white', only available for display_mode 'measures'): Set a color for the values of the measures in the tabular.
- 'row_col_names_color' (default: 'light gray'): Set color for row and column names.

For information on the evaluation parameters, see also the procedure evaluate_dl_model.</abstract>
<chapters lang="en_US">
<item>Deep Learning</item>
<item>Classification</item>
</chapters>
<library lang="en_US">MVTec Standard Procedures</library>
<short lang="en_US">Display evaluation results of an evaluated DL model of type 'classification'.</short>
<parameters>
<parameter id="EvalParam">
<default_type>integer</default_type>
<default_value>EvalParam</default_value>
<description lang="en_US">Dictionary with the evaluation parameters.</description>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>dict</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="EvaluationResult">
<default_type>integer</default_type>
<default_value>EvaluationResult</default_value>
<description lang="en_US">Dictionary with the classification evaluation result.</description>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>dict</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="GenParam">
<default_type>integer</default_type>
<default_value>[]</default_value>
<description lang="en_US">Dictionary with the generic parameters used to configure the visualization.</description>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>dict</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="WindowHandleDict">
<default_type>integer</default_type>
<default_value>WindowHandleDict</default_value>
<description lang="en_US">Dictionary with the handles for the windows in which the matrices shall be displayed.</description>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>dict</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
</parameters>
</docu>
</procedure>
<procedure name="dev_display_classification_evaluation_class_pie_chart" access="local">
<interface>
<ic>
<par name="WindowHandle" base_type="ctrl" dimension="0"/>
<par name="EvaluationResult" base_type="ctrl" dimension="0"/>
<par name="ClassIDs" base_type="ctrl" dimension="0"/>
<par name="Mode" base_type="ctrl" dimension="0"/>
</ic>
</interface>
<body>
<c>* </c>
<c>* This procedure plots pie charts for precision and recall.</c>
<c>* More detailed, the mean over all classes that have been used for</c>
<c>* evaluation and the values for each class are plotted.</c>
<c>* </c>
<c>* Switch off automatic flushing to make visualization smooth.</c>
<l>get_window_param (WindowHandle, 'flush', FlushValue)</l>
<l>set_window_param (WindowHandle, 'flush', 'false')</l>
<c>* Drawing parameters.</c>
<c>* Overall pie-chart.</c>
<l>CenterRowOverall := 150</l>
<l>CenterColOverall := 150</l>
<l>RadiusOverall := 100</l>
<c>* Per-class pie-chart.</c>
<l>MaxClassChartsPerRow := 10</l>
<l>RadiusClass := 40</l>
<l>ChartRowDistance := 3 * RadiusClass</l>
<l>ChartColDistance := 2.5 * RadiusClass</l>
<l>StartRow := CenterRowOverall + 1.5 * RadiusOverall + 1.5 * RadiusClass</l>
<l>StartCol := 1.5 * RadiusClass</l>
<c>* </c>
<c>* Get values.</c>
<l>KeysToPlot := 'global'</l>
<l>get_dict_param (EvaluationResult, 'key_exists', 'global', KeyExists)</l>
<l>if (KeyExists)</l>
<l>    KeysToPlot := 'global'</l>
<l>    NumClassCharts := |ClassIDs|</l>
<l>    get_dict_tuple (EvaluationResult, 'global', Measures)</l>
<l>    get_dict_tuple (Measures, 'mean_' + Mode, MeanValue)</l>
<l>    get_dict_tuple (Measures, Mode + '_per_class', ValuesPerClass)</l>
<l>    MainTitle := 'Mean ' + Mode</l>
<l>    ClassTitles := 'Class id ' + ClassIDs</l>
<l>else</l>
<c>    * Search for evaluated classes.</c>
<l>    get_dict_param (EvaluationResult, 'keys', [], Keys)</l>
<l>    tuple_regexp_select (Keys, 'class_id', KeysToPlot)</l>
<l>    tuple_regexp_match (KeysToPlot, 'class_id_(.*)', ClassIDsStr)</l>
<l>    ClassIDs := number(ClassIDsStr)</l>
<l>    if (|ClassIDs| == 1)</l>
<c>        * We do not need to plot the small pie charts for each class.</c>
<l>        NumClassCharts := 0</l>
<l>        MainTitle := Mode + ' for class id ' + ClassIDs[0]</l>
<l>        ClassTitles := []</l>
<l>    else</l>
<l>        NumClassCharts := |ClassIDs|</l>
<l>        MainTitle := 'Mean ' + Mode</l>
<l>        ClassTitles := 'Class id ' + ClassIDs</l>
<l>    endif</l>
<l>    ValuesPerClass := []</l>
<l>    for Index := 0 to |ClassIDs| - 1 by 1</l>
<l>        get_dict_tuple (EvaluationResult, KeysToPlot[Index], Measures)</l>
<l>        get_dict_tuple (Measures, Mode, Value)</l>
<l>        ValuesPerClass := [ValuesPerClass,Value]</l>
<l>    endfor</l>
<l>    MeanValue := mean(ValuesPerClass)</l>
<l>endif</l>
<c>* </c>
<c>* Open Window and set font.</c>
<l>WindowWidth := max2(550,(min2(NumClassCharts,MaxClassChartsPerRow) - 1) * ChartColDistance + 2 * StartCol)</l>
<l>WindowHeight := 3 * RadiusOverall + ceil(real(NumClassCharts) / MaxClassChartsPerRow) * 3 * RadiusClass</l>
<l>dev_set_window (WindowHandle)</l>
<l>dev_set_window_extents (0, 0, WindowWidth, WindowHeight)</l>
<l>gen_image_const (Image, 'byte', WindowWidth, WindowHeight)</l>
<l>dev_display (Image)</l>
<l>dev_clear_window ()</l>
<l>query_font (WindowHandle, Font)</l>
<l>Font := Font[0] + '-Bold-15'</l>
<l>set_font (WindowHandle, Font)</l>
<c>* </c>
<c>* Draw the pie-chart.</c>
<l>Colors := ['green','red']</l>
<l>create_dict (GenParamPieChart)</l>
<l>set_dict_tuple (GenParamPieChart, 'title', MainTitle)</l>
<l>dev_display_pie_chart (WindowHandle, [MeanValue,1.0 - MeanValue], CenterRowOverall, CenterColOverall, RadiusOverall, Colors, GenParamPieChart)</l>
<c>* </c>
<c>* Write description for pie chart.</c>
<l>dev_disp_text ('Results: ', 'image', 20, CenterColOverall + RadiusOverall + 20, 'white', 'box', 'false')</l>
<l>if (Mode == 'precision')</l>
<l>    Description := ['precision (TP / (TP + FP))','false positives']</l>
<l>elseif (Mode == 'recall')</l>
<l>    Description := ['recall (TP / (TP + FN))','false negatives']</l>
<l>else</l>
<l>    throw ('Mode not supported: ' + Mode)</l>
<l>endif</l>
<l>PercentStr := ([MeanValue,1.0 - MeanValue] * 100)$'.1f' + ''</l>
<l>for Index := 0 to |Description| - 1 by 1</l>
<l>    dev_disp_text (PercentStr[Index] + '%: ' + Description[Index], 'image', 30 + (Index + 1) * 20, CenterColOverall + RadiusOverall + 20, Colors[Index], 'box', 'false')</l>
<l>endfor</l>
<c>* </c>
<c>* Per class pie charts.</c>
<l>for Index := 0 to NumClassCharts - 1 by 1</l>
<c>    * Get the position of the class-pie-chart.</c>
<l>    CenterRow := StartRow + floor(real(Index) / MaxClassChartsPerRow) * ChartRowDistance</l>
<l>    CenterCol := StartCol + (Index % MaxClassChartsPerRow) * ChartColDistance</l>
<l>    set_dict_tuple (GenParamPieChart, 'title', ClassTitles[Index])</l>
<l>    dev_display_pie_chart (WindowHandle, [ValuesPerClass[Index],1.0 - ValuesPerClass[Index]], CenterRow, CenterCol, RadiusClass, Colors, GenParamPieChart)</l>
<l>endfor</l>
<c>* </c>
<c>* Flush buffer and reset value for 'flush'.</c>
<l>flush_buffer (WindowHandle)</l>
<l>set_window_param (WindowHandle, 'flush', FlushValue)</l>
<c>* </c>
<l>return ()</l>
</body>
<docu id="dev_display_classification_evaluation_class_pie_chart">
<abstract lang="en_US">This procedure displays the evaluation results in the dictionary EvaluationResult as a pie-chart.
Thereby, the procedure plots one pie-chart for a specific class or all classes together.

WindowHandle determines in which window the pie-chart is displayed.
With Mode you can specify, which kind of pie-chart is displayed. 

For the string Mode, the following options are available:
- 'precision': For each evaluated class, the charts give an overview of the ratio of true positives (TP) and false positives (FP). Moreover, the mean over all evaluated classes are displayed. Precision is defined as TP / (TP + FP)
- 'recall': For each evaluated class, the charts show the ratio of true positives (TP) to all ground truth instances (TP + FN). Moreover, the mean over all evaluated classes are displayed. Recall is defined as TP / (TP + FN).</abstract>
<chapters lang="en_US">
<item>Deep Learning</item>
<item>Classification</item>
</chapters>
<library lang="en_US">MVTec Internal Procedures</library>
<short lang="en_US">Display pie charts for prediction or recall of an classification evaluation.</short>
<parameters>
<parameter id="ClassIDs">
<default_type>integer</default_type>
<default_value>ClassIDs</default_value>
<description lang="en_US">ClassIDs of the classes.</description>
<mixed_type>false</mixed_type>
<multivalue>optional</multivalue>
<sem_type>integer</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="EvaluationResult">
<default_type>integer</default_type>
<default_value>EvaluationResult</default_value>
<description lang="en_US">Dictionary containing the evaluation results returned by the procedure evaluate_dl_model.</description>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>dict</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="Mode">
<default_type>string</default_type>
<default_value>Mode</default_value>
<description lang="en_US">Mode specifies which kind of pie-chart is displayed.</description>
<multivalue>false</multivalue>
<sem_type>string</sem_type>
<type_list>
<item>string</item>
</type_list>
</parameter>
<parameter id="WindowHandle">
<default_type>integer</default_type>
<default_value>WindowHandle</default_value>
<description lang="en_US">Window handle, where the pie-chart is displayed.</description>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>handle</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
</parameters>
</docu>
</procedure>
<procedure name="dev_display_confidence_regions" access="local">
<interface>
<io>
<par name="ImageConfidence" base_type="iconic" dimension="0"/>
</io>
<ic>
<par name="DrawTransparency" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="Colors" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c>* </c>
<c>* This procedure displays a map of the confidences</c>
<c>* given in ImageConfidence as regions.</c>
<c>* DrawTransparency determines the alpha value of the colors.</c>
<c>* The used colors are returned.</c>
<c>* </c>
<c>* Define colors.</c>
<l>NumColors := 20</l>
<l>get_distinct_colors (NumColors, false, 0, 100, Colors)</l>
<l>WeightsColorsAlpha := Colors + DrawTransparency</l>
<l>ColorIndex := 0</l>
<c>* </c>
<c>* Threshold the image according to</c>
<c>* the number of colors and</c>
<c>* display resulting regions.</c>
<l>for ColorIndex := 0 to NumColors - 1 by 1</l>
<l>    Threshold := ColorIndex * (1.0 / NumColors)</l>
<l>    MinGray := Threshold</l>
<l>    MaxGray := Threshold + 1 / NumColors</l>
<l>    threshold (ImageConfidence, Region, Threshold, Threshold + (1.0 / NumColors))</l>
<l>    dev_set_color (WeightsColorsAlpha[ColorIndex])</l>
<l>    dev_display (Region)</l>
<l>endfor</l>
<l>return ()</l>
</body>
<docu id="dev_display_confidence_regions">
<abstract lang="en_US">This procedure displays a map of the confidences given in ImageConfidence.
Thereby, the confidence values within certain intervals are mapped to regions.

As a result, the procedure returns the colors it used to display the regions.
</abstract>
<chapters lang="de_DE">
<item>Graphik</item>
<item>Ausgabe</item>
</chapters>
<chapters lang="en_US">
<item>Graphics</item>
<item>Output</item>
</chapters>
<library lang="en_US">MVTec Standard Procedures</library>
<short lang="en_US">Display a map of the confidences.</short>
<parameters>
<parameter id="Colors">
<default_type>string</default_type>
<description lang="en_US">Defines the color values used as hexadecimal number within an RGBA quadruplet.</description>
<mixed_type>false</mixed_type>
<multivalue>optional</multivalue>
<sem_type>color</sem_type>
<type_list>
<item>string</item>
</type_list>
</parameter>
<parameter id="DrawTransparency">
<default_type>string</default_type>
<description lang="en_US">Defines the alpha value used as hexadecimal number within an RGBA quadruplet.</description>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>string</sem_type>
<type_list>
<item>string</item>
</type_list>
</parameter>
<parameter id="ImageConfidence">
<description lang="en_US">Image with the confidence values of the top predicted classes.</description>
<sem_type>image</sem_type>
</parameter>
</parameters>
</docu>
</procedure>
<procedure name="dev_display_data_code_2d_print_quality_results">
<interface>
<ic>
<par name="DataCodeHandle" base_type="ctrl" dimension="0"/>
<par name="ResultHandle" base_type="ctrl" dimension="0"/>
<par name="Mode" base_type="ctrl" dimension="0"/>
<par name="QualityStandard" base_type="ctrl" dimension="0"/>
<par name="Color" base_type="ctrl" dimension="0"/>
<par name="GenParamName" base_type="ctrl" dimension="0"/>
<par name="GenParamValue" base_type="ctrl" dimension="0"/>
</ic>
</interface>
<body>
<c>* This procedure displays the print quality results for data matrix ECC 200 codes.</c>
<c>* </c>
<c>* </c>
<c>* Available modes</c>
<l>MODE_RMMG := 'reflectance_margin_module_grades'</l>
<l>MODE_GRID := 'grid'</l>
<l>MODE_BAD := 'bad_modules'</l>
<l>SupportedModes := [MODE_RMMG,MODE_GRID,MODE_BAD]</l>
<c>* Available standards</c>
<l>SupportedQualityStandards := ['isoiec15415','isoiec_tr_29158','aimdpm_1_2006']</l>
<c>* Available generic parameters</c>
<l>GEN_CENTER := 'center'</l>
<l>GEN_CIRCLE := 'circle'</l>
<l>GEN_LEGEND := 'legend'</l>
<l>GEN_MAX_GRADE := 'max_grade'</l>
<c>* Defaults</c>
<l>DisplayCenter := false</l>
<l>DisplayCircle := true</l>
<l>DisplayLegend := true</l>
<l>MaxGrade := 3</l>
<c>* </c>
<c>* Check modes</c>
<l>if (|Mode| != 1)</l>
<l>    throw ('Please specify exactly one of following modes:' + sum(' ' + SupportedModes))</l>
<l>endif</l>
<l>if (find(SupportedModes,Mode) == -1)</l>
<l>    throw ('Unknown Mode: ' + Mode)</l>
<l>endif</l>
<c>* </c>
<c>* Check QualityStandard</c>
<l>if (find(SupportedQualityStandards,QualityStandard) == -1)</l>
<l>    throw ('Unknown QualityStandard: ' + QualityStandard)</l>
<l>else</l>
<l>    QualityStandard := 'quality_' + QualityStandard</l>
<l>endif</l>
<c>* </c>
<c>* Check generic parameters</c>
<c>* </c>
<c>* Override defaults in special modes</c>
<l>if (Mode == MODE_GRID)</l>
<l>    DisplayCenter := true</l>
<l>    DisplayCircle := false</l>
<l>    DisplayLegend := false</l>
<l>    MaxGrade := 4</l>
<l>    if (|Color| == 0)</l>
<l>        Color := 'gray'</l>
<l>    endif</l>
<l>elseif (Mode == MODE_BAD)</l>
<l>    DisplayCenter := false</l>
<l>    DisplayCircle := true</l>
<l>    DisplayLegend := false</l>
<l>    MaxGrade := 0</l>
<l>endif</l>
<c>* </c>
<l>if (|GenParamName| != |GenParamValue|)</l>
<c>    * Check if number of values matches number of parameters</c>
<l>    throw ('GenParamName and GenParamValue do not match.')</l>
<l>else</l>
<c>    * Set generic parameters</c>
<l>    for I := 0 to |GenParamName| - 1 by 1</l>
<c>        * 'center'</c>
<l>        if (GenParamName[I] == GEN_CENTER)</l>
<c>            * Check if values are valid</c>
<l>            if (GenParamValue[I] != 'true' and GenParamValue[I] != 'false')</l>
<l>                throw ('Wrong parameter value for generic parameter \'center\': ' + GenParamValue[I] + ' Please use \'true\' or \'false\'.')</l>
<l>            endif</l>
<c>            * Set new value</c>
<l>            DisplayCenter := GenParamValue[I] == 'true'</l>
<c>            * 'circle'</c>
<l>        elseif (GenParamName[I] == GEN_CIRCLE)</l>
<c>            * Check if values are valid</c>
<l>            if (GenParamValue[I] != 'true' and GenParamValue[I] != 'false')</l>
<l>                throw ('Wrong parameter value for generic parameter \'circle\': ' + GenParamValue[I] + ' Please use \'true\' or \'false\'.')</l>
<l>            endif</l>
<c>            * Set new value</c>
<l>            DisplayCircle := GenParamValue[I] == 'true'</l>
<l>        elseif (GenParamName[I] == GEN_LEGEND)</l>
<c>            * Check if values are valid</c>
<l>            if (GenParamValue[I] != 'true' and GenParamValue[I] != 'false')</l>
<l>                throw ('Wrong parameter value for generic parameter \'legend\': ' + GenParamValue[I] + ' Please use \'true\' or \'false\'.')</l>
<l>            endif</l>
<c>            * Set new value</c>
<l>            DisplayLegend := GenParamValue[I] == 'true'</l>
<l>        elseif (GenParamName[I] == GEN_MAX_GRADE)</l>
<c>            * Check if values are valid</c>
<l>            if (GenParamValue[I] &lt; 0 or GenParamValue[I] &gt; 4)</l>
<l>                throw ('Wrong parameter value for generic parameter \'max_grade\': ' + GenParamValue[I] + ' Please use a value between 0 and 4.')</l>
<l>            endif</l>
<c>            * Set new value</c>
<l>            MaxGrade := int(GenParamValue[I])</l>
<l>        else</l>
<c>            * Unknown parameter</c>
<l>            throw ('Unknown generic parameter: \'' + GenParamName[I])</l>
<l>        endif</l>
<l>    endfor</l>
<l>endif</l>
<c>* </c>
<c>* Check Color</c>
<l>if (|Color| == 0)</l>
<l>    Color := ['red','orange','yellow','cyan','green']</l>
<l>endif</l>
<c>* Build color tuple with rotating colors if too few colors are specified</c>
<l>while (|Color| &lt; MaxGrade + 1)</l>
<l>    Color := [Color,Color]</l>
<l>endwhile</l>
<c>* </c>
<c>* Visualization</c>
<c>* </c>
<c>* Get modulation grades, rows and cols for all symbol modules incl.</c>
<c>* the 4 quiet zones adjacent to the symbol and the finder patterns.</c>
<l>QualityParameter := QualityStandard + '_reflectance_margin_module_grades'</l>
<l>QualityRows := QualityStandard + '_rows'</l>
<l>QualityCols := QualityStandard + '_cols'</l>
<l>get_data_code_2d_results (DataCodeHandle, ResultHandle, QualityParameter, ModuleGrades)</l>
<l>get_data_code_2d_results (DataCodeHandle, ResultHandle, QualityRows, Rows)</l>
<l>get_data_code_2d_results (DataCodeHandle, ResultHandle, QualityCols, Cols)</l>
<l>QualityLabels := QualityStandard + '_labels'</l>
<l>get_data_code_2d_results (DataCodeHandle, ResultHandle, QualityStandard, Grades)</l>
<l>get_data_code_2d_results (DataCodeHandle, ResultHandle, QualityLabels, Labels)</l>
<l>get_data_code_2d_results (DataCodeHandle, ResultHandle, 'module_height', ModuleHeight)</l>
<l>get_data_code_2d_results (DataCodeHandle, ResultHandle, 'module_width', ModuleWidth)</l>
<l>Aperture := Grades[find(Labels,'Aperture')]</l>
<l>Radius := 0.5 * Aperture * min2(ModuleHeight,ModuleWidth)</l>
<c>* </c>
<c>* Iterate over all possible modulation grades to visualize</c>
<l>for Grade := 0 to MaxGrade by 1</l>
<l>    GradeIdx := find(ModuleGrades,Grade)</l>
<l>    if (GradeIdx &lt; 0)</l>
<l>        continue</l>
<l>    endif</l>
<l>    GradeRows := Rows[GradeIdx]</l>
<l>    GradeCols := Cols[GradeIdx]</l>
<l>    GradeRadius := gen_tuple_const(|GradeRows|,Radius)</l>
<l>    dev_set_color (Color[Grade])</l>
<l>    if (DisplayCircle)</l>
<l>        gen_circle_contour_xld (Circle, GradeRows, GradeCols, GradeRadius, rad(0), rad(360), 'positive', 1)</l>
<l>        dev_display (Circle)</l>
<l>    endif</l>
<l>    if (DisplayCenter)</l>
<l>        gen_cross_contour_xld (Cross, GradeRows, GradeCols, 2 * Radius, rad(0))</l>
<l>        dev_display (Cross)</l>
<l>    endif</l>
<l>endfor</l>
<l>if (DisplayLegend)</l>
<c>    * Display legend with modulation grades</c>
<l>    dev_disp_text (['Reflectance Margin','Module Grade ' + [0:MaxGrade]], 'window', 'bottom', 'left', ['white',Color], 'box_color', '#00000080')</l>
<l>endif</l>
<l>return ()</l>
</body>
<docu id="dev_display_data_code_2d_print_quality_results">
<abstract lang="en_US">This procedure can be used to display data code modules with print quality problems according to the data code standards ISO/IEC 15415 or AIM/DPM-1-2006.
The procedure calculates the reflectance margin module grades as described in ISO/IEC 15415 Chapter 7.8.4.3 (analogously for other standards), and displays the grades in different colors.
Unused modules are not displayed.

3 different modes are available that use different presets for the visualization:'reflectance_margin_module_grades' (default), 'bad_modules', 'grid'

'reflectance_margin_module_grades':
Display all modules with a grade less than 4 in different colors.
Used generic parameter settings: 'circle' = 'true', 'center' = 'false', 'legend' = 'true', 'max_grade' = 3.

'bad_modules':
Display only modules with a reflectance margin module grade of 0. These are modules that either are completely wrong (i.e., white instead of black and vice versa), or modules with a very bad modulation (i.e., with a gray value close to the calculated threshold between black and white modules).
Used generic parameter settings: 'circle' = 'true', 'center' = 'false', 'legend' = 'false', 'max_grade' = 0.

'grid':
Shows crosses at the positions where the module grades are calculated.
Used generic parameter settings: 'circle' = 'false', 'center' = 'true', 'legend' = 'false', 'max_grade' = 4.

The used standard can be specified in QualityStandard. Available values: 'isoiec15415', 'isoiec_tr_29158'.

The color palette used to display the module grades can be specified in Color. Color expects one color for each displayed grade. If less colors than grades are used, the colors are cycled through.


Available generic parameters:

'circle':
For every module, display a circle with a radius corresponding to the calculated aperture.
Possible values: 'true', 'false' 

'center':
For every module, display a cross at the position where the module grade is calculated.
Possible values: 'true', 'false'

'legend':
Display a legend that shows the used colors for each grade.
Possible values: 'true', 'false'

'max_grade':
Display only modules that have a grade less or equal to this value.
Possible values: 0,1,2,3,4
</abstract>
<chapters lang="de_DE">
<item>Identifizierung</item>
<item>Datacode</item>
</chapters>
<chapters lang="en_US">
<item>Identification</item>
<item>Data Code</item>
</chapters>
<example lang="en_US">create_data_code_2d_model ('Data Matrix ECC 200', [], [], DataCodeHandle)
set_data_code_2d_param (DataCodeHandle, 'default_parameters', 'enhanced_recognition')
read_image (Image, 'datacode/ecc200/ecc200_print_quality_02')
find_data_code_2d (Image, SymbolXLDs, DataCodeHandle, [], [], ResultHandle, DecodedDataStrings)
dev_display(Image)
Mode := 'reflectance_margin_module_grades'
dev_display_data_code_2d_print_quality_results (DataCodeHandle, ResultHandle, Mode, 'isoiec15415', [], [], [])    </example>
<library lang="de_DE">MVTec Standard Procedures</library>
<library lang="en_US">MVTec Standard Procedures</library>
<short lang="en_US">Display print quality information for individual data code modules.
</short>
<parameters>
<parameter id="Color">
<default_type>string</default_type>
<default_value>[]</default_value>
<description lang="en_US">Color(s) of the displayed modules.</description>
<mixed_type>false</mixed_type>
<multivalue>optional</multivalue>
<sem_type>color</sem_type>
<type_list>
<item>string</item>
</type_list>
<values>
<item>'red'</item>
<item>'green'</item>
<item>'blue'</item>
<item>'yellow'</item>
<item>['red','#cc0000','#990000','#660000']</item>
<item>'gray'</item>
</values>
</parameter>
<parameter id="DataCodeHandle">
<default_type>integer</default_type>
<description lang="en_US">Handle of the 2D data code model.</description>
<mixed_type>false</mixed_type>
<sem_type>datacode_2d</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="GenParamName">
<default_type>string</default_type>
<default_value>[]</default_value>
<description lang="en_US">Names of optional parameters to configure the output.</description>
<mixed_type>false</mixed_type>
<multivalue>optional</multivalue>
<sem_type>string</sem_type>
<type_list>
<item>string</item>
</type_list>
<value_list>
<item>'center'</item>
<item>'circle'</item>
<item>'legend'</item>
<item>'max_grade'</item>
</value_list>
</parameter>
<parameter id="GenParamValue">
<default_type>integer</default_type>
<default_value>[]</default_value>
<description lang="en_US">Values of the optional parameters.</description>
<multivalue>optional</multivalue>
<sem_type>any</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
<item>string</item>
</type_list>
<value_list>
<item>'true'</item>
<item>'false'</item>
<item>0</item>
<item>1</item>
<item>2</item>
<item>3</item>
<item>4</item>
</value_list>
</parameter>
<parameter id="Mode">
<default_type>string</default_type>
<default_value>'reflectance_margin_module_grades'</default_value>
<description lang="en_US">Display mode.</description>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>string</sem_type>
<type_list>
<item>string</item>
</type_list>
<value_list>
<item>'reflectance_margin_module_grades'</item>
<item>'bad_modules'</item>
<item>'grid'</item>
</value_list>
</parameter>
<parameter id="QualityStandard">
<default_type>string</default_type>
<default_value>'isoiec15415'</default_value>
<description lang="en_US">Quality standard used for calculation of the module grades.</description>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>string</sem_type>
<type_list>
<item>string</item>
</type_list>
<value_list>
<item>'isoiec15415'</item>
<item>'isoiec_tr_29158'</item>
<item>'aimdpm_1_2006'</item>
</value_list>
</parameter>
<parameter id="ResultHandle">
<default_type>integer</default_type>
<default_value>0</default_value>
<description lang="en_US">Handle of the 2D data code result handle.</description>
<mixed_type>false</mixed_type>
<sem_type>integer</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
</parameters>
</docu>
</procedure>
<procedure name="dev_display_detection_confusion_matrix" access="local">
<interface>
<ic>
<par name="WindowHandles" base_type="ctrl" dimension="0"/>
<par name="IoUEvaluationResult" base_type="ctrl" dimension="0"/>
<par name="ClassIDs" base_type="ctrl" dimension="0"/>
<par name="GenParam" base_type="ctrl" dimension="0"/>
</ic>
</interface>
<body>
<c>* </c>
<c>* This procedure displays the detection confusion matrix</c>
<c>* given in IoUEvaluationResult.</c>
<c>* Thereby, the matrix can be displayed with absolute or</c>
<c>* relative values.</c>
<c>* </c>
<c>* Set generic parameter default values.</c>
<l>DisplayAbsoluteMatrix := true</l>
<l>DisplayRelativeMatrix := false</l>
<l>DisplayColor := true</l>
<l>DisplayColumnWidth := 'equal'</l>
<c>* </c>
<c>* Parse generic parameters.</c>
<l>if (|GenParam| &gt; 0)</l>
<l>    GenParamKeys := ['display_color','display_relative_matrix','display_absolute_matrix','display_column_width']</l>
<l>    get_dict_param (GenParam, 'key_exists', GenParamKeys, KeyExists)</l>
<c>    * DisplayColor</c>
<l>    if (KeyExists[0])</l>
<l>        get_dict_tuple (GenParam, 'display_color', ValueTmp)</l>
<l>        if (|ValueTmp| != 1 or find([true,false],ValueTmp) == -1)</l>
<l>            throw ('Invalid value for \'display_color\'')</l>
<l>        else</l>
<l>            DisplayColor := ValueTmp</l>
<l>        endif</l>
<l>    endif</l>
<c>    * DisplayRelativeMatrix</c>
<l>    if (KeyExists[1])</l>
<l>        get_dict_tuple (GenParam, 'display_relative_matrix', ValueTmp)</l>
<l>        if (|ValueTmp| != 1 or find([true,false],ValueTmp) == -1)</l>
<l>            throw ('Invalid value for \'display_relative_matrix\'')</l>
<l>        else</l>
<l>            DisplayRelativeMatrix := ValueTmp</l>
<l>        endif</l>
<l>    endif</l>
<c>    * DisplayAbsoluteMatrix</c>
<l>    if (KeyExists[2])</l>
<l>        get_dict_tuple (GenParam, 'display_absolute_matrix', ValueTmp)</l>
<l>        if (|ValueTmp| != 1 or find([true,false],ValueTmp) == -1)</l>
<l>            throw ('Invalid value for \'display_absolute_matrix\'')</l>
<l>        else</l>
<l>            DisplayAbsoluteMatrix := ValueTmp</l>
<l>        endif</l>
<l>    endif</l>
<l>    if (KeyExists[3])</l>
<l>        get_dict_tuple (GenParam, 'display_column_width', DisplayColumnWidthTmp)</l>
<l>        if (|DisplayColumnWidthTmp| != 1 or find(['equal','minimal'],DisplayColumnWidthTmp) == -1)</l>
<l>            throw ('Invalid value for \'display_column_width\'')</l>
<l>        else</l>
<l>            DisplayColumnWidth := DisplayColumnWidthTmp</l>
<l>        endif</l>
<l>    endif</l>
<l>endif</l>
<c>* </c>
<l>if (not (DisplayRelativeMatrix or DisplayAbsoluteMatrix))</l>
<l>    throw ('At least one of \'display_absolute_matrix\' and \'display_relative_matrix\' should be true')</l>
<l>endif</l>
<l>if (DisplayRelativeMatrix + DisplayAbsoluteMatrix != |WindowHandles|)</l>
<l>    throw ('Wrong number of WindowHandles')</l>
<l>endif</l>
<l>if (DisplayRelativeMatrix or DisplayColor)</l>
<l>    CalculateRelativeMatrix := 1</l>
<l>else</l>
<l>    CalculateRelativeMatrix := 0</l>
<l>endif</l>
<c>* </c>
<c>* Calculate the confusion matrix with absolute values</c>
<c>* and the confusion matrix with relative errors.</c>
<c>* We start with an empty matrix</c>
<c>* and add the number of matching labels.</c>
<l>get_dict_tuple (IoUEvaluationResult, 'detection_confusion_matrix', ConfusionMatrix)</l>
<l>get_size_matrix (ConfusionMatrix, NumRows, NumColumns)</l>
<l>get_full_matrix (ConfusionMatrix, Values)</l>
<c>* </c>
<l>if (CalculateRelativeMatrix)</l>
<c>    * Calculate the relative matrix.</c>
<l>    copy_matrix (ConfusionMatrix, ConfusionMatrixRelative)</l>
<c>    * For each class:</c>
<l>    for C := 0 to |ClassIDs| - 1 by 1</l>
<c>        * Get the total number of predictions and calculate the relative values.</c>
<l>        get_value_matrix (ConfusionMatrix, gen_tuple_const(NumColumns,C), [0:NumColumns - 1], RowValues)</l>
<l>        if (sum(RowValues) &gt; 0)</l>
<l>            set_value_matrix (ConfusionMatrixRelative, gen_tuple_const(NumColumns,C), [0:NumColumns - 1], real(RowValues) / sum(RowValues))</l>
<l>        else</l>
<l>            set_value_matrix (ConfusionMatrixRelative, gen_tuple_const(NumColumns,C), [0:NumColumns - 1], real(RowValues))</l>
<l>        endif</l>
<c>        * Get the total number of ground truth and calculate relative false negatives.</c>
<l>        get_value_matrix (ConfusionMatrix, [C,|ClassIDs|], [C,C], NumTPAndFN)</l>
<l>        if (sum(NumTPAndFN) &gt; 0)</l>
<l>            set_value_matrix (ConfusionMatrixRelative, |ClassIDs|, C, real(NumTPAndFN[1]) / sum(NumTPAndFN))</l>
<l>        else</l>
<l>            set_value_matrix (ConfusionMatrixRelative, |ClassIDs|, C, real(NumTPAndFN[1]))</l>
<l>        endif</l>
<l>    endfor</l>
<l>endif</l>
<c>* </c>
<c>* Set color for displayed confusion matrix.</c>
<l>ValueColors := gen_tuple_const(|Values|,'#666666')</l>
<l>if (DisplayColor)</l>
<c>    * Display off-diagonal values in red.</c>
<l>    ValueColors := gen_tuple_const(|Values|,'#ff4500')</l>
<c>    * Display diagonal values in green.</c>
<l>    DiagonalColor := '#00ff00'</l>
<l>    tuple_gen_sequence (0, |ClassIDs| - 1, 1, Seq)</l>
<l>    DiagonalIndices := NumColumns * Seq + Seq</l>
<l>    ValueColors[DiagonalIndices] := DiagonalColor</l>
<l>endif</l>
<c>* </c>
<c>* Display the matrix.</c>
<c>* </c>
<c>* Collect column and row names.</c>
<l>ClassStrings := 'class_' + ClassIDs</l>
<l>FPStrings := ['FP bg','FP loc','FP dup','FP mult']</l>
<l>ColumnNames := [ClassStrings,FPStrings]</l>
<l>RowNames := [ClassStrings,'FN']</l>
<c>* </c>
<c>* Create GenParam for matrix display.</c>
<l>create_dict (GenParam)</l>
<l>set_dict_tuple (GenParam, 'display_column_width', DisplayColumnWidth)</l>
<l>set_dict_tuple (GenParam, 'display_color', DisplayColor)</l>
<c>* The last 4 values are meaningless and therefore not displayed.</c>
<l>set_dict_tuple (GenParam, 'idxs_no_display', [|Values| - 4:|Values| - 1])</l>
<l>set_dict_tuple (GenParam, 'axis_titles', ['Ground truth','Predicted'])</l>
<l>set_dict_tuple (GenParam, 'value_colors', ValueColors)</l>
<l>if (DisplayAbsoluteMatrix)</l>
<c>    * Display absolute matrix.</c>
<c>    * Calculate proper number format.</c>
<l>    max_matrix (ConfusionMatrix, 'full', MatrixMaxID)</l>
<l>    get_full_matrix (MatrixMaxID, MaxValue)</l>
<l>    if (MaxValue &gt; 0)</l>
<l>        NumberFormat := int(ceil(log10(MaxValue))) + '.0f'</l>
<l>    else</l>
<l>        NumberFormat := '1.0f'</l>
<l>    endif</l>
<l>    set_dict_tuple (GenParam, 'number_format', NumberFormat)</l>
<c>    * Set title.</c>
<l>    set_dict_tuple (GenParam, 'title', 'Detection confusion matrix, absolute')</l>
<l>    dev_display_matrix (ConfusionMatrix, ColumnNames, RowNames, WindowHandles[0], GenParam)</l>
<l>endif</l>
<l>if (DisplayRelativeMatrix)</l>
<c>    * Display relative matrix.</c>
<c>    * Convert relative matrix values to percent.</c>
<l>    get_full_matrix (ConfusionMatrixRelative, ValuesRelative)</l>
<l>    set_full_matrix (ConfusionMatrixRelative, 100 * ValuesRelative)</l>
<c>    * Set number format.</c>
<l>    NumberFormat := '2.1f'</l>
<l>    set_dict_tuple (GenParam, 'number_format', NumberFormat)</l>
<c>    * Set title.</c>
<l>    set_dict_tuple (GenParam, 'title', 'Detection confusion matrix, relative [%]')</l>
<l>    dev_display_matrix (ConfusionMatrixRelative, ColumnNames, RowNames, WindowHandles[DisplayAbsoluteMatrix], GenParam)</l>
<l>endif</l>
<c></c>
<l>return ()</l>
</body>
<docu id="dev_display_detection_confusion_matrix">
<abstract lang="en_US">This procedure displays the detection confusion matrices given in IoUEvaluationResult.
ClassIDs specifies the IDs of the classes distinguished by the model.
WindowHandles is a tuple containing the handles of the windows used for the display. 

The dictionary GenParam is used to determine, which matrix shall be displayed and in which style. Thereby, the following options are possible to set as entry:
- 'display_relative_matrix' (default: false): If set to true, a matrix is shown with relative values given as percentages. Note that for each class, the row sums up to one, thus 100 percent. That means, that we show the relative number of detections of this class in each field. For false negatives (FN), the relative number compared to the total number of ground truth objects of this class is shown.
- 'display_absolute_matrix' (default: true): If set to true, the matrix with absolute numbers of objects is shown.
- 'display_color' (default: true): If set to true, the displayed matrix values are colored in green and red. The diagonal values, i.e. the true positives are colored in green whereas the off-diagonal, i.e. false positives and false negatives, are colored in red. If set to false, all values are displayed in gray.
- 'display_column_width': This key can have the following associated values:
   -- 'equal' (default): All columns have the same width that equals the width of the longest row or column-name.
   -- 'minimal': The columns are just as wide as the column-name string plus a small offset.

The number of WindowHandles needed depends on the number of asked matrices: If both, 'display_absolute_matrix' and 'display_relative_matrix' are asked (thus, having a value 'true'), two window handles are needed. Thereby, the first is used for the absolute and the second for the relative matrix.
The windows in WindowHandles are not rearranged and might be overlapping when they are returned.

</abstract>
<chapters lang="de_DE">
<item>Deep Learning</item>
<item>Evaluierung</item>
</chapters>
<chapters lang="en_US">
<item>Deep Learning</item>
<item>Evaluation</item>
</chapters>
<library lang="en_US">MVTec Standard Procedures</library>
<short lang="en_US">Display the confusion matrix for the evaluation results of a model with type detection.</short>
<parameters>
<parameter id="ClassIDs">
<default_type>integer</default_type>
<default_value>ClassIDs</default_value>
<description lang="en_US">IDs of the classes the model distinguishes.</description>
<multivalue>optional</multivalue>
<sem_type>integer</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="GenParam">
<default_type>integer</default_type>
<default_value>[]</default_value>
<description lang="en_US">The dictionary is used to specify the matrix type and its visualization.</description>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>any</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="IoUEvaluationResult">
<default_type>integer</default_type>
<default_value>IoUEvaluationResult</default_value>
<description lang="en_US">Detailed detection evaluation results for one IoU-threshold containing per-class and overall detailed evaluation results.</description>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>dict</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="WindowHandles">
<default_type>integer</default_type>
<default_value>WindowHandles</default_value>
<description lang="en_US">Tuple of one or two window handles, where the matrices are displayed.
</description>
<mixed_type>false</mixed_type>
<multivalue>optional</multivalue>
<sem_type>handle</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
</parameters>
</docu>
</procedure>
<procedure name="dev_display_detection_detailed_evaluation">
<interface>
<ic>
<par name="EvaluationResult" base_type="ctrl" dimension="0"/>
<par name="EvalParam" base_type="ctrl" dimension="0"/>
<par name="GenParam" base_type="ctrl" dimension="0"/>
<par name="WindowHandleDict" base_type="ctrl" dimension="0"/>
</ic>
</interface>
<body>
<c>* </c>
<c>* This procedure visualizes the detailed evaluation results for a model of type detection.</c>
<c>* </c>
<c>* Set the default values.</c>
<l>DisplayPieChartsPrecision := true</l>
<l>DisplayPieChartsRecall := false</l>
<l>DisplayConfusionAbsolute := false</l>
<l>DisplayConfusionRelative := false</l>
<c>* </c>
<c>* Default settings for window placement.</c>
<l>BaseWindowRow := 0</l>
<l>BaseWindowColumn := 0</l>
<c>* </c>
<c>* Get some evaluation parameters.</c>
<l>get_dict_tuple (EvalParam, 'detailed_evaluation', DetailedEvaluation)</l>
<l>if (not DetailedEvaluation)</l>
<l>    throw ('detailed_evaluation has to be set to true for this visualization')</l>
<l>endif</l>
<l>get_dict_tuple (EvalParam, 'iou_threshold', AvailableIoUThresholds)</l>
<l>get_dict_tuple (EvalParam, 'max_num_detections', MaxNumDetections)</l>
<l>get_dict_tuple (EvalParam, 'area_ranges', AreaRanges)</l>
<l>get_dict_tuple (EvalParam, 'class_ids', ClassIDs)</l>
<c>* </c>
<c>* Use the first value under IoU threshold, MaxNumDetections and area-range.</c>
<l>IoUThreshold := AvailableIoUThresholds[0]</l>
<l>MaxNumDetections := MaxNumDetections[0]</l>
<l>get_dict_tuple (AreaRanges, 'name', AreaRangeName)</l>
<l>AreaRangeName := AreaRangeName[0]</l>
<c>* Get detailed evaluation results.</c>
<l>MaxNumDetStr := '' + MaxNumDetections</l>
<l>if (MaxNumDetections == -1)</l>
<l>    MaxNumDetStr := 'all'</l>
<l>endif</l>
<c>* </c>
<c>* Get the detailed evaluation results for the first IoU-threshold, although it might be changed below depending on generic parameters.</c>
<l>get_dict_tuple (EvaluationResult, 'max_num_detections_' + MaxNumDetStr, MaxNumEvaluationResult)</l>
<l>get_dict_tuple (MaxNumEvaluationResult, 'area_' + AreaRangeName, AreaEvaluationResult)</l>
<l>get_dict_tuple (AreaEvaluationResult, 'detailed_evaluation_iou_' + regexp_replace('' + IoUThreshold,'\\.',''), IoUEvaluationResult)</l>
<c>* </c>
<c>* Handle the generic parameters.</c>
<l>if (|GenParam| &gt; 0)</l>
<l>    GenParamKeys := ['display_mode','window_row','window_column','max_num_detections','area_range_name','iou_threshold']</l>
<l>    get_dict_param (GenParam, 'keys', [], Keys)</l>
<l>    for IndexKeys := 0 to |Keys| - 1 by 1</l>
<l>        if (find(GenParamKeys,Keys[IndexKeys]) == -1)</l>
<l>            throw ('Invalid GenParam key \'' + Keys[IndexKeys] + '\'')</l>
<l>        endif</l>
<l>    endfor</l>
<l>    get_dict_param (GenParam, 'key_exists', GenParamKeys, KeyExists)</l>
<c>    * Display mode.</c>
<l>    if (KeyExists[0])</l>
<l>        get_dict_tuple (GenParam, GenParamKeys[0], Value)</l>
<l>        if (|Value| == 0)</l>
<l>            throw ('GenParam key \'display_mode\' cannot be an empty tuple')</l>
<l>        else</l>
<c>            * Pie chart precision.</c>
<l>            DisplayPieChartsPrecision := find(Value,'pie_charts_precision')</l>
<l>            DisplayPieChartsPrecision := |DisplayPieChartsPrecision| &gt; 0 and DisplayPieChartsPrecision != -1</l>
<c>            * Pie chart recall.</c>
<l>            DisplayPieChartsRecall := find(Value,'pie_charts_recall')</l>
<l>            DisplayPieChartsRecall := |DisplayPieChartsRecall| &gt; 0 and DisplayPieChartsRecall != -1</l>
<c>            * Absolute confusion matrix.</c>
<l>            DisplayConfusionAbsolute := find(Value,'absolute_confusion_matrix')</l>
<l>            DisplayConfusionAbsolute := |DisplayConfusionAbsolute| &gt; 0 and DisplayConfusionAbsolute != -1</l>
<c>            * Relative confusion matrix.</c>
<l>            DisplayConfusionRelative := find(Value,'relative_confusion_matrix')</l>
<l>            DisplayConfusionRelative := |DisplayConfusionRelative| &gt; 0 and DisplayConfusionRelative != -1</l>
<l>            if (not (DisplayPieChartsPrecision or DisplayPieChartsRecall or DisplayConfusionAbsolute or DisplayConfusionRelative))</l>
<l>                throw ('\'display_mode\' not supported.')</l>
<l>            endif</l>
<l>        endif</l>
<l>    endif</l>
<c>    * BaseWindowRow.</c>
<l>    if (KeyExists[1])</l>
<l>        get_dict_tuple (GenParam, GenParamKeys[1], Value)</l>
<l>        if (|Value| == 1 and Value &gt;= 0)</l>
<l>            BaseWindowRow := Value</l>
<l>        else</l>
<l>            throw ('Invalid GenParam \'window_row\'.')</l>
<l>        endif</l>
<l>    endif</l>
<c>    * BaseWindowColumn.</c>
<l>    if (KeyExists[2])</l>
<l>        get_dict_tuple (GenParam, GenParamKeys[2], Value)</l>
<l>        if (|Value| == 1 and Value &gt;= 0)</l>
<l>            BaseWindowColumn := Value</l>
<l>        else</l>
<l>            throw ('Invalid GenParam \'window_column\'.')</l>
<l>        endif</l>
<l>    endif</l>
<c>    * MaxNumDetections.</c>
<l>    if (KeyExists[3])</l>
<l>        get_dict_tuple (GenParam, GenParamKeys[3], Value)</l>
<l>        MaxNumDetStr := '' + Value</l>
<l>        if (Value == -1)</l>
<l>            MaxNumDetStr := 'all'</l>
<l>        endif</l>
<l>        try</l>
<l>            get_dict_tuple (EvaluationResult, 'max_num_detections_' + MaxNumDetStr, MaxNumEvaluationResult)</l>
<l>        catch (Exception)</l>
<l>            throw ('Invalid GenParam \'max_num_detections\'')</l>
<l>        endtry</l>
<l>        MaxNumDetections := Value</l>
<l>    endif</l>
<c>    * AreaRange.</c>
<l>    if (KeyExists[4])</l>
<l>        get_dict_tuple (GenParam, GenParamKeys[4], Value)</l>
<l>        try</l>
<l>            get_dict_tuple (MaxNumEvaluationResult, 'area_' + Value, AreaEvaluationResult)</l>
<l>        catch (Exception)</l>
<l>            throw ('Invalid GenParam \'area_range_name\'')</l>
<l>        endtry</l>
<l>        AreaRangeName := Value</l>
<l>    endif</l>
<c>    * IoUThreshold.</c>
<l>    if (KeyExists[5])</l>
<l>        get_dict_tuple (GenParam, GenParamKeys[5], Value)</l>
<l>        try</l>
<l>            get_dict_tuple (AreaEvaluationResult, 'detailed_evaluation_iou_' + regexp_replace('' + Value,'\\.',''), IoUEvaluationResult)</l>
<l>        catch (Exception)</l>
<l>            throw ('Invalid GenParam \'iou_threshold\'')</l>
<l>        endtry</l>
<l>        IoUThreshold := Value</l>
<l>    endif</l>
<l>endif</l>
<c>* </c>
<c>* Check that the WindowHandleDict is of type dictionary.</c>
<l>try</l>
<l>    get_dict_param (WindowHandleDict, 'keys', [], Keys)</l>
<l>catch (Exception)</l>
<l>    if (Exception[0] == 1401)</l>
<l>        throw ('WindowHandleDict has to be of type dictionary. Use create_dict to create an empty dictionary.')</l>
<l>    else</l>
<l>        throw (Exception)</l>
<l>    endif</l>
<l>endtry</l>
<c>* </c>
<c>* Update the IoUEvaluationResult in case MaxNumDetections, AreaRange or IoUThreshold have changed.</c>
<l>get_dict_tuple (EvaluationResult, 'max_num_detections_' + MaxNumDetStr, MaxNumEvaluationResult)</l>
<l>get_dict_tuple (MaxNumEvaluationResult, 'area_' + AreaRangeName, AreaEvaluationResult)</l>
<l>get_dict_tuple (AreaEvaluationResult, 'detailed_evaluation_iou_' + regexp_replace('' + IoUThreshold,'\\.',''), IoUEvaluationResult)</l>
<l>set_dict_tuple (IoUEvaluationResult, 'iou_threshold', IoUThreshold)</l>
<c>* </c>
<c>* Generate pie-charts with false positives information.</c>
<l>if (DisplayPieChartsPrecision)</l>
<l>    get_dict_param (WindowHandleDict, 'key_exists', 'window_pie_chart_precision', WindowExists)</l>
<l>    if (not WindowExists)</l>
<l>        dev_open_window (BaseWindowRow, BaseWindowColumn, 512, 512, 'black', WindowHandlePieChartsPrecision)</l>
<l>        set_dict_tuple (WindowHandleDict, 'window_pie_chart_precision', WindowHandlePieChartsPrecision)</l>
<l>    else</l>
<l>        get_dict_tuple (WindowHandleDict, 'window_pie_chart_precision', WindowHandlePieChartsPrecision)</l>
<l>    endif</l>
<l>    dev_display_detection_evaluation_pie_charts (WindowHandlePieChartsPrecision, IoUEvaluationResult, ClassIDs, 'precision', BaseWindowRow, BaseWindowColumn)</l>
<l>endif</l>
<c>* </c>
<c>* Generate pie-charts with false negatives information.</c>
<l>if (DisplayPieChartsRecall)</l>
<l>    get_dict_param (WindowHandleDict, 'key_exists', 'window_pie_chart_recall', WindowExists)</l>
<l>    if (not WindowExists)</l>
<l>        dev_open_window (BaseWindowRow, BaseWindowColumn, 512, 512, 'black', WindowHandlePieChartsRecall)</l>
<l>        set_dict_tuple (WindowHandleDict, 'window_pie_chart_recall', WindowHandlePieChartsRecall)</l>
<l>    else</l>
<l>        get_dict_tuple (WindowHandleDict, 'window_pie_chart_recall', WindowHandlePieChartsRecall)</l>
<l>    endif</l>
<l>    dev_display_detection_evaluation_pie_charts (WindowHandlePieChartsRecall, IoUEvaluationResult, ClassIDs, 'recall', BaseWindowRow, BaseWindowColumn)</l>
<l>endif</l>
<c>* </c>
<c>* Visualize detection confusion matrix.</c>
<l>if (DisplayConfusionAbsolute or DisplayConfusionRelative)</l>
<l>    WindowHandlesConfusion := []</l>
<l>    create_dict (GenParam)</l>
<l>    set_dict_tuple (GenParam, 'display_relative_matrix', DisplayConfusionRelative)</l>
<l>    set_dict_tuple (GenParam, 'display_absolute_matrix', DisplayConfusionAbsolute)</l>
<l>    set_dict_tuple (GenParam, 'display_color', true)</l>
<l>    if (DisplayConfusionAbsolute)</l>
<l>        get_dict_param (WindowHandleDict, 'key_exists', 'window_absolute_confusion_matrix', WindowExists)</l>
<l>        if (not WindowExists)</l>
<l>            dev_open_window (BaseWindowRow, BaseWindowColumn, 512, 512, 'black', WindowHandleConfusionAbsolute)</l>
<l>            set_dict_tuple (WindowHandleDict, 'window_absolute_confusion_matrix', WindowHandleConfusionAbsolute)</l>
<l>        else</l>
<l>            get_dict_tuple (WindowHandleDict, 'window_absolute_confusion_matrix', WindowHandleConfusionAbsolute)</l>
<l>        endif</l>
<l>        WindowHandlesConfusion := [WindowHandlesConfusion,WindowHandleConfusionAbsolute]</l>
<l>    endif</l>
<l>    if (DisplayConfusionRelative)</l>
<l>        get_dict_param (WindowHandleDict, 'key_exists', 'window_relative_confusion_matrix', WindowExists)</l>
<l>        if (not WindowExists)</l>
<l>            dev_open_window (BaseWindowRow, BaseWindowColumn, 512, 512, 'black', WindowHandleConfusionRelative)</l>
<l>            set_dict_tuple (WindowHandleDict, 'window_relative_confusion_matrix', WindowHandleConfusionRelative)</l>
<l>        else</l>
<l>            get_dict_tuple (WindowHandleDict, 'window_relative_confusion_matrix', WindowHandleConfusionRelative)</l>
<l>        endif</l>
<l>        WindowHandlesConfusion := [WindowHandlesConfusion,WindowHandleConfusionRelative]</l>
<l>    endif</l>
<l>    dev_display_detection_confusion_matrix (WindowHandlesConfusion, IoUEvaluationResult, ClassIDs, GenParam)</l>
<l>    WindowHandleDict := [WindowHandleDict,WindowHandlesConfusion]</l>
<l>endif</l>
<c>* </c>
<c>* Rearrange windows.</c>
<c>* If all four windows are used we display the pie-charts to the left,</c>
<c>* while to the right the confusion matrices are shown below each other.</c>
<c>* Else, if the pie-charts are not displayed, we display the confusion matrices next to each other.</c>
<l>if (|WindowHandleDict| &gt;= 1)</l>
<l>    ColConfusion := [BaseWindowColumn,BaseWindowColumn]</l>
<l>    RowConfusion := [BaseWindowRow,BaseWindowRow]</l>
<l>    WidthConf := -1</l>
<l>    HeightConf := -1</l>
<l>    if (DisplayPieChartsPrecision or DisplayPieChartsRecall)</l>
<l>        if (DisplayPieChartsPrecision)</l>
<l>            get_window_extents (WindowHandlePieChartsPrecision, _, _, Width, Height)</l>
<l>            dev_set_window (WindowHandlePieChartsPrecision)</l>
<l>            dev_set_window_extents (BaseWindowRow, BaseWindowColumn, Width, Height)</l>
<l>        else</l>
<l>            get_window_extents (WindowHandlePieChartsRecall, _, _, Width, Height)</l>
<l>            if (not DisplayPieChartsPrecision)</l>
<l>                dev_set_window (WindowHandlePieChartsRecall)</l>
<l>                dev_set_window_extents (BaseWindowRow, BaseWindowColumn, Width, Height)</l>
<l>            endif</l>
<l>        endif</l>
<l>        ColConfusion := ColConfusion + Width + 8</l>
<l>        if (DisplayPieChartsPrecision and DisplayPieChartsRecall)</l>
<l>            dev_set_window (WindowHandlePieChartsRecall)</l>
<l>            dev_set_window_extents (BaseWindowRow + Height + 55, BaseWindowColumn, Width, Height)</l>
<l>        endif</l>
<l>    endif</l>
<l>    if (DisplayConfusionAbsolute)</l>
<l>        get_window_extents (WindowHandleConfusionAbsolute, Row, Column, WidthConf, HeightConf)</l>
<l>        dev_set_window (WindowHandleConfusionAbsolute)</l>
<l>        dev_set_window_extents (RowConfusion[0], ColConfusion[0], WidthConf, HeightConf)</l>
<l>        if (DisplayPieChartsPrecision or DisplayPieChartsRecall)</l>
<l>            RowConfusion[1] := RowConfusion[1] + HeightConf + 55</l>
<l>        else</l>
<l>            ColConfusion[1] := ColConfusion[1] + WidthConf + 8</l>
<l>        endif</l>
<l>    endif</l>
<l>    if (DisplayConfusionRelative)</l>
<l>        dev_set_window (WindowHandleConfusionRelative)</l>
<l>        dev_set_window_extents (RowConfusion[1], ColConfusion[1], WidthConf, HeightConf)</l>
<l>    endif</l>
<l>endif</l>
<c>* </c>
<l>return ()</l>
</body>
<docu id="dev_display_detection_detailed_evaluation">
<abstract lang="en_US">This procedure visualizes the results of a detailed evaluation for a model of type detection.
For this purpose, it displays the confusion matrix as well as the pie-charts for the false positives.

The optional dictionary GenParam can be used to configure the visualization. For this purpose, the following entries can be set:
- 'display_mode': You can set the following values to determine the display mode:
   -- 'pie_charts_precision' (default): Pie-charts with the ratios of different false positive error types for all classes and for each class individually are shown.
   -- 'pie_charts_recall': Pie-charts with the recall and false negative ratio for all classes and for each class individually are shown.
   -- 'absolute_confusion_matrix' and/or 'relative_confusion_matrix': The detection confusion matrices showing absolute and/or relative number of occurrences of true positives, false negatives and false positives due to class confusion, background detections, bad localization, duplicate detections or due to multiple reasons are displayed.
- 'iou_threshold': Set the IoU-threshold to be used for display (see evaluate_dl_model). Only a single value that is contained in the EvaluationResult can be used. The default value is the first IoU-threshold given under 'iou_threshold' in the dictionary EvalParam.
- 'max_num_detections': Set the maximum number of detections to be used for display (see evaluate_dl_model). Only a single value that is contained in the EvaluationResult can be used. The default value is the first maximal number of detections given under 'max_num_detections' in the dictionary EvalParam.
- 'area_range_name': Set the name of the area range of detections to be used for display (see evaluate_dl_model). Only a single value that is contained in the EvaluationResult can be used. The default value is the first area range name given under the key 'area_ranges' as value 'name' in the dictionary EvalParam.

For information on the evaluation parameters, see also the procedure evaluate_dl_model.</abstract>
<chapters lang="de_DE">
<item>Deep Learning</item>
<item>Evaluierung</item>
</chapters>
<chapters lang="en_US">
<item>Deep Learning</item>
<item>Evaluation</item>
</chapters>
<library lang="en_US">MVTec Standard Procedures</library>
<short lang="en_US">Visualize the results of a detailed evaluation for a model of type detection.</short>
<parameters>
<parameter id="EvalParam">
<default_type>integer</default_type>
<default_value>EvalParam</default_value>
<description lang="en_US">Dictionary with the evaluation parameters.</description>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>dict</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="EvaluationResult">
<default_type>integer</default_type>
<default_value>EvaluationResult</default_value>
<description lang="en_US">Dictionary with the detailed detection evaluation result.</description>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>dict</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="GenParam">
<default_type>integer</default_type>
<default_value>[]</default_value>
<description lang="en_US">Dictionary with the generic parameters used to configure the visualization.</description>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>any</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="WindowHandleDict">
<default_type>integer</default_type>
<description lang="en_US">Dictionary with the handles for the windows in which the matrices shall be displayed.</description>
<mixed_type>false</mixed_type>
<sem_type>dict</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
</parameters>
</docu>
</procedure>
<procedure name="dev_display_detection_eval_class_pie_chart" access="local">
<interface>
<ic>
<par name="WindowHandle" base_type="ctrl" dimension="0"/>
<par name="ClassEvaluationResult" base_type="ctrl" dimension="0"/>
<par name="CenterRow" base_type="ctrl" dimension="0"/>
<par name="Mode" base_type="ctrl" dimension="0"/>
<par name="CenterColumn" base_type="ctrl" dimension="0"/>
<par name="Radius" base_type="ctrl" dimension="0"/>
<par name="Colors" base_type="ctrl" dimension="0"/>
<par name="Title" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="Ratios" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c>* This procedure displays the evaluation results</c>
<c>* in the dictionary ClassEvaluationResult as a pie-chart.</c>
<c>* Thereby, the procedure plots one pie-chart</c>
<c>* for a specific class or all classes together.</c>
<c>* </c>
<c>* num_fp has to be handled separately.</c>
<l>if (Mode == 'precision')</l>
<l>    Keys := ['num_tp','num_fp_class','num_fp_background','num_fp_localization','num_fp_duplicate','num_fp_multiple']</l>
<l>else</l>
<l>    Keys := ['num_tp','num_fn']</l>
<l>endif</l>
<l>Numbers := gen_tuple_const(|Keys|,0)</l>
<l>for K := 0 to |Keys| - 1 by 1</l>
<l>    get_dict_tuple (ClassEvaluationResult, Keys[K], Num)</l>
<l>    Numbers[K] := Num</l>
<l>endfor</l>
<l>NumTotal := sum(Numbers)</l>
<l>ColorsPieChart := Colors</l>
<l>if (NumTotal == 0)</l>
<c>    * No predictions available, we print a full gray circle.</c>
<l>    Ratios := 1.0</l>
<l>    ColorsPieChart := 'gray'</l>
<l>else</l>
<l>    Ratios := real(Numbers) / NumTotal</l>
<l>endif</l>
<c>* </c>
<c>* Draw the pie-chart.</c>
<l>create_dict (GenParamPieChart)</l>
<l>if (Title != '')</l>
<l>    set_dict_tuple (GenParamPieChart, 'title', Title)</l>
<l>endif</l>
<l>dev_display_pie_chart (WindowHandle, Ratios, CenterRow, CenterColumn, Radius, ColorsPieChart, GenParamPieChart)</l>
<c>* </c>
<c>* Highlight total number of false positives.</c>
<l>if (NumTotal &gt; 0)</l>
<c>    * Add ratio of all false positives to output if there are any detections.</c>
<l>    get_dict_tuple (ClassEvaluationResult, 'num_fp', NumFP)</l>
<l>    Ratios := [Ratios,real(NumFP) / NumTotal]</l>
<l>endif</l>
<l>FullCircleAngle := 2 * 3.14159</l>
<l>gen_circle_contour_xld (ContCircle, CenterRow, CenterColumn, Radius + 2, Ratios[0] * FullCircleAngle, FullCircleAngle, 'positive', 1)</l>
<l>get_contour_xld (ContCircle, Row, Col)</l>
<l>gen_contour_polygon_xld (SectorFP, [CenterRow,Row,CenterRow], [CenterColumn,Col,CenterColumn])</l>
<c>* Rotate.</c>
<l>hom_mat2d_identity (HomMat2DIdentity)</l>
<l>hom_mat2d_rotate (HomMat2DIdentity, 0.25 * FullCircleAngle, CenterRow, CenterColumn, HomMat2DRotate)</l>
<l>affine_trans_contour_xld (SectorFP, SectorFP, HomMat2DRotate)</l>
<l>dev_set_window (WindowHandle)</l>
<l>dev_set_color (ColorsPieChart[|ColorsPieChart| - 1])</l>
<l>dev_set_line_width (3)</l>
<l>get_contour_style (WindowHandle, ContourStyle)</l>
<l>dev_set_contour_style ('stroke')</l>
<l>dev_display (SectorFP)</l>
<l>dev_set_contour_style (ContourStyle)</l>
<l>return ()</l>
</body>
<docu id="dev_display_detection_eval_class_pie_chart">
<abstract lang="en_US">This procedure displays the evaluation results in the dictionary ClassEvaluationResult as a pie-chart.
Thereby, the procedure plots one pie-chart for a specific class or all classes together.

WindowHandle determines in which window the pie-chart is displayed.
With Mode you can specify, which kind of pie-chart is displayed.
CenterRow and CenterColumn determine the center coordinates of the pie-chart, whose radius is determined over the input parameter Radius.
Colors is a tuple determining the colors of the sectors.

The string Title is optional and allows to set its content as a title over the pie-chart in white.

For the string Mode, the following options are available:
- 'precision': The charts give an overview of the ratio of true positives (TP) and of different categories of false positives (FP) relative to the total number of detections. Precision is defined as TP / (TP + FP)
- 'recall': The pie-charts show the ratio of true positives (TP) to all detected ground truth instances (TP + FN). Recall is defined as TP / (TP + FN).

The procedure returns the tuple Ratios, which contains for all following categories the corresponding ratio (in this order):
- 'num_tp': Relative number of true positives, i.e. the number of correctly detected ground truth annotations.
- 'num_fp_class': Relative number of detections with a wrong inferred class.
- 'num_fp_background': Relative number of detections within background regions, i.e., without overlap to any ground truth.
- 'num_fp_localization': Relative number of detections with a correct inferred class and overlapping with a ground truth annotation, but where the IoU is too low to be a true positive.
- 'num_fp_duplicate': Relative number of detections that are correct with respect to class and IoU, but where another correct detection with higher confidence to the ground truth annotation exists.
- 'num_fp_multiple': Relative number of detections with multiple reasons for being false positive, e.g. wrong class and low IoU.
- 'num_fp': Relative number of total false positives, i.e. the number of detections not matching to a ground truth annotation.</abstract>
<chapters lang="de_DE">
<item>Deep Learning</item>
<item>Evaluierung</item>
</chapters>
<chapters lang="en_US">
<item>Deep Learning</item>
<item>Evaluation</item>
</chapters>
<library lang="en_US">MVTec Standard Procedures</library>
<short lang="en_US">Display a pie-chart for the evaluation results of one class or all classes together.</short>
<parameters>
<parameter id="CenterColumn">
<default_type>real</default_type>
<default_value>CenterColumn</default_value>
<description lang="en_US">Center column coordinate of pie-chart.</description>
<multivalue>false</multivalue>
<sem_type>real</sem_type>
<type_list>
<item>real</item>
</type_list>
</parameter>
<parameter id="CenterRow">
<default_type>real</default_type>
<default_value>CenterRow</default_value>
<description lang="en_US">Center row coordinate of pie-chart.</description>
<multivalue>false</multivalue>
<sem_type>real</sem_type>
<type_list>
<item>real</item>
</type_list>
</parameter>
<parameter id="ClassEvaluationResult">
<default_type>integer</default_type>
<default_value>ClassEvaluationResult</default_value>
<description lang="en_US">Dictionary containing the evaluation results for one class or the overall results.</description>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>dict</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="Colors">
<default_type>string</default_type>
<default_value>Colors</default_value>
<description lang="en_US">Colors that are used for pie-chart sectors.</description>
<multivalue>true</multivalue>
<sem_type>string</sem_type>
<type_list>
<item>string</item>
</type_list>
</parameter>
<parameter id="Mode">
<description lang="en_US">Mode specifies which kind of pie-chart is displayed.</description>
<sem_type>string</sem_type>
</parameter>
<parameter id="Radius">
<default_type>real</default_type>
<default_value>Radius</default_value>
<description lang="en_US">Radius of the pie-chart.</description>
<multivalue>false</multivalue>
<sem_type>real</sem_type>
<type_list>
<item>real</item>
</type_list>
</parameter>
<parameter id="Ratios">
<default_type>real</default_type>
<description lang="en_US">Tuple containing the ratios of true positive and different false positive categories, namely 'num_tp', 'num_fp_class', 'num_fp_background', 'num_fp_localization', 'num_fp_duplicate', 'num_fp_multiple', 'num_fp' (in this order).</description>
<multivalue>true</multivalue>
<sem_type>real</sem_type>
<type_list>
<item>real</item>
</type_list>
</parameter>
<parameter id="Title">
<default_type>string</default_type>
<default_value>''</default_value>
<description lang="en_US">Optional title to be displayed above the pie-chart.</description>
<multivalue>false</multivalue>
<sem_type>string</sem_type>
<type_list>
<item>string</item>
</type_list>
</parameter>
<parameter id="WindowHandle">
<default_type>integer</default_type>
<default_value>WindowHandle</default_value>
<description lang="en_US">Window handle, where the pie-chart is displayed.</description>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>handle</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
</parameters>
</docu>
</procedure>
<procedure name="dev_display_detection_evaluation_pie_charts" access="local">
<interface>
<ic>
<par name="WindowHandle" base_type="ctrl" dimension="0"/>
<par name="IoUEvaluationResult" base_type="ctrl" dimension="0"/>
<par name="ClassIDs" base_type="ctrl" dimension="0"/>
<par name="Mode" base_type="ctrl" dimension="0"/>
<par name="BaseWindowRow" base_type="ctrl" dimension="0"/>
<par name="BaseWindowColumn" base_type="ctrl" dimension="0"/>
</ic>
</interface>
<body>
<c>* Display the detailed evaluation results for TP and FP as pie-charts.</c>
<c>* </c>
<c>* Switch off automatic flushing to make visualization smooth.</c>
<l>get_window_param (WindowHandle, 'flush', FlushValue)</l>
<l>set_window_param (WindowHandle, 'flush', 'false')</l>
<c>* Drawing parameters.</c>
<c>* Overall pie-chart.</c>
<l>CenterRowOverall := 150</l>
<l>CenterColOverall := 150</l>
<l>RadiusOverall := 100</l>
<c>* Per-class pie-chart.</c>
<l>ClassChartsPerRow := 10</l>
<l>RadiusClass := 40</l>
<l>ChartRowDistance := 3 * RadiusClass</l>
<l>ChartColDistance := 2.5 * RadiusClass</l>
<l>StartRow := CenterRowOverall + 1.5 * RadiusOverall + 1.5 * RadiusClass</l>
<l>StartCol := 1.5 * RadiusClass</l>
<c>* </c>
<c>* Open Window and set font.</c>
<l>WindowWidth := max2(600,(min2(|ClassIDs|,ClassChartsPerRow) - 1) * ChartColDistance + 2 * StartCol)</l>
<l>WindowHeight := 3 * RadiusOverall + ceil(real(|ClassIDs|) / ClassChartsPerRow) * 3 * RadiusClass</l>
<l>dev_set_window (WindowHandle)</l>
<l>dev_set_window_extents (BaseWindowRow, BaseWindowColumn, WindowWidth, WindowHeight)</l>
<l>gen_image_const (Image, 'byte', WindowWidth, WindowHeight)</l>
<l>dev_display (Image)</l>
<l>dev_clear_window ()</l>
<l>set_display_font (WindowHandle, 15, 'mono', 'true', 'false')</l>
<c>* </c>
<c>* Generate different red colors for false positive categories.</c>
<l>if (Mode == 'precision')</l>
<l>    NumColors := 7</l>
<l>else</l>
<l>    NumColors := 2</l>
<l>endif</l>
<l>Colors := gen_tuple_const(NumColors,'')</l>
<l>Colors[0] := 'green'</l>
<l>Colors[NumColors - 1] := 'red'</l>
<l>get_distinct_colors (NumColors - 1, false, 10, 45, ColorsFP)</l>
<l>Colors[1:NumColors - 2] := ColorsFP[1:|ColorsFP| - 1]</l>
<c>* </c>
<l>dev_display_detection_eval_class_pie_chart (WindowHandle, IoUEvaluationResult, CenterRowOverall, Mode, CenterColOverall, RadiusOverall, Colors, 'All classes', Ratios)</l>
<c>* </c>
<c>* Write descriptions for overall pie-chart.</c>
<l>if (|Ratios| &gt; 1)</l>
<l>    if (Mode == 'precision')</l>
<l>        Descriptions := ['true positives','false positives: wrong class','false positives: background','false positives: bad localization','false positives: duplicate','false positives: multiple reasons','false positives: total']</l>
<l>    else</l>
<l>        Descriptions := ['recall (TP / (TP + FN))','false negatives']</l>
<l>    endif</l>
<l>    get_dict_tuple (IoUEvaluationResult, 'iou_threshold', IoUThreshold)</l>
<l>    dev_disp_text ('Results @ IoU: ' + IoUThreshold, 'image', 20, CenterColOverall + RadiusOverall + 20, 'white', 'box', 'false')</l>
<l>    PercentStr := (Ratios * 100)$'.1f' + ''</l>
<l>    for IndexDescription := 0 to |Descriptions| - 2 by 1</l>
<l>        dev_disp_text (PercentStr[IndexDescription] + '%: ' + Descriptions[IndexDescription], 'image', 30 + (IndexDescription + 1) * 20, CenterColOverall + RadiusOverall + 20, Colors[IndexDescription], 'box', 'false')</l>
<l>    endfor</l>
<l>    dev_disp_text (PercentStr[IndexDescription] + '%: ' + Descriptions[IndexDescription], 'image', 30 + (IndexDescription + 1) * 20, CenterColOverall + RadiusOverall + 20, Colors[IndexDescription], 'box', 'false')</l>
<l>else</l>
<l>    dev_disp_text ('There are no predictions', 'image', 30, CenterColOverall + RadiusOverall + 20, 'white', 'box', 'false')</l>
<l>endif</l>
<c>* </c>
<c>* </c>
<c>* Per-class pie-charts.</c>
<c>* </c>
<l>for C := 0 to |ClassIDs| - 1 by 1</l>
<c>    * Get the position of the class-pie-chart.</c>
<l>    CenterRow := StartRow + floor(real(C) / ClassChartsPerRow) * ChartRowDistance</l>
<l>    CenterCol := StartCol + (C % ClassChartsPerRow) * ChartColDistance</l>
<l>    get_dict_tuple (IoUEvaluationResult, 'class_' + ClassIDs[C], ClassEvaluationResult)</l>
<l>    dev_display_detection_eval_class_pie_chart (WindowHandle, ClassEvaluationResult, CenterRow, Mode, CenterCol, RadiusClass, Colors, 'Class ' + ClassIDs[C], Ratios)</l>
<l>endfor</l>
<c>* </c>
<c>* Flush buffer and reset value for 'flush'.</c>
<l>flush_buffer (WindowHandle)</l>
<l>set_window_param (WindowHandle, 'flush', FlushValue)</l>
<c>* </c>
<l>return ()</l>
</body>
<docu id="dev_display_detection_evaluation_pie_charts">
<abstract lang="en_US">This procedure displays the evaluation results in IoUEvaluationResult as pie-charts.
Thereby, the procedure plots one pie-chart for all classes together as well as one for each individual class.
With Mode you can specify, which kind of pie-chart is displayed.

For the string Mode, the following options are available:
- 'precision': The charts give an overview of the ratio of true positives (TP) and of different categories of false positives (FP) relative to the total number of detections. Precision is defined as TP / (TP + FP)
- 'recall': The pie-charts show the ratio of true positives (TP) to all detected ground truth instances (TP + FN). Recall is defined as TP / (TP + FN). 

Note, the dictionary IoUEvaluationResult needs to contain overall as well as per-class detailed evaluation results.</abstract>
<chapters lang="de_DE">
<item>Deep Learning</item>
<item>Evaluierung</item>
</chapters>
<chapters lang="en_US">
<item>Deep Learning</item>
<item>Evaluation</item>
</chapters>
<library lang="en_US">MVTec Standard Procedures</library>
<short lang="en_US">Display the evaluation results as pie-charts.</short>
<parameters>
<parameter id="BaseWindowColumn">
<description lang="en_US">Column index of upper left corner, where the window is opened.</description>
<sem_type>integer</sem_type>
</parameter>
<parameter id="BaseWindowRow">
<description lang="en_US">Row index of upper left corner, where the window is opened.</description>
<sem_type>integer</sem_type>
</parameter>
<parameter id="ClassIDs">
<default_type>integer</default_type>
<default_value>ClassIDs</default_value>
<description lang="en_US">IDs of all classes the model can predict.</description>
<multivalue>optional</multivalue>
<sem_type>integer</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="IoUEvaluationResult">
<default_type>integer</default_type>
<default_value>IoUEvaluationResult</default_value>
<description lang="en_US">Dictionary containing the detailed evaluation results for one IoU threshold using a model of type detection.</description>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>dict</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="Mode">
<default_type>string</default_type>
<default_value>'precision'</default_value>
<description lang="en_US">Mode specifies which kind of pie-chart is displayed.</description>
<multivalue>false</multivalue>
<sem_type>string</sem_type>
<type_list>
<item>string</item>
</type_list>
<values>
<item>'precision'</item>
<item>'recall'</item>
</values>
</parameter>
<parameter id="WindowHandle">
<default_type>integer</default_type>
<default_value>WindowHandle</default_value>
<description lang="en_US">Window handle, where the pie-charts are displayed.</description>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>handle</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
</parameters>
</docu>
</procedure>
<procedure name="dev_display_dl_classifier_heatmap">
<interface>
<io>
<par name="Image" base_type="iconic" dimension="0"/>
</io>
<ic>
<par name="DLClassifierHandle" base_type="ctrl" dimension="0"/>
<par name="GenParamName" base_type="ctrl" dimension="0"/>
<par name="GenParamValue" base_type="ctrl" dimension="0"/>
<par name="WindowHandle" base_type="ctrl" dimension="0"/>
</ic>
</interface>
<body>
<c>* This procedure generates a heatmap for an Image which is classified</c>
<c>* with the deep learning classifier DLClassifierHandle and displays</c>
<c>* it in the WindowHandle. The procedure can be adjusted with generic</c>
<c>* parameters using GenParamName and GenParamValue.</c>
<c>* </c>
<c>* Please note that the heatmap is intended for visual inspection.</c>
<c>* Therefore, the resulting regions and confidence values are not</c>
<c>* returned. If you require the heatmap regions or confidence values,</c>
<c>* e.g. for your own visualization, these are the parameters to return:</c>
<c>* - HeatmapRegions (Regions in which confidence is decreased when occluded)</c>
<c>* - HeatmapRegionsNegative (Regions in which confidence is increased</c>
<c>*   when occluded)</c>
<c>* - OriginalConfidence (Confidence of original class assignment)</c>
<c>* - MaxDeviation (Maximum absolute deviation from OriginalConfidence in heatmap)</c>
<c>* </c>
<c>* Set default parameters.</c>
<l>FeatureSize := 30</l>
<l>SamplingSize := 7</l>
<l>DisplayConfidence := true</l>
<c>* </c>
<c>* Parse the input parameters.</c>
<l>for GenParamIndex := 0 to |GenParamName| - 1 by 1</l>
<l>    if (GenParamName[GenParamIndex] == 'feature_size')</l>
<c>        * Set 'feature_size'.</c>
<l>        FeatureSize := GenParamValue[GenParamIndex]</l>
<l>    elseif (GenParamName[GenParamIndex] == 'sampling_size')</l>
<c>        * Set 'sampling_size'.</c>
<l>        SamplingSize := GenParamValue[GenParamIndex]</l>
<l>    elseif (GenParamName[GenParamIndex] == 'display_confidence')</l>
<c>        * Set 'display_confidence'.</c>
<l>        DisplayConfidence := GenParamValue[GenParamIndex]</l>
<l>    else</l>
<l>        throw ('Unknown generic parameter: \'' + GenParamName[GenParamIndex] + '\'')</l>
<l>    endif</l>
<l>endfor</l>
<c>* </c>
<c>* Check the input parameters.</c>
<l>count_obj (Image, Number)</l>
<l>if (Number &gt; 1)</l>
<l>    throw ('Please use only a single image as input.')</l>
<l>endif</l>
<l>if (SamplingSize &lt; 0)</l>
<l>    throw ('The "sampling_size" (' + SamplingSize + ') must be greater than zero.')</l>
<l>endif</l>
<l>if (FeatureSize &lt; 0)</l>
<l>    throw ('The "feature_size" (' + FeatureSize + ') must be greater than zero.')</l>
<l>endif</l>
<l>if (SamplingSize &gt;= FeatureSize)</l>
<l>    throw ('The "sampling_size" (' + SamplingSize + ') must be smaller than the "feature_size" (' + FeatureSize + ')')</l>
<l>endif</l>
<l>get_dl_classifier_param (DLClassifierHandle, 'image_num_channels', NumInputChannels)</l>
<l>count_channels (Image, NumImageChannels)</l>
<l>if (NumImageChannels != NumInputChannels)</l>
<l>    throw ('The number of image channels (' + NumImageChannels + ') does not match ' + 'the number of input channels expected by the classifier (' + NumInputChannels + ')')</l>
<l>endif</l>
<c>* </c>
<c>* Get the predicted class and its confidence</c>
<c>* when classifying the original (unoccluded) image.</c>
<l>apply_dl_classifier (Image, DLClassifierHandle, DLClassifierResultHandle)</l>
<l>get_dl_classifier_result (DLClassifierResultHandle, 'all', 'confidences', OriginalConfidence)</l>
<l>get_dl_classifier_result (DLClassifierResultHandle, 'all', 'predicted_classes', OriginalPredictedClass)</l>
<l>clear_dl_classifier_result (DLClassifierResultHandle)</l>
<c>* </c>
<l>get_system ('clip_region', ClipRegionSettingBefore)</l>
<l>set_system ('clip_region', 'false')</l>
<c>* </c>
<c>* Partition the image into rectangular regions. The height and width of the</c>
<c>* rectangles are approximately equal to sampling_size.</c>
<l>partition_rectangle (Image, Partition, SamplingSize, SamplingSize)</l>
<l>height_width_ratio (Partition, HeightRegion, WidthRegion, RatioRegion)</l>
<c>* </c>
<c>* Generate a set of regions to be occluded based on the center coordinates</c>
<c>* and the dimensions of these rectangles. Depending on the values of</c>
<c>* feature_size and sampling_size, these regions may overlap.</c>
<l>SamplingSizeUsed := median([HeightRegion,WidthRegion])</l>
<l>get_image_size (Image, Width, Height)</l>
<l>gen_grid_region (RegionGrid, SamplingSizeUsed, SamplingSizeUsed, 'points', Width + 1, Height + 1)</l>
<l>get_region_points (RegionGrid, CenterRows, CenterColumns)</l>
<l>NumRegions := |CenterRows|</l>
<l>gen_circle (OccludedRegions, CenterRows, CenterColumns, gen_tuple_const(NumRegions,FeatureSize / 2))</l>
<c>* </c>
<c>* Generate and classify the occluded images.</c>
<l>Confidences := []</l>
<l>if (NumInputChannels == 1)</l>
<l>    intensity (OccludedRegions, Image, MeanGray, DeviationGray)</l>
<l>else</l>
<l>    decompose3 (Image, ImageR, ImageG, ImageB)</l>
<l>    intensity (OccludedRegions, ImageR, MeanRed, DeviationRed)</l>
<l>    intensity (OccludedRegions, ImageG, MeanGreen, DeviationGreen)</l>
<l>    intensity (OccludedRegions, ImageB, MeanBlue, DeviationBlue)</l>
<l>endif</l>
<l>get_dl_classifier_param (DLClassifierHandle, 'batch_size', BatchSize)</l>
<l>for BatchIndex := 0 to int(NumRegions / BatchSize) by 1</l>
<l>    gen_empty_obj (ImagesOccluded)</l>
<l>    tuple_gen_sequence (BatchIndex * BatchSize + 1, min([(BatchIndex + 1) * BatchSize,NumRegions]), 1, BatchIndices)</l>
<l>    for Index := 0 to |BatchIndices| - 1 by 1</l>
<l>        select_obj (OccludedRegions, OccludedRegion, BatchIndices[Index])</l>
<l>        if (NumInputChannels == 1)</l>
<l>            Mean := MeanGray[BatchIndices[Index] - 1]</l>
<l>        else</l>
<l>            Mean := [MeanRed[BatchIndices[Index] - 1],MeanGreen[BatchIndices[Index] - 1],MeanBlue[BatchIndices[Index] - 1]]</l>
<l>        endif</l>
<l>        paint_region (OccludedRegion, Image, ImageOccluded, Mean, 'fill')</l>
<l>        concat_obj (ImagesOccluded, ImageOccluded, ImagesOccluded)</l>
<l>    endfor</l>
<c>    * </c>
<c>    * For each occluded image, get the confidence</c>
<c>    * for the predicted class of the original image.</c>
<l>    count_obj (ImagesOccluded, NumImagesOccluded)</l>
<l>    if (NumImagesOccluded &gt; 0)</l>
<l>        apply_dl_classifier (ImagesOccluded, DLClassifierHandle, DLClassifierResultHandle)</l>
<l>        for IndexOccluded := 0 to NumImagesOccluded - 1 by 1</l>
<l>            get_dl_classifier_result (DLClassifierResultHandle, IndexOccluded, 'predicted_classes', PredictedClass)</l>
<l>            get_dl_classifier_result (DLClassifierResultHandle, IndexOccluded, 'confidences', Confidence)</l>
<l>            Confidences := [Confidences,Confidence[find(PredictedClass,OriginalPredictedClass)]]</l>
<l>        endfor</l>
<l>        clear_dl_classifier_result (DLClassifierResultHandle)</l>
<l>    endif</l>
<l>endfor</l>
<c>* </c>
<c>* Since it is too expensive to compute the confidence value</c>
<c>* for each individual pixel, we work with a subsampling of the image.</c>
<c>* The distance between two sampling points is controlled</c>
<c>* by the parameter 'sampling_size'. For each sampling point,</c>
<c>* we average over the confidence values of all images</c>
<c>* which were occluded with a regions to which this point belongs.</c>
<l>area_center (Partition, Area, AveragingCenterRows, AveragingCenterColumns)</l>
<l>tuple_gen_const (|AveragingCenterRows|, 0, PartitionConfidences)</l>
<l>for PartIndex := 0 to |AveragingCenterRows| - 1 by 1</l>
<l>    get_region_index (OccludedRegions, int(AveragingCenterRows[PartIndex]), int(AveragingCenterColumns[PartIndex]), ConfidenceIndices)</l>
<l>    PartitionConfidences[PartIndex] := mean(Confidences[ConfidenceIndices - 1])</l>
<l>endfor</l>
<c>* </c>
<c>* Compute the deviation from the original confidence value and its maximum absolute value.</c>
<l>ConfidenceDeviations := OriginalConfidence - PartitionConfidences</l>
<l>MaxDeviation := max(abs(ConfidenceDeviations))</l>
<c>* </c>
<c>* The heatmap is categorized into 'bins'. The regions where the deviation</c>
<c>* is highest are in the first bin, the regions where the deviation</c>
<c>* is lowest are in the last bin. This is done separately for deviations with</c>
<c>* positive and negative sign.</c>
<l>NumBins := 10</l>
<l>Step := 1 / real(NumBins)</l>
<l>End := 1 - (NumBins - 1) * Step</l>
<l>gen_empty_obj (HeatmapRegions)</l>
<l>for Factor := 1 to End by -Step</l>
<l>    Lesser := ConfidenceDeviations [&lt;=] MaxDeviation * Factor</l>
<l>    Greater := ConfidenceDeviations [&gt;] MaxDeviation * (Factor - Step)</l>
<l>    IndicesInBin := find(Lesser + Greater,2)</l>
<l>    if (IndicesInBin != -1)</l>
<l>        select_obj (Partition, PartsSelected, IndicesInBin + 1)</l>
<l>        union1 (PartsSelected, HeatmapRegion)</l>
<l>    else</l>
<l>        gen_empty_region (HeatmapRegion)</l>
<l>    endif</l>
<l>    concat_obj (HeatmapRegions, HeatmapRegion, HeatmapRegions)</l>
<l>endfor</l>
<l>gen_empty_obj (HeatmapRegionsNegative)</l>
<l>for Factor := 1 to End by -Step</l>
<l>    Lesser := ConfidenceDeviations [&lt;] -MaxDeviation * (Factor - Step)</l>
<l>    Greater := ConfidenceDeviations [&gt;=] -MaxDeviation * Factor</l>
<l>    IndicesInBin := find(Lesser + Greater,2)</l>
<l>    if (IndicesInBin != -1)</l>
<l>        select_obj (Partition, PartsSelected, IndicesInBin + 1)</l>
<l>        union1 (PartsSelected, HeatmapRegionNegative)</l>
<l>    else</l>
<l>        gen_empty_region (HeatmapRegionNegative)</l>
<l>    endif</l>
<l>    concat_obj (HeatmapRegionsNegative, HeatmapRegionNegative, HeatmapRegionsNegative)</l>
<l>endfor</l>
<c>* </c>
<c>* Visualize the heatmap.</c>
<l>dev_set_window (WindowHandle)</l>
<l>dev_clear_window ()</l>
<l>get_image_size (Image, WidthImage, HeightImage)</l>
<l>dev_set_part (0, 0, HeightImage - 1, WidthImage - 1)</l>
<l>dev_display (Image)</l>
<c>* For regions for which the confidence decreased, generate a color palette</c>
<c>* from red to yellow with 66% transparency</c>
<l>Colors := ['#ff3300','#ff6600','#ff9900','#ffcc00','#ffff00'] + '66'</l>
<l>for BinIndex := 1 to 5 by 1</l>
<l>    select_obj (HeatmapRegions, BinRegion, BinIndex)</l>
<l>    dev_set_color (Colors[BinIndex - 1])</l>
<l>    dev_display (BinRegion)</l>
<l>endfor</l>
<c>* For regions for which the confidence increased, generate a color palette</c>
<c>* from blue to cyan with 66% transparency</c>
<l>Colors := ['#0033ff','#0066ff','#0099ff','#00ccff','#00ffff'] + '66'</l>
<l>for BinIndex := 1 to 5 by 1</l>
<l>    select_obj (HeatmapRegionsNegative, BinRegion, BinIndex)</l>
<l>    dev_set_color (Colors[BinIndex - 1])</l>
<l>    dev_display (BinRegion)</l>
<l>endfor</l>
<c>* </c>
<l>if (DisplayConfidence)</l>
<l>    Text := []</l>
<l>    Text[|Text|] := 'Predicted Class: ' + OriginalPredictedClass</l>
<l>    Text[|Text|] := 'Original Confidence: ' + OriginalConfidence$'.3f'</l>
<l>    Text[|Text|] := 'Maximum Deviation:   ' + MaxDeviation$'.3f'</l>
<l>    dev_disp_text (Text, 'window', 'top', 'right', ['black','black'], [], [])</l>
<l>endif</l>
<c>* </c>
<l>set_system ('clip_region', ClipRegionSettingBefore)</l>
<l>return ()</l>
</body>
<docu id="dev_display_dl_classifier_heatmap">
<abstract lang="en_US">This procedure generates a heatmap for an Image, which is classified with the deep learning classifier DLClassifierHandle. It is visualized in the given WindowHandle. It also displays the original confidence value and the maximum deviation thereof. The procedure can be adjusted with generic parameters using GenParamName and GenParamValue. Note that the Image needs to be preprocessed for the computation of the heatmap using the same preprocessing procedure as used during training.

The heatmap is designed to indicate parts of the image, which are important for the decision of the classifier. To compute the heatmap, numerous new images are created by partially occluding (overpainting) a certain region of the original image. Each modified image is classified and the resulting confidence value is compared to the original one. If the displayed maximum value of these deviations is very small, the heatmap might not provide any significanct information. 

Regions for which the resulting confidence value is lower than the original one are visualized by colors ranging from red to yellow. Red represents a region where the deviation is high, orange represents a medium deviation, yellow a minor one. Regions for which the resulting confidence value is higher the original one are visualized by colors ranging from blue to cyan in a similar manner. If no color is displayed, the confidence values are (almost) not affected by the occlusions.

The heatmap should be used as a tool for visualizing and better understanding classification results. It is not intended as a segmentation tool. 

The following generic parameters are available:

* 'display_confidence':  controls whether the confidence of the original classification result and the deviation thereof are displayed by this procedure ('true') or not ('false'). The default is 'true'.

* 'feature_size': should be set to the expected size (diameter) in pixels of the feature/defect that you want to detect. Note the the result is very sensitive with respect to this parameter. The default is '30'.

* 'sampling_size': represents the approximate distance in pixels between two sampling points at which the heatmap is evaluated. The sampling size given by the user might be adjusted slightly in order to obtain an equidistant sampling over the whole image. The sampling_size must be smaller than the feature_size. The default is '7'.</abstract>
<chapters lang="en_US">
<item>Legacy</item>
<item>DL Classification</item>
</chapters>
<library lang="en_US">MVTec Standard Procedures</library>
<short lang="en_US">Visualize and return the heatmap of a deep learning classification.</short>
<warning lang="en_US">dev_display_dl_classifier_heatmap is obsolete and is only provided for reasons of backward compatibility.</warning>
<parameters>
<parameter id="DLClassifierHandle">
<default_type>integer</default_type>
<description lang="en_US">The deep-learning-based classifier.</description>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>dl_classifier</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="GenParamName">
<default_type>string</default_type>
<default_value>[]</default_value>
<description lang="en_US">Name of the generic parameter.</description>
<mixed_type>optional</mixed_type>
<multivalue>optional</multivalue>
<sem_type>attribute.name</sem_type>
<type_list>
<item>string</item>
</type_list>
<values>
<item>'feature_size'</item>
<item>'sampling_size'</item>
<item>'display_confidence'</item>
</values>
</parameter>
<parameter id="GenParamValue">
<default_type>integer</default_type>
<description lang="en_US">Value of the generic parameter.</description>
<mixed_type>optional</mixed_type>
<multivalue>optional</multivalue>
<sem_type>attribute.value</sem_type>
<type_list>
<item>integer</item>
<item>string</item>
</type_list>
<values>
<item>5</item>
<item>10</item>
<item>15</item>
<item>20</item>
<item>30</item>
<item>50</item>
<item>75</item>
<item>100</item>
<item>'true'</item>
<item>'false'</item>
</values>
</parameter>
<parameter id="Image">
<description lang="en_US">The image for which the heatmap is computed.</description>
<multichannel>true</multichannel>
<multivalue>false</multivalue>
<sem_type>image</sem_type>
<type_list>
<item>real</item>
</type_list>
</parameter>
<parameter id="WindowHandle">
<default_type>integer</default_type>
<description lang="en_US">Handle of the window in which the heatmap is displayed.</description>
<mixed_type>false</mixed_type>
<sem_type>window</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
</parameters>
</docu>
</procedure>
<procedure name="dev_display_dl_data">
<interface>
<ic>
<par name="DLSample" base_type="ctrl" dimension="0"/>
<par name="DLResult" base_type="ctrl" dimension="0"/>
<par name="DLDatasetInfo" base_type="ctrl" dimension="0"/>
<par name="KeysForDisplay" base_type="ctrl" dimension="0"/>
<par name="GenParam" base_type="ctrl" dimension="0"/>
<par name="WindowHandleDict" base_type="ctrl" dimension="0"/>
</ic>
</interface>
<body>
<c>* </c>
<c>* This procedure displays the content of the provided DLSample and/or DLResult</c>
<c>* depending on the input string KeysForDisplay.</c>
<c>* DLDatasetInfo is a dictionary containing the information about the dataset.</c>
<c>* The visualization can be adapted with GenParam.</c>
<c>* </c>
<c>* ** Set the default values: ***</c>
<c>* </c>
<c>* Define the screen width when a new window row is started.</c>
<l>ThresholdWidth := 1024</l>
<c>* Since potentially a lot of windows are opened,</c>
<c>* scale the windows consistently.</c>
<l>ScaleWindows := 0.8</l>
<c>* Set a font and a font size.</c>
<l>Font := 'mono'</l>
<l>FontSize := 14</l>
<c>* </c>
<l>LineWidth := 2</l>
<l>MapTransparency := 'cc'</l>
<l>MapColorBarWidth := 140</l>
<c>* </c>
<c>* Define anomaly detection-specific parameter values.</c>
<l>AnomalyRegionThreshold := -1</l>
<l>AnomalyClassificationThreshold := -1</l>
<l>AnomalyRegionLabelColor := '#40e0d0'</l>
<l>AnomalyColorTransparency := '40'</l>
<l>AnomalyRegionResultColor := '#ff0000c0'</l>
<c>* </c>
<c>* Define segmentation-specific parameter values.</c>
<l>SegMaxWeight := 0</l>
<l>SegDraw := 'fill'</l>
<l>SegTransparency := 'aa'</l>
<l>SegExcludeClassIDs := []</l>
<c>* </c>
<c>* Define bounding box-specific parameter values.</c>
<l>BboxLabelColor := '#000000' + '99'</l>
<l>BboxDisplayConfidence := 1</l>
<l>BboxTextColor := '#eeeeee'</l>
<c>* </c>
<c>* By default, display a description on the bottom.</c>
<l>ShowBottomDesc := true</l>
<c>* </c>
<c>* By default, show a legend with class IDs.</c>
<l>ShowLegend := true</l>
<c>* </c>
<c>* By default, show the anomaly ground truth regions.</c>
<l>ShowGroundTruthAnomalyRegions := true</l>
<c>* </c>
<c>* By default, show class IDs and color frames for classification ground truth/results.</c>
<l>ShowClassificationIDs := true</l>
<l>ShowClassificationColorFrame := true</l>
<c>* </c>
<c>* By default, show class labels for detection ground truth/results.</c>
<l>ShowLabels := true</l>
<c>* </c>
<c>* By default, show direction of the ground truth/results instances for detection with instance_type 'rectangle2'.</c>
<l>ShowDirection := true</l>
<c>* </c>
<c>* By default, use color scheme 'Jet' for the heatmap display.</c>
<l>HeatmapColorScheme := 'jet'</l>
<c>* ** Set user defined values: ***</c>
<c>* </c>
<c>* Overwrite default values by given generic parameters.</c>
<l>if (GenParam != [])</l>
<l>    get_dict_param (GenParam, 'keys', [], GenParamNames)</l>
<l>    for ParamIndex := 0 to |GenParamNames| - 1 by 1</l>
<l>        GenParamName := GenParamNames[ParamIndex]</l>
<l>        get_dict_tuple (GenParam, GenParamName, GenParamValue)</l>
<l>        if (GenParamName == 'threshold_width')</l>
<l>            ThresholdWidth := GenParamValue</l>
<l>        elseif (GenParamName == 'scale_windows')</l>
<l>            ScaleWindows := GenParamValue</l>
<l>        elseif (GenParamName == 'font')</l>
<l>            Font := GenParamValue</l>
<l>        elseif (GenParamName == 'font_size')</l>
<l>            FontSize := GenParamValue</l>
<l>        elseif (GenParamName == 'line_width')</l>
<l>            LineWidth := GenParamValue</l>
<l>        elseif (GenParamName == 'map_transparency')</l>
<l>            MapTransparency := GenParamValue</l>
<l>        elseif (GenParamName == 'map_color_bar_width')</l>
<l>            MapColorBarWidth := GenParamValue</l>
<l>        elseif (GenParamName == 'segmentation_max_weight')</l>
<l>            SegMaxWeight := GenParamValue</l>
<l>        elseif (GenParamName == 'segmentation_draw')</l>
<l>            SegDraw := GenParamValue</l>
<l>        elseif (GenParamName == 'segmentation_transparency')</l>
<l>            SegTransparency := GenParamValue</l>
<l>        elseif (GenParamName == 'segmentation_exclude_class_ids')</l>
<l>            SegExcludeClassIDs := GenParamValue</l>
<l>        elseif (GenParamName == 'bbox_label_color')</l>
<l>            BboxLabelColor := GenParamValue</l>
<l>        elseif (GenParamName == 'bbox_display_confidence')</l>
<l>            BboxDisplayConfidence := GenParamValue</l>
<l>        elseif (GenParamName == 'bbox_text_color')</l>
<l>            BboxTextColor := GenParamValue</l>
<l>        elseif (GenParamName == 'display_bottom_desc')</l>
<l>            ShowBottomDesc := GenParamValue</l>
<l>        elseif (GenParamName == 'display_legend')</l>
<l>            ShowLegend := GenParamValue</l>
<l>        elseif (GenParamName == 'display_classification_ids')</l>
<l>            ShowClassificationIDs := GenParamValue</l>
<l>        elseif (GenParamName == 'display_classification_color_frame')</l>
<l>            ShowClassificationColorFrame := GenParamValue</l>
<l>        elseif (GenParamName == 'display_labels')</l>
<l>            ShowLabels := GenParamValue</l>
<l>        elseif (GenParamName == 'display_direction')</l>
<l>            ShowDirection := GenParamValue</l>
<l>        elseif (GenParamName == 'heatmap_color_scheme')</l>
<l>            HeatmapColorScheme := GenParamValue</l>
<l>        elseif (GenParamName == 'display_ground_truth_anomaly_regions')</l>
<l>            ShowGroundTruthAnomalyRegions := GenParamValue</l>
<l>        elseif (GenParamName == 'anomaly_region_threshold')</l>
<l>            AnomalyRegionThreshold := GenParamValue</l>
<l>        elseif (GenParamName == 'anomaly_classification_threshold')</l>
<l>            AnomalyClassificationThreshold := GenParamValue</l>
<l>        elseif (GenParamName == 'anomaly_region_label_color')</l>
<l>            AnomalyRegionLabelColor := GenParamValue</l>
<l>        elseif (GenParamName == 'anomaly_region_result_color')</l>
<l>            AnomalyRegionResultColor := GenParamValue</l>
<l>        elseif (GenParamName == 'anomaly_color_transparency')</l>
<l>            AnomalyColorTransparency := GenParamValue</l>
<l>        else</l>
<l>            throw ('Unknown generic parameter: ' + GenParamName + '.')</l>
<l>        endif</l>
<l>    endfor</l>
<l>endif</l>
<c>* </c>
<c>* Get the dictionary keys.</c>
<l>get_dict_param (DLSample, 'keys', [], SampleKeys)</l>
<l>if (DLResult != [])</l>
<l>    get_dict_param (DLResult, 'keys', [], ResultKeys)</l>
<l>endif</l>
<c>* </c>
<c>* Get image ID if it is available.</c>
<l>get_dict_param (DLSample, 'key_exists', 'image_id', ImageIDExists)</l>
<l>if (ImageIDExists)</l>
<l>    get_dict_tuple (DLSample, 'image_id', ImageID)</l>
<l>    ImageIDString := 'image ID ' + ImageID</l>
<l>    ImageIDStringBraces := '(image ID ' + ImageID + ')'</l>
<l>    ImageIDStringCapital := 'Image ID ' + ImageID</l>
<l>else</l>
<l>    ImageIDString := ''</l>
<l>    ImageIDStringBraces := ImageIDString</l>
<l>    ImageIDStringCapital := ImageIDString</l>
<l>endif</l>
<c>* </c>
<c>* Check if DLDatasetInfo is valid.</c>
<l>if (DLDatasetInfo == [])</l>
<c>    * If DLDatasetInfo is empty, 'image' is the only key allowed in KeysForDisplay.</c>
<l>    if (|KeysForDisplay| != 1 or KeysForDisplay[0] != 'image')</l>
<l>        throw ('DLDatasetInfo is needed for requested keys in KeysForDisplay.')</l>
<l>    endif</l>
<l>else</l>
<c>    * Check if DLDatasetInfo contains necessary keys.</c>
<l>    NeededKeys := ['class_names','class_ids']</l>
<l>    for Index := 0 to |NeededKeys| - 1 by 1</l>
<l>        get_dict_param (DLDatasetInfo, 'keys', [], DLDatasetInfoKeys)</l>
<l>        if (find_first(DLDatasetInfoKeys,NeededKeys[Index]) == -1)</l>
<l>            throw ('Key ' + NeededKeys[Index] + ' is missing in DLDatasetInfo.')</l>
<l>        endif</l>
<l>    endfor</l>
<c>    * </c>
<c>    * Get the general dataset information, if available.</c>
<l>    get_dict_tuple (DLDatasetInfo, 'class_names', ClassNames)</l>
<l>    get_dict_tuple (DLDatasetInfo, 'class_ids', ClassIDs)</l>
<c>    * </c>
<c>    * Define distinct colors for the classes.</c>
<l>    get_dl_class_colors (ClassNames, Colors)</l>
<c>    * </c>
<l>    ClassesLegend := ClassIDs + ' : ' + ClassNames</l>
<l>endif</l>
<c>* </c>
<c>* ** Set window parameters: ***</c>
<c>* </c>
<c>* Set previous window coordinates.</c>
<l>PrevWindowCoordinates := [0,0,0,0,1]</l>
<c>* </c>
<c>* Check that the WindowHandleDict is of type dictionary.</c>
<l>try</l>
<l>    get_dict_param (WindowHandleDict, 'keys', [], Keys)</l>
<l>catch (Exception)</l>
<l>    if (Exception[0] == 1401)</l>
<l>        throw ('WindowHandleDict has to be of type dictionary. Use create_dict to create an empty dictionary.')</l>
<l>    else</l>
<l>        throw (Exception)</l>
<l>    endif</l>
<l>endtry</l>
<c>* For better usage, add meta information about the window handles in WindowHandleDict.</c>
<l>tuple_find (Keys, 'meta_information', MetaInfoIndex)</l>
<l>if (MetaInfoIndex == -1 or MetaInfoIndex == [])</l>
<l>    create_dict (MetaInfo)</l>
<l>    set_dict_tuple (WindowHandleDict, 'meta_information', MetaInfo)</l>
<l>endif</l>
<c>* </c>
<c>* For each window, set 'flush' to 'false' to avoid flickering.</c>
<l>FlushValues := []</l>
<l>get_dict_param (WindowHandleDict, 'keys', [], WindowHandleKeys)</l>
<l>for Index := 0 to |WindowHandleKeys| - 1 by 1</l>
<c>    * Only consider the WindowHandleKeys that are needed for the current visualization.</c>
<l>    KeyIndex := find(KeysForDisplay,WindowHandleKeys[Index])</l>
<l>    if (KeyIndex != -1 and KeyIndex != [])</l>
<l>        get_dict_tuple (WindowHandleDict, WindowHandleKeys[Index], WindowHandles)</l>
<l>        for WindowIndex := 0 to |WindowHandles| - 1 by 1</l>
<l>            get_window_param (WindowHandles[WindowIndex], 'flush', FlushValue)</l>
<l>            FlushValues := [FlushValues,FlushValue]</l>
<l>            set_window_param (WindowHandles[WindowIndex], 'flush', 'false')</l>
<l>        endfor</l>
<l>    endif</l>
<l>endfor</l>
<c>* </c>
<c>* ** Display the data: ***</c>
<c>* </c>
<c>* Display data dictionaries.</c>
<l>for KeyIndex := 0 to |KeysForDisplay| - 1 by 1</l>
<l>    if (KeysForDisplay[KeyIndex] == 'image')</l>
<c>        * </c>
<c>        * Image.</c>
<l>        get_image (Image, SampleKeys, DLSample)</l>
<c>        * </c>
<c>        * Get or open next window.</c>
<l>        get_image_size (Image, WidthImage, HeightImage)</l>
<l>        get_next_window (Font, FontSize, ShowBottomDesc, WidthImage, HeightImage, 0, ScaleWindows, ThresholdWidth, PrevWindowCoordinates, WindowHandleDict, KeysForDisplay[KeyIndex], CurrentWindowHandle, WindowImageRatio, PrevWindowCoordinates)</l>
<c>        * </c>
<l>        dev_display (Image)</l>
<l>        if (ShowBottomDesc)</l>
<l>            dev_disp_text (ImageIDStringCapital, 'window', 'bottom', 'left', 'white', 'box', 'false')</l>
<l>        endif</l>
<l>    elseif (KeysForDisplay[KeyIndex] == 'anomaly_ground_truth')</l>
<c>        * Image.</c>
<l>        get_image (Image, SampleKeys, DLSample)</l>
<l>        get_anomaly_ground_truth_label (SampleKeys, DLSample, AnomalyLabelGroundTruth, AnomalyLabelIDGroundTruth)</l>
<c>        * </c>
<c>        * Get or open next window.</c>
<l>        get_image_size (Image, WidthImage, HeightImage)</l>
<l>        get_next_window (Font, FontSize, ShowBottomDesc, WidthImage, HeightImage, 0, ScaleWindows, ThresholdWidth, PrevWindowCoordinates, WindowHandleDict, KeysForDisplay[KeyIndex], CurrentWindowHandle, WindowImageRatio, PrevWindowCoordinates)</l>
<c>        * </c>
<c>        * Visualize image.</c>
<l>        dev_display (Image)</l>
<c>        * </c>
<l>        AnomalyRegionExists := 'false'</l>
<l>        if (ShowGroundTruthAnomalyRegions)</l>
<c>            * Show the ground truth region.</c>
<l>            dev_display_ground_truth_anomaly_regions (SampleKeys, DLSample, CurrentWindowHandle, LineWidth, AnomalyRegionLabelColor, AnomalyColorTransparency, AnomalyRegionExists)</l>
<l>        endif</l>
<c>        * </c>
<l>        Text := 'Ground truth anomalies ' + ImageIDStringBraces</l>
<l>        if (ShowBottomDesc)</l>
<l>            dev_disp_text (Text, 'window', 'bottom', 'left', 'white', 'box', 'false')</l>
<l>        endif</l>
<c>        * </c>
<c>        * Display the legend.</c>
<l>        if (ShowLegend)</l>
<l>            Text[|Text|] := ''</l>
<l>            Text[|Text|] := AnomalyLabelIDGroundTruth + ' : \'' + AnomalyLabelGroundTruth + '\''</l>
<l>            if (AnomalyRegionExists == 'false' and AnomalyLabelIDGroundTruth == 1 and ShowGroundTruthAnomalyRegions)</l>
<l>                Text[|Text|] := ''</l>
<l>                Text[|Text|] := 'No \'anomaly_ground_truth\' exists!'</l>
<l>            endif</l>
<c>            * </c>
<c>            * Get or open next child window</c>
<l>            get_child_window (HeightImage, Font, FontSize, Text, PrevWindowCoordinates, WindowHandleDict, KeysForDisplay[KeyIndex], WindowImageRatio, PrevWindowCoordinates)</l>
<l>            dev_disp_text (Text, 'window', 'top', 'left', 'white', 'box', 'false')</l>
<l>        endif</l>
<l>    elseif (KeysForDisplay[KeyIndex] == 'anomaly_result')</l>
<c>        * </c>
<c>        * Get image.</c>
<l>        get_image (Image, SampleKeys, DLSample)</l>
<c>        * </c>
<c>        * Get the anomaly image out of DLResult.</c>
<l>        get_anomaly_result (AnomalyImage, ResultKeys, DLResult, AnomalyScore, AnomalyClassID)</l>
<c>        * </c>
<c>        * Get or open next window.</c>
<l>        get_image_size (Image, WidthImage, HeightImage)</l>
<l>        get_next_window (Font, FontSize, ShowBottomDesc, WidthImage, HeightImage, 0, ScaleWindows, ThresholdWidth, PrevWindowCoordinates, WindowHandleDict, KeysForDisplay[KeyIndex], CurrentWindowHandle, WindowImageRatio, PrevWindowCoordinates)</l>
<c>        * </c>
<c>        * Visualize image.</c>
<l>        dev_display (Image)</l>
<c>        * </c>
<c>        * Display predicted anomaly regions.</c>
<l>        if (AnomalyRegionThreshold != -1)</l>
<l>            dev_display_result_anomaly_regions (AnomalyImage, AnomalyRegion, CurrentWindowHandle, AnomalyRegionThreshold, LineWidth, AnomalyRegionResultColor)</l>
<l>        endif</l>
<c>        * </c>
<l>        Text := 'Detected anomalies ' + ImageIDStringBraces</l>
<l>        if (ShowBottomDesc)</l>
<l>            dev_disp_text (Text, 'window', 'bottom', 'left', 'white', 'box', 'false')</l>
<l>        endif</l>
<c>        * </c>
<c>        * Display the legend.</c>
<l>        if (ShowLegend)</l>
<l>            Text[|Text|] := ''</l>
<l>            Text[|Text|] := '---------------'</l>
<l>            Text[|Text|] := 'Results '</l>
<l>            Text[|Text|] := '---------------'</l>
<l>            if (AnomalyClassID == 1)</l>
<l>                Text[|Text|] := AnomalyClassID + ' : \'nok\''</l>
<l>            else</l>
<l>                Text[|Text|] := AnomalyClassID + ' : \'ok\''</l>
<l>            endif</l>
<l>            Text[|Text|] := ''</l>
<l>            Text[|Text|] := 'Anomaly score: ' + AnomalyScore$'.2f'</l>
<l>            Text[|Text|] := ''</l>
<l>            if (AnomalyClassificationThreshold != -1 or AnomalyRegionThreshold != -1)</l>
<l>                Text[|Text|] := ''</l>
<l>                Text[|Text|] := '---------------'</l>
<l>                Text[|Text|] := 'Thresholds '</l>
<l>                Text[|Text|] := '---------------'</l>
<l>            endif</l>
<c>            * </c>
<l>            if (AnomalyClassificationThreshold != -1)</l>
<l>                Text[|Text|] := 'Classification: ' + AnomalyClassificationThreshold$'.2f'</l>
<l>                Text[|Text|] := ''</l>
<l>            endif</l>
<l>            if (AnomalyRegionThreshold != -1)</l>
<l>                Text[|Text|] := 'Segmentation: ' + AnomalyRegionThreshold$'.2f'</l>
<l>                Text[|Text|] := ''</l>
<l>            endif</l>
<c>            * </c>
<c>            * Get or open next child window</c>
<l>            get_child_window (HeightImage, Font, FontSize, Text, PrevWindowCoordinates, WindowHandleDict, KeysForDisplay[KeyIndex], WindowImageRatio, PrevWindowCoordinates)</l>
<l>            dev_disp_text (Text, 'window', 'top', 'left', 'white', 'box', 'false')</l>
<l>        endif</l>
<l>    elseif (KeysForDisplay[KeyIndex] == 'anomaly_both')</l>
<c>        * </c>
<c>        * Get image, ground truth and results.</c>
<l>        get_image (Image, SampleKeys, DLSample)</l>
<l>        get_anomaly_ground_truth_label (SampleKeys, DLSample, AnomalyLabelGroundTruth, AnomalyLabelIDGroundTruth)</l>
<l>        get_anomaly_result (AnomalyImage, ResultKeys, DLResult, AnomalyScore, AnomalyClassID)</l>
<c>        * </c>
<c>        * Get or open next window.</c>
<l>        get_image_size (Image, WidthImage, HeightImage)</l>
<l>        get_next_window (Font, FontSize, ShowBottomDesc, WidthImage, HeightImage, 0, ScaleWindows, ThresholdWidth, PrevWindowCoordinates, WindowHandleDict, KeysForDisplay[KeyIndex], CurrentWindowHandle, WindowImageRatio, PrevWindowCoordinates)</l>
<c>        * </c>
<c>        * Visualize image, ground truth (if available), and result regions.</c>
<l>        dev_display (Image)</l>
<l>        AnomalyRegionGroundTruthExists := 'false'</l>
<l>        if (ShowGroundTruthAnomalyRegions)</l>
<l>            dev_display_ground_truth_anomaly_regions (SampleKeys, DLSample, CurrentWindowHandle, LineWidth, AnomalyRegionLabelColor, AnomalyColorTransparency, AnomalyRegionGroundTruthExists)</l>
<l>        endif</l>
<c>        * </c>
<c>        * Display result anomaly regions.</c>
<l>        dev_display_result_anomaly_regions (AnomalyImage, AnomalyRegion, CurrentWindowHandle, AnomalyRegionThreshold, LineWidth, AnomalyRegionResultColor)</l>
<c>        * </c>
<l>        Text := 'GT and detected anomalies ' + ImageIDStringBraces</l>
<l>        if (ShowBottomDesc)</l>
<l>            dev_disp_text (Text, 'window', 'bottom', 'left', 'white', 'box', 'false')</l>
<l>        endif</l>
<c>        * </c>
<c>        * Get prediction color.</c>
<l>        PredictionColor := 'white'</l>
<l>        if (AnomalyLabelIDGroundTruth == AnomalyClassID)</l>
<l>            PredictionColor := 'green'</l>
<l>        else</l>
<l>            PredictionColor := 'red'</l>
<l>        endif</l>
<c>        * </c>
<c>        * Display the legend.</c>
<l>        if (ShowLegend)</l>
<l>            Text[|Text|] := ''</l>
<l>            Text[|Text|] := '---------------'</l>
<l>            Text[|Text|] := 'Ground truth '</l>
<l>            Text[|Text|] := '---------------'</l>
<l>            Text[|Text|] := AnomalyLabelIDGroundTruth + ' : \'' + AnomalyLabelGroundTruth + '\''</l>
<l>            if (AnomalyRegionGroundTruthExists == 'false' and AnomalyLabelIDGroundTruth == 1 and ShowGroundTruthAnomalyRegions)</l>
<l>                Text[|Text|] := ''</l>
<l>                Text[|Text|] := ' No \'anomaly_ground_truth\' exists!'</l>
<l>            endif</l>
<l>            Text[|Text|] := ''</l>
<l>            Text[|Text|] := '---------------'</l>
<l>            Text[|Text|] := 'Results '</l>
<l>            Text[|Text|] := '---------------'</l>
<l>            if (AnomalyClassID == 1)</l>
<l>                Text[|Text|] := AnomalyClassID + ' : \'nok\''</l>
<l>            else</l>
<l>                Text[|Text|] := AnomalyClassID + ' : \'ok\''</l>
<l>            endif</l>
<l>            Text[|Text|] := ''</l>
<l>            Text[|Text|] := 'Anomaly score: ' + AnomalyScore$'.2f'</l>
<l>            Text[|Text|] := ''</l>
<l>            if (AnomalyClassificationThreshold != -1 or AnomalyRegionThreshold != -1)</l>
<l>                Text[|Text|] := ''</l>
<l>                Text[|Text|] := '---------------'</l>
<l>                Text[|Text|] := 'Thresholds '</l>
<l>                Text[|Text|] := '---------------'</l>
<l>            endif</l>
<c>            * </c>
<l>            if (AnomalyClassificationThreshold != -1)</l>
<l>                Text[|Text|] := 'Classification: ' + AnomalyClassificationThreshold$'.2f'</l>
<l>                Text[|Text|] := ''</l>
<l>            endif</l>
<l>            if (AnomalyRegionThreshold != -1)</l>
<l>                Text[|Text|] := 'Segmentation: ' + AnomalyRegionThreshold$'.2f'</l>
<l>                Text[|Text|] := ''</l>
<l>            endif</l>
<c>            * Get or open next child window</c>
<l>            get_child_window (HeightImage, Font, FontSize, Text, PrevWindowCoordinates, WindowHandleDict, KeysForDisplay[KeyIndex], WindowImageRatio, PrevWindowCoordinates)</l>
<l>            tuple_gen_const (|Text|, 'white', LineColors)</l>
<l>            LineColors[|LineColors| - 8] := PredictionColor</l>
<l>            dev_disp_text (Text, 'window', 'top', 'left', LineColors, 'box', 'false')</l>
<l>        endif</l>
<l>    elseif (KeysForDisplay[KeyIndex] == 'anomaly_image')</l>
<c>        * </c>
<c>        * Image.</c>
<l>        get_image (Image, SampleKeys, DLSample)</l>
<c>        * </c>
<l>        get_anomaly_result (AnomalyImage, ResultKeys, DLResult, AnomalyScore, AnomalyClassID)</l>
<c>        * </c>
<c>        * Read in input image.</c>
<l>        get_dict_object (Image, DLSample, 'image')</l>
<c>        * Add the anomaly image to the input image.</c>
<l>        add_colormap_to_image (AnomalyImage, Image, AnomalyImage, HeatmapColorScheme)</l>
<c>        * </c>
<c>        * Get or open next window.</c>
<l>        get_image_size (Image, WidthImage, HeightImage)</l>
<l>        get_next_window (Font, FontSize, ShowBottomDesc, WidthImage, HeightImage, 0, ScaleWindows, ThresholdWidth, PrevWindowCoordinates, WindowHandleDict, KeysForDisplay[KeyIndex], CurrentWindowHandle, WindowImageRatio, PrevWindowCoordinates)</l>
<c>        * </c>
<l>        dev_display (AnomalyImage)</l>
<l>        Text := 'Anomaly image ' + ImageIDStringBraces</l>
<l>        if (ShowBottomDesc)</l>
<l>            dev_disp_text (Text, 'window', 'bottom', 'left', 'white', 'box', 'false')</l>
<l>        endif</l>
<c>        * Display the legend.</c>
<l>        if (ShowLegend)</l>
<l>            Text[|Text|] := ''</l>
<l>            if (AnomalyClassID == 1)</l>
<l>                Text[|Text|] := AnomalyClassID + ' : \'nok\''</l>
<l>            else</l>
<l>                Text[|Text|] := AnomalyClassID + ' : \'ok\''</l>
<l>            endif</l>
<l>            Text[|Text|] := ''</l>
<l>            Text[|Text|] := 'Anomaly score: ' + AnomalyScore$'.2f'</l>
<c>            * Get or open next child window</c>
<l>            get_child_window (HeightImage, Font, FontSize, Text, PrevWindowCoordinates, WindowHandleDict, KeysForDisplay[KeyIndex], WindowImageRatio, PrevWindowCoordinates)</l>
<l>            dev_disp_text (Text, 'window', 'top', 'left', 'white', 'box', 'false')</l>
<l>        endif</l>
<l>    elseif (KeysForDisplay[KeyIndex] == 'classification_ground_truth')</l>
<c>        * </c>
<c>        * Ground truth classification image and class label.</c>
<l>        get_image (Image, SampleKeys, DLSample)</l>
<c>        * </c>
<l>        get_classification_ground_truth (SampleKeys, DLSample, ClassificationLabelIDGroundTruth)</l>
<c>        * </c>
<c>        * Get or open next window.</c>
<l>        get_image_size (Image, WidthImage, HeightImage)</l>
<l>        get_next_window (Font, FontSize, ShowBottomDesc, WidthImage, HeightImage, 0, ScaleWindows, ThresholdWidth, PrevWindowCoordinates, WindowHandleDict, KeysForDisplay[KeyIndex], CurrentWindowHandle, WindowImageRatio, PrevWindowCoordinates)</l>
<c>        * </c>
<c>        * Visualization.</c>
<l>        dev_display (Image)</l>
<c>        * </c>
<l>        if (ShowClassificationIDs)</l>
<l>            Text := 'GT label ID: ' + ClassificationLabelIDGroundTruth</l>
<l>            dev_disp_text (Text, 'window', 'top', 'left', 'white', 'box', 'false')</l>
<l>        endif</l>
<c>        * </c>
<l>        if (ShowBottomDesc)</l>
<l>            Text := 'Ground truth classification ' + ImageIDStringBraces</l>
<l>            dev_disp_text (Text, 'window', 'bottom', 'left', 'white', 'box', 'false')</l>
<l>        endif</l>
<c>        * </c>
<c>        * Display the legend.</c>
<l>        if (ShowLegend)</l>
<l>            Text := 'Ground truth class ID ' + ImageIDStringBraces</l>
<l>            Text := [Text,ClassesLegend[ClassificationLabelIDGroundTruth]]</l>
<c>            * </c>
<c>            * Get or open next child window</c>
<l>            get_child_window (HeightImage, Font, FontSize, Text, PrevWindowCoordinates, WindowHandleDict, KeysForDisplay[KeyIndex], WindowImageRatio, PrevWindowCoordinates)</l>
<l>            dev_disp_text (Text, 'window', 'top', 'left', ['white',Colors[ClassificationLabelIDGroundTruth]], 'box', 'false')</l>
<l>        endif</l>
<l>    elseif (KeysForDisplay[KeyIndex] == 'classification_result')</l>
<c>        * </c>
<c>        * Ground truth classification image.</c>
<l>        get_image (Image, SampleKeys, DLSample)</l>
<c>        * </c>
<l>        get_classification_result (ResultKeys, DLResult, ClassificationLabelIDResult)</l>
<c>        * </c>
<c>        * Get or open next window.</c>
<l>        get_image_size (Image, WidthImage, HeightImage)</l>
<l>        get_next_window (Font, FontSize, ShowBottomDesc, WidthImage, HeightImage, 0, ScaleWindows, ThresholdWidth, PrevWindowCoordinates, WindowHandleDict, KeysForDisplay[KeyIndex], CurrentWindowHandle, WindowImageRatio, PrevWindowCoordinates)</l>
<c>        * </c>
<c>        * Visualization.</c>
<l>        dev_display (Image)</l>
<c>        * </c>
<c>        * Display the class IDs.</c>
<l>        if (ShowClassificationIDs)</l>
<l>            get_dict_tuple (WindowHandleDict, 'meta_information', MetaInfo)</l>
<l>            get_dict_tuple (MetaInfo, 'classification_result_margin_bottom', MarginBottom)</l>
<l>            get_dict_tuple (MetaInfo, 'classification_result_window_coordinates', WindowCoordinates)</l>
<l>            CurrentWindowHeight := WindowCoordinates[3] - WindowCoordinates[0]</l>
<l>            get_font_extents (CurrentWindowHandle, _, _, _, MaxHeight)</l>
<l>            Text := 'Result class ID: ' + ClassificationLabelIDResult</l>
<l>            if (ShowBottomDesc)</l>
<l>                dev_disp_text (Text, 'window', CurrentWindowHeight - (MarginBottom + MaxHeight + 10), 'left', 'white', 'box', 'false')</l>
<l>            else</l>
<l>                dev_disp_text (Text, 'window', 'bottom', 'left', 'white', 'box', 'false')</l>
<l>            endif</l>
<l>        endif</l>
<c>        * </c>
<l>        if (ShowBottomDesc)</l>
<l>            Text := 'Result classification ' + ImageIDStringBraces</l>
<l>            dev_disp_text (Text, 'window', 'bottom', 'left', 'white', 'box', 'false')</l>
<l>        endif</l>
<c>        * </c>
<c>        * Display the legend.</c>
<l>        if (ShowLegend)</l>
<l>            Text := 'Result class ID ' + ImageIDStringBraces</l>
<l>            if (ClassificationLabelIDResult == [])</l>
<l>                Text[|Text|] := 'No classification result is given!'</l>
<l>            else</l>
<l>                Text := [Text,ClassesLegend[ClassificationLabelIDResult]]</l>
<l>            endif</l>
<c>            * </c>
<c>            * Get or open next child window</c>
<l>            get_child_window (HeightImage, Font, FontSize, Text, PrevWindowCoordinates, WindowHandleDict, KeysForDisplay[KeyIndex], WindowImageRatio, PrevWindowCoordinates)</l>
<l>            dev_disp_text (Text, 'window', 'top', 'left', ['white',Colors[ClassificationLabelIDResult]], 'box', 'false')</l>
<l>        endif</l>
<l>    elseif (KeysForDisplay[KeyIndex] == 'classification_both')</l>
<c>        * </c>
<c>        * Ground truth and result classification image.</c>
<l>        get_image (Image, SampleKeys, DLSample)</l>
<c>        * </c>
<l>        get_classification_ground_truth (SampleKeys, DLSample, ClassificationLabelIDGroundTruth)</l>
<l>        get_classification_result (ResultKeys, DLResult, ClassificationLabelIDResult)</l>
<c>        * </c>
<c>        * Get or open next window.</c>
<l>        get_image_size (Image, WidthImage, HeightImage)</l>
<l>        get_next_window (Font, FontSize, ShowBottomDesc, WidthImage, HeightImage, 0, ScaleWindows, ThresholdWidth, PrevWindowCoordinates, WindowHandleDict, KeysForDisplay[KeyIndex], CurrentWindowHandle, WindowImageRatio, PrevWindowCoordinates)</l>
<c>        * </c>
<c>        * Visualization.</c>
<c>        * </c>
<c>        * Get prediction color.</c>
<l>        PredictionColor := 'white'</l>
<l>        if (ClassificationLabelIDGroundTruth == ClassificationLabelIDResult)</l>
<l>            PredictionText := 'Correct'</l>
<l>            PredictionColor := 'green'</l>
<l>        else</l>
<l>            PredictionText := 'Wrong'</l>
<l>            PredictionColor := 'red'</l>
<l>        endif</l>
<c>        * </c>
<c>        * Generate prediction color frame and show image.</c>
<l>        if (ShowClassificationColorFrame)</l>
<c>            * Create a frame with line width 7 that is completely displayed in the window.</c>
<l>            BoarderOffset := 7 / 2.</l>
<l>            get_dict_tuple (WindowHandleDict, 'meta_information', MetaInfo)</l>
<l>            get_dict_tuple (MetaInfo, 'classification_both_window_image_ratio_height', WindowImageRatioHeight)</l>
<l>            get_dict_tuple (MetaInfo, 'classification_both_window_image_ratio_width', WindowImageRatioWidth)</l>
<l>            BoarderOffsetRow := BoarderOffset / WindowImageRatioHeight</l>
<l>            BoarderOffsetCol := BoarderOffset / WindowImageRatioWidth</l>
<l>            gen_contour_polygon_xld (PredictionColorFrame, [BoarderOffsetRow - 0.5,BoarderOffsetRow - 0.5,HeightImage + 0.5 - BoarderOffsetRow,HeightImage + 0.5 - BoarderOffsetRow,BoarderOffsetRow - 0.5], [BoarderOffsetCol - 0.5,WidthImage + 0.5 - BoarderOffsetCol,WidthImage + 0.5 - BoarderOffsetCol,BoarderOffsetCol - 0.5,BoarderOffsetCol - 0.5])</l>
<l>            dev_set_line_width (7)</l>
<l>            dev_set_color (PredictionColor)</l>
<l>            dev_display (Image)</l>
<l>            dev_display (PredictionColorFrame)</l>
<l>        else</l>
<l>            dev_display (Image)</l>
<l>        endif</l>
<c>        * </c>
<l>        if (ShowClassificationIDs)</l>
<l>            get_dict_tuple (WindowHandleDict, 'meta_information', MetaInfo)</l>
<l>            get_dict_tuple (MetaInfo, KeysForDisplay[KeyIndex] + '_margin_bottom', MarginBottom)</l>
<l>            get_dict_tuple (MetaInfo, KeysForDisplay[KeyIndex] + '_window_coordinates', WindowCoordinates)</l>
<l>            CurrentWindowHeight := WindowCoordinates[3] - WindowCoordinates[0]</l>
<l>            get_font_extents (CurrentWindowHandle, _, _, _, MaxHeight)</l>
<l>            Text := 'GT label ID: ' + ClassificationLabelIDGroundTruth</l>
<l>            dev_disp_text (Text, 'window', 'top', 'left', 'white', 'box', 'false')</l>
<l>            Text := 'Result class ID: ' + ClassificationLabelIDResult</l>
<l>            if (ShowBottomDesc)</l>
<l>                dev_disp_text (Text, 'window', CurrentWindowHeight - (MarginBottom + MaxHeight + 10), 'left', 'white', 'box', 'false')</l>
<l>            else</l>
<l>                dev_disp_text (Text, 'window', 'bottom', 'left', 'white', 'box', 'false')</l>
<l>            endif</l>
<l>        endif</l>
<c>        * </c>
<l>        if (ShowBottomDesc)</l>
<l>            Text := 'Result/Ground truth classification ' + ImageIDStringBraces</l>
<l>            dev_disp_text (Text, 'window', 'bottom', 'left', 'white', 'box', 'false')</l>
<l>        endif</l>
<c>        * </c>
<c>        * Display the legend.</c>
<l>        if (ShowLegend)</l>
<l>            Text := 'Ground truth class ID ' + ImageIDStringBraces</l>
<l>            Text[|Text|] := ClassesLegend[ClassificationLabelIDGroundTruth]</l>
<l>            Text[|Text|] := ''</l>
<l>            Text[|Text|] := ''</l>
<l>            Text[|Text|] := 'Result class ID'</l>
<l>            if (ClassificationLabelIDResult == [])</l>
<l>                Text[|Text|] := 'No classification result is given!'</l>
<l>            else</l>
<l>                Text[|Text|] := ClassesLegend[ClassificationLabelIDResult]</l>
<l>                Text[|Text|] := ''</l>
<l>                Text[|Text|] := ''</l>
<l>                Text[|Text|] := 'Prediction '</l>
<l>                Text[|Text|] := PredictionText</l>
<l>            endif</l>
<c>            * </c>
<c>            * Get or open next child window.</c>
<l>            get_child_window (HeightImage, Font, FontSize, Text, PrevWindowCoordinates, WindowHandleDict, KeysForDisplay[KeyIndex], WindowImageRatio, PrevWindowCoordinates)</l>
<l>            tuple_gen_const (|Text|, 'white', LineColors)</l>
<l>            LineColors[1] := Colors[ClassificationLabelIDGroundTruth]</l>
<l>            if (ClassificationLabelIDResult != [])</l>
<l>                LineColors[5] := Colors[ClassificationLabelIDResult]</l>
<l>                LineColors[9] := PredictionColor</l>
<l>            endif</l>
<l>            dev_disp_text (Text, 'window', 'top', 'left', LineColors, 'box', 'false')</l>
<l>        endif</l>
<c>        * </c>
<l>    elseif (KeysForDisplay[KeyIndex] == 'heatmap_grad_cam' or KeysForDisplay[KeyIndex] == 'heatmap_confidence_based')</l>
<c>        * </c>
<c>        * Display the heatmap image (method 'heatmap_grad_cam' or 'heatmap_confidence_based')</c>
<c>        * in the selected color scheme.</c>
<c>        * Retrieve heatmap image, inferred image, and inference results.</c>
<l>        SelectedHeatmapMethod := KeysForDisplay[KeyIndex]</l>
<l>        if ((find(ResultKeys,'heatmap_grad_cam') != -1) or (find(ResultKeys,'heatmap_confidence_based') != -1))</l>
<l>            if (SelectedHeatmapMethod == 'heatmap_grad_cam')</l>
<l>                get_dict_tuple (DLResult, 'heatmap_grad_cam', DictHeatmap)</l>
<l>                MethodName := 'Grad-CAM'</l>
<l>            else</l>
<l>                get_dict_tuple (DLResult, 'heatmap_confidence_based', DictHeatmap)</l>
<l>                MethodName := 'Confidence based'</l>
<l>            endif</l>
<l>            get_dict_param (DictHeatmap, 'keys', [], HeatmapKeys)</l>
<l>            HeatmapImageName := regexp_select(HeatmapKeys,'heatmap_image_class_[0-9]*')</l>
<l>            TargetClassID := regexp_match(HeatmapImageName,'heatmap_image_class_([0-9]+)$')</l>
<l>            get_dict_object (ImageHeatmap, DictHeatmap, HeatmapImageName)</l>
<l>        else</l>
<l>            throw ('Heatmap image could not be found in DLResult.')</l>
<l>        endif</l>
<c>        * </c>
<l>        if (SelectedHeatmapMethod == 'heatmap_grad_cam')</l>
<c>            * Read in input image.</c>
<l>            get_dict_object (Image, DLSample, 'image')</l>
<c>            * Add the heatmap to the input image.</c>
<l>            add_colormap_to_image (ImageHeatmap, Image, ImageHeatmap, HeatmapColorScheme)</l>
<l>        endif</l>
<c>        * </c>
<c>        * Get or open next window.</c>
<l>        get_image_size (ImageHeatmap, WidthImage, HeightImage)</l>
<l>        get_next_window (Font, FontSize, ShowBottomDesc, WidthImage, HeightImage, 0, ScaleWindows, ThresholdWidth, PrevWindowCoordinates, WindowHandleDict, KeysForDisplay[KeyIndex], CurrentWindowHandle, WindowImageRatio, PrevWindowCoordinates)</l>
<c>        * </c>
<l>        dev_display (ImageHeatmap)</l>
<l>        if (ShowBottomDesc)</l>
<l>            Text := 'Classification heatmap ' + ImageIDStringBraces</l>
<l>            dev_disp_text (Text, 'window', 'bottom', 'left', 'white', 'box', 'false')</l>
<l>        endif</l>
<c>        * </c>
<c>        * Display the legend.</c>
<l>        if (ShowLegend)</l>
<l>            get_dict_tuple (DLResult, 'classification_class_names', ClassNames)</l>
<l>            get_dict_tuple (DLResult, 'classification_class_ids', ClassIDs)</l>
<l>            get_dict_tuple (DLResult, 'classification_confidences', Confidences)</l>
<l>            if (SelectedHeatmapMethod == 'heatmap_confidence_based')</l>
<l>                get_dict_tuple (DictHeatmap, 'classification_heatmap_maxdeviation', MaxDeviation)</l>
<l>            endif</l>
<l>            ClassificationLabelNameResult := ClassNames[0]</l>
<l>            ClassificationLabelIDResult := ClassIDs[0]</l>
<l>            TargetClassConfidence := Confidences[find(ClassIDs,number(TargetClassID))]</l>
<l>            Text := '--------- '</l>
<l>            Text[|Text|] := 'Image '</l>
<l>            Text[|Text|] := '--------- '</l>
<l>            Text[|Text|] := ''</l>
<l>            if (find(SampleKeys,'image_label_id') != -1)</l>
<l>                get_dict_tuple (DLSample, 'image_label_id', ClassificationLabelIDGroundTruth)</l>
<l>                get_dict_tuple (DLDatasetInfo, 'class_names', ClassificationLabelNamesGroundTruth)</l>
<c>                * Get prediction color.</c>
<l>                if (ClassificationLabelIDGroundTruth == ClassificationLabelIDResult)</l>
<l>                    PredictionColor := 'green'</l>
<l>                else</l>
<l>                    PredictionColor := 'red'</l>
<l>                endif</l>
<l>                Text[|Text|] := 'Ground truth class: '</l>
<l>                Text[|Text|] := ClassificationLabelNamesGroundTruth[ClassificationLabelIDGroundTruth]</l>
<l>                Text[|Text|] := ''</l>
<l>            endif</l>
<l>            Text[|Text|] := 'Predicted class: '</l>
<l>            Text[|Text|] := ClassificationLabelNameResult</l>
<l>            Text[|Text|] := ''</l>
<l>            Text[|Text|] := 'Confidence: ' + Confidences[0]$'.2f'</l>
<l>            Text[|Text|] := ''</l>
<l>            Text[|Text|] := '--------- '</l>
<l>            Text[|Text|] := 'Heatmap '</l>
<l>            Text[|Text|] := '--------- '</l>
<l>            Text[|Text|] := ''</l>
<l>            Text[|Text|] := 'Method: ' + MethodName</l>
<l>            Text[|Text|] := 'Target class: ' + TargetClassID</l>
<l>            Text[|Text|] := ''</l>
<l>            Text[|Text|] := 'Target class confidence: ' + TargetClassConfidence$'.2f'</l>
<l>            if (SelectedHeatmapMethod == 'heatmap_confidence_based')</l>
<l>                Text[|Text|] := 'Maximum deviation: ' + MaxDeviation$'.2f'</l>
<l>            endif</l>
<c>            * </c>
<c>            * Get or open next child window</c>
<l>            get_child_window (HeightImage, Font, FontSize, Text, PrevWindowCoordinates, WindowHandleDict, KeysForDisplay[KeyIndex], WindowImageRatio, PrevWindowCoordinates)</l>
<l>            tuple_gen_const (|Text|, 'white', LineColors)</l>
<l>            if (find(SampleKeys,'image_label_id') != -1)</l>
<l>                LineColors[8] := PredictionColor</l>
<l>            endif</l>
<l>            dev_disp_text (Text, 'window', 'top', 'left', LineColors, 'box', 'false')</l>
<l>        endif</l>
<c>        * </c>
<l>    elseif (KeysForDisplay[KeyIndex] == 'segmentation_weight')</l>
<c>        * </c>
<c>        * Weight image.</c>
<l>        get_weight_image (ImageWeight, SampleKeys, DLSample)</l>
<c>        * </c>
<c>        * Get or open next window.</c>
<l>        get_image_size (ImageWeight, WidthImage, HeightImage)</l>
<l>        get_next_window (Font, FontSize, ShowBottomDesc, WidthImage, HeightImage, 0, ScaleWindows, ThresholdWidth, PrevWindowCoordinates, WindowHandleDict, KeysForDisplay[KeyIndex], CurrentWindowHandle, WindowImageRatio, PrevWindowCoordinates)</l>
<c>        * </c>
<l>        dev_display (ImageWeight)</l>
<l>        if (ShowBottomDesc)</l>
<l>            dev_disp_text ('Weight image ' + ImageIDStringBraces, 'window', 'bottom', 'left', 'white', 'box', 'false')</l>
<l>        endif</l>
<l>    elseif (KeysForDisplay[KeyIndex] == 'segmentation_confidence')</l>
<c>        * </c>
<c>        * Segmentation confidences.</c>
<l>        get_confidence_image (ImageConfidence, ResultKeys, DLResult)</l>
<c>        * </c>
<c>        * Get or open next window.</c>
<l>        get_image_size (ImageConfidence, WidthImage, HeightImage)</l>
<l>        get_next_window (Font, FontSize, ShowBottomDesc, WidthImage, HeightImage, 0, ScaleWindows, ThresholdWidth, PrevWindowCoordinates, WindowHandleDict, KeysForDisplay[KeyIndex], CurrentWindowHandle, WindowImageRatio, PrevWindowCoordinates)</l>
<c>        * </c>
<l>        dev_display (ImageConfidence)</l>
<l>        if (ShowBottomDesc)</l>
<l>            dev_disp_text ('Confidence image ' + ImageIDStringBraces, 'window', 'bottom', 'left', 'white', 'box', 'false')</l>
<l>        endif</l>
<l>    elseif (KeysForDisplay[KeyIndex] == 'bbox_ground_truth')</l>
<c>        * </c>
<c>        * Sample bounding boxes on image.</c>
<l>        get_image (Image, SampleKeys, DLSample)</l>
<c>        * </c>
<c>        * Get or open next window.</c>
<l>        get_image_size (Image, WidthImage, HeightImage)</l>
<l>        get_next_window (Font, FontSize, ShowBottomDesc, WidthImage, HeightImage, 0, ScaleWindows, ThresholdWidth, PrevWindowCoordinates, WindowHandleDict, KeysForDisplay[KeyIndex], CurrentWindowHandle, WindowImageRatio, PrevWindowCoordinates)</l>
<c>        * </c>
<c>        * Visualization.</c>
<l>        dev_display (Image)</l>
<c>        * </c>
<l>        dev_display_ground_truth_detection (DLSample, SampleKeys, LineWidth, ClassIDs, Colors, BboxLabelColor, BboxTextColor, ShowLabels, ShowDirection, CurrentWindowHandle, BboxIDs)</l>
<l>        Text := 'Ground truth ' + ImageIDStringBraces</l>
<l>        if (ShowBottomDesc)</l>
<l>            dev_disp_text (Text, 'window', 'bottom', 'left', 'white', 'box', 'false')</l>
<l>        endif</l>
<c>        * </c>
<c>        * Display the legend.</c>
<l>        if (ShowLegend)</l>
<l>            BboxColors := 'white'</l>
<l>            if (|BboxIDs|)</l>
<l>                BboxIDsUniq := uniq(sort(BboxIDs))</l>
<l>                Text := [Text,ClassesLegend[BboxIDsUniq]]</l>
<l>                BboxColors := [BboxColors,Colors[BboxIDsUniq]]</l>
<l>            else</l>
<l>                Text := [Text,'No ground truth bounding boxes present.']</l>
<l>            endif</l>
<c>            * </c>
<c>            * Get or open next child window.</c>
<l>            get_child_window (HeightImage, Font, FontSize, Text, PrevWindowCoordinates, WindowHandleDict, KeysForDisplay[KeyIndex], WindowImageRatio, PrevWindowCoordinates)</l>
<l>            dev_disp_text (Text, 'window', 'top', 'left', BboxColors, 'box', 'false')</l>
<l>        endif</l>
<l>    elseif (KeysForDisplay[KeyIndex] == 'bbox_result')</l>
<c>        * </c>
<c>        * Result bounding boxes on image.</c>
<l>        get_image (Image, SampleKeys, DLSample)</l>
<c>        * </c>
<c>        * Get or open next window.</c>
<l>        get_image_size (Image, WidthImage, HeightImage)</l>
<l>        get_next_window (Font, FontSize, ShowBottomDesc, WidthImage, HeightImage, 0, ScaleWindows, ThresholdWidth, PrevWindowCoordinates, WindowHandleDict, KeysForDisplay[KeyIndex], CurrentWindowHandle, WindowImageRatio, PrevWindowCoordinates)</l>
<c>        * </c>
<c>        * Visualization.</c>
<l>        dev_display (Image)</l>
<c>        * </c>
<l>        if (find(ResultKeys,'bbox_confidence') != -1)</l>
<l>            get_dict_tuple (DLResult, 'bbox_confidence', BboxConfidences)</l>
<l>        else</l>
<l>            throw ('Result bounding box data could not be found in DLResult.')</l>
<l>        endif</l>
<l>        if (BboxDisplayConfidence)</l>
<l>            TextConf := ' (' + BboxConfidences$'.2f' + ')'</l>
<l>        else</l>
<l>            TextConf := gen_tuple_const(|BboxConfidences|,'')</l>
<l>        endif</l>
<l>        dev_display_result_detection (DLResult, ResultKeys, LineWidth, ClassIDs, TextConf, Colors, BboxLabelColor, WindowImageRatio, 'top', BboxTextColor, ShowLabels, ShowDirection, CurrentWindowHandle, BboxClassIndex)</l>
<l>        Text := 'Result bounding boxes ' + ImageIDStringBraces</l>
<l>        if (ShowBottomDesc)</l>
<l>            dev_disp_text (Text, 'window', 'bottom', 'left', 'white', 'box', 'false')</l>
<l>        endif</l>
<c>        * </c>
<c>        * Display the legend.</c>
<l>        if (ShowLegend)</l>
<l>            BboxColorsResults := 'white'</l>
<l>            if (|BboxClassIndex| &gt; 0)</l>
<l>                BboxClassIndexUniq := uniq(sort(BboxClassIndex))</l>
<l>                Text := [Text,ClassesLegend[BboxClassIndexUniq]]</l>
<l>                BboxColorsResults := [BboxColorsResults,Colors[BboxClassIndexUniq]]</l>
<l>            else</l>
<l>                Text := [Text,'No result bounding boxes present.']</l>
<l>            endif</l>
<c>            * </c>
<c>            * Get or open next child window.</c>
<l>            get_child_window (HeightImage, Font, FontSize, Text, PrevWindowCoordinates, WindowHandleDict, KeysForDisplay[KeyIndex], WindowImageRatio, PrevWindowCoordinates)</l>
<l>            dev_disp_text (Text, 'window', 'top', 'left', BboxColorsResults, 'box', 'false')</l>
<l>        endif</l>
<l>    elseif (KeysForDisplay[KeyIndex] == 'bbox_both')</l>
<c>        * </c>
<c>        * Ground truth and result bounding boxes on image.</c>
<l>        get_image (Image, SampleKeys, DLSample)</l>
<c>        * </c>
<c>        * Get or open next window.</c>
<l>        get_image_size (Image, WidthImage, HeightImage)</l>
<l>        get_next_window (Font, FontSize, ShowBottomDesc, WidthImage, HeightImage, 0, ScaleWindows, ThresholdWidth, PrevWindowCoordinates, WindowHandleDict, KeysForDisplay[KeyIndex], CurrentWindowHandle, WindowImageRatio, PrevWindowCoordinates)</l>
<c>        * </c>
<l>        dev_display (Image)</l>
<c>        * </c>
<c>        * Visualization.</c>
<l>        dev_display_ground_truth_detection (DLSample, SampleKeys, LineWidth, ClassIDs, Colors, BboxLabelColor, BboxTextColor, ShowLabels, ShowDirection, CurrentWindowHandle, BboxLabelIndex)</l>
<l>        if (find(ResultKeys,'bbox_confidence') != -1)</l>
<l>            get_dict_tuple (DLResult, 'bbox_confidence', BboxConfidences)</l>
<l>        else</l>
<l>            throw ('Result bounding box data could not be found in DLResult.')</l>
<l>        endif</l>
<l>        if (BboxDisplayConfidence)</l>
<l>            TextConf := ' (' + BboxConfidences$'.2f' + ')'</l>
<l>        else</l>
<l>            TextConf := gen_tuple_const(|BboxConfidences|,'')</l>
<l>        endif</l>
<l>        dev_display_result_detection (DLResult, ResultKeys, LineWidth, ClassIDs, TextConf, Colors, BboxLabelColor, WindowImageRatio, 'bottom', BboxTextColor, ShowLabels, ShowDirection, CurrentWindowHandle, BboxClassIndex)</l>
<l>        Text := 'Ground truth and result bounding boxes ' + ImageIDStringBraces</l>
<l>        if (ShowBottomDesc)</l>
<l>            dev_disp_text (Text, 'window', 'bottom', 'left', 'white', 'box', 'false')</l>
<l>        endif</l>
<l>        Text := 'Ground truth and'</l>
<l>        Text[|Text|] := 'result bounding boxes ' + ImageIDStringBraces</l>
<c>        * </c>
<c>        * Display the legend.</c>
<l>        if (ShowLegend)</l>
<l>            BboxColorsBoth := ['white','white']</l>
<l>            if (|BboxClassIndex| + |BboxLabelIndex| &gt; 0)</l>
<l>                BboxClassLabelIndexUniq := uniq(sort([BboxClassIndex,BboxLabelIndex]))</l>
<l>                Text := [Text,ClassesLegend[BboxClassLabelIndexUniq]]</l>
<l>                BboxColorsBoth := [BboxColorsBoth,Colors[BboxClassLabelIndexUniq]]</l>
<l>            else</l>
<l>                Text := [Text,'No ground truth nor result bounding boxes present.']</l>
<l>            endif</l>
<c>            * </c>
<c>            * Get or open next child window.</c>
<l>            get_child_window (HeightImage, Font, FontSize, Text, PrevWindowCoordinates, WindowHandleDict, KeysForDisplay[KeyIndex], WindowImageRatio, PrevWindowCoordinates)</l>
<l>            dev_disp_text (Text, 'window', 'top', 'left', BboxColorsBoth, 'box', 'false')</l>
<l>        endif</l>
<l>    elseif (KeysForDisplay[KeyIndex] == 'segmentation_image_ground_truth')</l>
<c>        * </c>
<c>        * Ground truth segmentation image.</c>
<l>        get_image (Image, SampleKeys, DLSample)</l>
<l>        get_segmentation_image_ground_truth (SegmentationImagGroundTruth, SampleKeys, DLSample)</l>
<c>        * </c>
<c>        * Get or open next window.</c>
<l>        get_image_size (Image, WidthImage, HeightImage)</l>
<l>        get_next_window (Font, FontSize, ShowBottomDesc, WidthImage, HeightImage, 0, ScaleWindows, ThresholdWidth, PrevWindowCoordinates, WindowHandleDict, KeysForDisplay[KeyIndex], CurrentWindowHandle, WindowImageRatio, PrevWindowCoordinates)</l>
<c>        * </c>
<c>        * Visualization.</c>
<l>        dev_display (Image)</l>
<c>        * </c>
<c>        * Display segmentation regions.</c>
<l>        ColorsSegmentation := Colors + SegTransparency</l>
<l>        get_draw (CurrentWindowHandle, DrawMode)</l>
<l>        dev_set_draw (SegDraw)</l>
<l>        get_line_width (CurrentWindowHandle, Width)</l>
<l>        dev_set_line_width (LineWidth)</l>
<l>        dev_display_segmentation_regions (SegmentationImagGroundTruth, ClassIDs, ColorsSegmentation, SegExcludeClassIDs, ImageClassIDs)</l>
<l>        dev_set_draw (DrawMode)</l>
<l>        dev_set_line_width (int(Width))</l>
<l>        Text := 'Ground truth segmentation ' + ImageIDStringBraces</l>
<l>        if (ShowBottomDesc)</l>
<l>            dev_disp_text (Text, 'window', 'bottom', 'left', 'white', 'box', 'false')</l>
<l>        endif</l>
<c>        * </c>
<c>        * Display the legend.</c>
<l>        if (ShowLegend)</l>
<l>            ImageClassIDsUniq := uniq(sort(ImageClassIDs))</l>
<l>            Text := [Text,ClassesLegend[ImageClassIDsUniq]]</l>
<c>            * </c>
<c>            * Get or open next child window</c>
<l>            get_child_window (HeightImage, Font, FontSize, Text, PrevWindowCoordinates, WindowHandleDict, KeysForDisplay[KeyIndex], WindowImageRatio, PrevWindowCoordinates)</l>
<l>            dev_disp_text (Text, 'window', 'top', 'left', ['white',Colors[ImageClassIDsUniq]], 'box', 'false')</l>
<l>        endif</l>
<l>    elseif (KeysForDisplay[KeyIndex] == 'segmentation_image_result')</l>
<c>        * </c>
<c>        * Result segmentation on image.</c>
<l>        get_image (Image, SampleKeys, DLSample)</l>
<l>        get_segmentation_image_result (SegmentationImageResult, ResultKeys, DLResult)</l>
<c>        * </c>
<c>        * Get or open next window.</c>
<l>        get_image_size (Image, WidthImage, HeightImage)</l>
<l>        get_next_window (Font, FontSize, ShowBottomDesc, WidthImage, HeightImage, 0, ScaleWindows, ThresholdWidth, PrevWindowCoordinates, WindowHandleDict, KeysForDisplay[KeyIndex], CurrentWindowHandle, WindowImageRatio, PrevWindowCoordinates)</l>
<c>        * </c>
<c>        * Visualization.</c>
<l>        dev_display (Image)</l>
<c>        * </c>
<c>        * Display result segmentation regions.</c>
<l>        ColorsResults := Colors + SegTransparency</l>
<l>        get_draw (CurrentWindowHandle, DrawMode)</l>
<l>        dev_set_draw (SegDraw)</l>
<l>        get_line_width (CurrentWindowHandle, Width)</l>
<l>        dev_set_line_width (LineWidth)</l>
<l>        dev_display_segmentation_regions (SegmentationImageResult, ClassIDs, ColorsResults, SegExcludeClassIDs, ImageClassIDs)</l>
<l>        dev_set_draw (DrawMode)</l>
<l>        dev_set_line_width (int(Width))</l>
<l>        Text := 'Result segmentation ' + ImageIDStringBraces</l>
<l>        if (ShowBottomDesc)</l>
<l>            dev_disp_text (Text, 'window', 'bottom', 'left', 'white', 'box', 'false')</l>
<l>        endif</l>
<c>        * </c>
<c>        * Display the legend.</c>
<l>        if (ShowLegend)</l>
<l>            ImageClassIDsUniq := uniq(sort(ImageClassIDs))</l>
<l>            Text := [Text,ClassesLegend[ImageClassIDsUniq]]</l>
<c>            * </c>
<c>            * Get or open next child window.</c>
<l>            get_child_window (HeightImage, Font, FontSize, Text, PrevWindowCoordinates, WindowHandleDict, KeysForDisplay[KeyIndex], WindowImageRatio, PrevWindowCoordinates)</l>
<l>            dev_disp_text (Text, 'window', 'top', 'left', ['white',Colors[ImageClassIDsUniq]], 'box', 'false')</l>
<l>        endif</l>
<l>    elseif (KeysForDisplay[KeyIndex] == 'segmentation_image_both')</l>
<c>        * </c>
<c>        * Ground truth and result segmentation on image.</c>
<l>        get_image (Image, SampleKeys, DLSample)</l>
<l>        get_segmentation_image_ground_truth (SegmentationImagGroundTruth, SampleKeys, DLSample)</l>
<l>        get_segmentation_image_result (SegmentationImageResult, ResultKeys, DLResult)</l>
<c>        * </c>
<c>        * Get or open next window.</c>
<l>        get_image_size (Image, WidthImage, HeightImage)</l>
<l>        get_next_window (Font, FontSize, ShowBottomDesc, WidthImage, HeightImage, 0, ScaleWindows, ThresholdWidth, PrevWindowCoordinates, WindowHandleDict, KeysForDisplay[KeyIndex], CurrentWindowHandle, WindowImageRatio, PrevWindowCoordinates)</l>
<c>        * </c>
<c>        * Visualization.</c>
<l>        dev_display (Image)</l>
<c>        * </c>
<c>        * Display regions.</c>
<l>        ColorsResults := Colors + SegTransparency</l>
<l>        dev_set_draw ('margin')</l>
<l>        dev_set_line_width (2)</l>
<l>        dev_display_segmentation_regions (SegmentationImagGroundTruth, ClassIDs, ColorsResults, SegExcludeClassIDs, GroundTruthIDs)</l>
<l>        dev_set_line_width (6)</l>
<l>        dev_display_segmentation_regions (SegmentationImageResult, ClassIDs, ColorsResults, SegExcludeClassIDs, ResultIDs)</l>
<l>        dev_set_draw ('fill')</l>
<l>        Text := 'Ground truth and result segmentation ' + ImageIDStringBraces</l>
<l>        if (ShowBottomDesc)</l>
<l>            dev_disp_text (Text, 'window', 'bottom', 'left', 'white', 'box', 'false')</l>
<l>        endif</l>
<c>        * </c>
<c>        * Display the legend.</c>
<l>        if (ShowLegend)</l>
<l>            ImageClassIDsUniq := uniq(sort([GroundTruthIDs,ResultIDs]))</l>
<l>            Text := [Text,ClassesLegend[ImageClassIDsUniq]]</l>
<l>            Text[|Text| + 1] := '- thicker line: result, thinner lines: ground truth'</l>
<l>            Text[|Text|] := '  (you may have to zoom in for a more detailed view)'</l>
<l>            StringSegExcludeClassIDs := ''</l>
<l>            for StringIndex := 0 to |SegExcludeClassIDs| - 1 by 1</l>
<l>                if (StringIndex == |SegExcludeClassIDs| - 1)</l>
<l>                    StringSegExcludeClassIDs := StringSegExcludeClassIDs + SegExcludeClassIDs[StringIndex]</l>
<l>                else</l>
<l>                    StringSegExcludeClassIDs := StringSegExcludeClassIDs + SegExcludeClassIDs[StringIndex] + ', '</l>
<l>                endif</l>
<l>            endfor</l>
<l>            if (SegExcludeClassIDs != [])</l>
<l>                Text[|Text|] := '- (excluded classID(s) ' + StringSegExcludeClassIDs + ' from visualization)'</l>
<l>            endif</l>
<c>            * </c>
<l>            get_child_window (HeightImage, Font, FontSize, Text, PrevWindowCoordinates, WindowHandleDict, KeysForDisplay[KeyIndex], WindowImageRatio, PrevWindowCoordinates)</l>
<l>            dev_disp_text (Text, 'window', 'top', 'left', ['white',Colors[ImageClassIDsUniq],'white','white','white'], 'box', 'false')</l>
<l>        endif</l>
<l>    elseif (KeysForDisplay[KeyIndex] == 'segmentation_image_diff')</l>
<c>        * </c>
<c>        * Difference of ground truth and result segmentation on image.</c>
<l>        get_image (Image, SampleKeys, DLSample)</l>
<l>        get_segmentation_image_ground_truth (SegmentationImagGroundTruth, SampleKeys, DLSample)</l>
<l>        get_segmentation_image_result (SegmentationImageResult, ResultKeys, DLResult)</l>
<c>        * </c>
<c>        * Get or open next window.</c>
<l>        get_image_size (Image, WidthImage, HeightImage)</l>
<l>        get_next_window (Font, FontSize, ShowBottomDesc, WidthImage, HeightImage, 0, ScaleWindows, ThresholdWidth, PrevWindowCoordinates, WindowHandleDict, KeysForDisplay[KeyIndex], CurrentWindowHandle, WindowImageRatio, PrevWindowCoordinates)</l>
<c>        * </c>
<c>        * Visualization.</c>
<l>        dev_display (Image)</l>
<l>        abs_diff_image (SegmentationImagGroundTruth, SegmentationImageResult, ImageAbsDiff, 1)</l>
<l>        min_max_gray (SegmentationImageResult, ImageAbsDiff, 0, Min, Max, Range)</l>
<l>        if (Min != Max)</l>
<l>            threshold (ImageAbsDiff, DiffRegion, 0.00001, Max)</l>
<l>            dev_set_color ('#ff0000' + SegTransparency)</l>
<l>            dev_display (DiffRegion)</l>
<l>        else</l>
<l>            dev_disp_text ('No difference found.', 'window', 'top', 'left', 'black', [], [])</l>
<l>        endif</l>
<l>        if (ShowBottomDesc)</l>
<l>            Text := 'Difference of ground truth and result segmentation ' + ImageIDStringBraces</l>
<l>            dev_disp_text (Text, 'window', 'bottom', 'left', 'white', 'box', 'false')</l>
<l>        endif</l>
<l>    elseif (KeysForDisplay[KeyIndex] == 'segmentation_weight_map')</l>
<c>        * </c>
<c>        * Weight map on image.</c>
<l>        get_image (Image, SampleKeys, DLSample)</l>
<l>        get_weight_image (ImageWeight, SampleKeys, DLSample)</l>
<c>        * </c>
<l>        if (SegMaxWeight == 0)</l>
<c>            * Calculate SegMaxWeight if not given in GenParam.</c>
<l>            min_max_gray (ImageWeight, ImageWeight, 0, MinWeight, SegMaxWeight, Range)</l>
<l>        endif</l>
<c>        * </c>
<c>        * Get or open next window.</c>
<l>        get_image_size (Image, WidthImage, HeightImage)</l>
<l>        get_next_window (Font, FontSize, ShowBottomDesc, WidthImage, HeightImage, MapColorBarWidth, ScaleWindows, ThresholdWidth, PrevWindowCoordinates, WindowHandleDict, KeysForDisplay[KeyIndex], CurrentWindowHandle, WindowImageRatio, PrevWindowCoordinates)</l>
<c>        * </c>
<c>        * Visualization.</c>
<l>        dev_display (Image)</l>
<l>        dev_display_weight_regions (ImageWeight, MapTransparency, SegMaxWeight, WeightsColors)</l>
<l>        dev_display_map_color_bar (WidthImage, HeightImage, MapColorBarWidth, WeightsColors, SegMaxWeight, WindowImageRatio, CurrentWindowHandle)</l>
<l>        if (ShowBottomDesc)</l>
<l>            dev_disp_text ('Weight map ' + ImageIDStringBraces, 'window', 'bottom', 'left', 'white', 'box', 'false')</l>
<l>        endif</l>
<l>    elseif (KeysForDisplay[KeyIndex] == 'segmentation_confidence_map')</l>
<c>        * </c>
<c>        * Segmentation confidence map on image.</c>
<l>        get_image (Image, SampleKeys, DLSample)</l>
<l>        get_confidence_image (ImageConfidence, ResultKeys, DLResult)</l>
<c>        * </c>
<c>        * Get or open next window.</c>
<l>        get_image_size (Image, WidthImage, HeightImage)</l>
<l>        get_next_window (Font, FontSize, ShowBottomDesc, WidthImage, HeightImage, MapColorBarWidth, ScaleWindows, ThresholdWidth, PrevWindowCoordinates, WindowHandleDict, KeysForDisplay[KeyIndex], CurrentWindowHandle, WindowImageRatio, PrevWindowCoordinates)</l>
<c>        * </c>
<c>        * Visualization.</c>
<l>        dev_display (Image)</l>
<l>        dev_display_confidence_regions (ImageConfidence, MapTransparency, ConfidenceColors)</l>
<l>        dev_display_map_color_bar (WidthImage, HeightImage, MapColorBarWidth, ConfidenceColors, 1.0, WindowImageRatio, CurrentWindowHandle)</l>
<l>        if (ShowBottomDesc)</l>
<l>            dev_disp_text ('Confidence map ' + ImageIDStringBraces, 'window', 'bottom', 'left', 'white', 'box', 'false')</l>
<l>        endif</l>
<l>    else</l>
<c>        * Reset flush buffer of existing windows before throwing an exception.</c>
<l>        get_dict_param (WindowHandleDict, 'keys', [], WindowHandleKeys)</l>
<l>        for Index := 0 to |WindowHandleKeys| - 1 by 1</l>
<c>            * Only consider the WindowHandleKeys that are needed for the current visualization.</c>
<l>            Indices := find(KeysForDisplay,WindowHandleKeys[Index])</l>
<l>            if (Indices != -1 and Indices != [])</l>
<l>                get_dict_tuple (WindowHandleDict, WindowHandleKeys[Index], WindowHandles)</l>
<l>                for WindowIndex := 0 to |WindowHandles| - 1 by 1</l>
<c>                    * Reset values of windows that have been changed temporarily.</c>
<l>                    set_window_param (WindowHandles[WindowIndex], 'flush', FlushValues[Index])</l>
<l>                endfor</l>
<l>            endif</l>
<l>        endfor</l>
<l>        throw ('Key for display unknown: ' + KeysForDisplay[KeyIndex])</l>
<l>    endif</l>
<l>endfor</l>
<c>* </c>
<c>* Display results.</c>
<l>get_dict_param (WindowHandleDict, 'keys', [], WindowHandleKeysNew)</l>
<l>for Index := 0 to |WindowHandleKeysNew| - 1 by 1</l>
<c>    * Only consider the WindowHandleKeys that are needed for the current visualization.</c>
<l>    KeyIndex := find(KeysForDisplay,WindowHandleKeysNew[Index])</l>
<l>    if (KeyIndex != -1 and KeyIndex != [])</l>
<l>        get_dict_tuple (WindowHandleDict, WindowHandleKeysNew[Index], WindowHandles)</l>
<l>        for WindowIndex := 0 to |WindowHandles| - 1 by 1</l>
<c>            * Display content of window handle.</c>
<l>            if (|WindowHandleKeys| == |WindowHandleKeysNew|)</l>
<c>                * Reset values of windows that have been changed temporarily.</c>
<l>                if (FlushValues[WindowIndex] == 'true')</l>
<l>                    flush_buffer (WindowHandles[WindowIndex])</l>
<l>                endif</l>
<l>                set_window_param (WindowHandles[WindowIndex], 'flush', FlushValues[WindowIndex])</l>
<l>            else</l>
<c>                * Per default, 'flush' of new windows should be set to 'true'.</c>
<l>                flush_buffer (WindowHandles[WindowIndex])</l>
<l>                set_window_param (WindowHandles[WindowIndex], 'flush', 'true')</l>
<l>            endif</l>
<l>        endfor</l>
<l>    endif</l>
<l>endfor</l>
<c>* </c>
<l>return ()</l>
</body>
<docu id="dev_display_dl_data">
<abstract lang="en_US">This procedure displays the content of the provided DLSample and/or DLResult depending on the input string KeysForDisplay.
DLDatasetInfo is a dictionary containing the information about the dataset.
WindowHandleDict gives the handles of the windows used for the display.
The dictionary GenParam allows you to customize the display.

The dictionary WindowHandleDict can specify the handles of the windows in which the images are to be shown or it can be an empty dictionary.
In the latter case, the required windows are opened and their handles are stored here.

KeysForDisplay determines, what is shown in the image. Thereby, the following values are possible depending on the model type:
- for all model types:
   -- 'image': Input image.
- for models of type 'anomaly_detection':
  -- 'anomaly_ground_truth': Image with ground truth label, if one exists.
  -- 'anomaly_result': Image with predicted anomaly regions: the regions in anomaly_image with values larger anomaly_region_threshold. 
  -- 'anomaly_both': Image with ground truth label (if one exists) and predicted anomaly regions.
  -- 'anomaly_image': Image with the predicted anomaly_image, whose values are transformed into an RGB-image.
- for models of type 'classification':
   -- 'classification_ground_truth': Image with ground truth label.
   -- 'classification_result': Image with the predicted class.
   -- 'classification_both': Image with both, its ground truth label and the predicted class.
   -- 'heatmap_confidence_based': Heatmap image and prediction information. The heatmap must be generated using the procedure gen_dl_model_classification_heatmap.
   -- 'heatmap_grad_cam': Heatmap image and prediction information. The heatmap must be generated using the operator gen_dl_model_heatmap.
- for models of type 'detection':
   -- 'bbox_ground_truth': Image with the ground truth bounding boxes.
   -- 'bbox_result': Image with the detected objects.
   -- 'bbox_both': Image with both, the ground truth bounding boxes and the detected objects.
- for models of type 'segmentation':
   -- 'segmentation_image_ground_truth': Input image, where the ground truth classes are displayed according to the defined style.
   -- 'segmentation_image_result': Input image, where the inferred classes are displayed according to the defined style.
   -- 'segmentation_image_both': Input image with the inferred classes and the ground truth classes marked by surrounding lines of different widths.
   -- 'segmentation_image_diff': Input image with regions, showing the difference between the inferred and ground truth classes. In case no difference is found, this is mentioned. 
   -- 'segmentation_confidence': Confidence image, where the confidence values are displayed as grey values.
   -- 'segmentation_confidence_map': RGB image, where the confidence values are displayed as semi-transparent regions over the input image.
   -- 'segmentation_weight': Weight image, where the weights are displayed as grey values.
   -- 'segmentation_weight_map': RGB image, where the weights are displayed as semi-transparent regions over the input image.

The entries needed in DLDatasetInfo depend on the value specified for KeysForDisplay. If 'image' is the only key used in KeysForDisplay,
an empty dictionary can be passed over. If other keys are used in KeysForDisplay, the dictionary should contain at least the keys: 'class_names', 'class_ids'.
We recommend to use DLDataset, if available.

The display can be customized through specifications in GenParam. The entries available depend on the model type:
- for all model types:
   -- 'threshold_width' (default: 1024): Define when a new row of windows is started.
       The value is given in pixels. Note, if one KeysForDisplay opens multiple windows, these windows are placed next to each other.
   -- 'scale_windows' (default: 0.8): Determine the size of the windows. The value has to be &gt;0, adapt it according to your screen resolution and desired visualization.
   -- 'font' (default: 'mono'): Set the font style used in set_display_font.
   -- 'font_size' (default: 14): Set the font size used in set_display_font.
   -- 'line_width' (default: 2): Set the width of all displayed lines. The value has to be an integer.
   -- 'display_legend' (default: true): Determine, whether to display the legend in an additional window next to the image window or not.
   -- 'display_bottom_desc' (default:true): Determine, whether to display image description at the bottom of the graphics window or not.
- for models of type 'anomaly_detection':
  -- 'anomaly_region_threshold' (default: -1): Set the threshold for values in anomaly_image to be displayed as anomaly region.
  -- 'anomaly_classification_threshold' (default: -1): Set the classification threshold displayed.
  -- 'anomaly_region_label_color' (default: '#ff0000c0'): Set the color and alpha value of the labeled regions as hexadecimal RGBA quadruplet.
  -- 'anomaly_region_result_color' (default: '#ff4500'): Set the color of the label of the predicted regions as hexadecimal RGB triplet.
  -- 'anomaly_color_transparency' (default: '80'): Set the alpha value used as hexadecimal number within an RGBA quadruplet for the predicted anomaly regions.
  -- 'display_ground_truth_anomaly_regions' (default: true): Determine, whether to display the ground truth labeled regions if they are present.
- for models of type 'classification':
   -- 'display_classification_ids' (default: true): Determine, whether to display the classification class IDs (ground truth/result) or not.
   -- 'display_classification_color_frame' (default: true): Determine, whether to display a frame which shows the prediction through a color (green: prediction is correct, red: prediction is wrong).
   -- 'heatmap_color_scheme' (default: 'jet'): Determine the color scheme used for the display of the model heatmap. For possible values see the procedure heatmap_to_rgb.
- for models of type 'detection':
   -- 'bbox_label_color' (default: '#00000099'): Set the color and alpha value of the label as hexadecimal RGBA quadruplet.
   -- 'bbox_display_confidence' (default: true) : Specify, if the confidence values are displayed in the label.
   -- 'bbox_text_color' (default: 'white'): Define the color of the text within the bounding boxes.
   -- 'display_labels' (default: true): Determine, whether to display the bounding box labels or not.
   -- 'display_direction' (default: true, only for instance_type 'rectangle2'): Determine, whether to indicate the direction of the instance within the bounding box by an arrow or not.
- for models of type 'segmentation':
   -- 'map_transparency' (default: 'cc'): Set the alpha value used as hexadecimal number within an RGBA quadruplet 
       when drawing a map ('segmentation_weight_map', 'segmentation_confidence_map'). Range: 00 to ff.
   -- 'map_color_bar_width' (default: 140): Determine the width of the color bar for a map ('segmentation_weight_map', 'segmentation_confidence_map').
   -- 'segmentation_max_weight' (default 0.0): Set the maximum weight value for the color bar range.
       For a value of 0, it is computed automatically for each image individually, while else the value has to be at least the largest weight occurring for all samples displayed.
   -- 'segmentation_draw': Set the drawing style. You can set the following values:
      --- 'fill' (default): The regions are marked by colored areas.
      --- 'margin': The regions are marked by surrounding lines.
   -- 'segmentation_transparency' (default: 'aa'): Set the alpha value used as hexadecimal number within an RGBA quadruplet
       for the drawn segmentation regions. Range: 00 to ff.
   -- 'segmentation_exclude_class_ids' (default: []): Set the IDs of classes which will not be displayed.</abstract>
<chapters lang="de_DE">
<item>Deep Learning</item>
<item>Modell</item>
</chapters>
<chapters lang="en_US">
<item>Deep Learning</item>
<item>Model</item>
</chapters>
<library lang="en_US">MVTec Standard Procedures</library>
<short lang="en_US">Visualize different images, annotations and inference results for a sample.</short>
<parameters>
<parameter id="DLDatasetInfo">
<description lang="en_US">Dictionary containing information about the dataset.</description>
<mixed_type>false</mixed_type>
<sem_type>dict</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="DLResult">
<default_value>[]</default_value>
<description lang="en_US">Dictionary containing the results obtained for the specified sample.</description>
<mixed_type>false</mixed_type>
<multivalue>optional</multivalue>
<sem_type>dict</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="DLSample">
<default_value>[]</default_value>
<description lang="en_US">Dictionary of the sample to be visualized.</description>
<mixed_type>false</mixed_type>
<multivalue>optional</multivalue>
<sem_type>dict</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="GenParam">
<default_type>integer</default_type>
<default_value>[]</default_value>
<description lang="en_US">Dictionary containing the generic parameters.</description>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>any</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="KeysForDisplay">
<default_type>string</default_type>
<description lang="en_US">Determines the requested visualizations.</description>
<mixed_type>false</mixed_type>
<multivalue>optional</multivalue>
<sem_type>string</sem_type>
<type_list>
<item>string</item>
</type_list>
<values>
<item>'image'</item>
<item>'classification_ground_truth'</item>
<item>'classification_result'</item>
<item>'classification_both'</item>
<item>'segmentation_weight'</item>
<item>'segmentation_weight_map'</item>
<item>'segmentation_confidence'</item>
<item>'segmentation_confidence_map'</item>
<item>'bbox_ground_truth'</item>
<item>'bbox_result'</item>
<item>'bbox_both'</item>
<item>'segmentation_image_ground_truth'</item>
<item>'segmentation_image_result'</item>
<item>'segmentation_image_both'</item>
<item>'segmentation_image_diff'</item>
</values>
</parameter>
<parameter id="WindowHandleDict">
<description lang="en_US">Dictionary containing the window handles to be used.</description>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>dict</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
</parameters>
</docu>
</procedure>
<procedure name="dev_display_dl_data_close_windows">
<interface>
<ic>
<par name="WindowHandleDict" base_type="ctrl" dimension="0"/>
</ic>
</interface>
<body>
<c>* </c>
<c>* This procedure closes all window handles</c>
<c>* that are contained in the dictionary WindowHandleDict.</c>
<c>* </c>
<l>dev_close_window_dict (WindowHandleDict)</l>
<c>* </c>
<l>return ()</l>
</body>
<docu id="dev_display_dl_data_close_windows">
<abstract lang="en_US">This procedure closes all windows whose handle is contained in the dictionary WindowHandleDict. </abstract>
<chapters lang="de_DE">
<item>Deep Learning</item>
<item>Modell</item>
</chapters>
<chapters lang="en_US">
<item>Deep Learning</item>
<item>Model</item>
</chapters>
<library lang="en_US">MVTec Standard Procedures</library>
<short lang="en_US">Close all windows whose handle is contained in the dictionary WindowHandleDict.</short>
<parameters>
<parameter id="WindowHandleDict">
<default_type>integer</default_type>
<description lang="en_US">All windows with a handle contained in this dictionary are to be closed.</description>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>dict</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
</parameters>
</docu>
</procedure>
<procedure name="dev_display_dl_data_tiled">
<interface>
<ic>
<par name="DLDataset" base_type="ctrl" dimension="0"/>
<par name="DLModelHandle" base_type="ctrl" dimension="0"/>
<par name="NumSamples" base_type="ctrl" dimension="0"/>
<par name="Split" base_type="ctrl" dimension="0"/>
<par name="GenParam" base_type="ctrl" dimension="0"/>
<par name="WindowHandle" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="WindowHandleOut" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c>* </c>
<c>* This procedure visualizes samples, their ground truth annotations, and,</c>
<c>* if not deactivated, the results obtained by applying the model given by DLModelHandle.</c>
<c>* </c>
<c>* ** Set the default values for all the generic parameters: ***</c>
<c>* </c>
<l>BackGroundColor := '#ffffff'</l>
<l>SpacingRow := 0</l>
<l>SpacingCol := 0</l>
<l>WindowRow := 0</l>
<l>WindowCol := 0</l>
<l>WindowWidth := 640</l>
<l>WindowHeight := 480</l>
<c>* For model of type detection and segmentation, it is displayed:</c>
<c>* - the plain input images in the first row,</c>
<c>* - the image and their ground truth annotations in the second row,</c>
<c>* - the image and their inference results in the third row.</c>
<c>* </c>
<c>* For models of type classification, it is displayed:</c>
<c>* - the input image with a prediction box.</c>
<l>IncludeImage := true</l>
<l>IncludeGroundTruth := true</l>
<l>IncludeResults := true</l>
<c>* </c>
<l>if (|GenParam| == 1)</l>
<l>    get_dict_param (GenParam, 'keys', [], Keys)</l>
<l>    for Index := 0 to |Keys| - 1 by 1</l>
<l>        Key := Keys[Index]</l>
<l>        get_dict_tuple (GenParam, Key, Value)</l>
<l>        if (Key == 'background_color')</l>
<l>            BackGroundColor := Value</l>
<l>        elseif (Key == 'spacing_row')</l>
<l>            SpacingRow := Value</l>
<l>        elseif (Key == 'spacing_col')</l>
<l>            SpacingCol := Value</l>
<l>        elseif (Key == 'window_width')</l>
<l>            WindowWidth := Value</l>
<l>        elseif (Key == 'window_height')</l>
<l>            WindowHeight := Value</l>
<l>        elseif (Key == 'window_row')</l>
<l>            WindowRow := Value</l>
<l>        elseif (Key == 'window_col')</l>
<l>            WindowCol := Value</l>
<l>        elseif (Key == 'display_input')</l>
<l>            IncludeImage := Value</l>
<l>        elseif (Key == 'display_ground_truth')</l>
<l>            IncludeGroundTruth := Value</l>
<l>        elseif (Key == 'display_result')</l>
<l>            IncludeResults := Value</l>
<l>        endif</l>
<l>    endfor</l>
<l>endif</l>
<c>* </c>
<c>* If a model was handed over, get model type.</c>
<l>if (DLModelHandle != [])</l>
<l>    get_dl_model_param (DLModelHandle, 'type', ModelType)</l>
<l>    if (ModelType != 'classification' and ModelType != 'detection' and ModelType != 'segmentation')</l>
<l>        throw ('Invalid model type')</l>
<l>    endif</l>
<l>else</l>
<c>    * </c>
<c>    * If no model was handed over, results are not displayed.</c>
<l>    IncludeResults := false</l>
<c>    * Conclude the model type from the existing keys.</c>
<l>    get_dict_tuple (DLDataset, 'samples', Samples)</l>
<l>    get_dict_param (Samples[0], 'key_exists', 'image_label_id', ClassificationLabelExists)</l>
<l>    get_dict_param (Samples[0], 'key_exists', 'bbox_label_id', DetectionLabelExists)</l>
<l>    get_dict_param (Samples[0], 'key_exists', 'segmentation_file_name', SegmentationLabelExists)</l>
<l>    if (ClassificationLabelExists)</l>
<l>        ModelType := 'classification'</l>
<l>    elseif (DetectionLabelExists)</l>
<l>        ModelType := 'detection'</l>
<l>    elseif (SegmentationLabelExists)</l>
<l>        ModelType := 'segmentation'</l>
<l>    else</l>
<l>        throw ('Cannot conclude model type from DLDataset.')</l>
<l>    endif</l>
<l>endif</l>
<c>* </c>
<c>* ** Generate results for a random subset of NumSamples-many samples: ***</c>
<c>* </c>
<c>* Select random samples.</c>
<l>get_dict_tuple (DLDataset, 'samples', DLSamples)</l>
<l>find_dl_samples (DLSamples, 'split', Split, 'or', SampleIndices)</l>
<l>tuple_shuffle (SampleIndices, SampleIndices)</l>
<c></c>
<c>* Make sure that NumSamples is not bigger than the found number of SampleIndices</c>
<l>NumSamples := min2(NumSamples,|SampleIndices|)</l>
<c>* </c>
<c>* Calculate the result for the selected samples.</c>
<l>NumSamples := min2(NumSamples,|SampleIndices|)</l>
<l>SampleIndices := SampleIndices[0:NumSamples - 1]</l>
<c>* </c>
<l>if (IncludeResults)</l>
<l>    read_dl_samples (DLDataset, SampleIndices, DLSamples)</l>
<l>    apply_dl_model (DLModelHandle, DLSamples, [], DLResult)</l>
<l>    DLResult := DLResult[0:NumSamples - 1]</l>
<l>    DLSamples := DLSamples[0:NumSamples - 1]</l>
<l>else</l>
<l>    read_dl_samples (DLDataset, SampleIndices, DLSamples)</l>
<l>endif</l>
<c>* </c>
<c>* ** Generate the tiled image and the tiled result data: ***</c>
<c>* </c>
<l>get_dict_tuple (DLDataset, 'class_ids', ClassIDs)</l>
<c>* For segmentation models, we need a class ID that is not present in class_ids, to</c>
<c>* mark regions without region visualization.</c>
<l>BackGroundClass := max(ClassIDs) + 1</l>
<l>RGB := [number('0x' + BackGroundColor{1:2}),number('0x' + BackGroundColor{3:4}),number('0x' + BackGroundColor{5:6})]</l>
<c>* </c>
<l>gen_empty_obj (FinalRows)</l>
<c>* </c>
<c>* Generate the tiled sample image.</c>
<l>gen_empty_obj (SampleImages)</l>
<l>for Index := 0 to NumSamples - 1 by 1</l>
<l>    get_dict_object (SampleImage, DLSamples[Index], 'image')</l>
<l>    count_channels (SampleImage, Channels)</l>
<l>    if (Channels != 3)</l>
<c>        * For any number of channels, that is not three, just use the first channel.</c>
<l>        access_channel (SampleImage, FirstChannel, 1)</l>
<l>        compose3 (FirstChannel, FirstChannel, FirstChannel, SampleImage)</l>
<l>    endif</l>
<c>    * Convert the images back to byte.</c>
<l>    scale_image (SampleImage, ImageScaled, 1, 127)</l>
<l>    convert_image_type (ImageScaled, ImageConverted, 'byte')</l>
<c>    * Add the image to to the tuple SampleImages.</c>
<l>    concat_obj (SampleImages, ImageConverted, SampleImages)</l>
<l>endfor</l>
<c>* Tile the images in a row.</c>
<l>get_image_size (SampleImages, Width, Height)</l>
<l>tuple_gen_const (|Width|, -1, Crop)</l>
<l>tuple_gen_const (|Width|, 0, OffsetRow)</l>
<l>if (ModelType == 'detection' or ModelType == 'segmentation')</l>
<l>    tile_images_offset (SampleImages, TiledImageRow, OffsetRow, [0,cumul(Width + SpacingCol)][0:|Width| - 1], Crop, Crop, Crop, Crop, cumul(Width + SpacingCol)[|Width| - 1] - SpacingCol, max(Height))</l>
<l>endif</l>
<c>* </c>
<c>* Generate the columns of images for the tiled output.</c>
<l>if (IncludeImage)</l>
<l>    if (ModelType == 'classification')</l>
<l>        throw ('The key \'display_input\' cannot be set for model type classification.')</l>
<l>        return ()</l>
<l>    endif</l>
<l>    concat_obj (FinalRows, TiledImageRow, FinalRows)</l>
<l>endif</l>
<l>if (IncludeGroundTruth)</l>
<l>    if (ModelType == 'classification')</l>
<l>        throw ('The key \'display_ground_truth\' cannot be set for model type classification.')</l>
<l>        return ()</l>
<l>    endif</l>
<l>    concat_obj (FinalRows, TiledImageRow, FinalRows)</l>
<l>endif</l>
<l>if (ModelType == 'detection' or ModelType == 'segmentation')</l>
<l>    if (IncludeResults)</l>
<l>        concat_obj (FinalRows, TiledImageRow, FinalRows)</l>
<l>    endif</l>
<l>    get_image_size (FinalRows, TiledWidth, TiledHeight)</l>
<l>    tile_images_offset (FinalRows, TiledImage, [0,cumul(TiledHeight + SpacingRow)][0:|TiledHeight| - 1], gen_tuple_const(|TiledHeight|,0), gen_tuple_const(|TiledHeight|,-1), gen_tuple_const(|TiledHeight|,-1), gen_tuple_const(|TiledHeight|,-1), gen_tuple_const(|TiledHeight|,-1), max(TiledWidth), cumul(TiledHeight + SpacingRow)[|TiledHeight| - 1] - SpacingRow)</l>
<c>    * Fill up with the background color.</c>
<l>    get_domain (TiledImage, Domain)</l>
<l>    full_domain (TiledImage, TiledImage)</l>
<l>    complement (Domain, RegionComplement)</l>
<l>    overpaint_region (TiledImage, RegionComplement, RGB, 'fill')</l>
<l>endif</l>
<c>* </c>
<c>* Generate the tiled data (classification prediction / segmentation regions / detection bounding boxes).</c>
<l>if (ModelType == 'classification')</l>
<c>    * </c>
<c>    * For classification results the image is shown within a colored frame.</c>
<c>    * </c>
<l>    gen_empty_obj (FinalRows)</l>
<c>    * </c>
<l>    if (IncludeResults)</l>
<l>        tuple_length (DLResult, NumResult)</l>
<l>        PredictionsCorrect := []</l>
<l>        ImageConfidences := []</l>
<l>        ResClassIndices := []</l>
<l>        ResClasses := []</l>
<l>        ImageIDs := []</l>
<l>        ImageLabelIDs := []</l>
<c>        * </c>
<l>        for IndexResult := 0 to NumResult - 1 by 1</l>
<c>            * </c>
<c>            * Get labels and classes.</c>
<l>            get_dict_tuple (DLResult[IndexResult], 'classification_confidences', ImageConfidence)</l>
<l>            get_dict_tuple (DLResult[IndexResult], 'classification_class_ids', ResClassIndex)</l>
<l>            get_dict_tuple (DLResult[IndexResult], 'classification_class_names', ResClass)</l>
<l>            get_dict_tuple (DLSamples[IndexResult], 'image_id', ImageID)</l>
<l>            get_dict_tuple (DLSamples[IndexResult], 'image_label_id', ImageLabelID)</l>
<c>            * </c>
<c>            * Check whether the actual sample prediction is false or correct.</c>
<l>            PredictionCorrect := ResClassIndex[0] == ImageLabelID</l>
<l>            PredictionsCorrect := [PredictionsCorrect,PredictionCorrect]</l>
<l>            ImageConfidences := [ImageConfidences,ImageConfidence[0]]</l>
<l>            ResClassIndices := [ResClassIndices,ResClassIndex[0]]</l>
<l>            ResClasses := [ResClasses,ResClass[0]]</l>
<l>            ImageIDs := [ImageIDs,ImageID]</l>
<l>            ImageLabelIDs := [ImageLabelIDs,ImageLabelID]</l>
<l>        endfor</l>
<c>        * </c>
<c>        * Tile the sample images.</c>
<l>        gen_tiled_classification_image_result (TiledImageRow, DLSamples, SpacingCol, PredictionsCorrect, ResClasses, TextImageRows, TextImageColumns, TextImageWidth, TextImageHeight)</l>
<l>        concat_obj (FinalRows, TiledImageRow, FinalRows)</l>
<l>    endif</l>
<l>    get_image_size (FinalRows, TiledWidth, TiledHeight)</l>
<l>    TiledImage := TiledImageRow</l>
<c>    * </c>
<l>elseif (ModelType == 'detection')</l>
<c>    * </c>
<c>    * For detection results the detected boxes must be moved</c>
<c>    * to the positions of the respective image.</c>
<l>    TopOffset := 0</l>
<l>    if (IncludeImage)</l>
<l>        TopOffset := TopOffset + SpacingRow + TiledHeight[0]</l>
<l>    endif</l>
<c>    * Check the detection type.</c>
<l>    if (|DLModelHandle| &gt; 0)</l>
<l>        get_dl_model_param (DLModelHandle, 'instance_type', InstanceType)</l>
<l>    else</l>
<l>        get_dict_param (DLSamples[0], 'key_exists', 'bbox_row1', Rect1KeyExists)</l>
<l>        if (Rect1KeyExists)</l>
<l>            InstanceType := 'rectangle1'</l>
<l>        else</l>
<l>            get_dict_param (DLSamples[0], 'key_exists', 'bbox_phi', Rect2KeyExists)</l>
<l>            if (Rect2KeyExists)</l>
<l>                InstanceType := 'rectangle2'</l>
<l>            else</l>
<l>                throw ('Not suitable sample keys!')</l>
<l>            endif</l>
<l>        endif</l>
<l>    endif</l>
<c>    * Move the ground truth labels.</c>
<l>    GTLabel := []</l>
<l>    if (InstanceType == 'rectangle1')</l>
<l>        GTCol1 := []</l>
<l>        GTRow1 := []</l>
<l>        GTCol2 := []</l>
<l>        GTRow2 := []</l>
<l>    else</l>
<l>        GTCol := []</l>
<l>        GTRow := []</l>
<l>        GTLength1 := []</l>
<l>        GTLength2 := []</l>
<l>        GTPhi := []</l>
<l>    endif</l>
<l>    if (IncludeGroundTruth)</l>
<l>        LeftOffset := 0</l>
<l>        for Index := 0 to NumSamples - 1 by 1</l>
<l>            get_dict_tuple (DLSamples[Index], 'bbox_label_id', LabelId)</l>
<l>            GTLabel := [GTLabel,LabelId]</l>
<l>            if (InstanceType == 'rectangle1')</l>
<l>                get_dict_tuple (DLSamples[Index], 'bbox_col1', Col1)</l>
<l>                GTCol1 := [GTCol1,Col1 + LeftOffset]</l>
<l>                get_dict_tuple (DLSamples[Index], 'bbox_row1', Row1)</l>
<l>                GTRow1 := [GTRow1,Row1 + TopOffset]</l>
<l>                get_dict_tuple (DLSamples[Index], 'bbox_col2', Col2)</l>
<l>                GTCol2 := [GTCol2,Col2 + LeftOffset]</l>
<l>                get_dict_tuple (DLSamples[Index], 'bbox_row2', Row2)</l>
<l>                GTRow2 := [GTRow2,Row2 + TopOffset]</l>
<l>            else</l>
<l>                get_dict_tuple (DLSamples[Index], 'bbox_col', Col)</l>
<l>                GTCol := [GTCol,Col + LeftOffset]</l>
<l>                get_dict_tuple (DLSamples[Index], 'bbox_row', Row)</l>
<l>                GTRow := [GTRow,Row + TopOffset]</l>
<l>                get_dict_tuple (DLSamples[Index], 'bbox_length1', Length1)</l>
<l>                GTLength1 := [GTLength1,Length1]</l>
<l>                get_dict_tuple (DLSamples[Index], 'bbox_length2', Length2)</l>
<l>                GTLength2 := [GTLength2,Length2]</l>
<l>                get_dict_tuple (DLSamples[Index], 'bbox_phi', Phi)</l>
<l>                GTPhi := [GTPhi,Phi]</l>
<l>            endif</l>
<l>            LeftOffset := LeftOffset + SpacingCol + Width[Index]</l>
<l>        endfor</l>
<l>        TopOffset := TopOffset + SpacingRow + TiledHeight[0]</l>
<l>    endif</l>
<l>    ResClass := []</l>
<l>    ResConfidence := []</l>
<l>    if (InstanceType == 'rectangle1')</l>
<l>        ResCol1 := []</l>
<l>        ResRow1 := []</l>
<l>        ResCol2 := []</l>
<l>        ResRow2 := []</l>
<l>    else</l>
<l>        ResCol := []</l>
<l>        ResRow := []</l>
<l>        ResLength1 := []</l>
<l>        ResLength2 := []</l>
<l>        ResPhi := []</l>
<l>    endif</l>
<c>    * Move the result classes.</c>
<l>    if (IncludeResults)</l>
<l>        LeftOffset := 0</l>
<l>        for Index := 0 to NumSamples - 1 by 1</l>
<l>            get_dict_tuple (DLResult[Index], 'bbox_class_id', ClassId)</l>
<l>            ResClass := [ResClass,ClassId]</l>
<l>            get_dict_tuple (DLResult[Index], 'bbox_confidence', Confidence)</l>
<l>            ResConfidence := [ResConfidence,Confidence]</l>
<l>            if (InstanceType == 'rectangle1')</l>
<l>                get_dict_tuple (DLResult[Index], 'bbox_col1', Col1)</l>
<l>                ResCol1 := [ResCol1,Col1 + LeftOffset]</l>
<l>                get_dict_tuple (DLResult[Index], 'bbox_row1', Row1)</l>
<l>                ResRow1 := [ResRow1,Row1 + TopOffset]</l>
<l>                get_dict_tuple (DLResult[Index], 'bbox_col2', Col2)</l>
<l>                ResCol2 := [ResCol2,Col2 + LeftOffset]</l>
<l>                get_dict_tuple (DLResult[Index], 'bbox_row2', Row2)</l>
<l>                ResRow2 := [ResRow2,Row2 + TopOffset]</l>
<l>            else</l>
<l>                get_dict_tuple (DLResult[Index], 'bbox_col', Col)</l>
<l>                ResCol := [ResCol,Col + LeftOffset]</l>
<l>                get_dict_tuple (DLResult[Index], 'bbox_row', Row)</l>
<l>                ResRow := [ResRow,Row + TopOffset]</l>
<l>                get_dict_tuple (DLResult[Index], 'bbox_length1', Length1)</l>
<l>                ResLength1 := [ResLength1,Length1]</l>
<l>                get_dict_tuple (DLResult[Index], 'bbox_length2', Length2)</l>
<l>                ResLength2 := [ResLength2,Length2]</l>
<l>                get_dict_tuple (DLResult[Index], 'bbox_phi', Phi)</l>
<l>                ResPhi := [ResPhi,Phi]</l>
<l>            endif</l>
<l>            LeftOffset := LeftOffset + SpacingCol + Width[Index]</l>
<l>        endfor</l>
<l>    endif</l>
<c>    * </c>
<l>elseif (ModelType == 'segmentation')</l>
<c>    * </c>
<c>    * The tiled segmentation result image is constructed in the same way as the tiled sample image.</c>
<l>    gen_empty_obj (FinalRows)</l>
<l>    if (IncludeImage)</l>
<l>        gen_image_const (Image, 'real', TiledWidth[0], TiledHeight[0])</l>
<c>        * For the top (image) row, set the (virtual) background class as segmentation result.</c>
<l>        gen_image_proto (Image, ImageCleared, BackGroundClass)</l>
<l>        concat_obj (FinalRows, ImageCleared, FinalRows)</l>
<l>    endif</l>
<c>    * </c>
<l>    if (IncludeGroundTruth)</l>
<l>        gen_tiled_segmentation_image (TiledImageRow, DLSamples, SpacingCol, Width, Height)</l>
<l>        concat_obj (FinalRows, TiledImageRow, FinalRows)</l>
<l>    endif</l>
<c>    * </c>
<l>    if (IncludeResults)</l>
<l>        gen_tiled_segmentation_image (TiledImageRow, DLResult, SpacingCol, Width, Height)</l>
<l>        concat_obj (FinalRows, TiledImageRow, FinalRows)</l>
<l>    endif</l>
<l>    get_image_size (FinalRows, TiledWidth, TiledHeight)</l>
<l>    tile_images_offset (FinalRows, TiledResult, [0,cumul(TiledHeight + SpacingRow)][0:|TiledHeight| - 1], gen_tuple_const(|TiledHeight|,0), gen_tuple_const(|TiledHeight|,-1), gen_tuple_const(|TiledHeight|,-1), gen_tuple_const(|TiledHeight|,-1), gen_tuple_const(|TiledHeight|,-1), max(TiledWidth), cumul(TiledHeight + SpacingRow)[|TiledHeight| - 1] - SpacingRow)</l>
<c>    * Fill up with the background color.</c>
<l>    get_domain (TiledResult, Domain)</l>
<l>    full_domain (TiledResult, TiledResult)</l>
<l>    complement (Domain, RegionComplement)</l>
<l>    overpaint_region (TiledResult, RegionComplement, BackGroundClass, 'fill')</l>
<l>endif</l>
<c>* </c>
<c>* ** Generate a TiledDLSample and a TiledDLResult to display them with dev_display_dl_data: ***</c>
<c>* </c>
<c>* Generate a tiled DLSample.</c>
<l>if (ModelType == 'classification')</l>
<l>    gen_dl_samples_from_images (TiledImage, TiledDLSample)</l>
<l>    set_dict_tuple (TiledDLSample, 'image_id', ImageID)</l>
<l>    set_dict_tuple (TiledDLSample, 'image_label_id', ImageLabelID)</l>
<l>elseif (ModelType == 'detection')</l>
<l>    gen_dl_samples_from_images (TiledImage, TiledDLSample)</l>
<l>    set_dict_tuple (TiledDLSample, 'bbox_label_id', GTLabel)</l>
<l>    if (InstanceType == 'rectangle1')</l>
<l>        set_dict_tuple (TiledDLSample, 'bbox_col1', GTCol1)</l>
<l>        set_dict_tuple (TiledDLSample, 'bbox_row1', GTRow1)</l>
<l>        set_dict_tuple (TiledDLSample, 'bbox_col2', GTCol2)</l>
<l>        set_dict_tuple (TiledDLSample, 'bbox_row2', GTRow2)</l>
<l>    else</l>
<l>        set_dict_tuple (TiledDLSample, 'bbox_col', GTCol)</l>
<l>        set_dict_tuple (TiledDLSample, 'bbox_row', GTRow)</l>
<l>        set_dict_tuple (TiledDLSample, 'bbox_length1', GTLength1)</l>
<l>        set_dict_tuple (TiledDLSample, 'bbox_length2', GTLength2)</l>
<l>        set_dict_tuple (TiledDLSample, 'bbox_phi', GTPhi)</l>
<l>    endif</l>
<l>elseif (ModelType == 'segmentation')</l>
<l>    gen_dl_samples_from_images (TiledImage, TiledDLSample)</l>
<l>endif</l>
<c>* </c>
<c>* Generate a tiled DLResult.</c>
<l>create_dict (TiledDLResult)</l>
<l>if (ModelType == 'classification')</l>
<l>    set_dict_tuple (TiledDLResult, 'image_class_id', ResClassIndices[0])</l>
<l>    set_dict_tuple (TiledDLResult, 'image_confidence', ImageConfidences)</l>
<l>elseif (ModelType == 'segmentation')</l>
<l>    set_dict_object (TiledResult, TiledDLResult, 'segmentation_image')</l>
<l>elseif (ModelType == 'detection')</l>
<l>    set_dict_tuple (TiledDLResult, 'bbox_class_id', ResClass)</l>
<l>    set_dict_tuple (TiledDLResult, 'bbox_confidence', ResConfidence)</l>
<l>    if (InstanceType == 'rectangle1')</l>
<l>        set_dict_tuple (TiledDLResult, 'bbox_col1', ResCol1)</l>
<l>        set_dict_tuple (TiledDLResult, 'bbox_row1', ResRow1)</l>
<l>        set_dict_tuple (TiledDLResult, 'bbox_col2', ResCol2)</l>
<l>        set_dict_tuple (TiledDLResult, 'bbox_row2', ResRow2)</l>
<l>    else</l>
<l>        set_dict_tuple (TiledDLResult, 'bbox_col', ResCol)</l>
<l>        set_dict_tuple (TiledDLResult, 'bbox_row', ResRow)</l>
<l>        set_dict_tuple (TiledDLResult, 'bbox_length1', ResLength1)</l>
<l>        set_dict_tuple (TiledDLResult, 'bbox_length2', ResLength2)</l>
<l>        set_dict_tuple (TiledDLResult, 'bbox_phi', ResPhi)</l>
<l>    endif</l>
<l>endif</l>
<c>* </c>
<c>* Set display parameters.</c>
<l>create_dict (GenParam)</l>
<c>* Pinch off all text display from dev_display_dl_data for a clutterless visualization.</c>
<l>set_dict_tuple (GenParam, 'display_bottom_desc', false)</l>
<l>set_dict_tuple (GenParam, 'display_legend', false)</l>
<l>set_dict_tuple (GenParam, 'display_labels', false)</l>
<l>if (ModelType == 'detection' and |DLModelHandle| &gt; 0)</l>
<c>    * Don't display directions if 'ignore_direction' is set to 'true'.</c>
<l>    get_dl_model_param (DLModelHandle, 'ignore_direction', IgnoreDirection)</l>
<l>    if (IgnoreDirection == 'true')</l>
<l>        set_dict_tuple (GenParam, 'display_direction', false)</l>
<l>    endif</l>
<l>endif</l>
<c>* </c>
<c>* Initialize the window for displaying the tiled comparison of input and result.</c>
<l>create_dict (WindowHandleDict)</l>
<l>if (|WindowHandle| == 0)</l>
<l>    get_image_size (TiledImage, Width, Height)</l>
<l>    dev_open_window_fit_size (WindowRow, WindowCol, Width, Height, WindowWidth, WindowHeight, WindowHandle)</l>
<l>endif</l>
<l>get_window_param (WindowHandle, 'flush', Flush)</l>
<l>if (Flush == 'true')</l>
<l>    set_window_param (WindowHandle, 'flush', 'false')</l>
<l>endif</l>
<l>set_window_param (WindowHandle, 'background_color', BackGroundColor)</l>
<l>dev_set_window (WindowHandle)</l>
<l>dev_clear_window ()</l>
<l>WindowHandleOut := WindowHandle</l>
<c>* </c>
<l>if (ModelType == 'classification')</l>
<l>    KeyForDisplay := 'image'</l>
<l>elseif (ModelType == 'segmentation')</l>
<l>    KeyForDisplay := 'segmentation_image_result'</l>
<l>elseif (ModelType == 'detection')</l>
<l>    KeyForDisplay := 'bbox_both'</l>
<l>endif</l>
<c>* </c>
<l>set_dict_tuple (WindowHandleDict, KeyForDisplay, WindowHandle)</l>
<c>* </c>
<c>* Display the tiled image.</c>
<l>dev_display_dl_data (TiledDLSample, TiledDLResult, DLDataset, KeyForDisplay, GenParam, WindowHandleDict)</l>
<c>* </c>
<c>* For classification, display additional text.</c>
<l>if (ModelType == 'classification')</l>
<l>    get_image_size (TiledImage, Width, Height)</l>
<l>    for Index := 0 to NumSamples - 1 by 1</l>
<l>        GTText := 'Ground truth: ' + ImageLabelIDs[Index]</l>
<l>        PredictionText := 'Prediction: ' + ResClassIndices[Index]</l>
<l>        get_string_extents (WindowHandle, GTText, _, _, GTWidth, TextHeight)</l>
<l>        get_string_extents (WindowHandle, PredictionText, _, _, PredictionWidth, _)</l>
<c>        * Get ratio between image and window coordinate system.</c>
<l>        get_window_extents (WindowHandle, _, _, WindowWidth, WindowHeight)</l>
<c>        * Adapt widths of texts to plot it correctly in window coordinate system.</c>
<l>        if (Height / real(Width) &gt; WindowHeight / real(WindowWidth))</l>
<l>            WindowImageRatio := 1.0 / (WindowHeight / real(Height[0]))</l>
<l>        else</l>
<l>            WindowImageRatio := 1.0 / (WindowWidth / real(Width[0]))</l>
<l>        endif</l>
<l>        if (TextImageWidth &lt; (GTWidth + PredictionWidth) * WindowImageRatio + 30)</l>
<c>            * Make shorter text.</c>
<l>            GTText := 'GT: ' + ImageLabelIDs[Index]</l>
<l>            PredictionText := 'Pred.: ' + ResClassIndices[Index]</l>
<l>            get_string_extents (WindowHandle, GTText, _, _, GTWidth, TextHeight)</l>
<l>            get_string_extents (WindowHandle, PredictionText, _, _, PredictionWidth, _)</l>
<l>        endif</l>
<l>        dev_disp_text (GTText, 'image', TextImageRows[Index] + TextImageHeight / 2 - TextHeight, TextImageColumns[Index] + 10, 'white', 'box', 'false')</l>
<l>        dev_disp_text (PredictionText, 'image', TextImageRows[Index] + TextImageHeight / 2 - TextHeight, TextImageColumns[Index] + TextImageWidth - PredictionWidth * WindowImageRatio - 10, 'white', 'box', 'false')</l>
<l>    endfor</l>
<l>endif</l>
<c>* </c>
<l>if (Flush == 'true')</l>
<c>    * Only flush the window, if 'flush' is 'true'. Otherwise the caller</c>
<c>    * (who set flush to 'false' on purpose) is responsible for flushing.</c>
<l>    flush_buffer (WindowHandle)</l>
<l>endif</l>
<l>set_window_param (WindowHandle, 'flush', Flush)</l>
<c>* </c>
<l>return ()</l>
</body>
<docu id="dev_display_dl_data_tiled">
<abstract lang="en_US">This procedure visualizes samples. Depending on the model type, also ground truth annotations are displayed. If not deactivated, the results obtained by applying the model given by DLModelHandle are displayed as well.

DLDataset is the dictionary with all information about the dataset out of which the samples to be shown are taken.
NumSamples is an integer determining how many random samples are shown.
Split is a string specifying from which subset the samples are taken, thus the subset given under the key 'split'.
WindowHandle determines the handle for the window of the visualizations. If an empty tuple is passed, a new window is opened.
WindowHandleOut returns the handle of the window used for the display.

Handing over an empty tuple, [], instead of a DLModelHandle results in visualization of the ground truth annotations only.

For model types 'detection' and 'segmentation': The different samples are shown in columns, while the different images for a sample, the raw input image, the ground truth annotations, and the inferred results, are shown in different rows.
For model type 'classification': The different samples are shown in a matrix or single row (dependent on NumSamples). For a single sample the raw input image and the inferred prediction is shown within a color box (red color frame with a red cross for a false prediction, green color frame a with a green checkmark for a correct prediction).

Note, if it is wished to display the results, they are inferred for the given samples within this procedure by calling the apply_dl_model operator. See also the options of GenParam.
The model has to be of type 'classification', 'detection', or 'segmentation'.

The display can be customized through specifications in GenParam. The following entries are possible:
 - 'background_color' (default: '#ffffff'): String, determining the color of the spacing areas as hexadecimal number within an RGB triplet.
 - 'display_input' (default: true): Determines if the raw input images are shown (true) or not (false) (only for model type 'detection' and 'segmentation').
 - 'display_ground_truth' (default: true): Determines if the ground truth annotations are shown (true) or not (false) (only for model type 'detection' and 'segmentation').
 - 'display_result' (default: true): Determines if results are inferred and displayed (true) or not (false). 
 - 'spacing_col' (default: 0): Integer, setting the number of pixels used to separate the columns in the tiled visualization.
 - 'spacing_row' (default: 0): Integer, setting the number of pixels used to separate the rows in the tiled visualization.
 - 'window_row', 'window_col', 'window_width', 'window_height': These parameters define the position and size of a new window,
    if one is opened by an internal call of dev_open_window_fit_size.
    Latter one is the case for the first opening of a window, i.e., when an empty tuple is provided for WindowHandle.
    The default values are 0, 0, 640, 480, for possible values and ranges, please see dev_open_window_fit_size.</abstract>
<chapters lang="de_DE">
<item>Deep Learning</item>
<item>Modell</item>
</chapters>
<chapters lang="en_US">
<item>Deep Learning</item>
<item>Model</item>
</chapters>
<library lang="en_US">MVTec Standard Procedures</library>
<short lang="en_US">Visualize for a given number of samples the raw image, ground truth annotation, and inferred results.</short>
<parameters>
<parameter id="DLDataset">
<default_type>integer</default_type>
<description lang="en_US">Dictionary containing the dataset.</description>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>dict</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="DLModelHandle">
<default_type>integer</default_type>
<description lang="en_US">Handle of the deep-learning-based model.</description>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>dl_model</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="GenParam">
<default_value>[]</default_value>
<description lang="en_US">Dictionary containing the generic parameters used to customize the display.</description>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>any</sem_type>
</parameter>
<parameter id="NumSamples">
<default_type>integer</default_type>
<default_value>3</default_value>
<description lang="en_US">Number of samples to visualize.</description>
<multivalue>false</multivalue>
<sem_type>integer</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="Split">
<default_type>string</default_type>
<default_value>test</default_value>
<description lang="en_US">Determines from which subset the samples are taken, thus the subset given under the key 'split'.</description>
<multivalue>false</multivalue>
<sem_type>string</sem_type>
<type_list>
<item>string</item>
</type_list>
<values>
<item>train</item>
<item>test</item>
<item>validation</item>
</values>
</parameter>
<parameter id="WindowHandle">
<default_type>integer</default_type>
<default_value>[]</default_value>
<description lang="en_US">Input window handle.</description>
<mixed_type>false</mixed_type>
<multivalue>optional</multivalue>
<sem_type>window</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="WindowHandleOut">
<default_type>integer</default_type>
<description lang="en_US">Output window handle.</description>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>window</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
</parameters>
</docu>
</procedure>
<procedure name="dev_display_dl_interactive_confusion_matrix">
<interface>
<ic>
<par name="DLDataset" base_type="ctrl" dimension="0"/>
<par name="EvaluationResult" base_type="ctrl" dimension="0"/>
<par name="GenParam" base_type="ctrl" dimension="0"/>
</ic>
</interface>
<body>
<c>* </c>
<c>* This procedure displays a confusion matrix that can be used interactively to display samples.</c>
<c>* </c>
<c>* Set generic parameter defaults.</c>
<l>DisplayMatrix := 'absolute'</l>
<l>DisplayColor := true</l>
<l>DisplayColumnWidth := 'equal'</l>
<l>Font := 'mono'</l>
<l>FontSize := 14</l>
<c>* </c>
<c>* Handle the generic parameters.</c>
<l>GenParamDevData := []</l>
<l>if (|GenParam| &gt; 0)</l>
<c>    * </c>
<c>    * Possible keys for generic parameters of this procedure and common keys with dev_display_dl_data.</c>
<l>    GenParamKeysOnlyInteractive := ['display_matrix','display_color','display_column_width']</l>
<l>    GenParamKeysCommon := ['font','font_size']</l>
<l>    GenParamKeysInteractive := [GenParamKeysOnlyInteractive,GenParamKeysCommon]</l>
<c>    * All other keys are expected to be generic parameters for dev_display_dl_data.</c>
<l>    copy_dict (GenParam, [], [], GenParamDevData)</l>
<l>    for Index := 0 to |GenParamKeysOnlyInteractive| - 1 by 1</l>
<l>        try</l>
<l>            remove_dict_key (GenParamDevData, GenParamKeysOnlyInteractive[Index])</l>
<l>        catch (Exception)</l>
<l>        endtry</l>
<l>    endfor</l>
<l>    get_dict_param (GenParam, 'key_exists', GenParamKeysInteractive[0], DisplayMatrixExists)</l>
<l>    get_dict_param (GenParam, 'key_exists', GenParamKeysInteractive[1], DisplayColorExists)</l>
<l>    get_dict_param (GenParam, 'key_exists', GenParamKeysInteractive[2], DisplayColumnWidthExists)</l>
<l>    get_dict_param (GenParam, 'key_exists', GenParamKeysInteractive[3], FontExists)</l>
<l>    get_dict_param (GenParam, 'key_exists', GenParamKeysInteractive[4], FontSizeExists)</l>
<c>    * Set display matrix.</c>
<l>    if (DisplayMatrixExists)</l>
<l>        get_dict_tuple (GenParam, 'display_matrix', DisplayMatrix)</l>
<l>        if (|DisplayMatrix| != 1 or find(['absolute','relative'],DisplayMatrix) == -1)</l>
<l>            throw ('Invalid value for \'display_matrix\'')</l>
<l>        endif</l>
<l>    endif</l>
<c>    * Set display color.</c>
<l>    if (DisplayColorExists)</l>
<l>        get_dict_tuple (GenParam, 'display_color', DisplayColor)</l>
<l>        if (|DisplayColor| != 1 or find(['true','false'],DisplayColor) == -1)</l>
<l>            throw ('Invalid value for \'display_color\'')</l>
<l>        else</l>
<l>            if (DisplayColor == 'true')</l>
<l>                DisplayColor := true</l>
<l>            else</l>
<l>                DisplayColor := false</l>
<l>            endif</l>
<l>        endif</l>
<l>    endif</l>
<c>    * Set display column width.</c>
<l>    if (DisplayColumnWidthExists)</l>
<l>        get_dict_tuple (GenParam, 'display_column_width', DisplayColumnWidth)</l>
<l>        if (|DisplayColumnWidth| != 1 or find(['equal','minimal'],DisplayColumnWidth) == -1)</l>
<l>            throw ('Invalid value for \'display_column_width\'')</l>
<l>        endif</l>
<l>    endif</l>
<c>    * Set font.</c>
<l>    if (FontExists)</l>
<l>        get_dict_tuple (GenParam, 'font', Font)</l>
<l>    endif</l>
<c>    * Set font size.</c>
<l>    if (FontSizeExists)</l>
<l>        get_dict_tuple (GenParam, 'font_size', FontSize)</l>
<l>        if (FontSize &lt; 8 or FontSize &gt; 64)</l>
<l>            throw ('Key \'font_size\' for font size has to be in range of [8,64]')</l>
<l>        endif</l>
<l>    endif</l>
<l>endif</l>
<c>* </c>
<c>* Get information from DLDataset and EvaluationResult.</c>
<l>get_dict_tuple (DLDataset, 'class_names', ClassNames)</l>
<l>get_dict_tuple (DLDataset, 'class_ids', ClassIDs)</l>
<l>get_dict_tuple (EvaluationResult, 'evaluated_samples', EvaluatedSamples)</l>
<l>get_dict_tuple (EvaluatedSamples, 'image_ids', ImageIDs)</l>
<l>get_dict_tuple (EvaluatedSamples, 'image_label_ids', ImageLabelIDs)</l>
<l>get_dict_tuple (EvaluatedSamples, 'top1_predictions', Predictions)</l>
<c>* Get or calculate confusion matrix.</c>
<l>get_dict_param (EvaluationResult, 'key_exists', DisplayMatrix + '_confusion_matrix', KeyExists)</l>
<l>if (KeyExists)</l>
<l>    get_dict_tuple (EvaluationResult, DisplayMatrix + '_confusion_matrix', ConfusionMatrix)</l>
<l>else</l>
<c>    * Check if all classes are available in the image label IDs.</c>
<l>    if (uniq(sort(ImageLabelIDs)) != sort(ClassIDs))</l>
<l>        throw ('Not all classes are represented in the ground truth labels. \nPlease check your data split.')</l>
<l>    endif</l>
<l>    gen_confusion_matrix (ImageLabelIDs, Predictions, ['display_matrix','return_matrix'], ['none',DisplayMatrix], [], ConfusionMatrix)</l>
<l>endif</l>
<c>* </c>
<c>* Calculate proper number format and convert relative matrix values to percent, if needed.</c>
<l>if (DisplayMatrix == 'relative')</l>
<c>    * To avoid overwritting of the values, copy matrix inplace.</c>
<l>    copy_matrix (ConfusionMatrix, ConfusionMatrix)</l>
<l>    get_full_matrix (ConfusionMatrix, ValuesRelative)</l>
<l>    set_full_matrix (ConfusionMatrix, 100 * ValuesRelative)</l>
<l>    NumberFormat := '3.0f'</l>
<l>else</l>
<l>    max_matrix (ConfusionMatrix, 'full', MatrixMaxID)</l>
<l>    get_full_matrix (MatrixMaxID, MaxValue)</l>
<l>    NumberFormat := int(ceil(log10(MaxValue))) + '.0f'</l>
<l>endif</l>
<c>* </c>
<c>* Cut class names for better visualization and get mapping between class IDs and class names.</c>
<l>if (ClassNames != [])</l>
<c>    * Cut class names.</c>
<l>    MaxChars := 14</l>
<l>    for Index := 0 to |ClassNames| - 1 by 1</l>
<l>        Str := ClassNames[Index]</l>
<l>        tuple_is_string (Str, IsString)</l>
<l>        if (IsString)</l>
<l>            tuple_strlen (Str, Length)</l>
<l>            if (Length &gt; MaxChars)</l>
<l>                SubStr := Str{0:MaxChars - 3} + '...'</l>
<l>                ClassNames[Index] := SubStr</l>
<l>            endif</l>
<l>        endif</l>
<l>    endfor</l>
<c>    * Generate mapping.</c>
<l>    tuple_gen_const (max(ClassIDs), -1, ClassIDsToNamesMapping)</l>
<l>    ClassIDsToNamesMapping[ClassIDs] := [0:|ClassIDs| - 1]</l>
<l>endif</l>
<c>* </c>
<c>* Get color for matrix entries.</c>
<l>ValueColors := gen_tuple_const(|ClassIDs| * |ClassIDs|,'white')</l>
<l>if (DisplayColor)</l>
<c>    * Display off-diagonal values in red.</c>
<l>    ValueColors := gen_tuple_const(|ClassIDs| * |ClassIDs|,'#ff4500')</l>
<c>    * Display diagonal values in green.</c>
<l>    DiagonalColor := '#00ff00'</l>
<l>    tuple_gen_sequence (0, |ClassIDs| - 1, 1, Seq)</l>
<l>    DiagonalIndices := |ClassIDs| * Seq + Seq</l>
<l>    ValueColors[DiagonalIndices] := DiagonalColor</l>
<l>endif</l>
<c>* </c>
<c>* </c>
<c>* * Generate and display interactive confusion matrix.</c>
<c>* </c>
<c>* Open and set new window.</c>
<l>dev_open_window (0, 0, 512, 512, 'black', WindowHandle)</l>
<l>dev_set_window (WindowHandle)</l>
<l>try</l>
<l>    set_display_font (WindowHandle, FontSize, Font, 'false', 'false')</l>
<l>catch (Exception)</l>
<l>    dev_close_window ()</l>
<l>    throw ('No valid font: ' + Font)</l>
<l>endtry</l>
<c>* </c>
<l>ColumnNames := ClassNames</l>
<l>RowNames := ClassNames</l>
<l>AxisTitles := ['Ground Truth','Predicted']</l>
<l>get_size_matrix (ConfusionMatrix, NumRows, NumColumns)</l>
<l>AxisColor := 'light gray'</l>
<l>BoxColor := gen_tuple_const(|ClassNames| * |ClassNames|,'#333333')</l>
<l>HighlightColor := '#fce9d4'</l>
<c>* </c>
<c>* Calculate the width of the name strings.</c>
<l>ColStringWidths := []</l>
<l>MinStringWidth := 1e3</l>
<l>MaxStringWidth := 0</l>
<l>StringHeight := 0</l>
<l>for StringIndex := 0 to |ClassNames| - 1 by 1</l>
<l>    get_string_extents (WindowHandle, ClassNames[StringIndex], _, _, StringWidth, StringHeightTmp)</l>
<l>    ColStringWidths := [ColStringWidths,StringWidth]</l>
<l>    MinStringWidth := min2(MinStringWidth,StringWidth)</l>
<l>    MaxStringWidth := max2(MaxStringWidth,StringWidth)</l>
<l>    StringHeight := max2(StringHeight,StringHeightTmp)</l>
<l>endfor</l>
<c>* The columns should have a minimum width for four characters.</c>
<l>get_string_extents (WindowHandle, 'test', _, _, StringWidth, _)</l>
<l>MaxStringWidth := max2(MaxStringWidth,StringWidth)</l>
<c>* </c>
<c>* Set display parameters, e.g., margin borders, row- and column-offsets.</c>
<l>TitleHeight := 0</l>
<l>AxisTitleHeight := 0</l>
<l>get_string_extents (WindowHandle, AxisTitles, _, _, AxisTitleWidth, AxisTitleHeight)</l>
<l>RowStart := 80 + TitleHeight + AxisTitleHeight</l>
<l>RowDistance := StringHeight + 10</l>
<l>RowEnd := StringHeight * 7</l>
<l>ColumnStart := 50 + MaxStringWidth</l>
<l>ColumnOffset := 30</l>
<l>ColumnEnd := ColumnOffset</l>
<c>* </c>
<c>* Adapt the window size to fit the confusion matrix.</c>
<l>if (DisplayColumnWidth == 'minimal')</l>
<c>    * Every column of the confusion matrix is as narrow as possible</c>
<c>    * based to the respective string widths.</c>
<l>    Width := sum(ColStringWidths) + ColumnOffset * NumColumns + ColumnStart + ColumnEnd</l>
<l>elseif (DisplayColumnWidth == 'equal')</l>
<c>    * Every column of the confusion matrix should have the same width.</c>
<c>    * based on the maximum string width.</c>
<l>    Width := (MaxStringWidth + ColumnOffset) * NumColumns + ColumnStart + ColumnEnd</l>
<l>endif</l>
<l>Height := RowDistance * NumRows + RowStart + RowEnd</l>
<c>* </c>
<c>* Set reasonable limits for graphics window (adapt if necessary).</c>
<l>WidthLimit := [450,Width]</l>
<l>HeightLimit := [250,Height]</l>
<l>dev_resize_window_fit_size (0, 0, Width, Height, WidthLimit, HeightLimit)</l>
<c>* </c>
<c>* Calculate row and column coordinates for display of text and buttons.</c>
<l>TextRow := []</l>
<l>TextColumn := []</l>
<l>RowStartTmp := 0</l>
<l>ColumnDistance := [0,cumul(ColStringWidths[0:NumColumns - 2] + ColumnOffset)]</l>
<l>if (DisplayColumnWidth == 'equal')</l>
<l>    ColumnDistance := [0:NumColumns - 1] * (MaxStringWidth + ColumnOffset)</l>
<l>endif</l>
<l>for Index := 0 to NumRows - 1 by 1</l>
<l>    TextRow := [TextRow,gen_tuple_const(NumColumns,RowStartTmp)]</l>
<l>    RowStartTmp := RowStartTmp + RowDistance</l>
<l>    TextColumn := [TextColumn,ColumnDistance]</l>
<l>endfor</l>
<c>* Display the confusion matrix with a margin from the top and left.</c>
<l>TextColumn := TextColumn + ColumnStart</l>
<l>TextRow := TextRow + RowStart</l>
<c>* Align the numbers right.</c>
<l>get_full_matrix (ConfusionMatrix, MatrixValues)</l>
<l>MatrixText := MatrixValues$NumberFormat</l>
<c>* Calculate button widths and heights.</c>
<l>MatrixTextWidths := []</l>
<l>for Index := 0 to |MatrixText| - 1 by 1</l>
<l>    get_string_extents (WindowHandle, MatrixText[Index], _, _, MatrixTextWidth, _)</l>
<l>    MatrixTextWidths := [MatrixTextWidths,MatrixTextWidth]</l>
<l>endfor</l>
<l>ButtonHeight := gen_tuple_const(|MatrixText|,StringHeight * 1.5)</l>
<l>ButtonWidth := gen_tuple_const(|MatrixText|,max2(MinStringWidth,0.9 * MinStringWidth) * 1.2)</l>
<c>* Calculate offset between button and text column coordinates to keep the entries in the matrix aligned.</c>
<l>TextToButtonOffset := ButtonWidth[0] / 2 + max(MatrixTextWidths) / 2 - min(MatrixTextWidths)</l>
<c>* </c>
<c>* Find zero-entries to avoid that they are selectable by a button.</c>
<l>ZeroIndices := find(MatrixValues [==] 0.0,1)</l>
<l>NonZeroIndizes := difference([0:|MatrixValues| - 1],ZeroIndices)</l>
<c>* </c>
<c>* Add continue button.</c>
<l>NonZeroIndizes := [NonZeroIndizes,|MatrixText|]</l>
<l>MatrixText := [MatrixText,'Continue']</l>
<l>get_string_extents (WindowHandle, 'Continue', _, _, ContinueTextWidth, ContinueTextHeight)</l>
<l>get_window_extents (WindowHandle, Row, Column, WindowWidth, WindowHeight)</l>
<l>TextRow := [TextRow,WindowHeight - ContinueTextHeight - 20]</l>
<l>TextColumn := [TextColumn,WindowWidth - ContinueTextWidth - 40]</l>
<l>ButtonHeight := [ButtonHeight,ContinueTextHeight * 1.5]</l>
<l>ButtonWidth := [ButtonWidth,ContinueTextWidth * 1.2]</l>
<l>ValueColors := [ValueColors,'black']</l>
<l>BoxColor := [BoxColor,'#f28d26']</l>
<c>* </c>
<c>* Display values of matrix with buttons.</c>
<l>DisplayMatrix := true</l>
<l>while (DisplayMatrix)</l>
<c>    * </c>
<c>    * Display axis titles, row, and column names.</c>
<l>    dev_disp_text (AxisTitles[0], 'window', 'top', 'right', 'white', 'box', 'false')</l>
<l>    dev_disp_text (AxisTitles[1], 'window', 'bottom', 'left', 'white', 'box', 'false')</l>
<l>    dev_disp_text (RowNames, 'window', TextRow[[0:NumColumns:NumColumns * (NumRows - 1)]], gen_tuple_const(NumRows,TextColumn[0] - MaxStringWidth - ColumnOffset), AxisColor, 'box', 'false')</l>
<l>    dev_disp_text (ColumnNames, 'window', gen_tuple_const(NumColumns,TextRow[0] - RowDistance), TextColumn[0:NumColumns - 1], AxisColor, 'box', 'false')</l>
<c>    * </c>
<c>    * Display matrix entries. Zero-entries are displayed as text, all others as buttons.</c>
<l>    if (ZeroIndices != -1)</l>
<l>        dev_disp_text (MatrixText[ZeroIndices], 'window', TextRow[ZeroIndices], TextColumn[ZeroIndices] + TextToButtonOffset, ValueColors[ZeroIndices], 'box', 'false')</l>
<l>    endif</l>
<l>    dev_disp_button (MatrixText[NonZeroIndizes], TextRow[NonZeroIndizes], TextColumn[NonZeroIndizes], ButtonWidth[NonZeroIndizes], ButtonHeight[NonZeroIndizes], ValueColors[NonZeroIndizes], BoxColor[NonZeroIndizes], HighlightColor, WindowHandle, SelectedButton)</l>
<c>    * </c>
<c>    * Display axis titles, row names, column names, and zero-entries again to update screen.</c>
<l>    dev_disp_text (AxisTitles[0], 'window', 'top', 'right', 'white', 'box', 'false')</l>
<l>    dev_disp_text (AxisTitles[1], 'window', 'bottom', 'left', 'white', 'box', 'false')</l>
<l>    dev_disp_text (RowNames, 'window', TextRow[[0:NumColumns:NumColumns * (NumRows - 1)]], gen_tuple_const(NumRows,TextColumn[0] - MaxStringWidth - ColumnOffset), AxisColor, 'box', 'false')</l>
<l>    dev_disp_text (ColumnNames, 'window', gen_tuple_const(NumColumns,TextRow[0] - RowDistance), TextColumn[0:NumColumns - 1], AxisColor, 'box', 'false')</l>
<l>    if (ZeroIndices != -1)</l>
<l>        dev_disp_text (MatrixText[ZeroIndices], 'window', TextRow[ZeroIndices], TextColumn[ZeroIndices] + TextToButtonOffset, ValueColors[ZeroIndices], 'box', 'false')</l>
<l>    endif</l>
<c>    * </c>
<l>    if (SelectedButton == |NonZeroIndizes| - 1)</l>
<c>        * Continue-button.</c>
<l>        DisplayMatrix := false</l>
<l>        dev_set_window (WindowHandle)</l>
<l>        dev_close_window ()</l>
<l>    else</l>
<c>        * Find correct samples and display them.</c>
<l>        MatrixEntryIndex := NonZeroIndizes[SelectedButton]</l>
<l>        GroundTruthClassID := MatrixEntryIndex % |ClassIDs|</l>
<l>        PredictedClassID := MatrixEntryIndex / |ClassIDs|</l>
<l>        GTIndices := find(ImageLabelIDs [==] GroundTruthClassID,1)</l>
<l>        PredictionIndices := find(Predictions [==] PredictedClassID,1)</l>
<l>        ImageIDsSelected := ImageIDs[intersection(GTIndices,PredictionIndices)]</l>
<l>        create_dict (WindowHandleDict)</l>
<l>        DisplaySamples := true</l>
<l>        DisplayIndex := 0</l>
<l>        while (DisplaySamples)</l>
<l>            get_dict_tuple (DLDataset, 'samples', DLSamples)</l>
<l>            find_dl_samples (DLSamples, 'image_id', ImageIDsSelected[DisplayIndex], 'match', DLSampleIndex)</l>
<l>            read_dl_samples (DLDataset, DLSampleIndex, DLSample)</l>
<c>            * Create temporary DLResult for display.</c>
<l>            create_dict (DLResult)</l>
<l>            set_dict_tuple (DLResult, 'classification_class_ids', PredictedClassID)</l>
<l>            set_dict_tuple (DLResult, 'classification_class_names', ClassNames[ClassIDsToNamesMapping[PredictedClassID]])</l>
<l>            dev_display_dl_data (DLSample, DLResult, DLDataset, 'classification_both', GenParamDevData, WindowHandleDict)</l>
<c>            * Display buttons.</c>
<l>            get_dict_tuple (WindowHandleDict, 'classification_both', WindowHandles)</l>
<l>            WindowHandleLegend := WindowHandles[|WindowHandles| - 1]</l>
<c>            * </c>
<l>            DataButtonNames := ['Previous','Next','Continue']</l>
<l>            get_string_extents (WindowHandleLegend, 'Continue', _, _, ContinueTextWidth, ContinueTextHeight)</l>
<l>            get_window_extents (WindowHandleLegend, Row, Column, WindowWidth, WindowHeight)</l>
<l>            DataTextRow := gen_tuple_const(3,WindowHeight - ContinueTextHeight - 20)</l>
<l>            DataTextColumn := [20,(WindowWidth - ContinueTextWidth) / 2,WindowWidth - ContinueTextWidth - 20]</l>
<l>            DataButtonHeight := gen_tuple_const(3,ContinueTextHeight * 1.5)</l>
<l>            DataButtonWidth := gen_tuple_const(3,ContinueTextWidth * 1.2)</l>
<l>            DataValueColors := gen_tuple_const(3,'black')</l>
<l>            DataBoxColor := gen_tuple_const(3,'#f28d26')</l>
<l>            dev_disp_button (DataButtonNames, DataTextRow, DataTextColumn, DataButtonWidth, DataButtonHeight, DataValueColors, DataBoxColor, HighlightColor, WindowHandleLegend, SelectedDataButton)</l>
<c>            * </c>
<l>            if (SelectedDataButton == 0)</l>
<c>                * Previous-button.</c>
<l>                DisplayIndex := (|ImageIDsSelected| + DisplayIndex - 1) % |ImageIDsSelected|</l>
<l>            elseif (SelectedDataButton == 1)</l>
<c>                * Next-button.</c>
<l>                DisplayIndex := (DisplayIndex + 1) % |ImageIDsSelected|</l>
<l>            else</l>
<c>                * Continue-button.</c>
<l>                DisplaySamples := false</l>
<l>                dev_close_window_dict (WindowHandleDict)</l>
<l>            endif</l>
<l>        endwhile</l>
<l>    endif</l>
<l>endwhile</l>
<c>* </c>
<l>return ()</l>
</body>
<docu id="dev_display_dl_interactive_confusion_matrix">
<abstract lang="en_US">This procedure displays a confusion matrix that can be used interactively to display evaluated samples.

The dictionary DLDataset provides the images and information about the ground truth annotations of the samples.
The dictionary EvaluationResult provides the information about which samples are evaluated and their inference.

Clicking on a confusion matrix entry displays the corresponding samples.

The dictionary GenParam is used to determine, which matrix shall be displayed and in which style. Thereby, the following options are possible to set as entry:
- 'display_color' (default: 'true'): Display values in confusion matrix colored in green (diagonal) and red (off-diagonal) or only in white ('false').
- 'display_column_width': This key can have the following associated values:
   -- 'equal' (default): All columns have the same width that equals the width of the longest row or column-name.
   -- 'minimal': The columns are just as wide as the column-name string plus a small offset.
- 'display_matrix' (default: 'absolute'): Determine if the matrix shows absolute (value 'absolute') or relative (value 'relative') numbers. 
- 'font' (default: 'mono'): Font of the window showing the confusion matrix.
- 'font_size' (default: 14): Font size of the window showing the confusion matrix. The font size has to be in the range [8,64].

Additionally, all generic parameters for dev_display_dl_data are supported for the display of particular samples.</abstract>
<chapters lang="en_US">
<item>Deep Learning</item>
<item>Classification</item>
</chapters>
<library lang="en_US">MVTec Standard Procedures</library>
<short lang="en_US">This procedure displays a confusion matrix that can be used interactively to display samples.</short>
<parameters>
<parameter id="DLDataset">
<default_type>integer</default_type>
<default_value>DLDataset</default_value>
<description lang="en_US">DLDataset dictionary containing samples.</description>
<mixed_type>false</mixed_type>
<sem_type>dict</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="EvaluationResult">
<default_type>integer</default_type>
<default_value>EvaluationResult</default_value>
<description lang="en_US">Dictionary containing evaluation results.</description>
<mixed_type>false</mixed_type>
<sem_type>dict</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="GenParam">
<default_type>integer</default_type>
<default_value>GenParam</default_value>
<description lang="en_US">Dictionary containing generic parameters.</description>
<mixed_type>false</mixed_type>
<sem_type>dict</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
</parameters>
</docu>
</procedure>
<procedure name="dev_display_find_box_3d_results" access="local">
<interface>
<ic>
<par name="WindowHandle1" base_type="ctrl" dimension="0"/>
<par name="BoxInformation" base_type="ctrl" dimension="0"/>
<par name="ObjectModel3DBox" base_type="ctrl" dimension="0"/>
<par name="ObjectModel3DScene" base_type="ctrl" dimension="0"/>
<par name="Score" base_type="ctrl" dimension="0"/>
<par name="Pose" base_type="ctrl" dimension="0"/>
</ic>
</interface>
<body>
<c>* Get box finder data.</c>
<l>gen_empty_object_model_3d (SampledEdges)</l>
<l>try</l>
<l>    get_dict_tuple (BoxInformation, 'sampled_edges', SampledEdges)</l>
<l>    get_dict_tuple (BoxInformation, 'sampled_reference_points', ReferencePoints)</l>
<l>    get_dict_tuple (BoxInformation, 'sampled_scene', SampledScene)</l>
<l>    get_dict_tuple (BoxInformation, 'results', BoxResultsDict)</l>
<l>    get_dict_param (BoxResultsDict, 'keys', [], AllBoxResultsDictKeys)</l>
<c>    * </c>
<l>    Labels := []</l>
<l>    for Index := 0 to |AllBoxResultsDictKeys| - 1 by 1</l>
<l>        get_dict_tuple (BoxResultsDict, Index, CurrResult)</l>
<l>        get_dict_tuple (CurrResult, 'score', CurrScore)</l>
<c>        * </c>
<l>        CurrLabel := 'Score:   ' + CurrScore$'.2f'</l>
<l>        Labels := [Labels,CurrLabel]</l>
<l>    endfor</l>
<l>catch (Exception)</l>
<l>endtry</l>
<c>* </c>
<l>Instructions[0] := 'Rotate: Left button'</l>
<l>Instructions[1] := 'Zoom:   Shift + left button'</l>
<l>Instructions[2] := 'Move:   Ctrl  + left button'</l>
<c>* </c>
<c>* Generate color vector for visualization.</c>
<l>Colors := ['red','green','blue','cyan','magenta','yellow','medium slate blue','coral','slate blue','orange red','dark olive green']</l>
<c>* </c>
<c>* Number of found boxes.</c>
<l>Number := |Score|</l>
<c>* </c>
<c>* Move the model into the scene.</c>
<l>* rigid_trans_object_model_3d (ObjectModel3DBox, Pose, ObjectModel3DResult)</l>
<l>ObjectModel3DResult := ObjectModel3DBox</l>
<l>ColorsVis := Colors[[0:Number - 1] % |Colors|]</l>
<c>* </c>
<c>* Visualize results.</c>
<l>Message := 'Final Results:'</l>
<l>Message[1] := 'Original scene points (gray)'</l>
<l>Message[2] := 'Sampled scene points (cyan)'</l>
<l>Message[3] := 'Reference points (yellow)'</l>
<l>Message[4] := Number + ' object' + ['s',''][Number == 1] + ' found'</l>
<l>visualize_object_model_3d (WindowHandle1, [ObjectModel3DScene,SampledScene,ReferencePoints,ObjectModel3DResult], [], [], ['color_' + [0:Number + 2],'point_size_' + [0,1,2],'disp_pose','alpha'], ['gray','cyan','yellow',ColorsVis,1.0,3.0,5.0,'true',0.5], Message, ['','','',Labels], Instructions, PoseOut)</l>
<l>dev_set_window (WindowHandle1)</l>
<l>dev_clear_window ()</l>
<l>return ()</l>
</body>
<docu id="dev_display_find_box_3d_results">
<chapters lang="en_US">
<item>3D Matching</item>
<item>3D-Box</item>
</chapters>
<library lang="en_US">MVTec Standard Procedures</library>
<parameters>
<parameter id="BoxInformation">
<default_type>handle</default_type>
<description lang="en_US">Dictionary with results of the box finder.</description>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>dict</sem_type>
<type_list>
<item>handle</item>
</type_list>
</parameter>
<parameter id="ObjectModel3DBox">
<default_type>handle</default_type>
<description lang="en_US">3D object models of the found boxes.</description>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>object_model_3d</sem_type>
<type_list>
<item>handle</item>
</type_list>
</parameter>
<parameter id="ObjectModel3DScene">
<default_type>handle</default_type>
<description lang="en_US">The scene where the object is to be found, as passed to find_box_3d.</description>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>object_model_3d</sem_type>
<type_list>
<item>handle</item>
</type_list>
</parameter>
<parameter id="Pose"/>
<parameter id="Score"/>
<parameter id="WindowHandle1">
<default_type>integer</default_type>
<mixed_type>false</mixed_type>
<sem_type>window</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
</parameters>
</docu>
</procedure>
<procedure name="dev_display_ground_truth_anomaly_regions" access="local">
<interface>
<ic>
<par name="SampleKeys" base_type="ctrl" dimension="0"/>
<par name="DLSample" base_type="ctrl" dimension="0"/>
<par name="CurrentWindowHandle" base_type="ctrl" dimension="0"/>
<par name="LineWidth" base_type="ctrl" dimension="0"/>
<par name="AnomalyRegionLabelColor" base_type="ctrl" dimension="0"/>
<par name="AnomalyColorTransparency" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="AnomalyRegionExists" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c>* </c>
<c>* This procedure visualizes the ground truth anomalies</c>
<c>* if there is an anomaly_ground_truth in DLSample.</c>
<c>* </c>
<c>* Get current set color.</c>
<l>get_rgba (CurrentWindowHandle, Red, Green, Blue, Alpha)</l>
<l>InitialColor := []</l>
<l>for IndexColor := 0 to |Red| - 1 by 1</l>
<l>    Color_RGBA := '#' + Red[IndexColor]$'2x' + Green[IndexColor]$'2x' + Blue[IndexColor]$'2x' + Alpha[IndexColor]$'2x'</l>
<l>    tuple_regexp_replace (Color_RGBA, [' ','replace_all'], '0', Color_RGBA)</l>
<l>    InitialColor := [InitialColor,Color_RGBA]</l>
<l>endfor</l>
<c>* </c>
<l>if (find(SampleKeys,'anomaly_ground_truth') != -1)</l>
<l>    get_dict_object (AnomalyImage, DLSample, 'anomaly_ground_truth')</l>
<l>    threshold (AnomalyImage, AnomalyRegion, 1, 255)</l>
<c>    * Get non-empty regions.</c>
<l>    region_features (AnomalyRegion, 'area', Area)</l>
<l>    if (Area &gt; 0)</l>
<l>        dev_set_color (AnomalyRegionLabelColor + AnomalyColorTransparency)</l>
<c>        * Display the anomaly region.</c>
<l>        dev_set_draw ('fill')</l>
<l>        dev_display (AnomalyRegion)</l>
<l>    endif</l>
<l>    AnomalyRegionExists := 'true'</l>
<l>else</l>
<l>    AnomalyRegionExists := 'false'</l>
<l>endif</l>
<c>* </c>
<c>* Reset colors.</c>
<l>dev_set_color (InitialColor)</l>
<c>* </c>
<l>return ()</l>
</body>
<docu id="dev_display_ground_truth_anomaly_regions">
<chapters lang="en_US">
<item>Deep Learning</item>
<item>Anomaly Detection</item>
</chapters>
<library lang="en_US">MVTec Standard Procedures</library>
<short lang="en_US">Display the ground truth anomaly regions of the given DLSample.</short>
<parameters>
<parameter id="AnomalyColorTransparency"/>
<parameter id="AnomalyRegionExists">
<sem_type>string</sem_type>
</parameter>
<parameter id="AnomalyRegionLabelColor"/>
<parameter id="CurrentWindowHandle">
<default_type>integer</default_type>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>window</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="DLSample">
<default_type>integer</default_type>
<mixed_type>false</mixed_type>
<sem_type>dict</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="LineWidth">
<sem_type>number</sem_type>
</parameter>
<parameter id="SampleKeys">
<sem_type>string</sem_type>
</parameter>
</parameters>
</docu>
</procedure>
<procedure name="dev_display_ground_truth_detection" access="local">
<interface>
<ic>
<par name="DLSample" base_type="ctrl" dimension="0"/>
<par name="SampleKeys" base_type="ctrl" dimension="0"/>
<par name="LineWidthBbox" base_type="ctrl" dimension="0"/>
<par name="ClassIDs" base_type="ctrl" dimension="0"/>
<par name="BboxColors" base_type="ctrl" dimension="0"/>
<par name="BboxLabelColor" base_type="ctrl" dimension="0"/>
<par name="TextColor" base_type="ctrl" dimension="0"/>
<par name="ShowLabels" base_type="ctrl" dimension="0"/>
<par name="ShowDirection" base_type="ctrl" dimension="0"/>
<par name="WindowHandle" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="BboxIDs" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c>* </c>
<c>* This procedure displays the ground truth bounding boxes of DLSample.</c>
<c>* </c>
<l>InstanceType := 'rectangle1'</l>
<l>if (find(SampleKeys,'bbox_row1') != -1)</l>
<l>    get_dict_tuple (DLSample, 'bbox_row1', BboxRow1)</l>
<l>    get_dict_tuple (DLSample, 'bbox_col1', BboxCol1)</l>
<l>    get_dict_tuple (DLSample, 'bbox_row2', BboxRow2)</l>
<l>    get_dict_tuple (DLSample, 'bbox_col2', BboxCol2)</l>
<l>    get_dict_tuple (DLSample, 'bbox_label_id', BboxLabels)</l>
<l>elseif (find(SampleKeys,'bbox_phi') != -1)</l>
<l>    get_dict_tuple (DLSample, 'bbox_row', BboxRow)</l>
<l>    get_dict_tuple (DLSample, 'bbox_col', BboxCol)</l>
<l>    get_dict_tuple (DLSample, 'bbox_length1', BboxLength1)</l>
<l>    get_dict_tuple (DLSample, 'bbox_length2', BboxLength2)</l>
<l>    get_dict_tuple (DLSample, 'bbox_phi', BboxPhi)</l>
<l>    get_dict_tuple (DLSample, 'bbox_label_id', BboxLabels)</l>
<l>    InstanceType := 'rectangle2'</l>
<l>else</l>
<l>    throw ('Ground truth bounding box data could not be found in DLSample.')</l>
<l>endif</l>
<l>if (|BboxLabels| &gt; 0)</l>
<c>    * Generate bounding box XLDs.</c>
<l>    if (InstanceType == 'rectangle1')</l>
<l>        tuple_gen_const (|BboxRow1|, 0.0, BboxPhi)</l>
<l>        gen_rectangle2_contour_xld (BboxRectangle, 0.5 * (BboxRow1 + BboxRow2), 0.5 * (BboxCol1 + BboxCol2), BboxPhi, 0.5 * (BboxCol2 - BboxCol1), 0.5 * (BboxRow2 - BboxRow1))</l>
<l>        LabelRow := BboxRow1</l>
<l>        LabelCol := BboxCol1</l>
<l>    else</l>
<l>        gen_rectangle2_contour_xld (BboxRectangle, BboxRow, BboxCol, BboxPhi, BboxLength1, BboxLength2)</l>
<l>        LabelRow := BboxRow</l>
<l>        LabelCol := BboxCol</l>
<l>        if (ShowDirection)</l>
<l>            HeadSize := 20.0</l>
<l>            gen_arrow_contour_xld (OrientationArrows, BboxRow, BboxCol, BboxRow - (BboxLength1 + HeadSize) * sin(BboxPhi), BboxCol + (BboxLength1 + HeadSize) * cos(BboxPhi), HeadSize, HeadSize)</l>
<l>        endif</l>
<l>    endif</l>
<c>    * </c>
<l>    dev_set_line_width (LineWidthBbox)</l>
<c>    * </c>
<c>    * Collect the ClassIDs of the bounding boxes.</c>
<l>    BboxIDs := []</l>
<l>    BboxClassIDs := []</l>
<c>    * </c>
<c>    * Draw the bounding boxes.</c>
<l>    get_contour_style (WindowHandle, ContourStyle)</l>
<l>    dev_set_contour_style ('stroke_and_fill')</l>
<l>    for IndexBbox := 0 to |BboxLabels| - 1 by 1</l>
<l>        select_obj (BboxRectangle, RectangleSelected, IndexBbox + 1)</l>
<l>        ClassID := find(ClassIDs,BboxLabels[IndexBbox])</l>
<l>        BboxClassIDs := [BboxClassIDs,ClassID]</l>
<l>        BboxIDs := [BboxIDs,ClassID]</l>
<l>        dev_set_color (BboxColors[ClassID] + '60')</l>
<l>        dev_display (RectangleSelected)</l>
<l>        if (InstanceType == 'rectangle2' and ShowDirection)</l>
<l>            select_obj (OrientationArrows, ArrowSelected, IndexBbox + 1)</l>
<l>            dev_set_color (BboxColors[ClassID] + 'FF')</l>
<l>            dev_display (ArrowSelected)</l>
<l>            dev_set_color (BboxColors[ClassID] + '60')</l>
<l>        endif</l>
<l>    endfor</l>
<c>    * </c>
<c>    * Write text to the bounding boxes.</c>
<l>    if (ShowLabels)</l>
<c>        * For better visibility the text is displayed after all bounding boxes are drawn.</c>
<l>        for IndexBbox := 0 to |BboxLabels| - 1 by 1</l>
<l>            ClassID := BboxClassIDs[IndexBbox]</l>
<l>            if (TextColor == '')</l>
<l>                TxtColor := BboxColors[ClassID]</l>
<l>            else</l>
<l>                TxtColor := TextColor</l>
<l>            endif</l>
<l>            dev_disp_text (BboxLabels[IndexBbox], 'image', LabelRow[IndexBbox], LabelCol[IndexBbox], TextColor, ['box_color','shadow','border_radius'], [BboxLabelColor,'false',0])</l>
<l>        endfor</l>
<l>    endif</l>
<c>    * </c>
<l>    dev_set_contour_style (ContourStyle)</l>
<l>else</l>
<c>    * Do nothing if there are no ground truth bounding boxes.</c>
<l>    BboxIDs := []</l>
<l>endif</l>
<c>* </c>
<l>return ()</l>
</body>
<docu id="dev_display_ground_truth_detection">
<abstract lang="en_US">This procedure displays the ground truth bounding boxes of DLSample.

SampleKeys is a tuple which should contain all the keys of DLSample.
LineWidthBbox sets the width of the lines with which the bounding boxes are drawn.
ClassIDs is a tuple with all the IDs of the different classes the network can distinguish.
BboxColors determines the colors of the bounding boxes for every class, which are given over hexadecimal numbers within an RGB triplet.
BboxLabelColor is a string determining the color used to display the bounding box labels.
TextColor is a string determining the color used to display the text within the label.
ShowLabels is a boolean, determining if the labels are shown or not.
ShowDirection is a boolean, determining if direction of the instance within the bounding box should be indicated by an arrow or not. Supported only for instance_type 'rectangle2'.
WindowHandle determines handle of the window.
The procedure returns the IDs of the classes assigned for the bounding box contents in BboxIDs.</abstract>
<chapters lang="de_DE">
<item>Graphik</item>
<item>Ausgabe</item>
</chapters>
<chapters lang="en_US">
<item>Graphics</item>
<item>Output</item>
</chapters>
<library lang="en_US">MVTec Standard Procedures</library>
<short lang="en_US">Display the ground truth bounding boxes of DLSample.</short>
<parameters>
<parameter id="BboxColors">
<default_type>string</default_type>
<description lang="en_US">Determines the colors of the bounding boxes for every class, which are given over hexadecimal numbers within an RGB triplet.</description>
<mixed_type>false</mixed_type>
<multivalue>optional</multivalue>
<sem_type>color</sem_type>
<type_list>
<item>string</item>
</type_list>
</parameter>
<parameter id="BboxIDs">
<default_type>integer</default_type>
<description lang="en_US">IDs of the classes assigned for the bounding box contents in BboxIDs.</description>
<multivalue>optional</multivalue>
<sem_type>integer</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="BboxLabelColor">
<default_type>string</default_type>
<description lang="en_US">Determines the color used to display the bounding box labels.</description>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>color</sem_type>
<type_list>
<item>string</item>
</type_list>
</parameter>
<parameter id="ClassIDs">
<default_type>integer</default_type>
<description lang="en_US">Tuple with all the IDs of the different classes the network can distinguish.</description>
<multivalue>true</multivalue>
<sem_type>integer</sem_type>
<type_list>
<item>integer</item>
<item>string</item>
</type_list>
</parameter>
<parameter id="DLSample">
<default_type>integer</default_type>
<description lang="en_US">Dictionary of the sample whose bounding boxes are to be visualized.</description>
<mixed_type>false</mixed_type>
<sem_type>dict</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="LineWidthBbox">
<default_type>integer</default_type>
<description lang="en_US">Sets the width of the lines with which the bounding boxes are drawn.</description>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>integer</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="SampleKeys">
<description lang="en_US">A tuple which should contain all the keys of DLSample.</description>
<sem_type>string</sem_type>
</parameter>
<parameter id="ShowDirection">
<description lang="en_US">Determines if the direction of an instance within the bounding box is visualized or not. Supported only for instance_type 'rectangle2'.</description>
<multivalue>false</multivalue>
<sem_type>integer</sem_type>
</parameter>
<parameter id="ShowLabels">
<description lang="en_US">Determines if the labels are shown or not.</description>
<sem_type>integer</sem_type>
</parameter>
<parameter id="TextColor">
<default_type>string</default_type>
<default_value>'white'</default_value>
<description lang="en_US">Determines the color used the for text within the label.</description>
<sem_type>color</sem_type>
<type_list>
<item>real</item>
<item>string</item>
</type_list>
</parameter>
<parameter id="WindowHandle">
<default_type>integer</default_type>
<description lang="en_US">Handle of the window used for the display.</description>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>window</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
</parameters>
</docu>
</procedure>
<procedure name="dev_display_init_train_dl_model" access="local">
<interface>
<ic>
<par name="DLModelHandle" base_type="ctrl" dimension="0"/>
<par name="TrainParam" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="DisplayData" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c>* </c>
<c>* This procedure initializes the visualization of the training progress.</c>
<c>* </c>
<c>* Get the actual model type.</c>
<l>get_dl_model_param (DLModelHandle, 'type', ModelType)</l>
<c>* </c>
<c>* Initialize display data.</c>
<l>create_dict (DisplayData)</l>
<l>get_dict_tuple (TrainParam, 'display_param', DisplayParam)</l>
<l>set_dict_tuple (DisplayData, 'display_param', DisplayParam)</l>
<l>get_dict_tuple (DisplayParam, 'enabled', DisplayEnabled)</l>
<l>set_dict_tuple (DisplayData, 'enabled', DisplayEnabled)</l>
<c>* </c>
<c>* Set last_display in order to display the next iteration.</c>
<l>get_dict_tuple (TrainParam, 'update_interval_seconds', DisplayIntervalSeconds)</l>
<l>count_seconds (Time)</l>
<l>set_dict_tuple (DisplayData, 'last_update', Time - DisplayIntervalSeconds * 2)</l>
<c>* </c>
<l>if (not DisplayEnabled)</l>
<l>    return ()</l>
<l>endif</l>
<c>* </c>
<l>WindowWidthText := 700</l>
<l>WindowHeightText := 750</l>
<l>WindowWidthImagesMax := 1200 - WindowWidthText</l>
<l>WindowHeightImagesMax := WindowHeightText</l>
<l>WindowBGColor := 'light gray'</l>
<c>* </c>
<c>* Open and setup text window.</c>
<l>dev_open_window (0, 0, WindowWidthText, WindowHeightText, WindowBGColor, WindowHandleText)</l>
<l>set_display_font (WindowHandleText, 16, 'mono', 'true', 'false')</l>
<l>set_dict_tuple (DisplayData, 'window_text', WindowHandleText)</l>
<l>set_dict_tuple (DisplayData, 'window_text_width', WindowWidthText)</l>
<l>set_dict_tuple (DisplayData, 'window_text_height', WindowHeightText)</l>
<c>* </c>
<c>* Configure images window, which is opened later by another procedure.</c>
<l>WindowYImages := 0</l>
<l>WindowXImages := WindowWidthText + 10</l>
<l>set_dict_tuple (DisplayData, 'window_images', [])</l>
<l>get_dict_tuple (DisplayParam, 'tiled_param', TiledParamDict)</l>
<c>* Only set values if they are not already given</c>
<l>try</l>
<l>    get_dict_tuple (TiledParamDict, 'window_row', WindowYImages)</l>
<l>catch (Exception)</l>
<l>    set_dict_tuple (TiledParamDict, 'window_row', WindowYImages)</l>
<l>endtry</l>
<l>try</l>
<l>    get_dict_tuple (TiledParamDict, 'window_col', WindowXImages)</l>
<l>catch (Exception)</l>
<l>    set_dict_tuple (TiledParamDict, 'window_col', WindowXImages)</l>
<l>endtry</l>
<l>try</l>
<l>    get_dict_tuple (TiledParamDict, 'window_width', WindowWidthImagesMax)</l>
<l>catch (Exception)</l>
<l>    set_dict_tuple (TiledParamDict, 'window_width', WindowWidthImagesMax)</l>
<l>endtry</l>
<l>try</l>
<l>    get_dict_tuple (TiledParamDict, 'window_height', WindowHeightImagesMax)</l>
<l>catch (Exception)</l>
<l>    set_dict_tuple (TiledParamDict, 'window_height', WindowHeightImagesMax)</l>
<l>endtry</l>
<c>* </c>
<c>* Set specific display parameters for all available model types.</c>
<l>if (ModelType == 'classification')</l>
<l>    set_dict_tuple (TiledParamDict, 'display_input', false)</l>
<l>    set_dict_tuple (TiledParamDict, 'display_ground_truth', false)</l>
<l>    set_dict_tuple (TiledParamDict, 'display_legend', false)</l>
<l>endif</l>
<l>set_dict_tuple (DisplayData, 'window_images_x', WindowXImages)</l>
<l>set_dict_tuple (DisplayData, 'window_images_y', WindowYImages)</l>
<l>set_dict_tuple (DisplayData, 'window_images_genparam', TiledParamDict)</l>
<c>* </c>
<l>set_dict_tuple (DisplayData, 'last_change_plot', Time)</l>
<l>set_dict_tuple (DisplayData, 'plot_eval', false)</l>
<l>dev_set_window (WindowHandleText)</l>
<c>* </c>
<l>return ()</l>
</body>
<docu id="dev_display_init_train_dl_model">
<abstract lang="en_US">This procedure initializes the visualization of the training progress.</abstract>
<chapters lang="de_DE">
<item>Deep Learning</item>
<item>Modell</item>
</chapters>
<chapters lang="en_US">
<item>Deep Learning</item>
<item>Model</item>
</chapters>
<library lang="en_US">MVTec Standard Procedures</library>
<short lang="en_US">Initialize the visualization of the training progress.</short>
<parameters>
<parameter id="DLModelHandle">
<default_type>integer</default_type>
<description lang="en_US">The dl model, which is used during training.</description>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>dl_model</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="DisplayData">
<default_type>integer</default_type>
<mixed_type>false</mixed_type>
<sem_type>dict</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="TrainParam">
<default_type>integer</default_type>
<mixed_type>false</mixed_type>
<sem_type>dict</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
</parameters>
</docu>
</procedure>
<procedure name="dev_display_map_color_bar" access="local">
<interface>
<ic>
<par name="ImageWidth" base_type="ctrl" dimension="0"/>
<par name="ImageHeight" base_type="ctrl" dimension="0"/>
<par name="MapColorBarWidth" base_type="ctrl" dimension="0"/>
<par name="Colors" base_type="ctrl" dimension="0"/>
<par name="MaxValue" base_type="ctrl" dimension="0"/>
<par name="WindowImageRatio" base_type="ctrl" dimension="0"/>
<par name="WindowHandle" base_type="ctrl" dimension="0"/>
</ic>
</interface>
<body>
<c>* </c>
<c>* This procedure displays a color bar next to the image</c>
<c>* specified with ImageWidth and ImageHeight.</c>
<c>* </c>
<l>get_system ('clip_region', ClipRegion)</l>
<l>set_system ('clip_region', 'false')</l>
<c>* </c>
<c>* Display the color bar.</c>
<l>ColorIndex := 0</l>
<l>RectHeight := 1.0 * ImageHeight / |Colors|</l>
<c>* Set draw mode to fill</c>
<l>get_draw (WindowHandle, DrawMode)</l>
<l>dev_set_draw ('fill')</l>
<l>for Row := ImageHeight - 1 to 0 by -RectHeight</l>
<c>    * The color bar consists of multiple rectangle1.</c>
<l>    Row1 := Row - RectHeight</l>
<l>    Column1 := ImageWidth + 20 / WindowImageRatio</l>
<l>    Row2 := Row</l>
<l>    Column2 := ImageWidth + 20 + MapColorBarWidth / WindowImageRatio</l>
<l>    gen_rectangle1 (Rectangle, Row1, Column1, Row2, Column2)</l>
<l>    dev_set_color (Colors[ColorIndex])</l>
<l>    dev_display (Rectangle)</l>
<l>    ColorIndex := ColorIndex + 1</l>
<l>endfor</l>
<c>* </c>
<c>* Display labels for color bar.</c>
<l>get_string_extents (WindowHandle, '0123456789', _, _, _, TextHeight)</l>
<l>for Index := 0 to 1 by 0.2</l>
<l>    Text := (MaxValue - Index * MaxValue)$'.1f'</l>
<l>    dev_disp_text (Text, 'image', Index * (ImageHeight - 2 * (TextHeight / WindowImageRatio)), ImageWidth + 40 / WindowImageRatio, 'black', 'box', 'false')</l>
<l>endfor</l>
<c>* </c>
<l>set_system ('clip_region', ClipRegion)</l>
<l>dev_set_draw (DrawMode)</l>
<l>return ()</l>
</body>
<docu id="dev_display_map_color_bar">
<abstract lang="en_US">This procedure displays a color bar in the window given over its handle.
It allows to draw the color bar next to an image, whose dimensions are specified by ImageWidth and ImageHeight.
MapColorBarWidth specifies the width of the color bar elements.
Colors is a tuple determining the different colors used for the color bar and therewith also sets the number of differently colored rectangles.
MaxValue specifies the maximal value the color bar represents. Note, the values are displayed with one decimal place. 
WindowImageRatio specifies the ratio of the window.</abstract>
<chapters lang="de_DE">
<item>Graphik</item>
<item>Ausgabe</item>
</chapters>
<chapters lang="en_US">
<item>Graphics</item>
<item>Output</item>
</chapters>
<library lang="en_US">MVTec Standard Procedures</library>
<short lang="en_US">Display a color bar next to an image.</short>
<parameters>
<parameter id="Colors">
<default_type>string</default_type>
<description lang="en_US">Determines the colors to be used for the color bar.</description>
<mixed_type>false</mixed_type>
<multivalue>optional</multivalue>
<sem_type>color</sem_type>
<type_list>
<item>string</item>
</type_list>
</parameter>
<parameter id="ImageHeight">
<default_type>integer</default_type>
<description lang="en_US">Determines the height of the image, next to which the color bar is drawn.</description>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>extent.x</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="ImageWidth">
<default_type>integer</default_type>
<description lang="en_US">Determines the width of the image, next to which the color bar is drawn.</description>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>extent.y</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="MapColorBarWidth">
<description lang="en_US">Determines the width of the color bar.</description>
</parameter>
<parameter id="MaxValue">
<description lang="en_US">Specifies the maximal value the color bar represents.</description>
<multivalue>false</multivalue>
<sem_type>number</sem_type>
</parameter>
<parameter id="WindowHandle">
<default_type>integer</default_type>
<description lang="en_US">Handle of the image in which the color bar is drawn.</description>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>window</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="WindowImageRatio">
<default_type>string</default_type>
<description lang="en_US">Specifies the aspect ratio of the window size.</description>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>real</sem_type>
<type_list>
<item>string</item>
</type_list>
</parameter>
</parameters>
</docu>
</procedure>
<procedure name="dev_display_matrix" access="local">
<interface>
<ic>
<par name="Matrix" base_type="ctrl" dimension="0"/>
<par name="ColumnNames" base_type="ctrl" dimension="0"/>
<par name="RowNames" base_type="ctrl" dimension="0"/>
<par name="WindowHandle" base_type="ctrl" dimension="0"/>
<par name="GenParam" base_type="ctrl" dimension="0"/>
</ic>
</interface>
<body>
<c>* </c>
<c>* Display a matrix in a window.</c>
<c>* </c>
<c>* GenParam (all are optional):</c>
<c>*   - display_column_width: Either 'equal' or 'minimal'. For 'equal', all columns have the same width</c>
<c>*                           that equals the width of the longest row or column-name.</c>
<c>*   - display_color:        If true, the values will be displayed with the colors that are given by</c>
<c>*                           'value_colors'.</c>
<c>*                           Else, all values are displayed in white.</c>
<c>*   - idxs_no_display:      Indices of the matrix that should not be displayed. The indices should be</c>
<c>*                           given in row-major order, according to get_full_matrix. If not given or if</c>
<c>*                           set to an empty tuple, all matrix values are displayed.</c>
<c>*   - axis_titles:          Titles for the matrix x- and y-axis that are displayed at the top-right</c>
<c>*                           and bottom-left of the matrix, respectively. Should be a tuple of length</c>
<c>*                           two or an empty tuple if no axis titles should be displayed.</c>
<c>*   - value_colors:         Tuple containing the hex color-string for each value of the matrix. If a</c>
<c>*                           single value is given, this color is used for all values, else it must have</c>
<c>*                           the length of the number of values in the matrix. Is ignored if</c>
<c>*                           display_color is false.</c>
<c>*   - number_format:        Format of the numbers when they are converted to strings for display.</c>
<c>*                           Default: 2.0f</c>
<c>*   - title:                Title of the displayed matrix, if given shown in the top-left.</c>
<c>*   - row_col_names_color:  Color of column and row names. Default: 'light gray'</c>
<c>* </c>
<c>* </c>
<c>* Get the matrix dimensions.</c>
<l>get_size_matrix (Matrix, NumRows, NumColumns)</l>
<c>* Set defaults parameters.</c>
<l>DisplayColumnWidth := 'equal'</l>
<l>DisplayColor := false</l>
<l>IdxsNoDisplay := []</l>
<l>AxisTitles := []</l>
<l>ValueColors := gen_tuple_const(NumRows * NumColumns,'white')</l>
<l>NumberFormat := '2.0f'</l>
<l>Title := []</l>
<l>AxisColor := 'light gray'</l>
<c>* Get parameters and overwrite</c>
<l>GenParamKeys := ['display_column_width','display_color','idxs_no_display','axis_titles','value_colors','number_format','title','row_col_names_color']</l>
<l>if (|GenParam| &gt; 0)</l>
<l>    get_dict_param (GenParam, 'key_exists', GenParamKeys, KeyExists)</l>
<c>    * DisplayColumnWidth.</c>
<l>    if (KeyExists[0])</l>
<l>        get_dict_tuple (GenParam, 'display_column_width', ValueTmp)</l>
<l>        if (|ValueTmp| != 1 or find(['equal','minimal'],ValueTmp) == -1)</l>
<l>            throw ('Invalid value for \'display_column_width\'')</l>
<l>        else</l>
<l>            DisplayColumnWidth := ValueTmp</l>
<l>        endif</l>
<l>    endif</l>
<c>    * DisplayColor.</c>
<l>    if (KeyExists[1])</l>
<l>        get_dict_tuple (GenParam, 'display_color', ValueTmp)</l>
<l>        if (|ValueTmp| != 1 or find([true,false],ValueTmp) == -1)</l>
<l>            throw ('Invalid value for \'display_color\'')</l>
<l>        else</l>
<l>            DisplayColor := ValueTmp</l>
<l>        endif</l>
<l>    endif</l>
<c>    * ValueIdxsNoDisplay.</c>
<l>    if (KeyExists[2])</l>
<l>        get_dict_tuple (GenParam, 'idxs_no_display', ValueTmp)</l>
<l>        if (|ValueTmp| &gt; 0)</l>
<l>            if (min(ValueTmp) &lt; 0 or max(ValueTmp) &gt; NumRows * NumColumns - 1 or not is_int(ValueTmp) or |ValueTmp| &gt; NumRows * NumColumns)</l>
<l>                throw ('Invalid value for \'idxs_no_display\'')</l>
<l>            endif</l>
<l>        endif</l>
<l>        IdxsNoDisplay := ValueTmp</l>
<l>    endif</l>
<c>    * AxisTitles.</c>
<l>    if (KeyExists[3])</l>
<l>        get_dict_tuple (GenParam, 'axis_titles', ValueTmp)</l>
<l>        if (|ValueTmp| &gt; 0)</l>
<l>            if (|ValueTmp| &gt; 2 or is_string_elem(ValueTmp) != gen_tuple_const(|ValueTmp|,1))</l>
<l>                throw ('Invalid value for \'axis_titles\'')</l>
<l>            endif</l>
<l>        endif</l>
<l>        AxisTitles := ValueTmp</l>
<l>    endif</l>
<c>    * ValueColors.</c>
<l>    if (KeyExists[4] and DisplayColor)</l>
<l>        get_dict_tuple (GenParam, 'value_colors', ValueTmp)</l>
<l>        if (|ValueTmp| &gt; 0)</l>
<l>            if ((|ValueTmp| != NumColumns * NumRows and |ValueTmp| != 1) or not is_string(ValueTmp))</l>
<l>                throw ('Invalid value for \'value_colors\'')</l>
<l>            endif</l>
<l>            if (|ValueTmp| == 1)</l>
<l>                ValueTmp := gen_tuple_const(NumRows * NumColumns,ValueTmp)</l>
<l>            endif</l>
<l>        endif</l>
<l>        ValueColors := ValueTmp</l>
<l>    endif</l>
<c>    * NumberFormat.</c>
<l>    if (KeyExists[5])</l>
<l>        get_dict_tuple (GenParam, 'number_format', ValueTmp)</l>
<l>        if (|ValueTmp| != 1 or not is_string(ValueTmp))</l>
<l>            throw ('Invalid value for \'number_format\'')</l>
<l>        else</l>
<l>            NumberFormat := ValueTmp</l>
<l>        endif</l>
<l>    endif</l>
<c>    * Title.</c>
<l>    if (KeyExists[6])</l>
<l>        get_dict_tuple (GenParam, 'title', ValueTmp)</l>
<l>        if (|ValueTmp| != 1 or not is_string(ValueTmp))</l>
<l>            throw ('Invalid value for \'title\'')</l>
<l>        else</l>
<l>            Title := ValueTmp</l>
<l>        endif</l>
<l>    endif</l>
<c>    * Color of column and row names.</c>
<l>    if (KeyExists[7])</l>
<l>        get_dict_tuple (GenParam, 'row_col_names_color', ValueTmp)</l>
<l>        if (|ValueTmp| != 1 or not is_string(ValueTmp))</l>
<l>            throw ('Invalid value for \'row_col_names_color\'')</l>
<l>        else</l>
<l>            AxisColor := ValueTmp</l>
<l>        endif</l>
<l>    endif</l>
<l>endif</l>
<c>* </c>
<c>* </c>
<c>* Calculate the width of row and column-name-strings.</c>
<l>ColStringWidths := []</l>
<l>AllNames := [ColumnNames,RowNames]</l>
<l>MaxStringWidth := 0</l>
<l>for StringIndex := 0 to |AllNames| - 1 by 1</l>
<l>    String := AllNames[StringIndex]</l>
<l>    get_string_extents (WindowHandle, String, Ascent, Descent, StringWidth, StringHeight)</l>
<l>    if (StringIndex &lt; |ColumnNames|)</l>
<l>        ColStringWidths := [ColStringWidths,StringWidth]</l>
<l>    endif</l>
<l>    MaxStringWidth := max2(MaxStringWidth,StringWidth)</l>
<l>endfor</l>
<c>* The columns should have a minimum width for 4 characters.</c>
<l>get_string_extents (WindowHandle, 'test', Ascent, Descent, StringWidth, StringHeight)</l>
<c>* Update the maximum string width.</c>
<l>MaxStringWidth := max2(MaxStringWidth,StringWidth)</l>
<c>* </c>
<c>* Set parameters for nice display, e.g. distances from window border, row- and column-offsets,</c>
<c>* axis titles and title.</c>
<l>TitleHeight := 0</l>
<l>AxisTitleHeight := 0</l>
<l>if (|AxisTitles| &gt; 0)</l>
<l>    if (|Title| &gt; 0)</l>
<l>        get_string_extents (WindowHandle, Title, TitleAscent, TitleDescent, TitleWidth, TitleHeight)</l>
<l>        get_string_extents (WindowHandle, AxisTitles, AxisTitleAscent, AxisTitleDescent, AxisTitleWidth, AxisTitleHeight)</l>
<l>    endif</l>
<l>endif</l>
<l>RowStart := 80 + TitleHeight + AxisTitleHeight</l>
<l>RowDistance := StringHeight + 10</l>
<l>RowEnd := StringHeight * 7</l>
<l>ColumnStart := 50 + MaxStringWidth</l>
<l>ColumnOffset := 30</l>
<l>ColumnEnd := ColumnOffset</l>
<c>* </c>
<c>* Adapt the window size to fit the confusion matrix.</c>
<l>if (DisplayColumnWidth == 'minimal')</l>
<c>    * Every column of the confusion matrix is as narrow as possible</c>
<c>    * based to the respective string widths.</c>
<l>    Width := sum(ColStringWidths) + ColumnOffset * NumColumns + ColumnStart + ColumnEnd</l>
<l>elseif (DisplayColumnWidth == 'equal')</l>
<c>    * Every column of the confusion matrix should have the same width.</c>
<c>    * based on the maximum string width.</c>
<l>    Width := (MaxStringWidth + ColumnOffset) * NumColumns + ColumnStart + ColumnEnd</l>
<l>endif</l>
<l>Height := RowDistance * NumRows + RowStart + RowEnd</l>
<l>dev_set_window (WindowHandle)</l>
<l>dev_clear_window ()</l>
<c>* </c>
<c>* Set reasonable limits for graphics window (adapt if necessary).</c>
<l>WidthLimit := [450,Width]</l>
<l>HeightLimit := [250,Height]</l>
<l>dev_resize_window_fit_size (0, 0, Width, Height, WidthLimit, HeightLimit)</l>
<c>* </c>
<c>* </c>
<c>* Calculate row and column coordinates for display of values.</c>
<l>TextRow := []</l>
<l>TextColumn := []</l>
<l>RowStartTmp := 0</l>
<l>ColumnDistance := [0,cumul(ColStringWidths[0:NumColumns - 2] + ColumnOffset)]</l>
<l>if (DisplayColumnWidth == 'equal')</l>
<l>    ColumnDistance := [0:NumColumns - 1] * (MaxStringWidth + ColumnOffset)</l>
<l>endif</l>
<l>for Index := 0 to NumRows - 1 by 1</l>
<l>    TextRow := [TextRow,gen_tuple_const(NumColumns,RowStartTmp)]</l>
<l>    RowStartTmp := RowStartTmp + RowDistance</l>
<l>    TextColumn := [TextColumn,ColumnDistance]</l>
<l>endfor</l>
<c>* Display the confusion matrix with a margin from the top and left.</c>
<l>TextColumn := TextColumn + ColumnStart</l>
<l>TextRow := TextRow + RowStart</l>
<c>* </c>
<c>* Display axis titles.</c>
<l>if (|AxisTitles| &gt; 0)</l>
<l>    if (|Title| &gt; 0)</l>
<l>        get_string_extents (WindowHandle, Title, TitleAscent, TitleDescent, TitleWidth, TitleHeight)</l>
<l>        AxisTitleRowX := 1.5 * ceil(TitleHeight)</l>
<l>    else</l>
<l>        AxisTitleRowX := 'top'</l>
<l>    endif</l>
<l>    dev_disp_text (AxisTitles[0], 'window', AxisTitleRowX, 'right', 'white', 'box', 'false')</l>
<l>    dev_disp_text (AxisTitles[1], 'window', 'bottom', 'left', 'white', 'box', 'false')</l>
<l>endif</l>
<c>* </c>
<c>* Display title.</c>
<l>if (|Title| &gt; 0)</l>
<l>    dev_disp_text (Title, 'window', 'top', 'left', 'white', 'box', 'false')</l>
<l>endif</l>
<c>* </c>
<c>* Display row names.</c>
<l>dev_disp_text (RowNames, 'window', TextRow[[0:NumColumns:NumColumns * (NumRows - 1)]], gen_tuple_const(NumRows,TextColumn[0] - MaxStringWidth - ColumnOffset), AxisColor, 'box', 'false')</l>
<c>* </c>
<c>* Display column names.</c>
<l>dev_disp_text (ColumnNames, 'window', gen_tuple_const(NumColumns,TextRow[0] - RowDistance), TextColumn[0:NumColumns - 1], AxisColor, 'box', 'false')</l>
<c>* </c>
<c>* </c>
<c>* Align the numbers right.</c>
<l>get_full_matrix (Matrix, MatrixText)</l>
<l>MatrixText := MatrixText$NumberFormat</l>
<c>* </c>
<c>* </c>
<c>* Handle no-display indices.</c>
<l>IdxsDisplay := difference([0:|MatrixText| - 1],IdxsNoDisplay)</l>
<c>* </c>
<c>* Display confusion matrix.</c>
<l>dev_disp_text (MatrixText[IdxsDisplay], 'window', TextRow[IdxsDisplay], TextColumn[IdxsDisplay], ValueColors[IdxsDisplay], 'box', 'false')</l>
<l>return ()</l>
</body>
<docu id="dev_display_matrix">
<abstract lang="en_US">Display the values of a matrix inside a window.

GenParam (all are optional):

- display_column_width: Either 'equal' or 'minimal'. For 'equal', all columns have the same width that equals the width of the longest row or column-name. For 'minimal', the columns are just as wide as the column-name string plus a small offset. Default: 'equal'.

- display_color: If true, the values will be displayed with the colors that are given by 'value_colors'. Else, all values are displayed in white. Default: false

- idxs_no_display: Indices of the matrix that should not be displayed. The indices should be given in row-major order, according to get_full_matrix. If not given or if set to an empty tuple, all matrix values are displayed. Default: []

- axis_titles: Titles for the matrix x- and y-axis that are displayed at the top-right and bottom-left of the matrix, respectively. Should be a tuple of length two or an empty tuple if no axis titles should be displayed. Default: []

- value_colors: Tuple containing the hex color-string for each value of the matrix. If a single value is given, this color is used for all values, else it must have the length of the number of values in the matrix. Is ignored if display_color is false.

- number_format: Format of the numbers when they are converted to strings for display. Default: '2.0f'.

- title: Title of the displayed matrix, if given shown in the top-left in white.</abstract>
<chapters lang="de_DE">
<item>Graphik</item>
<item>Ausgabe</item>
</chapters>
<chapters lang="en_US">
<item>Graphics</item>
<item>Output</item>
</chapters>
<library lang="en_US">MVTec Standard Procedures</library>
<short lang="en_US">Display a matrix inside a window</short>
<parameters>
<parameter id="ColumnNames">
<default_value>ColumnNames</default_value>
<description lang="en_US">Names of the columns of the matrix.</description>
<multivalue>optional</multivalue>
<sem_type>string</sem_type>
</parameter>
<parameter id="GenParam">
<default_type>integer</default_type>
<default_value>[]</default_value>
<description lang="en_US">Dict containing generic parameters.</description>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>any</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="Matrix">
<default_type>integer</default_type>
<default_value>Matrix</default_value>
<description lang="en_US">The matrix to be displayed.</description>
<mixed_type>false</mixed_type>
<sem_type>matrix</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="RowNames">
<default_value>RowNames</default_value>
<description lang="en_US">Names of the rows of the matrix.</description>
<multivalue>optional</multivalue>
<sem_type>string</sem_type>
</parameter>
<parameter id="WindowHandle">
<default_type>integer</default_type>
<default_value>WindowHandle</default_value>
<description lang="en_US">The handle of the window where the matrix should be displayed.</description>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>window</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
</parameters>
</docu>
</procedure>
<procedure name="dev_display_ncc_matching_results">
<interface>
<ic>
<par name="ModelID" base_type="ctrl" dimension="0"/>
<par name="Color" base_type="ctrl" dimension="0"/>
<par name="Row" base_type="ctrl" dimension="0"/>
<par name="Column" base_type="ctrl" dimension="0"/>
<par name="Angle" base_type="ctrl" dimension="0"/>
<par name="Model" base_type="ctrl" dimension="0"/>
</ic>
</interface>
<body>
<c>* This procedure displays the results of Correlation-Based Matching.</c>
<c>* </c>
<l>NumMatches := |Row|</l>
<l>if (NumMatches &gt; 0)</l>
<l>    if (|Model| == 0)</l>
<l>        tuple_gen_const (NumMatches, 0, Model)</l>
<l>    elseif (|Model| == 1)</l>
<l>        tuple_gen_const (NumMatches, Model, Model)</l>
<l>    endif</l>
<l>    for Index := 0 to |ModelID| - 1 by 1</l>
<l>        get_ncc_model_region (ModelRegion, ModelID[Index])</l>
<l>        gen_contour_region_xld (ModelRegion, ModelContours, 'border_holes')</l>
<l>        dev_set_color (Color[Index % |Color|])</l>
<l>        for Match := 0 to NumMatches - 1 by 1</l>
<l>            if (Index == Model[Match])</l>
<l>                hom_mat2d_identity (HomMat2DIdentity)</l>
<l>                hom_mat2d_rotate (HomMat2DIdentity, Angle[Match], 0, 0, HomMat2DRotate)</l>
<l>                hom_mat2d_translate (HomMat2DRotate, Row[Match], Column[Match], HomMat2DTranslate)</l>
<l>                affine_trans_contour_xld (ModelContours, ContoursAffinTrans, HomMat2DTranslate)</l>
<l>                dev_display (ContoursAffinTrans)</l>
<l>                affine_trans_pixel (HomMat2DTranslate, 0, 0, RowTrans, ColTrans)</l>
<l>                gen_cross_contour_xld (Cross, RowTrans, ColTrans, 6, Angle[Match])</l>
<l>                dev_display (Cross)</l>
<l>            endif</l>
<l>        endfor</l>
<l>    endfor</l>
<l>endif</l>
<l>return ()</l>
</body>
<docu id="dev_display_ncc_matching_results">
<abstract lang="en_US">The procedure dev_display_ncc_matching_results displays the results of correlation-based matching. 

In ModelID, the NCC models for which results should be displayed are passed. This parameter typically contains the same values that were returned by the operators find_ncc_model or find_ncc_models.

Color is a tuple of colors that will be used for the visualization. If Color contains only one element, all found instances are displayed in this color. If each found instance should be displayed in a color associated with the respective NCC model, the number of colors has to correspond to the number of NCC models in ModelID. If Color is a tuple that does not have the same number of elements as ModelID, the specified colors are used cyclically for the visualization of the matching results.


Row, Column, and Angle contain the position and rotation information of the found instances of the NCC models.

The elements of Model describe to which element of the tuple ModelID the elements of Row, Column, Angle refer to. The elements of Model are indices into the tuple ModelID, i.e., they can contain values from 0 to |ModelID|-1.  Hence, a value of 0 in an element of Model corresponds to an instance of the first model in ModelID. If only one model is given in ModelID, Model can be set to 0. Otherwise, the output of the operator find_ncc_models can be used directly.
</abstract>
<chapters>
<item>Matching</item>
<item>Shape-Based</item>
</chapters>
<chapters lang="de_DE">
<item>Matching</item>
<item>Korrelationsbasiert</item>
</chapters>
<chapters lang="en_US">
<item>Matching</item>
<item>Correlation-Based</item>
</chapters>
<example lang="en_US">read_image (Image, 'circle_plate')
* 
gen_rectangle2 (Template, 420, 786, 0, 50, 50)
reduce_domain (Image, Template, ImageTemplate)
create_ncc_model (ImageTemplate, 'auto', -rad(45), rad(90), 'auto', 'use_polarity', Model1ID)
*
gen_rectangle2 (Template, 710, 790, 0, 100, 100)
reduce_domain (Image, Template, ImageTemplate)
create_ncc_model (ImageTemplate, 'auto', -rad(45), rad(90), 'auto', 'use_polarity', Model2ID)
*
ModelIDs := [Model1ID,Model2ID]
rotate_image (ImageTemplate, ImageRotate, 10, 'constant')
find_ncc_models (ImageRotate, ModelIDs,  -rad(45), rad(90), 0.8, 2, 0.5, 'true', 0, Row, Column, Angle, Score, Model)
*
dev_display_ncc_matching_results (ModelIDs, ['green', 'blue'], Row, Column, Angle, Model)
</example>
<keywords lang="de_DE">
<item>Ergebnisse des korrelationsbasierten Matchings anzeigen</item>
</keywords>
<keywords lang="en_US">
<item>display results of correlation-based matching</item>
</keywords>
<library lang="de_DE">MVTec Standard Procedures</library>
<library lang="en_US">MVTec Standard Procedures</library>
<predecessor>
<item>find_ncc_model</item>
<item>find_ncc_models</item>
</predecessor>
<short>This procedure displays the results of Shape-based Matching.</short>
<short lang="de_DE">Anzeigen der Ergebnisse der korrelationsbasierten Matchings.</short>
<short lang="en_US">Display the results of Correlation-Based Matching.</short>
<parameters>
<parameter id="Angle">
<default_type>real</default_type>
<description lang="en_US">Rotation angle of the found instances of the models.</description>
<mixed_type>optional</mixed_type>
<multivalue>optional</multivalue>
<sem_type>angle.rad</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
<parameter id="Color">
<default_type>string</default_type>
<default_value>'red'</default_value>
<description lang="en_US">Colors used for the visualization of the matching result.</description>
<mixed_type>false</mixed_type>
<multivalue>optional</multivalue>
<sem_type>color</sem_type>
<type_list>
<item>string</item>
</type_list>
<values>
<item>'red'</item>
<item>'green'</item>
<item>'blue'</item>
<item>['red','green','blue']</item>
<item>['red','green','blue','cyan','magenta','yellow']</item>
</values>
</parameter>
<parameter id="Column">
<default_type>real</default_type>
<description lang="en_US">Column coordinate of the found instances of the models.</description>
<mixed_type>optional</mixed_type>
<multivalue>optional</multivalue>
<sem_type>point.x</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
<parameter id="Model">
<default_type>integer</default_type>
<default_value>0</default_value>
<description lang="en_US">Index of the found instances of the models.</description>
<mixed_type>false</mixed_type>
<multivalue>optional</multivalue>
<sem_type>integer</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="ModelID">
<default_type>integer</default_type>
<description lang="en_US">IDs of the NCC models for which the results should be displayed.</description>
<mixed_type>false</mixed_type>
<multivalue>optional</multivalue>
<sem_type>ncc_model</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="Row">
<default_type>real</default_type>
<description lang="en_US">Row coordinate of the found instances of the models.</description>
<mixed_type>optional</mixed_type>
<multivalue>optional</multivalue>
<sem_type>point.y</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
</parameters>
</docu>
</procedure>
<procedure name="dev_display_pie_chart">
<interface>
<ic>
<par name="WindowHandle" base_type="ctrl" dimension="0"/>
<par name="Ratios" base_type="ctrl" dimension="0"/>
<par name="Row" base_type="ctrl" dimension="0"/>
<par name="Column" base_type="ctrl" dimension="0"/>
<par name="Radius" base_type="ctrl" dimension="0"/>
<par name="Colors" base_type="ctrl" dimension="0"/>
<par name="GenParam" base_type="ctrl" dimension="0"/>
</ic>
</interface>
<body>
<c>* </c>
<c>* Draw a pie-chart into the active window.</c>
<c>* </c>
<c>* Check input Ratios.</c>
<l>if (sum(Ratios [&lt;] 0.0) &gt; 0)</l>
<l>    throw ('Values of parameter Ratios must be positive.')</l>
<l>endif</l>
<l>Tolerance := 0.1</l>
<l>if (abs(1 - sum(Ratios)) &gt;= Tolerance)</l>
<l>    throw ('Sum of Ratios differs too much from 1.')</l>
<l>endif</l>
<c>* </c>
<c>* Get current window handle.</c>
<l>dev_get_window (InitialWindowHandle)</l>
<c>* In case there is no open window, no initial values are to be reset.</c>
<l>NoInitialWindow := 0</l>
<l>if (InitialWindowHandle == -1)</l>
<l>    NoInitialWindow := 1</l>
<l>else</l>
<c>    * Get current set color.</c>
<l>    get_rgba (InitialWindowHandle, Red, Green, Blue, Alpha)</l>
<l>    InitialColor := []</l>
<l>    for IndexColor := 0 to |Red| - 1 by 1</l>
<l>        Color_RGBA := '#' + Red[IndexColor]$'2x' + Green[IndexColor]$'2x' + Blue[IndexColor]$'2x' + Alpha[IndexColor]$'2x'</l>
<l>        tuple_regexp_replace (Color_RGBA, [' ','replace_all'], '0', Color_RGBA)</l>
<l>        InitialColor := [InitialColor,Color_RGBA]</l>
<l>    endfor</l>
<l>endif</l>
<l>dev_set_window (WindowHandle)</l>
<c>* </c>
<c>* In case no segment colors are specified, generate random colors.</c>
<l>if (|Colors| == 0)</l>
<c>    * Generate random colors.</c>
<l>    get_distinct_colors (|Ratios|, true, 0, 220, Colors)</l>
<l>endif</l>
<c>* </c>
<c>* Set default parameters.</c>
<l>Title := []</l>
<l>TitleColor := 'white'</l>
<c>* Get generic parameters.</c>
<l>if (|GenParam| &gt; 0)</l>
<l>    get_dict_param (GenParam, 'key_exists', 'title', TitleKeyExists)</l>
<l>    get_dict_param (GenParam, 'key_exists', 'title_color', TitleColorKeyExists)</l>
<c>    * </c>
<c>    * Title text.</c>
<l>    if (TitleKeyExists)</l>
<l>        get_dict_tuple (GenParam, 'title', GivenTitle)</l>
<l>        if (not is_string(GivenTitle) or strlen(GivenTitle) &lt; 1)</l>
<l>            throw ('Invalid value for key \'title\'')</l>
<l>        endif</l>
<l>        Title := GivenTitle</l>
<l>    endif</l>
<c>    * Title color.</c>
<l>    if (TitleColorKeyExists)</l>
<l>        get_dict_tuple (GenParam, 'title_color', GivenTitleColor)</l>
<l>        if (not is_string(GivenTitleColor))</l>
<l>            throw ('Invalid value for key \'title_color\'')</l>
<l>        endif</l>
<l>        try</l>
<l>            dev_set_color (GivenTitleColor)</l>
<l>        catch (Exception)</l>
<l>            throw ('Invalid value for key \'title_color\'')</l>
<l>        endtry</l>
<l>        TitleColor := GivenTitleColor</l>
<l>    endif</l>
<l>endif</l>
<l>FullCircleAngle := 2 * 3.14159</l>
<l>StartAngle := 0</l>
<c>* </c>
<c>* Generate circle-sectors.</c>
<l>Ratios := Ratios / sum(Ratios)</l>
<l>DrawColors := []</l>
<l>gen_empty_obj (Sectors)</l>
<l>for K := 0 to |Ratios| - 1 by 1</l>
<l>    if (Ratios[K] &gt; 0)</l>
<l>        EndAngle := StartAngle + Ratios[K] * FullCircleAngle</l>
<l>        gen_circle_contour_xld (Arc, Row, Column, Radius, StartAngle, EndAngle, 'positive', 1)</l>
<l>        get_contour_xld (Arc, Rows, Columns)</l>
<l>        gen_contour_polygon_xld (Sector, [Row,Rows,Row], [Column,Columns,Column])</l>
<l>        StartAngle := EndAngle</l>
<l>        DrawColors := [DrawColors,Colors[K]]</l>
<l>        concat_obj (Sectors, Sector, Sectors)</l>
<l>    endif</l>
<l>endfor</l>
<c>* Rotate 90 degrees such that the first sector starts at the top.</c>
<l>hom_mat2d_identity (HomMat2DIdentity)</l>
<l>hom_mat2d_rotate (HomMat2DIdentity, 0.25 * FullCircleAngle, Row, Column, HomMat2DRotate)</l>
<l>affine_trans_contour_xld (Sectors, Sectors, HomMat2DRotate)</l>
<c>* </c>
<c>* Display sectors.</c>
<l>dev_set_window (WindowHandle)</l>
<l>get_contour_style (WindowHandle, ContourStyle)</l>
<l>dev_set_contour_style ('stroke_and_fill')</l>
<l>dev_set_color (DrawColors)</l>
<l>dev_display (Sectors)</l>
<c>* (Optional) title.</c>
<l>if (Title != [])</l>
<l>    get_string_extents (WindowHandle, Title, Ascent, Descent, Width, Height)</l>
<l>    dev_disp_text (Title, 'image', Row - Radius - Height - Ascent - Descent, Column - Width / 2, TitleColor, 'box', 'false')</l>
<l>endif</l>
<l>dev_set_contour_style (ContourStyle)</l>
<c>* </c>
<c>* Reset original window and colors (and close the window in case there was none open).</c>
<l>if (NoInitialWindow)</l>
<l>    dev_close_window ()</l>
<l>else</l>
<l>    dev_set_window (InitialWindowHandle)</l>
<l>    dev_set_color (InitialColor)</l>
<l>endif</l>
<l>return ()</l>
</body>
<docu id="dev_display_pie_chart">
<abstract lang="en_US">This procedure draws a pie-chart into the given WindowHandle with its center at the point (Row, Column) and the given Radius.

Ratios determines the number of sectors and their angle. Note, Ratios should sum up to 1.0 and they are rescaled if the sum does not differ more than 0.1.
Colors is a tuple of strings determining the colors used for the pie-chart sectors. In order to do so it needs to have the same length as Ratios. Otherwise it can be set to an empty tuple, resulting in random distinct colors.

The dictionary GenParam supports the following key/value pairs:
- 'title': Set the given string as title on the top of the pie chart.
- 'title_color': Set the color used to display the title.</abstract>
<chapters lang="de_DE">
<item>Graphik</item>
<item>Ausgabe</item>
</chapters>
<chapters lang="en_US">
<item>Graphics</item>
<item>Output</item>
</chapters>
<library lang="en_US">MVTec Standard Procedures</library>
<short lang="en_US">This procedure draws a pie chart into the active window handle.</short>
<parameters>
<parameter id="Colors">
<default_type>string</default_type>
<default_value>Colors</default_value>
<description lang="en_US">Colors of the pie chart sectors.</description>
<multivalue>true</multivalue>
<sem_type>string</sem_type>
<type_list>
<item>string</item>
</type_list>
</parameter>
<parameter id="Column">
<default_type>real</default_type>
<default_value>Column</default_value>
<description lang="en_US">Column coordinate of the pie chart center.</description>
<multivalue>false</multivalue>
<sem_type>real</sem_type>
<type_list>
<item>real</item>
</type_list>
</parameter>
<parameter id="GenParam">
<default_type>integer</default_type>
<default_value>[]</default_value>
<description lang="en_US">Dictionary containing generic parameters.</description>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>any</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="Radius">
<default_type>real</default_type>
<default_value>Radius</default_value>
<description lang="en_US">Radius of the pie chart.</description>
<multivalue>false</multivalue>
<sem_type>real</sem_type>
<type_list>
<item>real</item>
</type_list>
</parameter>
<parameter id="Ratios">
<default_type>real</default_type>
<default_value>Ratios</default_value>
<description lang="en_US">Tuple of ratios determining the pie chart sectors.</description>
<multivalue>optional</multivalue>
<sem_type>real</sem_type>
<type_list>
<item>real</item>
</type_list>
</parameter>
<parameter id="Row">
<default_type>real</default_type>
<default_value>Row</default_value>
<description lang="en_US">Row coordinate of the pie chart center.</description>
<multivalue>false</multivalue>
<sem_type>real</sem_type>
<type_list>
<item>real</item>
</type_list>
</parameter>
<parameter id="WindowHandle">
<default_type>integer</default_type>
<default_value>WindowHandle</default_value>
<description lang="en_US">Window handle, where the pie chart is displayed.</description>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>handle</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
</parameters>
</docu>
</procedure>
<procedure name="dev_display_pixel_confusion_matrix" access="local">
<interface>
<ic>
<par name="ConfusionMatrix" base_type="ctrl" dimension="0"/>
<par name="ClassNames" base_type="ctrl" dimension="0"/>
<par name="GenParam" base_type="ctrl" dimension="0"/>
<par name="WindowHandles" base_type="ctrl" dimension="0"/>
</ic>
</interface>
<body>
<c>* </c>
<c>* This procedure displays the confusion matrix given by ConfusionMatrix.</c>
<c>* Thereby, the matrix can be displayed with absolute or</c>
<c>* relative values.</c>
<c>* </c>
<c>* Set the default values for generic parameters.</c>
<l>DisplayAbsoluteMatrix := true</l>
<l>DisplayRelativeMatrix := false</l>
<l>DisplayColor := true</l>
<l>DisplayColumnWidth := 'equal'</l>
<l>RowColNameColor := 'light gray'</l>
<c>* </c>
<c>* Parse generic parameters.</c>
<l>if (|GenParam| &gt; 0)</l>
<l>    GenParamKeys := ['display_color','display_relative_matrix','display_absolute_matrix','display_column_width','row_col_names_color']</l>
<l>    get_dict_param (GenParam, 'key_exists', GenParamKeys, KeyExists)</l>
<c>    * DisplayColor</c>
<l>    if (KeyExists[0])</l>
<l>        get_dict_tuple (GenParam, GenParamKeys[0], ValueTmp)</l>
<l>        if (|ValueTmp| != 1 or find([true,false],ValueTmp) == -1)</l>
<l>            throw ('Invalid value for \'display_color\'')</l>
<l>        else</l>
<l>            DisplayColor := ValueTmp</l>
<l>        endif</l>
<l>    endif</l>
<c>    * DisplayRelativeMatrix.</c>
<l>    if (KeyExists[1])</l>
<l>        get_dict_tuple (GenParam, GenParamKeys[1], ValueTmp)</l>
<l>        if (|ValueTmp| != 1 or find([true,false],ValueTmp) == -1)</l>
<l>            throw ('Invalid value for \'display_relative_matrix\'')</l>
<l>        else</l>
<l>            DisplayRelativeMatrix := ValueTmp</l>
<l>        endif</l>
<l>    endif</l>
<c>    * DisplayAbsoluteMatrix.</c>
<l>    if (KeyExists[2])</l>
<l>        get_dict_tuple (GenParam, GenParamKeys[2], ValueTmp)</l>
<l>        if (|ValueTmp| != 1 or find([true,false],ValueTmp) == -1)</l>
<l>            throw ('Invalid value for \'display_absolute_matrix\'')</l>
<l>        else</l>
<l>            DisplayAbsoluteMatrix := ValueTmp</l>
<l>        endif</l>
<l>    endif</l>
<c>    * DisplayColumnWidth.</c>
<l>    if (KeyExists[3])</l>
<l>        get_dict_tuple (GenParam, GenParamKeys[3], DisplayColumnWidthTmp)</l>
<l>        if (|DisplayColumnWidthTmp| != 1 or find(['equal','minimal'],DisplayColumnWidthTmp) == -1)</l>
<l>            throw ('Invalid value for \'display_column_width\'')</l>
<l>        else</l>
<l>            DisplayColumnWidth := DisplayColumnWidthTmp</l>
<l>        endif</l>
<l>    endif</l>
<c>    * Color for row and column names.</c>
<l>    if (KeyExists[4])</l>
<l>        get_dict_tuple (GenParam, GenParamKeys[4], ValueTmp)</l>
<l>        if (|ValueTmp| != 1 or not is_string(ValueTmp))</l>
<l>            throw ('Invalid value for \'row_col_names_color\'')</l>
<l>        endif</l>
<l>        RowColNameColor := ValueTmp</l>
<l>    endif</l>
<l>endif</l>
<c>* </c>
<l>if (not (DisplayRelativeMatrix or DisplayAbsoluteMatrix))</l>
<l>    throw ('At least one of \'display_absolute_matrix\' and \'display_relative_matrix\' should be true')</l>
<l>endif</l>
<l>if (DisplayRelativeMatrix + DisplayAbsoluteMatrix != |WindowHandles|)</l>
<l>    throw ('Wrong number of WindowHandles')</l>
<l>endif</l>
<c>* </c>
<c>* Calculate the confusion matrix with absolute values</c>
<c>* and the confusion matrix with relative errors.</c>
<l>get_size_matrix (ConfusionMatrix, NumRows, NumColumns)</l>
<l>get_full_matrix (ConfusionMatrix, Values)</l>
<c>* </c>
<l>if (DisplayRelativeMatrix)</l>
<c>    * Calculate relative matrix for display and in order to set colors correctly.</c>
<l>    copy_matrix (ConfusionMatrix, ConfusionMatrixRelative)</l>
<c>    * For each class:</c>
<l>    for C := 0 to |ClassNames| - 1 by 1</l>
<c>        * Get the total number of predictions and calculate the relative values.</c>
<l>        get_value_matrix (ConfusionMatrix, gen_tuple_const(NumColumns,C), [0:NumColumns - 1], RowValues)</l>
<l>        if (sum(RowValues) &gt; 0)</l>
<l>            set_value_matrix (ConfusionMatrixRelative, gen_tuple_const(NumColumns,C), [0:NumColumns - 1], real(RowValues) / sum(RowValues))</l>
<l>        else</l>
<l>            set_value_matrix (ConfusionMatrixRelative, gen_tuple_const(NumColumns,C), [0:NumColumns - 1], real(RowValues))</l>
<l>        endif</l>
<l>    endfor</l>
<l>endif</l>
<c>* </c>
<c>* Set color for displayed confusion matrix.</c>
<l>ValueColors := gen_tuple_const(|Values|,'#666666')</l>
<l>if (DisplayColor)</l>
<c>    * Display off-diagonal values in red.</c>
<l>    ValueColors := gen_tuple_const(|Values|,'#ff4500')</l>
<c>    * Display diagonal values in green.</c>
<l>    DiagonalColor := '#00ff00'</l>
<l>    tuple_gen_sequence (0, NumColumns - 1, 1, Seq)</l>
<l>    DiagonalIndices := NumColumns * Seq + Seq</l>
<l>    ValueColors[DiagonalIndices] := DiagonalColor</l>
<l>endif</l>
<c>* </c>
<c>* Display the matrix.</c>
<c>* </c>
<c>* Create GenParam for matrix display.</c>
<l>create_dict (GenParamDisplay)</l>
<l>set_dict_tuple (GenParamDisplay, 'display_column_width', DisplayColumnWidth)</l>
<l>set_dict_tuple (GenParamDisplay, 'display_color', DisplayColor)</l>
<l>set_dict_tuple (GenParamDisplay, 'axis_titles', ['Ground truth labels','Predicted classes'])</l>
<l>set_dict_tuple (GenParamDisplay, 'value_colors', ValueColors)</l>
<l>set_dict_tuple (GenParamDisplay, 'row_col_names_color', RowColNameColor)</l>
<l>if (DisplayAbsoluteMatrix)</l>
<c>    * Display absolute matrix.</c>
<c>    * Calculate proper number format.</c>
<l>    max_matrix (ConfusionMatrix, 'full', MatrixMaxID)</l>
<l>    get_full_matrix (MatrixMaxID, MaxValue)</l>
<l>    if (MaxValue &gt; 0)</l>
<l>        NumberFormat := int(ceil(log10(MaxValue))) + '.0f'</l>
<l>    else</l>
<l>        NumberFormat := '1.0f'</l>
<l>    endif</l>
<l>    set_dict_tuple (GenParamDisplay, 'number_format', NumberFormat)</l>
<c>    * Set title.</c>
<l>    set_dict_tuple (GenParamDisplay, 'title', 'Pixel confusion matrix, absolute')</l>
<c>    * Display the matrix.</c>
<l>    dev_display_matrix (ConfusionMatrix, ClassNames, ClassNames, WindowHandles[0], GenParamDisplay)</l>
<l>endif</l>
<c>* </c>
<l>if (DisplayRelativeMatrix)</l>
<c>    * Display relative matrix.</c>
<c>    * Convert relative matrix values to percent.</c>
<l>    get_full_matrix (ConfusionMatrixRelative, ValuesRelative)</l>
<l>    set_full_matrix (ConfusionMatrixRelative, 100 * ValuesRelative)</l>
<c>    * Set number format.</c>
<l>    NumberFormat := '2.1f'</l>
<l>    set_dict_tuple (GenParamDisplay, 'number_format', NumberFormat)</l>
<c>    * Set title.</c>
<l>    set_dict_tuple (GenParamDisplay, 'title', 'Pixel confusion matrix, relative [%]')</l>
<c>    * Display the matrix.</c>
<l>    dev_display_matrix (ConfusionMatrixRelative, ClassNames, ClassNames, WindowHandles[DisplayAbsoluteMatrix], GenParamDisplay)</l>
<l>endif</l>
<c></c>
<l>return ()</l>
</body>
<docu id="dev_display_pixel_confusion_matrix">
<abstract lang="en_US">This procedure displays the confusion matrix given by ConfusionMatrix.
ClassNames determines the classes and their names in the confusion matrix.
WindowHandles is a tuple containing the handles of the windows used for the display. 

The dictionary GenParam is used to determine, which matrix shall be displayed and in which style. Thereby, the following options are possible to set as entry:
- 'display_relative_matrix' (default: false): If set to true, a matrix is shown with relative values given as percentages. Note that for each class, the row sums up to one, thus 100 percent. That means, that we show the relative number of detections of this class in each field.
- 'display_absolute_matrix' (default: true): If set to true, the matrix with absolute numbers of objects is shown.
- 'display_color' (default: true): If set to true, the displayed matrix values are colored in green and red. The diagonal values, i.e. the true positives are colored in green whereas the off-diagonal values, i.e. false positives and false negatives, are colored in red. If set to false, all values are displayed in gray.
- 'display_column_width': This key can have the following associated values:
   -- 'equal' (default): All columns have the same width that equals the width of the longest row or column-name.
   -- 'minimal': The columns are just as wide as the column-name string plus a small offset.
- RowColNameColor (default: 'light gray'): String, determining the color used to display column and row names.

The number of WindowHandles needed depends on the number of requested matrices: If both, 'display_absolute_matrix' and 'display_relative_matrix' are requested (thus, having a value 'true'), two window handles are needed. Thereby, the first is used for the absolute and the second for the relative matrix.
The windows in WindowHandles are not rearranged and might be overlapping when they are returned.
</abstract>
<chapters lang="de_DE">
<item>Deep Learning</item>
<item>Evaluierung</item>
</chapters>
<chapters lang="en_US">
<item>Deep Learning</item>
<item>Evaluation</item>
</chapters>
<library lang="en_US">MVTec Standard Procedures</library>
<short lang="en_US">Display the confusion matrix given by ConfusionMatrix.</short>
<parameters>
<parameter id="ClassNames">
<default_type>string</default_type>
<default_value>ClassNames</default_value>
<description lang="en_US">The ClassNames to be displayed with the confusion matrix.</description>
<multivalue>optional</multivalue>
<sem_type>any</sem_type>
<type_list>
<item>string</item>
</type_list>
</parameter>
<parameter id="ConfusionMatrix">
<default_type>integer</default_type>
<default_value>ConfusionMatrix</default_value>
<description lang="en_US">The confusion matrix to be displayed.</description>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>matrix</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="GenParam">
<default_value>[]</default_value>
<description lang="en_US">The dictionary is used to specify the matrix type and its visualization.</description>
<multivalue>false</multivalue>
<sem_type>any</sem_type>
</parameter>
<parameter id="WindowHandles">
<default_type>integer</default_type>
<default_value>WindowHandles</default_value>
<description lang="en_US">Tuple of one or two window handles, where the matrices are displayed.</description>
<mixed_type>false</mixed_type>
<multivalue>optional</multivalue>
<sem_type>handle</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
</parameters>
</docu>
</procedure>
<procedure name="dev_display_result_anomaly_regions" access="local">
<interface>
<io>
<par name="AnomalyImage" base_type="iconic" dimension="0"/>
</io>
<oo>
<par name="AnomalyRegion" base_type="iconic" dimension="0"/>
</oo>
<ic>
<par name="CurrentWindowHandle" base_type="ctrl" dimension="0"/>
<par name="AnomalyRegionThreshold" base_type="ctrl" dimension="0"/>
<par name="LineWidth" base_type="ctrl" dimension="0"/>
<par name="AnomalyRegionResultColor" base_type="ctrl" dimension="0"/>
</ic>
</interface>
<body>
<c>* </c>
<c>* This procedure displays the result anomaly regions</c>
<c>* given in DLResult as anomaly_image.</c>
<c>* </c>
<c>* Get current set color.</c>
<l>get_rgba (CurrentWindowHandle, Red, Green, Blue, Alpha)</l>
<l>InitialColor := []</l>
<l>for IndexColor := 0 to |Red| - 1 by 1</l>
<l>    Color_RGBA := '#' + Red[IndexColor]$'2x' + Green[IndexColor]$'2x' + Blue[IndexColor]$'2x' + Alpha[IndexColor]$'2x'</l>
<l>    tuple_regexp_replace (Color_RGBA, [' ','replace_all'], '0', Color_RGBA)</l>
<l>    InitialColor := [InitialColor,Color_RGBA]</l>
<l>endfor</l>
<c>* </c>
<l>if (AnomalyRegionThreshold &gt; 1 or AnomalyRegionThreshold &lt; 0)</l>
<l>    throw ('Selected \'anomaly_region_threshold\' out of range. It must be between 0 and 1.')</l>
<l>endif</l>
<l>threshold (AnomalyImage, AnomalyRegion, AnomalyRegionThreshold, 1)</l>
<c>* </c>
<c>* Display anomaly regions.</c>
<c>* Get non-empty regions.</c>
<l>region_features (AnomalyRegion, 'area', Area)</l>
<c>* </c>
<c>* Display all non-empty class regions in distinct colors.</c>
<l>if (Area &gt; 0)</l>
<l>    dev_set_color (AnomalyRegionResultColor)</l>
<l>    dev_set_line_width (LineWidth)</l>
<l>    dev_set_draw ('margin')</l>
<l>    dev_display (AnomalyRegion)</l>
<l>endif</l>
<c>* </c>
<c>* Reset colors.</c>
<l>dev_set_color (InitialColor)</l>
<c>* </c>
<l>return ()</l>
</body>
<docu id="dev_display_result_anomaly_regions">
<chapters lang="en_US">
<item>Deep Learning</item>
<item>Anomaly Detection</item>
</chapters>
<library lang="en_US">MVTec Standard Procedures</library>
<short lang="en_US">Display the detected anomaly regions.</short>
<parameters>
<parameter id="AnomalyImage"/>
<parameter id="AnomalyRegion"/>
<parameter id="AnomalyRegionResultColor">
<sem_type>string</sem_type>
</parameter>
<parameter id="AnomalyRegionThreshold"/>
<parameter id="CurrentWindowHandle"/>
<parameter id="LineWidth"/>
</parameters>
</docu>
</procedure>
<procedure name="dev_display_result_detection" access="local">
<interface>
<ic>
<par name="DLResult" base_type="ctrl" dimension="0"/>
<par name="ResultKeys" base_type="ctrl" dimension="0"/>
<par name="LineWidthBbox" base_type="ctrl" dimension="0"/>
<par name="ClassIDs" base_type="ctrl" dimension="0"/>
<par name="TextConf" base_type="ctrl" dimension="0"/>
<par name="Colors" base_type="ctrl" dimension="0"/>
<par name="BoxLabelColor" base_type="ctrl" dimension="0"/>
<par name="WindowImageRatio" base_type="ctrl" dimension="0"/>
<par name="TextPositionRow" base_type="ctrl" dimension="0"/>
<par name="TextColor" base_type="ctrl" dimension="0"/>
<par name="ShowLabels" base_type="ctrl" dimension="0"/>
<par name="ShowDirection" base_type="ctrl" dimension="0"/>
<par name="WindowHandle" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="BboxIDs" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c>* </c>
<c>* This procedure displays the bounding boxes defined by DLResult.</c>
<c>* The ClassIDs are necessary to display bounding boxes from the same class</c>
<c>* always with the same color.</c>
<c>* </c>
<l>InstanceType := 'rectangle1'</l>
<l>if (find(ResultKeys,'bbox_row1') != -1)</l>
<l>    get_dict_tuple (DLResult, 'bbox_row1', BboxRow1)</l>
<l>    get_dict_tuple (DLResult, 'bbox_col1', BboxCol1)</l>
<l>    get_dict_tuple (DLResult, 'bbox_row2', BboxRow2)</l>
<l>    get_dict_tuple (DLResult, 'bbox_col2', BboxCol2)</l>
<l>    get_dict_tuple (DLResult, 'bbox_class_id', BboxClasses)</l>
<l>elseif (find(ResultKeys,'bbox_phi') != -1)</l>
<l>    get_dict_tuple (DLResult, 'bbox_row', BboxRow)</l>
<l>    get_dict_tuple (DLResult, 'bbox_col', BboxCol)</l>
<l>    get_dict_tuple (DLResult, 'bbox_length1', BboxLength1)</l>
<l>    get_dict_tuple (DLResult, 'bbox_length2', BboxLength2)</l>
<l>    get_dict_tuple (DLResult, 'bbox_phi', BboxPhi)</l>
<l>    get_dict_tuple (DLResult, 'bbox_class_id', BboxClasses)</l>
<l>    InstanceType := 'rectangle2'</l>
<l>else</l>
<l>    throw ('Result bounding box data could not be found in DLResult.')</l>
<l>endif</l>
<l>if (|BboxClasses| &gt; 0)</l>
<c>    * Generate bounding box XLDs.</c>
<l>    if (InstanceType == 'rectangle1')</l>
<l>        tuple_gen_const (|BboxRow1|, 0.0, BboxPhi)</l>
<l>        gen_rectangle2_contour_xld (BboxRectangle, 0.5 * (BboxRow1 + BboxRow2), 0.5 * (BboxCol1 + BboxCol2), BboxPhi, 0.5 * (BboxCol2 - BboxCol1), 0.5 * (BboxRow2 - BboxRow1))</l>
<l>        LabelRow1 := BboxRow1</l>
<l>        LabelRow2 := BboxRow2</l>
<l>        LabelCol := BboxCol1</l>
<l>    else</l>
<l>        gen_rectangle2_contour_xld (BboxRectangle, BboxRow, BboxCol, BboxPhi, BboxLength1, BboxLength2)</l>
<l>        LabelRow1 := BboxRow</l>
<l>        LabelRow2 := BboxRow</l>
<l>        LabelCol := BboxCol</l>
<l>        if (ShowDirection)</l>
<l>            HeadSize := 20.0</l>
<l>            gen_arrow_contour_xld (OrientationArrows, BboxRow, BboxCol, BboxRow - (BboxLength1 + HeadSize) * sin(BboxPhi), BboxCol + (BboxLength1 + HeadSize) * cos(BboxPhi), HeadSize, HeadSize)</l>
<l>        endif</l>
<l>    endif</l>
<c>    * </c>
<l>    get_draw (WindowHandle, DrawMode)</l>
<l>    dev_set_draw ('margin')</l>
<l>    get_line_style (WindowHandle, Style)</l>
<l>    dev_set_line_width (LineWidthBbox)</l>
<c>    * </c>
<c>    * Collect ClassIDs of the bounding boxes.</c>
<l>    BboxIDs := []</l>
<l>    BboxClassIDs := []</l>
<c>    * </c>
<c>    * Draw bounding boxes.</c>
<l>    for IndexBbox := 0 to |BboxClasses| - 1 by 1</l>
<l>        select_obj (BboxRectangle, RectangleSelected, IndexBbox + 1)</l>
<l>        ClassID := find(ClassIDs,BboxClasses[IndexBbox])</l>
<l>        BboxClassIDs := [BboxClassIDs,ClassID]</l>
<l>        BboxIDs := [BboxIDs,ClassID]</l>
<l>        get_line_width (WindowHandle, LineWidth)</l>
<l>        dev_set_line_width (int(LineWidth + 2))</l>
<l>        dev_set_color ('black')</l>
<l>        dev_display (RectangleSelected)</l>
<l>        if (InstanceType == 'rectangle2' and ShowDirection)</l>
<l>            select_obj (OrientationArrows, ArrowSelected, IndexBbox + 1)</l>
<l>            dev_display (ArrowSelected)</l>
<l>        endif</l>
<l>        dev_set_line_width (int(LineWidth))</l>
<l>        dev_set_color (Colors[ClassID])</l>
<l>        dev_display (RectangleSelected)</l>
<l>        if (InstanceType == 'rectangle2' and ShowDirection)</l>
<l>            dev_display (ArrowSelected)</l>
<l>        endif</l>
<l>    endfor</l>
<c>    * </c>
<c>    * Draw text of bounding boxes.</c>
<l>    if (ShowLabels)</l>
<c>        * For better visibility the text is displayed after all bounding boxes are drawn.</c>
<l>        for IndexBbox := 0 to |BboxClasses| - 1 by 1</l>
<l>            ClassID := BboxClassIDs[IndexBbox]</l>
<l>            Text := BboxClasses[IndexBbox] + TextConf[IndexBbox]</l>
<l>            get_string_extents (WindowHandle, Text, Ascent, Descent, _, _)</l>
<l>            if (TextPositionRow == 'bottom')</l>
<l>                TextRow := LabelRow2[IndexBbox] - (Ascent + Descent) / WindowImageRatio</l>
<l>            else</l>
<l>                TextRow := LabelRow1[IndexBbox]</l>
<l>            endif</l>
<l>            if (TextColor == '')</l>
<l>                TxtColor := Colors[ClassID]</l>
<l>            else</l>
<l>                TxtColor := TextColor</l>
<l>            endif</l>
<l>            dev_disp_text (Text, 'image', TextRow, LabelCol[IndexBbox], TxtColor, ['box_color','shadow','border_radius'], [BoxLabelColor,'false',0])</l>
<l>        endfor</l>
<l>    endif</l>
<c>    * </c>
<l>    dev_set_draw (DrawMode)</l>
<l>    set_line_style (WindowHandle, Style)</l>
<l>else</l>
<c>    * Do nothing if no results are present.</c>
<l>    BboxIDs := []</l>
<l>endif</l>
<c>* </c>
<l>return ()</l>
</body>
<docu id="dev_display_result_detection">
<abstract lang="en_US">This procedure displays the inferred bounding boxes in DLResult.

ResultKeys is a tuple which should contain all the keys of DLResult.
LineWidthBbox sets the width of the lines with which the bounding boxes are drawn.
ClassIDs is a tuple with all the IDs of the different classes the network can distinguish.
TextConf is a tuple of strings with the confidences.
Colors determines the colors of the bounding boxes for every class, which are given over hexadecimal numbers within an RGB triplet.
BoxLabelColor is a string, determining the color used to display the bounding box labels.
WindowImageRatio is a real, determining the image ratio of the window used for the display.
TextPositionRow determines, where next to the bounding box the class and confidences are displayed. Supported values: 'top' (default), 'bottom'.
TextColor is a string determining the color used to display the text within the label.
ShowLabels is a boolean, determining if the labels are shown or not.
ShowDirection is a boolean, determining if direction of the instance within the bounding box should be indicated by an arrow or not. Supported only for instance_type 'rectangle2'.

WindowHandle determines handle of the window.

The procedure returns the IDs of the classes assigned for the bounding box contents in BboxIDs.</abstract>
<chapters lang="de_DE">
<item>Graphik</item>
<item>Ausgabe</item>
</chapters>
<chapters lang="en_US">
<item>Graphics</item>
<item>Output</item>
</chapters>
<library lang="en_US">MVTec Standard Procedures</library>
<short lang="en_US">Display result bounding boxes.</short>
<parameters>
<parameter id="BboxIDs">
<default_type>integer</default_type>
<multivalue>optional</multivalue>
<sem_type>integer</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="BoxLabelColor">
<default_type>string</default_type>
<multivalue>false</multivalue>
<sem_type>color</sem_type>
<type_list>
<item>string</item>
</type_list>
</parameter>
<parameter id="ClassIDs">
<default_type>integer</default_type>
<multivalue>optional</multivalue>
<sem_type>integer</sem_type>
<type_list>
<item>integer</item>
<item>string</item>
</type_list>
</parameter>
<parameter id="Colors">
<default_type>string</default_type>
<multivalue>optional</multivalue>
<sem_type>color</sem_type>
<type_list>
<item>string</item>
</type_list>
</parameter>
<parameter id="DLResult">
<default_type>integer</default_type>
<mixed_type>false</mixed_type>
<sem_type>dict</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="LineWidthBbox">
<default_type>integer</default_type>
<multivalue>false</multivalue>
<sem_type>integer</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="ResultKeys">
<sem_type>string</sem_type>
</parameter>
<parameter id="ShowDirection">
<description lang="en_US">Determines if the direction of an instance within the bounding box is visualized or not. Supported only for instance_type 'rectangle2'.</description>
<multivalue>false</multivalue>
<sem_type>integer</sem_type>
</parameter>
<parameter id="ShowLabels">
<sem_type>integer</sem_type>
</parameter>
<parameter id="TextColor">
<default_type>string</default_type>
<default_value>'white'</default_value>
<multivalue>optional</multivalue>
<sem_type>string</sem_type>
<type_list>
<item>string</item>
</type_list>
</parameter>
<parameter id="TextConf">
<default_type>string</default_type>
<multivalue>optional</multivalue>
<sem_type>string</sem_type>
<type_list>
<item>string</item>
</type_list>
</parameter>
<parameter id="TextPositionRow">
<default_type>integer</default_type>
<multivalue>optional</multivalue>
<sem_type>integer</sem_type>
<type_list>
<item>integer</item>
<item>string</item>
</type_list>
</parameter>
<parameter id="WindowHandle">
<default_type>integer</default_type>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>window</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="WindowImageRatio">
<default_type>real</default_type>
<multivalue>false</multivalue>
<sem_type>real</sem_type>
<type_list>
<item>real</item>
</type_list>
</parameter>
</parameters>
</docu>
</procedure>
<procedure name="dev_display_segmentation_evaluation">
<interface>
<ic>
<par name="EvaluationResult" base_type="ctrl" dimension="0"/>
<par name="EvalParam" base_type="ctrl" dimension="0"/>
<par name="GenParam" base_type="ctrl" dimension="0"/>
<par name="WindowHandleDict" base_type="ctrl" dimension="0"/>
</ic>
</interface>
<body>
<c>* </c>
<c>* This procedure visualizes the evaluation results for a model of type segmentation.</c>
<c>* </c>
<c>* Set the default values.</c>
<l>DisplayConfusionAbsolute := false</l>
<l>DisplayConfusionRelative := false</l>
<l>DisplayMeasures := true</l>
<l>MeasureColor := 'white'</l>
<l>RowColNameColor := 'light gray'</l>
<l>DisplayColor := true</l>
<c>* </c>
<c>* Handle the generic parameters.</c>
<l>if (|GenParam| &gt; 0)</l>
<l>    GenParamKeys := ['display_mode','measure_color','row_col_names_color','display_color_confusion_matrix']</l>
<l>    get_dict_param (GenParam, 'keys', [], Keys)</l>
<l>    for KeyIndex := 0 to |Keys| - 1 by 1</l>
<l>        if (find(GenParamKeys,Keys[KeyIndex]) == -1)</l>
<l>            throw ('Invalid GenParam key \'' + Keys[KeyIndex] + '\'')</l>
<l>        endif</l>
<l>    endfor</l>
<l>    get_dict_param (GenParam, 'key_exists', GenParamKeys, KeyExists)</l>
<c>    * Set display mode.</c>
<l>    if (KeyExists[0])</l>
<l>        SupportedModes := ['absolute_confusion_matrix','relative_confusion_matrix','measures']</l>
<l>        get_dict_tuple (GenParam, GenParamKeys[0], Value)</l>
<l>        if (|Value| == 0)</l>
<l>            throw ('GenParam key \'display_mode\' cannot be an empty tuple')</l>
<l>        endif</l>
<l>        DisplayConfusionAbsolute := false</l>
<l>        DisplayConfusionRelative := false</l>
<l>        DisplayMeasures := false</l>
<l>        for ValueIndex := 0 to |Value| - 1 by 1</l>
<l>            if (Value[ValueIndex] == SupportedModes[0])</l>
<l>                DisplayConfusionAbsolute := true</l>
<l>            elseif (Value[ValueIndex] == SupportedModes[1])</l>
<l>                DisplayConfusionRelative := true</l>
<l>            elseif (Value[ValueIndex] == SupportedModes[2])</l>
<l>                DisplayMeasures := true</l>
<l>            else</l>
<l>                throw ('Invalid value for GenParam key \'display_mode\'')</l>
<l>            endif</l>
<l>        endfor</l>
<l>    endif</l>
<c>    * Set MeasureColor.</c>
<l>    if (KeyExists[1])</l>
<l>        get_dict_tuple (GenParam, GenParamKeys[1], Value)</l>
<l>        if (|Value| != 1)</l>
<l>            throw ('GenParam \'measure_color\' must be a single value')</l>
<l>        endif</l>
<l>        try</l>
<l>            color_string_to_rgb (Value, RGB)</l>
<l>        catch (Exception)</l>
<l>            throw ('GenParam \'measure_color\' must be a valid color string')</l>
<l>        endtry</l>
<l>        MeasureColor := Value</l>
<l>    endif</l>
<c>    * Set color for row and column names.</c>
<l>    if (KeyExists[2])</l>
<l>        get_dict_tuple (GenParam, GenParamKeys[2], Value)</l>
<l>        if (|Value| != 1)</l>
<l>            throw ('GenParam \'row_col_names_color\' must be a single value')</l>
<l>        endif</l>
<l>        try</l>
<l>            color_string_to_rgb (Value, RGB)</l>
<l>        catch (Exception)</l>
<l>            throw ('GenParam \'row_col_names_color\' must be a valid color string')</l>
<l>        endtry</l>
<l>        RowColNameColor := Value</l>
<l>    endif</l>
<c>    * Set DisplayColor.</c>
<l>    if (KeyExists[3])</l>
<l>        get_dict_tuple (GenParam, GenParamKeys[3], Value)</l>
<l>        if (Value != true and Value != false)</l>
<l>            throw ('GenParam \'display_color_confusion_matrix\' should be either true or false')</l>
<l>        endif</l>
<l>        DisplayColor := Value</l>
<l>    endif</l>
<l>endif</l>
<c>* </c>
<c>* Get the class names.</c>
<l>get_dict_param (EvalParam, 'key_exists', ['class_names','class_ids'], KeysExist)</l>
<l>if (not sum(KeysExist))</l>
<l>    throw ('EvalParam must contain at least one of the keys \'class_names\' or \'class_ids\'')</l>
<l>elseif (not KeysExist[0])</l>
<c>    * If class names are not given, use class IDs instead.</c>
<l>    get_dict_tuple (EvalParam, 'class_ids', ClassIDs)</l>
<l>    ClassNames := 'class_' + ClassIDs</l>
<l>else</l>
<c>    * Get the class names from the EvalParam dict.</c>
<l>    get_dict_tuple (EvalParam, 'class_names', ClassNames)</l>
<l>endif</l>
<c>* </c>
<c>* Cut class names for better visualization.</c>
<l>if (ClassNames != [])</l>
<l>    MaxChars := 14</l>
<l>    for Index := 0 to |ClassNames| - 1 by 1</l>
<l>        Str := ClassNames[Index]</l>
<l>        tuple_is_string (Str, IsString)</l>
<l>        if (IsString)</l>
<l>            tuple_strlen (Str, Length)</l>
<l>            if (Length &gt; MaxChars)</l>
<l>                SubStr := Str{0:MaxChars - 3} + '...'</l>
<l>                ClassNames[Index] := SubStr</l>
<l>            endif</l>
<l>        endif</l>
<l>    endfor</l>
<l>endif</l>
<c>* </c>
<c>* Get the evaluation results.</c>
<c>* Initialize the result variables.</c>
<l>PixelConfMatrix := []</l>
<l>MeanIoU := []</l>
<l>ClassIoU := []</l>
<l>PixelAccuracy := []</l>
<l>MeanAccuracy := []</l>
<l>ClassPixelAccuracy := []</l>
<c>* </c>
<c>* Get some evaluation parameters.</c>
<l>MeasureKeys := ['pixel_confusion_matrix','mean_iou','class_iou','pixel_accuracy','mean_accuracy','class_pixel_accuracy']</l>
<l>get_dict_param (EvaluationResult, 'key_exists', MeasureKeys, MeasureKeysExist)</l>
<c>* </c>
<c>* Check the input evaluation results for necessary entries.</c>
<l>if (sum(MeasureKeysExist) == 0)</l>
<l>    throw ('There are no valid keys given in EvaluationResult.')</l>
<l>endif</l>
<l>if (sum(MeasureKeysExist) - MeasureKeysExist[0] == 0 and DisplayMeasures)</l>
<l>    throw ('There are no measures given in EvaluationResult')</l>
<l>endif</l>
<c>* </c>
<c>* Pixel confusion matrix.</c>
<l>if (MeasureKeysExist[0])</l>
<l>    get_dict_tuple (EvaluationResult, MeasureKeys[0], PixelConfMatrix)</l>
<l>else</l>
<l>    if (DisplayConfusionAbsolute or DisplayConfusionRelative)</l>
<l>        throw ('\'pixel_confusion_matrix\' has to be set as measure in evaluation for this visualization')</l>
<l>    endif</l>
<l>endif</l>
<c>* Mean IoU.</c>
<l>if (MeasureKeysExist[1])</l>
<l>    get_dict_tuple (EvaluationResult, MeasureKeys[1], MeanIoU)</l>
<l>endif</l>
<c>* Class IoU.</c>
<l>if (MeasureKeysExist[2])</l>
<l>    get_dict_tuple (EvaluationResult, MeasureKeys[2], ClassIoU)</l>
<l>endif</l>
<c>* Pixel accuracy.</c>
<l>if (MeasureKeysExist[3])</l>
<l>    get_dict_tuple (EvaluationResult, MeasureKeys[3], PixelAccuracy)</l>
<l>endif</l>
<c>* Mean accuracy.</c>
<l>if (MeasureKeysExist[4])</l>
<l>    get_dict_tuple (EvaluationResult, MeasureKeys[4], MeanAccuracy)</l>
<l>endif</l>
<c>* Class pixel accuracy.</c>
<l>if (MeasureKeysExist[5])</l>
<l>    get_dict_tuple (EvaluationResult, MeasureKeys[5], ClassPixelAccuracy)</l>
<l>endif</l>
<c>* </c>
<c>* </c>
<l>MeasuresDisplayed := false</l>
<c>* </c>
<c>* Set parameters for the visualization of measures.</c>
<l>if (DisplayMeasures)</l>
<l>    create_dict (GenParamMeasures)</l>
<l>    set_dict_tuple (GenParamMeasures, 'title', 'Measures')</l>
<l>    set_dict_tuple (GenParamMeasures, 'number_format', '0.3f')</l>
<l>    set_dict_tuple (GenParamMeasures, 'display_column_width', 'minimal')</l>
<l>    set_dict_tuple (GenParamMeasures, 'value_colors', MeasureColor)</l>
<l>    set_dict_tuple (GenParamMeasures, 'display_color', true)</l>
<l>    set_dict_tuple (GenParamMeasures, 'row_col_names_color', RowColNameColor)</l>
<c>    * </c>
<c>    * Visualize class measures.</c>
<l>    if (ClassIoU != [] or ClassPixelAccuracy != [])</l>
<c>        * Create matrix.</c>
<l>        NumRows := (ClassIoU != []) + (ClassPixelAccuracy != []) + 2 * (PixelAccuracy != [])</l>
<l>        RowNames := []</l>
<l>        IdxsNoDisplay := []</l>
<l>        create_matrix (NumRows, |ClassNames| + 1, 0., ClassMeasures)</l>
<l>        if (ClassIoU != [])</l>
<c>            * Add row for class IoU.</c>
<l>            set_value_matrix (ClassMeasures, gen_tuple_const(|ClassNames|,0), [0:|ClassNames| - 1], ClassIoU)</l>
<l>            ValidClassIoUs := ClassIoU[find(ClassIoU [&gt;] -1,1)]</l>
<l>            set_value_matrix (ClassMeasures, 0, |ClassNames|, mean(ValidClassIoUs))</l>
<l>            RowNames := [RowNames,'IoU']</l>
<l>        endif</l>
<l>        if (ClassPixelAccuracy != [])</l>
<c>            * Add row for class pixel accuracy.</c>
<l>            RowIndex := ClassIoU != []</l>
<l>            set_value_matrix (ClassMeasures, gen_tuple_const(|ClassNames|,RowIndex), [0:|ClassNames| - 1], ClassPixelAccuracy)</l>
<l>            ValidClassPixelAccuracy := ClassPixelAccuracy[find(ClassPixelAccuracy [&gt;] -1,1)]</l>
<l>            set_value_matrix (ClassMeasures, RowIndex, |ClassNames|, mean(ValidClassPixelAccuracy))</l>
<l>            RowNames := [RowNames,'Pixel Acc.']</l>
<l>        endif</l>
<l>        if (PixelAccuracy != [])</l>
<c>            * Add row for overall pixel accuracy.</c>
<l>            RowIndex := (ClassIoU != []) + (ClassPixelAccuracy != [])</l>
<l>            set_value_matrix (ClassMeasures, RowIndex + 1, 0, PixelAccuracy)</l>
<l>            RowNames := [RowNames,'','Pixel Acc. (overall)']</l>
<l>            IdxsNoDisplay1 := [RowIndex * (|ClassNames| + 1):(RowIndex + 1) * (|ClassNames| + 1) - 1]</l>
<l>            IdxsNoDisplay2 := [(RowIndex + 1) * (|ClassNames| + 1) + 1:(RowIndex + 2) * (|ClassNames| + 1) - 1]</l>
<l>            IdxsNoDisplay := [IdxsNoDisplay,IdxsNoDisplay1,IdxsNoDisplay2]</l>
<l>        endif</l>
<c>        * Add GenParamMeasures parameter for displaying the matrix.</c>
<l>        set_dict_tuple (GenParamMeasures, 'idxs_no_display', IdxsNoDisplay)</l>
<c>        * Add 'mean' to column names.</c>
<l>        ColNames := [ClassNames,'mean']</l>
<c>        * </c>
<c>        * Check if there is already a window handle.</c>
<l>        get_dict_param (WindowHandleDict, 'key_exists', 'window_measures', WindowMeasuresExists)</l>
<l>        if (WindowMeasuresExists)</l>
<l>            get_dict_tuple (WindowHandleDict, 'window_measures', WindowHandleMeasures)</l>
<l>            dev_set_window (WindowHandleMeasures)</l>
<l>        else</l>
<l>            dev_open_window (0, 0, 512, 512, 'black', WindowHandleMeasures)</l>
<l>            set_dict_tuple (WindowHandleDict, 'window_measures', WindowHandleMeasures)</l>
<l>        endif</l>
<c>        * </c>
<c>        * Display.</c>
<l>        dev_display_matrix (ClassMeasures, ColNames, RowNames, WindowHandleMeasures, GenParamMeasures)</l>
<c>        * </c>
<l>        MeasuresDisplayed := true</l>
<l>    endif</l>
<c>    * </c>
<c>    * Visualize mean measures.</c>
<l>    if (not MeasuresDisplayed and (MeanIoU != [] or PixelAccuracy != [] or MeanAccuracy != []))</l>
<c>        * Create matrix.</c>
<l>        NumRows := (MeanIoU != []) + (PixelAccuracy != []) + (MeanAccuracy != [])</l>
<l>        RowNames := []</l>
<l>        create_matrix (NumRows, 1, 0., Measures)</l>
<l>        if (MeanIoU != [])</l>
<l>            set_value_matrix (Measures, 0, 0, MeanIoU)</l>
<l>            RowNames := [RowNames,'Mean IoU']</l>
<l>        endif</l>
<l>        if (MeanAccuracy != [])</l>
<l>            RowIndex := MeanIoU != []</l>
<l>            set_value_matrix (Measures, RowIndex, 0, MeanAccuracy)</l>
<l>            RowNames := [RowNames,'Mean Class Pixel Acc.']</l>
<l>        endif</l>
<l>        if (PixelAccuracy != [])</l>
<l>            RowIndex := (MeanIoU != []) + (MeanAccuracy != [])</l>
<l>            set_value_matrix (Measures, RowIndex, 0, PixelAccuracy)</l>
<l>            RowNames := [RowNames,'Pixel Acc. (overall)']</l>
<l>        endif</l>
<c>        * </c>
<c>        * Check if there is already a window handle.</c>
<l>        get_dict_param (WindowHandleDict, 'key_exists', 'window_measures', WindowMeasuresExists)</l>
<l>        if (WindowMeasuresExists)</l>
<l>            get_dict_tuple (WindowHandleDict, 'window_measures', WindowHandleMeasures)</l>
<l>            dev_set_window (WindowHandleMeasures)</l>
<l>        else</l>
<l>            dev_open_window (0, 0, 512, 512, 'black', WindowHandleMeasures)</l>
<l>            set_dict_tuple (WindowHandleDict, 'window_measures', WindowHandleMeasures)</l>
<l>        endif</l>
<c>        * </c>
<c>        * Display.</c>
<l>        dev_display_matrix (Measures, '', RowNames, WindowHandleMeasures, GenParamMeasures)</l>
<c>        * </c>
<l>        MeasuresDisplayed := true</l>
<l>    endif</l>
<c>    * </c>
<l>endif</l>
<c>* </c>
<c>* Visualize the pixel confusion matrix.</c>
<l>if (DisplayConfusionAbsolute or DisplayConfusionRelative)</l>
<c>    * Collect the window handles.</c>
<l>    WindowHandlesConfusion := []</l>
<c>    * Set the display parameters.</c>
<l>    create_dict (GenParamConfusion)</l>
<l>    set_dict_tuple (GenParamConfusion, 'display_relative_matrix', DisplayConfusionRelative)</l>
<l>    set_dict_tuple (GenParamConfusion, 'display_absolute_matrix', DisplayConfusionAbsolute)</l>
<l>    set_dict_tuple (GenParamConfusion, 'display_color', DisplayColor)</l>
<l>    set_dict_tuple (GenParamConfusion, 'row_col_names_color', RowColNameColor)</l>
<l>    if (DisplayConfusionAbsolute)</l>
<c>        * Check if there is already a window handle.</c>
<l>        get_dict_param (WindowHandleDict, 'key_exists', 'window_confusion_absolute', WindowConfAbsoluteExists)</l>
<l>        if (WindowConfAbsoluteExists)</l>
<l>            get_dict_tuple (WindowHandleDict, 'window_confusion_absolute', WindowHandleConfusionAbsolute)</l>
<l>            dev_set_window (WindowHandleConfusionAbsolute)</l>
<l>        else</l>
<l>            dev_open_window (0, 0, 512, 512, 'black', WindowHandleConfusionAbsolute)</l>
<l>            set_dict_tuple (WindowHandleDict, 'window_confusion_absolute', WindowHandleConfusionAbsolute)</l>
<l>        endif</l>
<l>        WindowHandlesConfusion := [WindowHandlesConfusion,WindowHandleConfusionAbsolute]</l>
<l>    endif</l>
<l>    if (DisplayConfusionRelative)</l>
<c>        * Check if there is already a window handle.</c>
<l>        get_dict_param (WindowHandleDict, 'key_exists', 'window_confusion_relative', WindowConfRelativeExists)</l>
<l>        if (WindowConfRelativeExists)</l>
<l>            get_dict_tuple (WindowHandleDict, 'window_confusion_relative', WindowHandleConfusionRelative)</l>
<l>            dev_set_window (WindowHandleConfusionRelative)</l>
<l>        else</l>
<l>            dev_open_window (0, 0, 512, 512, 'black', WindowHandleConfusionRelative)</l>
<l>            set_dict_tuple (WindowHandleDict, 'window_confusion_relative', WindowHandleConfusionRelative)</l>
<l>        endif</l>
<l>        WindowHandlesConfusion := [WindowHandlesConfusion,WindowHandleConfusionRelative]</l>
<l>    endif</l>
<l>    ColNames := ClassNames</l>
<l>    dev_display_pixel_confusion_matrix (PixelConfMatrix, ColNames, GenParamConfusion, WindowHandlesConfusion)</l>
<l>endif</l>
<c>* </c>
<c>* Rearrange windows.</c>
<l>WindowHandleKeys := ['window_measures','window_confusion_absolute','window_confusion_relative']</l>
<l>get_dict_param (WindowHandleDict, 'key_exists', WindowHandleKeys, WindowHandleKeysExist)</l>
<l>if (sum(WindowHandleKeysExist) &gt; 1)</l>
<l>    ColConfusion := [0,0]</l>
<l>    RowConfusion := [0,0]</l>
<l>    WidthConf := -1</l>
<l>    HeightConf := -1</l>
<l>    if (MeasuresDisplayed)</l>
<l>        get_window_extents (WindowHandleMeasures, _, _, Width, Height)</l>
<l>        RowConfusion := [Height + 55,Height + 55]</l>
<l>    endif</l>
<l>    if (DisplayConfusionAbsolute)</l>
<l>        get_window_extents (WindowHandleConfusionAbsolute, Row, Column, WidthConf, HeightConf)</l>
<l>        dev_set_window (WindowHandleConfusionAbsolute)</l>
<l>        dev_set_window_extents (RowConfusion[0], ColConfusion[0], WidthConf, HeightConf)</l>
<l>        dev_get_preferences ('graphics_window_context_menu', PreferenceValues)</l>
<l>        ColConfusion[1] := WidthConf + 8</l>
<l>    endif</l>
<l>    if (DisplayConfusionRelative)</l>
<l>        dev_set_window (WindowHandleConfusionRelative)</l>
<l>        dev_set_window_extents (RowConfusion[1], ColConfusion[1], WidthConf, HeightConf)</l>
<l>    endif</l>
<l>endif</l>
<c>* </c>
<l>return ()</l>
</body>
<docu id="dev_display_segmentation_evaluation">
<abstract lang="en_US">This procedure visualizes the results of an evaluation for a model of type segmentation.
The dictionary EvalParam is used to get the names or IDs of the classes that are evaluated.
WindowHandleDict is a dictionary containing the window handles. 

The optional dictionary GenParam can be used to configure the visualization. For this purpose, the following entries can be set:
- 'display_mode': You can set the following values to determine what is displayed (as a single value or a tuple of values):
   -- 'measures' (default): display the measures specified in the dictionary EvaluationResult.
       To do so, this procedure looks for the following measures:
      --- 'pixel_confusion_matrix'
      --- 'mean_iou'
      --- 'class_iou'
      --- 'pixel_accuracy'
      --- 'mean_accuracy'
      --- 'class_pixel_accuracy'
   -- 'absolute_confusion_matrix': display the absolute confusion matrix.
   -- 'relative_confusion_matrix': display the relative confusion matrix.
- 'measure_color' (default: 'white'): Specify the color in which the measure values are displayed. 
- 'row_col_names_color' (default: 'light gray'): Specify the color in which the class names and measure names are displayed. 
- 'display_color_confusion_matrix' (default: true): Determine, whether to display the numbers
   in the confusion matrix in green (true positives) and red (false positives) or not.

The window, in which the values are displayed, can be given using the dictionary WindowHandleDict
   with the following keys:
- 'window_measures': Handle of the window to display the measures.
- 'window_confusion_absolute': Handle of the window to display the absolute confusion matrix.
- 'window_confusion_relative': Handle of the window to display the relative confusion matrix.
If a visualization is requested, but no corresponding key for the window handle found in WindowHandleDict,
a new window is opened and the corresponding key is set to the dictionary.

Please see the chapters Deep Learning and Semantic Segmentation in the Reference Manual for explanations to the different measures.
</abstract>
<chapters lang="de_DE">
<item>Deep Learning</item>
<item>Evaluierung</item>
</chapters>
<chapters lang="en_US">
<item>Deep Learning</item>
<item>Evaluation</item>
</chapters>
<library lang="en_US">MVTec Standard Procedures</library>
<short lang="en_US">Visualize the results of an evaluation for a model of type segmentation.</short>
<parameters>
<parameter id="EvalParam">
<default_type>integer</default_type>
<default_value>EvalParam</default_value>
<description lang="en_US">Dictionary with the evaluation parameters.</description>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>dict</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="EvaluationResult">
<default_type>integer</default_type>
<default_value>EvaluationResult</default_value>
<description lang="en_US">Dictionary with the segmentation evaluation result.</description>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>dict</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="GenParam">
<default_type>integer</default_type>
<default_value>[]</default_value>
<description lang="en_US">Dictionary with the generic parameters used to configure the visualization.</description>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>any</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="WindowHandleDict">
<default_type>integer</default_type>
<default_value>WindowHandleDict</default_value>
<description lang="en_US">Dictionary with the handles for the windows in which the matrices shall be displayed.</description>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>dict</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
</parameters>
</docu>
</procedure>
<procedure name="dev_display_segmentation_regions" access="local">
<interface>
<io>
<par name="SegmentationImage" base_type="iconic" dimension="0"/>
</io>
<ic>
<par name="ClassIDs" base_type="ctrl" dimension="0"/>
<par name="ColorsSegmentation" base_type="ctrl" dimension="0"/>
<par name="ExcludeClassIDs" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="ImageClassIDs" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c>* </c>
<c>* This procedure displays the ground truth/result segmentation</c>
<c>* given in SegmentationImage as regions. The ClassIDs are necessary to</c>
<c>* display ground truth/result segmentations from the same class</c>
<c>* always with the same color. It is possible to exclude certain ClassIDs</c>
<c>* from being displayed. The displayed classes are returned in ImageClassIDs.</c>
<c>* </c>
<c>* </c>
<c>* Remove excluded class IDs from the list.</c>
<l>IncludedClassIDs := difference(ClassIDs,ExcludeClassIDs)</l>
<c>* </c>
<c>* Get a region for each class ID.</c>
<l>threshold (SegmentationImage, Regions, IncludedClassIDs, IncludedClassIDs)</l>
<c>* </c>
<c>* Get classes with non-empty regions.</c>
<l>region_features (Regions, 'area', Area)</l>
<l>ImageClassIDs := select_mask(IncludedClassIDs,Area [&gt;] 0)</l>
<c>* </c>
<c>* Display all non-empty class regions in distinct colors.</c>
<l>for Index := 0 to |IncludedClassIDs| - 1 by 1</l>
<l>    if (Area[Index] &gt; 0)</l>
<c>        * Use class ID to determine region color.</c>
<l>        ClassID := IncludedClassIDs[Index]</l>
<l>        IndexColor := find_first(ClassIDs,ClassID)</l>
<l>        dev_set_color (ColorsSegmentation[IndexColor])</l>
<c>        * Display the segmentation region.</c>
<l>        select_obj (Regions, SelectedRegion, Index + 1)</l>
<l>        dev_display (SelectedRegion)</l>
<l>    endif</l>
<l>endfor</l>
<l>return ()</l>
</body>
<docu id="dev_display_segmentation_regions">
<chapters lang="de_DE">
<item>Graphik</item>
<item>Ausgabe</item>
</chapters>
<chapters lang="en_US">
<item>Graphics</item>
<item>Output</item>
</chapters>
<library lang="en_US">MVTec Standard Procedures</library>
<short lang="en_US">Display the ground truth/result segmentation as regions.</short>
<parameters>
<parameter id="ClassIDs">
<default_type>integer</default_type>
<mixed_type>false</mixed_type>
<multivalue>true</multivalue>
<sem_type>integer</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="ColorsSegmentation">
<default_type>string</default_type>
<mixed_type>false</mixed_type>
<multivalue>true</multivalue>
<sem_type>color</sem_type>
<type_list>
<item>string</item>
</type_list>
</parameter>
<parameter id="ExcludeClassIDs">
<default_value>[]</default_value>
<multivalue>optional</multivalue>
<sem_type>integer</sem_type>
</parameter>
<parameter id="ImageClassIDs">
<default_type>integer</default_type>
<mixed_type>false</mixed_type>
<multivalue>optional</multivalue>
<sem_type>integer</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="SegmentationImage">
<sem_type>image</sem_type>
<type_list>
<item>byte</item>
</type_list>
</parameter>
</parameters>
</docu>
</procedure>
<procedure name="dev_display_shape_matching_results">
<interface>
<ic>
<par name="ModelID" base_type="ctrl" dimension="0"/>
<par name="Color" base_type="ctrl" dimension="0"/>
<par name="Row" base_type="ctrl" dimension="0"/>
<par name="Column" base_type="ctrl" dimension="0"/>
<par name="Angle" base_type="ctrl" dimension="0"/>
<par name="ScaleR" base_type="ctrl" dimension="0"/>
<par name="ScaleC" base_type="ctrl" dimension="0"/>
<par name="Model" base_type="ctrl" dimension="0"/>
</ic>
</interface>
<body>
<c>* This procedure displays the results of Shape-Based Matching.</c>
<c>* </c>
<c>* Ensure that the different models have the same use_clutter value.</c>
<c>* </c>
<c>* This procedure displays the results on the active graphics window.</c>
<l>dev_get_window (WindowHandle)</l>
<c>* If no graphics window is currently open, nothing can be displayed.</c>
<l>if (WindowHandle == -1)</l>
<l>    return ()</l>
<l>endif</l>
<c>* </c>
<l>UseClutter := 'false'</l>
<l>try</l>
<l>    get_shape_model_clutter (ClutterRegion, ModelID[0], 'use_clutter', UseClutter0, HomMat2D, ClutterContrast)</l>
<l>    for Index := 0 to |ModelID| - 1 by 1</l>
<l>        get_shape_model_clutter (ClutterRegion, ModelID[Index], 'use_clutter', UseClutter, HomMat2D, ClutterContrast)</l>
<l>        if (UseClutter != UseClutter0)</l>
<l>            throw ('Shape models are not of the same clutter type')</l>
<l>        endif</l>
<l>    endfor</l>
<l>catch (Exception)</l>
<l>endtry</l>
<l>if (UseClutter == 'true')</l>
<l>    dev_set_draw ('margin')</l>
<c>    * For clutter-enabled models, the Color tuple should have either</c>
<c>    * exactly 2 entries, or 2* the number of models. The first color</c>
<c>    * is used for the match and the second for the clutter region,</c>
<c>    * respectively.</c>
<l>    if ((|Color| != 2 * |ModelID|) and |Color| != 2)</l>
<l>        throw ('Length of Color does not correspond to models with enabled clutter parameters')</l>
<l>    endif</l>
<l>endif</l>
<c></c>
<l>NumMatches := |Row|</l>
<l>if (NumMatches &gt; 0)</l>
<l>    if (|ScaleR| == 1)</l>
<l>        tuple_gen_const (NumMatches, ScaleR, ScaleR)</l>
<l>    endif</l>
<l>    if (|ScaleC| == 1)</l>
<l>        tuple_gen_const (NumMatches, ScaleC, ScaleC)</l>
<l>    endif</l>
<l>    if (|Model| == 0)</l>
<l>        tuple_gen_const (NumMatches, 0, Model)</l>
<l>    elseif (|Model| == 1)</l>
<l>        tuple_gen_const (NumMatches, Model, Model)</l>
<l>    endif</l>
<c>    * Redirect all display calls to a buffer window and update the</c>
<c>    * graphics window only at the end, to speed up the visualization.</c>
<l>    set_window_param (WindowHandle, 'flush', 'false')</l>
<l>    for Index := 0 to |ModelID| - 1 by 1</l>
<l>        get_shape_model_contours (ModelContours, ModelID[Index], 1)</l>
<l>        if (UseClutter == 'true')</l>
<l>            get_shape_model_clutter (ClutterRegion, ModelID[Index], [], GenParamValue, HomMat2D, ClutterContrast)</l>
<l>            hom_mat2d_invert (HomMat2D, HomMat2DInvert)</l>
<l>        endif</l>
<l>        dev_set_color (Color[Index % |Color|])</l>
<l>        for Match := 0 to NumMatches - 1 by 1</l>
<l>            if (Index == Model[Match])</l>
<l>                get_hom_mat2d_from_matching_result (Row[Match], Column[Match], Angle[Match], ScaleR[Match], ScaleC[Match], HomMat2DTranslate)</l>
<l>                affine_trans_contour_xld (ModelContours, ContoursAffinTrans, HomMat2DTranslate)</l>
<l>                if (UseClutter == 'true')</l>
<l>                    hom_mat2d_compose (HomMat2DTranslate, HomMat2DInvert, HomMat2DCompose)</l>
<l>                    affine_trans_region (ClutterRegion, RegionAffineTrans, HomMat2DCompose, 'constant')</l>
<l>                    if (|Color| == 2)</l>
<l>                        dev_set_color (Color[1])</l>
<l>                        dev_display (RegionAffineTrans)</l>
<l>                        dev_set_color (Color[0])</l>
<l>                    else</l>
<l>                        dev_set_color (Color[Index * 2 + 1])</l>
<l>                        dev_display (RegionAffineTrans)</l>
<l>                        dev_set_color (Color[Index * 2])</l>
<l>                    endif</l>
<l>                endif</l>
<l>                dev_display (ContoursAffinTrans)</l>
<l>            endif</l>
<l>        endfor</l>
<l>    endfor</l>
<c>    * Copy the content of the buffer window to the graphics window.</c>
<l>    set_window_param (WindowHandle, 'flush', 'true')</l>
<l>    flush_buffer (WindowHandle)</l>
<l>endif</l>
<l>return ()</l>
</body>
<docu id="dev_display_shape_matching_results">
<abstract lang="en_US">The procedure dev_display_shape_matching_results displays the results of shape-based matching. 

In ModelID, the shape models for which results should be displayed are passed. This parameter typically contains the same values that were passed to the operator that was used to find the instances of the shape model. Note that different shape models must have the same value for use_clutter, i.e. the same clutter type. Otherwise, an error message is returned.

Color is a tuple of colors that will be used for the visualization. If Color contains only one element, all found instances are displayed in this color. If each found instance should be displayed in a color associated with the respective shape model, the number of colors has to correspond to the number of shape models in ModelID. If Color is a tuple that does not have the same number of elements as ModelID, the specified colors are used cyclically for the visualization of the matching results. If the shape model(s) have been extended by clutter parameters, Color must have either exactly two entries or double the number of shape models used, otherwise an error message is returned. If Color has exactly two colors, the first will be used for displaying the match and the second for the clutter region. If Color has double the number of shape models, the colors are used pairwise for each model, for displaying the match and the clutter region, respectively.

Row, Column, and Angle contain the position and rotation information of the found instances of the shape models.

ScaleR and ScaleC contain the scale of the found instances of the shape model. Their value should be set depending on the way the shape model instances were found:
- find_shape_model(s) was used to find the instances of the shape model: ScaleR and ScaleC should be set to 1.0.
- find_scaled_shape_model(s) was used to find the instances of the shape model: ScaleR and ScaleC contain the scale of the found instance.
- find_aniso_shape_model(s) was used to find the instances of the shape model: ScaleR and ScaleC contain the respective anisotropic scales of the found instances.

The elements of Model describe to which element of the tuple ModelID the elements of Row, Column, Angle, ScaleR, and ScaleC refer to. The elements of Model are indices into the tuple ModelID, i.e., they can contain values from 0 to |ModelID|-1.  Hence, a value of 0 in an element of Model corresponds to an instance of the first model in ModelID. If only one model is given in ModelID, Model can be set to 0. Otherwise, the output of the operators find_shape_models, find_scaled_shape_models, or find_aniso_shape_models can be used directly.</abstract>
<chapters>
<item>Matching</item>
<item>Shape-Based</item>
</chapters>
<chapters lang="de_DE">
<item>Matching</item>
<item>Formbasiert</item>
</chapters>
<chapters lang="en_US">
<item>Matching</item>
<item>Shape-Based</item>
</chapters>
<example lang="en_US">read_image(Image,'mreut')
gen_rectangle1(Rectangle1, 30, 20, 100, 200)
gen_rectangle1 (Rectangle2, 130, 120, 200, 200)
reduce_domain (Image, Rectangle1, ImageReduced1)
reduce_domain (Image, Rectangle2, ImageReduced2)
create_scaled_shape_model(ImageReduced1, 'auto', -0.39, 0.79,
                          'auto', 0.9, 1.1, 'auto', 'auto',
                          'use_polarity', 'auto', 'auto', ModelID1)
create_scaled_shape_model(ImageReduced2, 'auto', -0.39, 0.79,
                          'auto', 0.9, 1.1, 'auto', 'auto',
                          'use_polarity', 'auto', 'auto', ModelID2)
find_scaled_shape_models (Image, [ModelID1,ModelID2], -0.39, 0.78,
                          0.9, 1.1, 0.5, 2, 0.5, 'least_squares', 0, 0.9,
                          Row, Column, Angle, Scale, Score, Model)
dev_display_shape_matching_results ([ModelID1,ModelID2], ['red','green'],
                          Row, Column, Angle, Scale, 1.0, Model)</example>
<keywords lang="de_DE">
<item>Ergebnisse des formbasierten Matchings anzeigen</item>
</keywords>
<keywords lang="en_US">
<item>display results of shape-based matching</item>
</keywords>
<library lang="de_DE">MVTec Standard Procedures</library>
<library lang="en_US">MVTec Standard Procedures</library>
<predecessor>
<item>find_shape_model</item>
<item>find_shape_models</item>
<item>find_scaled_shape_model</item>
<item>find_scaled_shape_models</item>
<item>find_aniso_shape_model</item>
<item>find_aniso_shape_models</item>
</predecessor>
<short>This procedure displays the results of Shape-based Matching.</short>
<short lang="de_DE">Anzeigen der Ergebnisse des formbasierten Matchings.</short>
<short lang="en_US">Display the results of Shape-Based Matching.</short>
<parameters>
<parameter id="Angle">
<default_type>real</default_type>
<description lang="en_US">Rotation angle of the found instances of the models.</description>
<mixed_type>optional</mixed_type>
<multivalue>optional</multivalue>
<sem_type>angle.rad</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
<parameter id="Color">
<default_type>string</default_type>
<default_value>'red'</default_value>
<description lang="en_US">Colors used for the visualization of the matching result.</description>
<mixed_type>false</mixed_type>
<multivalue>optional</multivalue>
<sem_type>color</sem_type>
<type_list>
<item>string</item>
</type_list>
<values>
<item>'red'</item>
<item>'green'</item>
<item>'blue'</item>
<item>['red','green','blue']</item>
<item>['red','green','blue','cyan','magenta','yellow']</item>
</values>
</parameter>
<parameter id="Column">
<default_type>real</default_type>
<description lang="en_US">Column coordinate of the found instances of the models.</description>
<mixed_type>optional</mixed_type>
<multivalue>optional</multivalue>
<sem_type>point.x</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
<parameter id="Model">
<default_type>integer</default_type>
<default_value>0</default_value>
<description lang="en_US">Index of the found instances of the models.</description>
<mixed_type>false</mixed_type>
<multivalue>optional</multivalue>
<sem_type>integer</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="ModelID">
<default_type>integer</default_type>
<description lang="en_US">IDs of the shape models for which the results should be displayed.</description>
<mixed_type>false</mixed_type>
<multivalue>optional</multivalue>
<sem_type>shape_model</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="Row">
<default_type>real</default_type>
<description lang="en_US">Row coordinate of the found instances of the models.</description>
<mixed_type>optional</mixed_type>
<multivalue>optional</multivalue>
<sem_type>point.y</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
<parameter id="ScaleC">
<default_type>real</default_type>
<default_value>1.0</default_value>
<description lang="en_US">Scale of the found instances of the models in the column direction.</description>
<mixed_type>optional</mixed_type>
<multivalue>optional</multivalue>
<sem_type>number</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
<parameter id="ScaleR">
<default_type>real</default_type>
<default_value>1.0</default_value>
<description lang="en_US">Scale of the found instances of the models in the row direction.</description>
<mixed_type>optional</mixed_type>
<multivalue>optional</multivalue>
<sem_type>number</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
</parameters>
</docu>
</procedure>
<procedure name="dev_display_surface_matching_results" access="local">
<interface>
<ic>
<par name="WindowHandle1" base_type="ctrl" dimension="0"/>
<par name="SurfaceMatchingResultID" base_type="ctrl" dimension="0"/>
<par name="ObjectModel3DModel" base_type="ctrl" dimension="0"/>
<par name="ObjectModel3DScene" base_type="ctrl" dimension="0"/>
<par name="Score" base_type="ctrl" dimension="0"/>
<par name="Pose" base_type="ctrl" dimension="0"/>
<par name="EdgesTrained" base_type="ctrl" dimension="0"/>
<par name="VisibilityTrained" base_type="ctrl" dimension="0"/>
</ic>
</interface>
<body>
<c>* Get Matching data</c>
<c></c>
<l>try</l>
<l>    get_surface_matching_result (SurfaceMatchingResultID, 'param_names', 0, GenParamNames)</l>
<l>    get_surface_matching_result (SurfaceMatchingResultID, 'param_values', 0, GenParamValues)</l>
<l>    get_find_parameter (GenParamNames, GenParamValues, 'use_3d_edges', 'true', Use3DEdges)</l>
<l>catch (Exception)</l>
<l>    Use3DEdges := 'true'</l>
<l>endtry</l>
<l>if (Use3DEdges == 1)</l>
<l>    Use3DEdges := 'true'</l>
<l>endif</l>
<c></c>
<l>gen_empty_object_model_3d (SampledEdges)</l>
<l>if (EdgesTrained == 'true' and Use3DEdges == 'true')</l>
<l>    try</l>
<l>        get_surface_matching_result (SurfaceMatchingResultID, 'sampled_edges', [], SampledEdges)</l>
<l>    catch (Exception)</l>
<l>    endtry</l>
<l>endif</l>
<l>get_surface_matching_result (SurfaceMatchingResultID, 'key_points', [], KeyPoints)</l>
<l>get_surface_matching_result (SurfaceMatchingResultID, 'sampled_scene', [], SampledScene)</l>
<c>* </c>
<l>Labels := []</l>
<l>for Index := 0 to |Score| - 1 by 1</l>
<l>    get_surface_matching_result (SurfaceMatchingResultID, 'all_scores', Index, CurrScores)</l>
<l>    CurrLabel := 'Total Score:   ' + CurrScores[0]$'.2f'</l>
<l>    if (|CurrScores| &gt; 1)</l>
<l>        CurrLabel := CurrLabel + '\nSurface Score: ' + CurrScores[1]$'.2f'</l>
<l>    endif</l>
<l>    if (|CurrScores| &gt; 2 and Use3DEdges == 'true' and EdgesTrained == 'true')</l>
<l>        CurrLabel := CurrLabel + '\n3D Edge Score: ' + CurrScores[2]$'.2f'</l>
<l>    endif</l>
<l>    if (|CurrScores| &gt; 3 and Use3DEdges == 'true' and EdgesTrained == 'true')</l>
<l>        CurrLabel := CurrLabel + '\n2D Edge Score: ' + CurrScores[3]$'.2f'</l>
<l>    endif</l>
<l>    if (|CurrScores| &gt; 4 and VisibilityTrained == 'true')</l>
<l>        CurrLabel := CurrLabel + '\nView-based Score: ' + CurrScores[4]$'.2f'</l>
<l>    endif</l>
<l>    Labels := [Labels,CurrLabel]</l>
<l>endfor</l>
<c>* </c>
<l>Instructions[0] := 'Rotate: Left button'</l>
<l>Instructions[1] := 'Zoom:   Shift + left button'</l>
<l>Instructions[2] := 'Move:   Ctrl  + left button'</l>
<c>* </c>
<c>* Generate color vector for visualization</c>
<l>Colors := ['red','green','blue','cyan','magenta','yellow','medium slate blue','coral','slate blue','orange red','dark olive green']</l>
<c>* </c>
<c>* Number of Matches</c>
<l>Number := |Score|</l>
<c>* </c>
<c>* Move the model into the scene</c>
<l>rigid_trans_object_model_3d (ObjectModel3DModel, Pose, ObjectModel3DResult)</l>
<l>ColorsVis := Colors[[0:Number - 1] % |Colors|]</l>
<c>* </c>
<c>* Visualize results</c>
<l>if (EdgesTrained == 'true')</l>
<l>    Message := 'Original scene points (gray)'</l>
<l>    Message[1] := 'Sampled scene points (cyan)'</l>
<l>    Message[2] := 'Key points (yellow)'</l>
<l>    Message[3] := 'Sampled 3d edges (green)'</l>
<l>    Message[4] := Number + ' object' + ['s',''][Number == 1] + ' found '</l>
<l>    visualize_object_model_3d (WindowHandle1, [ObjectModel3DScene,SampledEdges,SampledScene,KeyPoints,ObjectModel3DResult], [], [], ['color_' + [0:Number + 3],'point_size_' + [0,1,2,3],'disp_pose','alpha'], ['gray','green','cyan','yellow',ColorsVis,1.0,3.0,3.0,5.0,'true',0.5], Message, ['','','','',Labels], Instructions, PoseOut)</l>
<l>else</l>
<l>    Message := 'Final Results:'</l>
<l>    Message[1] := 'Original scene points (gray)'</l>
<l>    Message[2] := 'Sampled scene points (cyan)'</l>
<l>    Message[3] := 'Key points (yellow)'</l>
<l>    Message[4] := Number + ' object' + ['s',''][Number == 1] + ' found'</l>
<l>    visualize_object_model_3d (WindowHandle1, [ObjectModel3DScene,SampledScene,KeyPoints,ObjectModel3DResult], [], [], ['color_' + [0:Number + 2],'point_size_' + [0,1,2],'disp_pose','alpha'], ['gray','cyan','yellow',ColorsVis,1.0,3.0,5.0,'true',0.5], Message, ['','','',Labels], Instructions, PoseOut)</l>
<l>endif</l>
<l>dev_set_window (WindowHandle1)</l>
<l>dev_clear_window ()</l>
<l>return ()</l>
</body>
<docu id="dev_display_surface_matching_results">
<chapters lang="en_US">
<item>3D Matching</item>
<item>Surface-Based</item>
</chapters>
<library lang="en_US">MVTec Standard Procedures</library>
<parameters>
<parameter id="EdgesTrained"/>
<parameter id="ObjectModel3DModel"/>
<parameter id="ObjectModel3DScene"/>
<parameter id="Pose"/>
<parameter id="Score"/>
<parameter id="SurfaceMatchingResultID"/>
<parameter id="VisibilityTrained"/>
<parameter id="WindowHandle1"/>
</parameters>
</docu>
</procedure>
<procedure name="dev_display_tiled_legend" access="local">
<interface>
<ic>
<par name="WindowImages" base_type="ctrl" dimension="0"/>
<par name="GenParam" base_type="ctrl" dimension="0"/>
</ic>
</interface>
<body>
<c>* </c>
<c>* This procedure displays a legend of dev_display_dl_data_tiled</c>
<c>* according to the generic parameters.</c>
<c>* </c>
<l>try</l>
<l>    get_dict_tuple (GenParam, 'display_legend', DisplayLegend)</l>
<l>    if (not DisplayLegend)</l>
<l>        return ()</l>
<l>    endif</l>
<l>catch (Exception)</l>
<l>endtry</l>
<c>* </c>
<l>LegendText := []</l>
<l>try</l>
<l>    get_dict_tuple (GenParam, 'display_input', Flag)</l>
<l>    if (Flag)</l>
<l>        LegendText := [LegendText,'input']</l>
<l>    endif</l>
<l>catch (Exception)</l>
<l>    LegendText := [LegendText,'input']</l>
<l>endtry</l>
<l>try</l>
<l>    get_dict_tuple (GenParam, 'display_ground_truth', Flag)</l>
<l>    if (Flag)</l>
<l>        LegendText := [LegendText,'ground truth']</l>
<l>    endif</l>
<l>catch (Exception)</l>
<l>    LegendText := [LegendText,'ground truth']</l>
<l>endtry</l>
<l>try</l>
<l>    get_dict_tuple (GenParam, 'display_result', Flag)</l>
<l>    if (Flag)</l>
<l>        LegendText := [LegendText,'result']</l>
<l>    endif</l>
<l>catch (Exception)</l>
<l>    LegendText := [LegendText,'result']</l>
<l>endtry</l>
<l>if (|LegendText| == 3)</l>
<l>    PosTexts := ['Top:    ','Center: ','Bottom: ']</l>
<l>elseif (|LegendText| == 2)</l>
<l>    PosTexts := ['Top:    ','Bottom: ']</l>
<l>else</l>
<l>    PosTexts := ''</l>
<l>endif</l>
<l>dev_set_window (WindowImages)</l>
<l>Text := PosTexts + LegendText</l>
<l>dev_disp_text (Text, 'window', 'top', 'right', 'black', [], [])</l>
<l>return ()</l>
</body>
<docu id="dev_display_tiled_legend">
<abstract lang="en_US">This procedure displays a legend of dev_display_dl_data_tiled according to the generic parameters.
</abstract>
<chapters lang="de_DE">
<item>Deep Learning</item>
<item>Modell</item>
</chapters>
<chapters lang="en_US">
<item>Deep Learning</item>
<item>Model</item>
</chapters>
<library lang="en_US">MVTec Standard Procedures</library>
<short lang="en_US">Display a legend according to the generic parameters.</short>
<parameters>
<parameter id="GenParam">
<default_type>integer</default_type>
<description lang="en_US">Generic parameter dictionary, which is used in the tiled display call.</description>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>dict</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="WindowImages">
<default_type>integer</default_type>
<description lang="en_US">Window handle for text display.</description>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>window</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
</parameters>
</docu>
</procedure>
<procedure name="dev_display_train_info_anomaly_detection" access="local">
<interface>
<ic>
<par name="TrainParam" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="WindowHandleInfo" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c>* </c>
<c>* This procedure displays information about the training parameters of an anomaly detection model.</c>
<c>* </c>
<c>* Initialize display data.</c>
<l>get_dict_tuple (TrainParam, 'display_param', DisplayParam)</l>
<l>get_dict_tuple (DisplayParam, 'enabled', DisplayEnabled)</l>
<c>* </c>
<l>if (not DisplayEnabled)</l>
<l>    return ()</l>
<l>endif</l>
<c>* </c>
<l>WindowWidth := 500</l>
<l>WindowHeight := 200</l>
<l>WindowBGColor := 'light gray'</l>
<c>* </c>
<c>* Open and setup text window.</c>
<l>dev_open_window (0, 0, WindowWidth, WindowHeight, WindowBGColor, WindowHandleInfo)</l>
<l>set_display_font (WindowHandleInfo, 16, 'mono', 'true', 'false')</l>
<l>dev_set_window (WindowHandleInfo)</l>
<c>* </c>
<c>* Display information.</c>
<l>get_dict_tuple (TrainParam, 'anomaly_param', TrainParamAnomaly)</l>
<l>get_dict_tuple (TrainParamAnomaly, 'domain_ratio', DomainRatio)</l>
<l>get_dict_tuple (TrainParamAnomaly, 'error_threshold', ErrorThreshold)</l>
<l>get_dict_tuple (TrainParamAnomaly, 'regularization_noise', RegularizationNoise)</l>
<l>get_dict_tuple (TrainParamAnomaly, 'max_num_epochs', MaxNumEpochs)</l>
<l>TrainInformationLeft := ['Training anomaly detection model.','','Max. number of epochs:','Domain ratio:','Error threshold:','Regularization noise:','','This may take some time...']</l>
<l>TrainInformationRight := ['','',MaxNumEpochs,DomainRatio$'.4f',ErrorThreshold$'.4f',RegularizationNoise$'.4f']</l>
<l>dev_disp_text (TrainInformationLeft, 'window', 'top', 'left', 'black', 'box', 'false')</l>
<l>dev_disp_text (TrainInformationRight, 'window', 'top', 'right', 'black', 'box', 'false')</l>
<c>* </c>
<l>return ()</l>
</body>
<docu id="dev_display_train_info_anomaly_detection">
<abstract lang="en_US">This procedure displays information about the training parameters of an anomaly detection model.</abstract>
<chapters lang="de_DE">
<item>Deep Learning</item>
<item>Modell</item>
</chapters>
<chapters lang="en_US">
<item>Deep Learning</item>
<item>Anomaly Detection</item>
</chapters>
<library lang="en_US">MVTec Standard Procedures</library>
<short lang="en_US">Display information about the training of an anomaly detection model.</short>
<parameters>
<parameter id="TrainParam">
<default_type>integer</default_type>
<description lang="en_US">The dictionary with the training parameters for anomaly detection.</description>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>dict</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="WindowHandleInfo">
<default_type>integer</default_type>
<description lang="en_US">The handle of the window where the information is displayed.</description>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>window</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
</parameters>
</docu>
</procedure>
<procedure name="dev_display_update_train_dl_model" access="local">
<interface>
<ic>
<par name="TrainParam" base_type="ctrl" dimension="0"/>
<par name="DisplayData" base_type="ctrl" dimension="0"/>
<par name="TrainInfo" base_type="ctrl" dimension="0"/>
<par name="Epochs" base_type="ctrl" dimension="0"/>
<par name="Loss" base_type="ctrl" dimension="0"/>
<par name="LearningRate" base_type="ctrl" dimension="0"/>
<par name="EvalEpochs" base_type="ctrl" dimension="0"/>
<par name="EvalValues" base_type="ctrl" dimension="0"/>
<par name="EvalValuesTrain" base_type="ctrl" dimension="0"/>
</ic>
</interface>
<body>
<c>* </c>
<c>* This procedure updates the various texts and plots.</c>
<c>* It uses precomputed information (TrainInfo, EvaluationInfos,...).</c>
<c>* </c>
<l>get_dict_tuple (DisplayData, 'enabled', DisplayEnabled)</l>
<l>if (not DisplayEnabled)</l>
<l>    return ()</l>
<l>endif</l>
<c>* </c>
<l>get_dict_tuple (DisplayData, 'display_param', DisplayParam)</l>
<c>* </c>
<l>get_dict_tuple (DisplayData, 'window_text', WindowText)</l>
<l>set_window_param (WindowText, 'flush', 'false')</l>
<c>* Only switch to window if the current window is not the text window (performance).</c>
<l>dev_get_window (WindowHandle)</l>
<l>if (WindowHandle != WindowText)</l>
<l>    dev_set_window (WindowText)</l>
<l>    WindowHandle := WindowText</l>
<l>endif</l>
<l>dev_clear_window ()</l>
<c>* </c>
<l>get_dict_tuple (DisplayParam, 'change_plot_interval_seconds', ChangePlotIntervalSeconds)</l>
<l>get_dict_tuple (DisplayData, 'last_change_plot', LastChange)</l>
<l>count_seconds (Seconds)</l>
<l>get_dict_tuple (DisplayData, 'plot_eval', PlotEval)</l>
<l>if (Seconds - LastChange &gt;= ChangePlotIntervalSeconds)</l>
<l>    PlotEval := not PlotEval and |EvalEpochs| &gt;= 2</l>
<l>    set_dict_tuple (DisplayData, 'plot_eval', PlotEval)</l>
<l>    set_dict_tuple (DisplayData, 'last_change_plot', Seconds)</l>
<l>endif</l>
<c>* </c>
<l>if (PlotEval)</l>
<l>    TextPlot := '2/2'</l>
<l>else</l>
<l>    TextPlot := '1/2'</l>
<l>    PlotTrainEval := false</l>
<l>endif</l>
<l>HeadlineText := 'Showing plot ' + TextPlot + ':'</l>
<c>* </c>
<c>* Shall the training evaluation be plotted?</c>
<l>PlotTrainEval := false</l>
<c>* </c>
<c>* In case there are missing evaluation values (-1),</c>
<c>* we just reuse the previous values.</c>
<l>if (|EvalValuesTrain|)</l>
<l>    PlotTrainEval := max(EvalValuesTrain) != -1</l>
<l>    if (PlotTrainEval)</l>
<l>        tuple_find (EvalValuesTrain, -1, Indices)</l>
<l>        if (Indices != -1 and Indices != [])</l>
<l>            for Index := 0 to |Indices| - 1 by 1</l>
<l>                if (Indices[Index] == 0)</l>
<l>                    EvalValuesTrain[0] := 0.0</l>
<l>                else</l>
<l>                    EvalValuesTrain[Indices[Index]] := EvalValuesTrain[Indices[Index] - 1]</l>
<l>                endif</l>
<l>            endfor</l>
<l>        endif</l>
<l>    endif</l>
<l>endif</l>
<c>* </c>
<l>get_part (WindowText, PartRow1, PartColumn1, PartRow2, PartColumn2)</l>
<l>get_window_extents (WindowHandle, _, _, Width, Height)</l>
<c>* Generate a background rectangle for the plot.</c>
<c>* For a correct visualization of the rectangle, the region</c>
<c>* may not be cut off.</c>
<l>get_system ('clip_region', ClipRegionValue)</l>
<l>set_system ('clip_region', 'false')</l>
<l>gen_rectangle1 (PlotBackground, 470, 9, PartRow2 - 6, PartColumn2 - 10)</l>
<l>set_system ('clip_region', ClipRegionValue)</l>
<c>* </c>
<l>PlotHeight := (PartRow2 - 30 - 480) * Height / (PartRow2 - PartRow1 + 1)</l>
<l>LegendRow := 479</l>
<l>LegendDistanceLeft := 65</l>
<l>LegendDistanceRight := 85</l>
<c>* </c>
<c>* Get change strategy parameters and check if a learning rate strategy exits</c>
<l>PlotLearningRateStrategy := false</l>
<l>RightMargin := 35</l>
<l>get_dict_tuple (TrainParam, 'change_strategies', ChangeStrategies)</l>
<l>if (|ChangeStrategies| &gt; 0)</l>
<l>    for Idx := 0 to |ChangeStrategies| - 1 by 1</l>
<l>        ChangeStrategy := ChangeStrategies[Idx]</l>
<l>        get_dict_tuple (ChangeStrategy, 'model_param', ChangeStrategyName)</l>
<l>        if (ChangeStrategyName == 'learning_rate')</l>
<l>            PlotLearningRateStrategy := true</l>
<l>            get_dict_tuple (ChangeStrategy, 'values', ChangeStrategiesValues)</l>
<l>            get_dict_tuple (ChangeStrategy, 'initial_value', ChangeStrategiesInitial)</l>
<c>            * </c>
<c>            * Plot parameters for the learning rate</c>
<l>            StrategyMin := min(LearningRate)</l>
<l>            StrategyMax := max(LearningRate)</l>
<l>            LogLRMin := log10(max2(1e-8,StrategyMin))</l>
<l>            LogLRMax := log10(max2(1e-8,StrategyMax))</l>
<c>            * </c>
<l>            if (fabs(LogLRMax - LogLRMin) &lt; 1e-4)</l>
<l>                LogLRMin := LogLRMin - 5e-5</l>
<l>                LogLRMax := LogLRMax + 5e-5</l>
<l>            endif</l>
<c>            * </c>
<l>            LRScale := (LogLRMax - LogLRMin) / PlotHeight</l>
<l>            LROffset := 15</l>
<l>            LogLROffset := LROffset * LRScale</l>
<c>            * </c>
<l>            StartYLearningRate := pow(10,LogLRMin - 1.0 * LogLROffset)</l>
<l>            EndYLearningRate := pow(10,LogLRMax + 1.0 * LogLROffset)</l>
<l>            TicksYLearningRate := PlotHeight / 5 * LRScale</l>
<c>            * </c>
<l>            LogYLearningRate := 'true'</l>
<l>            RightMargin := 75</l>
<l>        endif</l>
<l>    endfor</l>
<l>endif</l>
<l>LRColor := '#1332ffdd'</l>
<l>LRLineWidth := 2</l>
<l>LRTextLegend := '\'learning_rate\''</l>
<c>* Space for legends</c>
<l>TopMarginPlots := 480 + 20</l>
<c>* </c>
<c>* </c>
<l>if (PlotEval)</l>
<l>    dev_set_color ('white')</l>
<l>    dev_set_draw ('fill')</l>
<l>    dev_display (PlotBackground)</l>
<l>    TicksX := max2(0.1,(max(EvalEpochs) - min(EvalEpochs)) * 0.15)</l>
<l>    EvalValuesMin := min([EvalValues,max2(0.0,EvalValuesTrain)])</l>
<l>    EvalValuesMax := max([EvalValues,EvalValuesTrain])</l>
<l>    if (abs(EvalValuesMax - EvalValuesMin) &lt; 1e-3)</l>
<l>        EvalValuesMin := EvalValuesMin - 5e-4</l>
<l>        EvalValuesMax := EvalValuesMax + 5e-4</l>
<l>    endif</l>
<l>    TicksY := (EvalValuesMax - EvalValuesMin) * 0.1</l>
<l>    StartY := EvalValuesMin - (EvalValuesMax - EvalValuesMin) * 0.1</l>
<l>    EndY := EvalValuesMax + (EvalValuesMax - EvalValuesMin) * 0.1</l>
<c>    * </c>
<l>    YAxisLabel := 'Evaluation value'</l>
<l>    get_dict_tuple (TrainInfo, 'best_evaluation', BestEvaluationData)</l>
<l>    if (|BestEvaluationData| &gt; 0)</l>
<l>        get_dict_tuple (BestEvaluationData, 'comparison_keys', BestEvaluationComparisonKeys)</l>
<l>        YAxisLabel := 'Evaluation value'</l>
<l>        if (|BestEvaluationComparisonKeys| &gt; 1)</l>
<l>            pretty_print_tuple (BestEvaluationComparisonKeys, YAxisLabel)</l>
<l>            YAxisLabel := 'mean(' + YAxisLabel + ')'</l>
<l>        else</l>
<l>            YAxisLabel := BestEvaluationComparisonKeys</l>
<l>        endif</l>
<l>    endif</l>
<c>    * Use a smaller, non-bold font for the plot.</c>
<l>    set_display_font (WindowText, 12, 'mono', 'false', 'false')</l>
<c>    * Plot larning rate if the corresponding strategy exists.</c>
<l>    if (PlotLearningRateStrategy)</l>
<c>        * </c>
<c>        * Display current values in appropriate colors.</c>
<l>        get_string_extents (WindowText, LRTextLegend, _, _, StringExtendsLegendRight, _)</l>
<l>        dev_disp_text (LRTextLegend, 'image', LegendRow, Width - StringExtendsLegendRight - LegendDistanceRight, LRColor, 'box', 'false')</l>
<l>        plot_tuple_no_window_handling (WindowText, Epochs, LearningRate, '', '', LRColor, ['log_y','axes_color','start_y','end_y','ticks_y','margin_top','margin_bottom','margin_left','margin_right','line_width','axes_color','axis_location_y','format_y'], [LogYLearningRate,'black',StartYLearningRate,EndYLearningRate,TicksYLearningRate,TopMarginPlots,30,65,RightMargin,LRLineWidth,'#898b8f','right','.1e'])</l>
<l>    endif</l>
<c>    * Plot validation evaluation values.</c>
<l>    plot_tuple_no_window_handling (WindowText, EvalEpochs, EvalValues, 'Epochs', '', '#36a2eb', ['axes_color','ticks_x','ticks_y','start_y','end_y','margin_top','margin_bottom','margin_left','margin_right','line_width','axes_color'], ['black',TicksX,TicksY,StartY,EndY,TopMarginPlots,30,65,RightMargin,3,'#898b8f'])</l>
<c>    * Plot train evaluation values.</c>
<l>    if (PlotTrainEval)</l>
<l>        Bullet := '\xe2\x97\x8f'</l>
<l>        Line := '\xE2\x80\x95'</l>
<l>        YAxisTitle := '  \'' + YAxisLabel + '\' (' + Line + ' validation, ' + Bullet + '-- training)'</l>
<l>        plot_tuple_no_window_handling (WindowText, EvalEpochs, EvalValuesTrain, 'Epochs', '', '#36a2eb', ['style','axes_color','ticks_x','ticks_y','start_y','end_y','margin_top','margin_bottom','margin_left','margin_right','line_width','axes_color'], [20,'black',TicksX,TicksY,StartY,EndY,TopMarginPlots,30,65,RightMargin,3,'#898b8f'])</l>
<l>        plot_tuple_no_window_handling (WindowText, EvalEpochs, EvalValuesTrain, 'Epochs', '', '#36a2eb', ['style','axes_color','ticks_x','ticks_y','start_y','end_y','margin_top','margin_bottom','margin_left','margin_right','line_width','axes_color'], ['circle','black',TicksX,TicksY,StartY,EndY,TopMarginPlots,30,65,RightMargin,3,'#898b8f'])</l>
<l>    else</l>
<l>        YAxisTitle := '  \'' + YAxisLabel + '\''</l>
<l>    endif</l>
<c>    * Display title of y-axis.</c>
<l>    dev_disp_text (YAxisTitle, 'image', LegendRow, LegendDistanceLeft, '#36a2eb', 'box', 'false')</l>
<c>    * Reset font.</c>
<l>    set_display_font (WindowText, 16, 'mono', 'true', 'false')</l>
<l>else</l>
<l>    if (|Epochs| &gt; 3)</l>
<l>        dev_set_color ('white')</l>
<l>        dev_set_draw ('fill')</l>
<l>        dev_display (PlotBackground)</l>
<c>        * </c>
<l>        TicksX := max2(0.1,(max(Epochs) - min(Epochs)) * 0.15)</l>
<c>        * </c>
<c>        * Set StartY and EndY, such that there is a margin on top and bottom to</c>
<c>        * avoid that the plot overlaps with the axis captions. (With respect to</c>
<c>        * the logarithmic plotting of the Loss function)</c>
<c>        * Set this offset in window coordinates:</c>
<l>        Offset := 15</l>
<c>        * Calculate min max values to determine the correct offset in log</c>
<c>        * coordinates.</c>
<l>        LogMin := log10(max2(0.00001,min(Loss)))</l>
<l>        LogMax := log10(max2(0.00001,max(Loss)))</l>
<c>        * </c>
<l>        if (fabs(LogMax - LogMin) &lt; 0.0001)</l>
<l>            LogMin := LogMin - 0.00005</l>
<l>            LogMax := LogMax + 0.00005</l>
<l>        endif</l>
<c>        * </c>
<l>        Scale := (LogMax - LogMin) / PlotHeight</l>
<l>        LogOffset := Offset * Scale</l>
<l>        StartY := pow(10,LogMin - LogOffset)</l>
<l>        EndY := pow(10,LogMax + LogOffset)</l>
<l>        TicksY := PlotHeight / 10 * Scale</l>
<c>        * </c>
<c>        * Use a smaller, non-bold font for the plot.</c>
<l>        set_display_font (WindowText, 12, 'mono', 'false', 'false')</l>
<l>        LogY := 'true'</l>
<c>        * Plot learning rate if the corresponding strategy exists.</c>
<l>        if (PlotLearningRateStrategy)</l>
<c>            * </c>
<c>            * Display current values in appropriate colors.</c>
<l>            get_string_extents (WindowText, LRTextLegend, _, _, StringExtendsLegendRight, _)</l>
<l>            dev_disp_text (LRTextLegend, 'image', LegendRow, Width - StringExtendsLegendRight - LegendDistanceRight, LRColor, 'box', 'false')</l>
<l>            plot_tuple_no_window_handling (WindowText, Epochs, LearningRate, '', '', LRColor, ['log_y','axes_color','start_y','end_y','ticks_y','margin_top','margin_bottom','margin_left','margin_right','line_width','axes_color','axis_location_y','format_y'], [LogY,'black',StartYLearningRate,EndYLearningRate,TicksYLearningRate,TopMarginPlots,30,65,RightMargin,LRLineWidth,'#898b8f','right','.1e'])</l>
<l>        endif</l>
<l>        YAxisLabel := 'Loss'</l>
<l>        dev_disp_text ('  ' + YAxisLabel, 'image', LegendRow, LegendDistanceLeft, '#ff6384', 'box', 'false')</l>
<l>        plot_tuple_no_window_handling (WindowText, Epochs, Loss, 'Epochs', '', '#ff6384', ['log_y','axes_color','ticks_x','ticks_y','start_y','end_y','margin_top','margin_bottom','margin_left','margin_right','line_width','axes_color'], [LogY,'black',TicksX,TicksY,StartY,EndY,TopMarginPlots,30,65,RightMargin,3,'#898b8f'])</l>
<l>        set_display_font (WindowText, 16, 'mono', 'true', 'false')</l>
<l>    else</l>
<l>        HeadlineText := 'Waiting for data to initialize the plot...'</l>
<l>    endif</l>
<l>endif</l>
<c></c>
<l>dev_disp_text (HeadlineText, 'image', 445, 9, 'black', 'box', 'false')</l>
<c>* </c>
<c>* Model parameter status.</c>
<l>get_dict_tuple (DisplayParam, 'status_model_params', TextModelParams)</l>
<l>get_dict_tuple (TrainInfo, 'model_params', ModelParams)</l>
<l>StatusModelParamsLeft := []</l>
<l>StatusModelParamsRight := []</l>
<l>for Index := 0 to |TextModelParams| - 1 by 1</l>
<l>    ParName := TextModelParams[Index]</l>
<l>    try</l>
<l>        get_dict_tuple (ModelParams, ParName, Tuple)</l>
<l>    catch (Exception)</l>
<l>        continue</l>
<l>    endtry</l>
<l>    if (ParName == 'batch_size_multiplier' and Tuple == 1)</l>
<l>        continue</l>
<l>    endif</l>
<l>    StatusModelParamsLeft := [StatusModelParamsLeft,'\'' + ParName + '\'']</l>
<c></c>
<l>    pretty_print_tuple (Tuple, TupleStr)</l>
<l>    StatusModelParamsRight := [StatusModelParamsRight,TupleStr]</l>
<l>endfor</l>
<l>if (|StatusModelParamsLeft| &gt; 0)</l>
<l>    StatusModelParamsLeft := ['Model parameters:','  ' + StatusModelParamsLeft]</l>
<l>    StatusModelParamsRight := [' ',StatusModelParamsRight]</l>
<l>endif</l>
<c>* </c>
<c>* Evaluation status.</c>
<l>StatusEvaluationLeft := []</l>
<l>StatusEvaluationRight := []</l>
<l>get_dict_tuple (TrainInfo, 'best_evaluation', BestEvaluationData)</l>
<l>if (|BestEvaluationData| &gt; 0)</l>
<l>    get_dict_tuple (BestEvaluationData, 'comparison_keys', BestEvaluationComparisonKeys)</l>
<l>    get_dict_tuple (BestEvaluationData, 'best_value', BestEvaluationValue)</l>
<l>    get_dict_tuple (BestEvaluationData, 'best_info', BestEvaluationInfo)</l>
<l>    get_dict_tuple (BestEvaluationInfo, 'epoch', BestEvaluationEpoch)</l>
<l>    get_dict_tuple (BestEvaluationData, 'best_value_train', BestTrainEvaluationValue)</l>
<l>    get_dict_tuple (BestEvaluationData, 'best_info_train', BestTrainEvaluationInfo)</l>
<l>    get_dict_tuple (BestTrainEvaluationInfo, 'epoch', BestTrainEvaluationEpoch)</l>
<l>    get_dict_tuple (TrainInfo, 'num_epochs', NumEpochs)</l>
<l>    if (|BestEvaluationComparisonKeys| &gt; 1)</l>
<l>        StatusEvaluationLeft := [StatusEvaluationLeft,'Measures']</l>
<l>        BestEvaluationComparisonKeysStr := 'multiple (' + |BestEvaluationComparisonKeys| + ')'</l>
<l>    else</l>
<l>        StatusEvaluationLeft := [StatusEvaluationLeft,'Measure']</l>
<l>        BestEvaluationComparisonKeysStr := '\'' + BestEvaluationComparisonKeys + '\''</l>
<l>    endif</l>
<c>    * </c>
<l>    StatusEvaluationRight := [StatusEvaluationRight,BestEvaluationComparisonKeysStr]</l>
<c>    * Validation value.</c>
<l>    StatusEvaluationLeft := [StatusEvaluationLeft,'Best value validation (value / epoch)']</l>
<l>    StatusEvaluationRight := [StatusEvaluationRight,BestEvaluationValue$'0.3f' + ' / ' + BestEvaluationEpoch$'0.1f']</l>
<c>    * Training value.</c>
<l>    if (PlotTrainEval)</l>
<l>        StatusEvaluationLeft := [StatusEvaluationLeft,'Best value training (value / epoch)']</l>
<l>        StatusEvaluationRight := [StatusEvaluationRight,BestTrainEvaluationValue$'0.3f' + ' / ' + BestTrainEvaluationEpoch$'0.1f']</l>
<l>    endif</l>
<c>    * </c>
<l>    StatusEvaluationLeft := ['Evaluation:','  ' + StatusEvaluationLeft]</l>
<l>    StatusEvaluationRight := [' ',StatusEvaluationRight]</l>
<l>endif</l>
<c>* </c>
<c>* Train status.</c>
<l>StatusTrainLeft := []</l>
<l>StatusTrainRight := []</l>
<l>get_dict_tuple (TrainInfo, 'epoch', EpochReal)</l>
<l>get_dict_tuple (TrainInfo, 'num_epochs', NumEpochs)</l>
<l>StatusTrainLeft := [StatusTrainLeft,'Epoch']</l>
<l>StatusTrainRight := [StatusTrainRight,EpochReal$'.1f' + ' of ' + NumEpochs]</l>
<l>get_dict_tuple (TrainInfo, 'mean_loss', MeanLoss)</l>
<l>if (|MeanLoss| == 0)</l>
<l>    MeanLossStr := ''</l>
<l>else</l>
<l>    MeanLossStr := MeanLoss$'0.4f'</l>
<l>endif</l>
<l>StatusTrainLeft := [StatusTrainLeft,'Loss']</l>
<l>StatusTrainRight := [StatusTrainRight,MeanLossStr]</l>
<c>* </c>
<c>* Elapsed and remaining time.</c>
<l>get_dict_tuple (TrainInfo, 'start_epoch', StartEpoch)</l>
<l>get_dict_tuple (TrainInfo, 'start_time', StartTime)</l>
<l>estimate_progress (StartTime, StartEpoch, EpochReal, NumEpochs, SecondsElapsed, SecondsRemaining, ProgressPercent, ProgressPerSecond)</l>
<l>timespan_string (SecondsElapsed, 'auto', TimeElapsedString)</l>
<l>timespan_string (SecondsRemaining, 'top2', TimeRemainingString)</l>
<l>StatusTrainLeft := [StatusTrainLeft,'Time elapsed','Time left']</l>
<l>StatusTrainRight := [StatusTrainRight,TimeElapsedString,TimeRemainingString]</l>
<c>* </c>
<c>* Indent train status items.</c>
<l>StatusTrainLeft := ['Train status:','  ' + StatusTrainLeft]</l>
<l>StatusTrainRight := [' ',StatusTrainRight]</l>
<c>* </c>
<c>* Combine all.</c>
<l>StatusLeft := ['train_dl_model',' ',' ',StatusTrainLeft,' ',StatusEvaluationLeft,' ',StatusModelParamsLeft]</l>
<l>StatusRight := [' ',' ',' ',StatusTrainRight,' ',StatusEvaluationRight,' ',StatusModelParamsRight]</l>
<c>* </c>
<c>* Cut strings with too many chars.</c>
<l>MaxChars := 14</l>
<l>for Index := 0 to |StatusRight| - 1 by 1</l>
<l>    Str := StatusRight[Index]</l>
<l>    tuple_is_string (Str, IsString)</l>
<l>    if (IsString)</l>
<l>        tuple_strlen (Str, Length)</l>
<l>        if (Length &gt; MaxChars)</l>
<l>            SubStr := Str{0:MaxChars - 3} + '...'</l>
<l>            StatusRight[Index] := SubStr</l>
<l>        endif</l>
<l>    endif</l>
<l>endfor</l>
<c>* </c>
<c>* Display the text.</c>
<l>get_dict_tuple (DisplayData, 'window_text', WindowText)</l>
<c>* </c>
<l>dev_disp_text (StatusLeft, 'window', 'top', 'left', 'black', 'box', 'false')</l>
<l>dev_disp_text (StatusRight, 'window', 'top', 'right', 'black', 'box', 'false')</l>
<l>flush_buffer (WindowText)</l>
<l>set_window_param (WindowText, 'flush', 'true')</l>
<l>get_part (WindowText, Row1, Column1, Row2, Column2)</l>
<l>get_dict_tuple (DisplayData, 'window_text_width', WindowTextWidth)</l>
<l>get_dict_tuple (DisplayData, 'window_text_height', WindowTextHeight)</l>
<l>if (WindowTextWidth - 1 != Column2 - Column1 or WindowTextHeight - 1 != Row2 - Row1)</l>
<l>    dev_set_part (Row1, Column1, Row1 + WindowTextHeight - 1, Column1 + WindowTextWidth - 1)</l>
<l>endif</l>
<c>* </c>
<l>return ()</l>
</body>
<docu id="dev_display_update_train_dl_model">
<abstract lang="en_US">This procedure updates the various texts and plots during training of a deep-learning-based model.
It uses precomputed information.</abstract>
<chapters lang="de_DE">
<item>Deep Learning</item>
<item>Modell</item>
</chapters>
<chapters lang="en_US">
<item>Deep Learning</item>
<item>Model</item>
</chapters>
<library lang="en_US">MVTec Standard Procedures</library>
<short lang="en_US">Update the various texts and plots during training.</short>
<parameters>
<parameter id="DisplayData">
<default_type>integer</default_type>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>dict</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="Epochs"/>
<parameter id="EvalEpochs"/>
<parameter id="EvalValues"/>
<parameter id="EvalValuesTrain"/>
<parameter id="LearningRate"/>
<parameter id="Loss"/>
<parameter id="TrainInfo">
<default_type>integer</default_type>
<description lang="en_US">Dictionary or tuple of dictionaries returning summarized status information which are calculated during the training.</description>
<mixed_type>false</mixed_type>
<sem_type>dict</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="TrainParam">
<default_type>integer</default_type>
<description lang="en_US">Dictionary with training parameters.</description>
<mixed_type>false</mixed_type>
<sem_type>dict</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
</parameters>
</docu>
</procedure>
<procedure name="dev_display_weight_regions" access="local">
<interface>
<io>
<par name="ImageWeight" base_type="iconic" dimension="0"/>
</io>
<ic>
<par name="DrawTransparency" base_type="ctrl" dimension="0"/>
<par name="SegMaxWeight" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="Colors" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c>* </c>
<c>* This procedure displays a map of the weights</c>
<c>* given in ImageWeight as regions.</c>
<c>* The transparency can be adjusted.</c>
<c>* The used colors are returned.</c>
<c>* </c>
<c>* Define colors.</c>
<l>NumColors := 20</l>
<l>get_distinct_colors (NumColors, false, 0, 160, Colors)</l>
<l>tuple_inverse (Colors, Colors)</l>
<l>WeightsColorsAlpha := Colors + DrawTransparency</l>
<c>* </c>
<c>* Get gay values of ImageWeight.</c>
<l>get_domain (ImageWeight, Domain)</l>
<l>get_region_points (Domain, Rows, Columns)</l>
<l>get_grayval (ImageWeight, Rows, Columns, GrayVal)</l>
<c>* </c>
<c>* Check that the gray values of the image</c>
<c>* are below the specified maximum.</c>
<l>if (max(GrayVal) &gt; SegMaxWeight)</l>
<l>    throw ('The maximum weight (' + max(GrayVal) + ') in the weight image is greater than the given SegMaxWeight (' + SegMaxWeight + ').')</l>
<l>endif</l>
<c>* </c>
<l>while (GrayVal != [])</l>
<c>    * Go through all gray value 'groups',</c>
<c>    * starting from the maximum.</c>
<l>    GrayValWeight := max(GrayVal)</l>
<l>    GrayVal := remove(GrayVal,find(GrayVal,GrayValWeight))</l>
<l>    threshold (ImageWeight, WeightsRegion, GrayValWeight, GrayValWeight)</l>
<c>    * </c>
<c>    * Visualize the respective group.</c>
<l>    ColorIndex := int(ceil(GrayValWeight / SegMaxWeight * (NumColors - 1)))</l>
<l>    ClassColor := WeightsColorsAlpha[ColorIndex]</l>
<l>    dev_set_color (ClassColor)</l>
<l>    dev_display (WeightsRegion)</l>
<l>endwhile</l>
<l>return ()</l>
</body>
<docu id="dev_display_weight_regions">
<chapters lang="de_DE">
<item>Graphik</item>
<item>Ausgabe</item>
</chapters>
<chapters lang="en_US">
<item>Graphics</item>
<item>Output</item>
</chapters>
<library lang="en_US">MVTec Standard Procedures</library>
<short lang="en_US">Display a map of weights.</short>
<parameters>
<parameter id="Colors">
<default_type>string</default_type>
<mixed_type>false</mixed_type>
<multivalue>optional</multivalue>
<sem_type>color</sem_type>
<type_list>
<item>string</item>
</type_list>
</parameter>
<parameter id="DrawTransparency">
<default_type>string</default_type>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>string</sem_type>
<type_list>
<item>string</item>
</type_list>
</parameter>
<parameter id="ImageWeight">
<multichannel>false</multichannel>
<multivalue>false</multivalue>
<sem_type>image</sem_type>
</parameter>
<parameter id="SegMaxWeight"/>
</parameters>
</docu>
</procedure>
<procedure name="dev_open_window_fit_image">
<interface>
<io>
<par name="Image" base_type="iconic" dimension="0"/>
</io>
<ic>
<par name="Row" base_type="ctrl" dimension="0"/>
<par name="Column" base_type="ctrl" dimension="0"/>
<par name="WidthLimit" base_type="ctrl" dimension="0"/>
<par name="HeightLimit" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="WindowHandle" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c>* This procedure opens a new graphics window and adjusts the size</c>
<c>* such that it fits into the limits specified by WidthLimit</c>
<c>* and HeightLimit, but also maintains the correct image aspect ratio.</c>
<c>* </c>
<c>* If it is impossible to match the minimum and maximum extent requirements</c>
<c>* at the same time (f.e. if the image is very long but narrow),</c>
<c>* the maximum value gets a higher priority,</c>
<c>* </c>
<c>* Parse input tuple WidthLimit</c>
<l>if (|WidthLimit| == 0 or WidthLimit &lt; 0)</l>
<l>    MinWidth := 500</l>
<l>    MaxWidth := 800</l>
<l>elseif (|WidthLimit| == 1)</l>
<l>    MinWidth := 0</l>
<l>    MaxWidth := WidthLimit</l>
<l>else</l>
<l>    MinWidth := WidthLimit[0]</l>
<l>    MaxWidth := WidthLimit[1]</l>
<l>endif</l>
<c>* Parse input tuple HeightLimit</c>
<l>if (|HeightLimit| == 0 or HeightLimit &lt; 0)</l>
<l>    MinHeight := 400</l>
<l>    MaxHeight := 600</l>
<l>elseif (|HeightLimit| == 1)</l>
<l>    MinHeight := 0</l>
<l>    MaxHeight := HeightLimit</l>
<l>else</l>
<l>    MinHeight := HeightLimit[0]</l>
<l>    MaxHeight := HeightLimit[1]</l>
<l>endif</l>
<c>* </c>
<c>* Test, if window size has to be changed.</c>
<l>ResizeFactor := 1</l>
<l>get_image_size (Image, ImageWidth, ImageHeight)</l>
<c>* First, expand window to the minimum extents (if necessary).</c>
<l>if (MinWidth &gt; ImageWidth or MinHeight &gt; ImageHeight)</l>
<l>    ResizeFactor := max([real(MinWidth) / ImageWidth,real(MinHeight) / ImageHeight])</l>
<l>endif</l>
<l>TempWidth := ImageWidth * ResizeFactor</l>
<l>TempHeight := ImageHeight * ResizeFactor</l>
<c>* Then, shrink window to maximum extents (if necessary).</c>
<l>if (MaxWidth &lt; TempWidth or MaxHeight &lt; TempHeight)</l>
<l>    ResizeFactor := ResizeFactor * min([real(MaxWidth) / TempWidth,real(MaxHeight) / TempHeight])</l>
<l>endif</l>
<l>WindowWidth := ImageWidth * ResizeFactor</l>
<l>WindowHeight := ImageHeight * ResizeFactor</l>
<c>* Resize window</c>
<l>dev_open_window (Row, Column, WindowWidth, WindowHeight, 'black', WindowHandle)</l>
<l>dev_set_part (0, 0, ImageHeight - 1, ImageWidth - 1)</l>
<l>return ()</l>
</body>
<docu id="dev_open_window_fit_image">
<abstract lang="en_US">This procedure  opens a new graphics window with a given minimum and maximum extent such that it preserves the aspect ratio of the given image.

The position of the new graphics window is given by the parameters Row and Column, which define the position of the upper left corner of the graphics window.

The size of the new graphics window is determined such that the limits given in WidthLimit and HeightLimit are fulfilled and that the aspect ratio of the given image is preserved. To restrict only the maximum size of the new graphics window, only one value must be passed in WidthLimit and HeightLimit, respectively. To restrict both the minimum and the maximum size, WidthLimit and HeightLimit must contain a tuple with two elements, each. The first element defines the minimum size and the second element defines the maximum size of the new graphics window.

If it is not possible to set the window size such that all limits (minimum and maximum width and height as well as the aspect ratio of the given image) are fulfilled, the limit for the minimum window size is neglected.

If WidthLimit is empty or negative, the following default value is used: [500,800].
If HeightLimit is empty or negative, the following default value is used: [400,600].</abstract>
<alternatives>
<item>dev_open_window_fit_size</item>
<item>dev_open_window</item>
</alternatives>
<chapters>
<item>Develop</item>
</chapters>
<chapters lang="de_DE">
<item>Develop</item>
</chapters>
<chapters lang="en_US">
<item>Develop</item>
</chapters>
<example lang="en_US">read_image (Image, 'mreut')
*
* Open a new graphics window with the default size limits.
dev_open_window_fit_image (Image, 0, 0, -1, -1, WindowHandle1)
*
* Open a new graphics window at the position (50,50) with a
* minimum size of 300 x 200 and a maximum size of 600 x 400.
dev_open_window_fit_image (Image, 50, 50, [300,600], [200,400],
                           WindowHandle2)</example>
<keywords lang="de_DE">
<item>Grafikfenster öffnen</item>
<item>Größe eines Grafikfensters setzen</item>
</keywords>
<keywords lang="en_US">
<item>open graphics window</item>
<item>set size of graphics window</item>
</keywords>
<library lang="de_DE">MVTec Standard Procedures</library>
<library lang="en_US">MVTec Standard Procedures</library>
<see_also>
<item>dev_resize_window_fit_image</item>
<item>dev_resize_window_fit_size</item>
</see_also>
<short>Opens a graphics window with a given maximum and minimum extent such that it preserves the aspect ratio of the given image</short>
<short lang="de_DE">Open a new graphics window that preserves the aspect ratio of the given image.</short>
<short lang="en_US">Open a new graphics window that preserves the aspect ratio of the given image.</short>
<successor>
<item>dev_display</item>
</successor>
<parameters>
<parameter id="Column">
<default_type>integer</default_type>
<default_value>0</default_value>
<description lang="en_US">Column coordinate of the upper left corner of the new window.</description>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>integer</sem_type>
<type_list>
<item>integer</item>
</type_list>
<values>
<item>0</item>
<item>10</item>
<item>50</item>
<item>100</item>
<item>150</item>
<item>200</item>
<item>500</item>
</values>
</parameter>
<parameter id="HeightLimit">
<default_type>integer</default_type>
<default_value>-1</default_value>
<description lang="en_US">Limit for the window height.</description>
<mixed_type>false</mixed_type>
<multivalue>optional</multivalue>
<sem_type>integer</sem_type>
<type_list>
<item>integer</item>
</type_list>
<values>
<item>300</item>
<item>400</item>
<item>500</item>
<item>600</item>
<item>800</item>
<item>1000</item>
<item>[400,600]</item>
<item>[500,800]</item>
</values>
</parameter>
<parameter id="Image">
<description lang="en_US">Image to the size of which the new window is adapted.</description>
<multichannel>optional</multichannel>
<multivalue>false</multivalue>
<sem_type>image</sem_type>
<type_list>
<item>byte</item>
<item>int1</item>
<item>int2</item>
<item>uint2</item>
<item>int4</item>
<item>int8</item>
<item>real</item>
<item>cyclic</item>
<item>direction</item>
<item>complex</item>
<item>vector_field</item>
</type_list>
</parameter>
<parameter id="Row">
<default_type>integer</default_type>
<default_value>0</default_value>
<description lang="en_US">Row coordinate of the upper left corner of the new window.</description>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>integer</sem_type>
<type_list>
<item>integer</item>
</type_list>
<values>
<item>0</item>
<item>10</item>
<item>50</item>
<item>100</item>
<item>150</item>
<item>200</item>
<item>500</item>
</values>
</parameter>
<parameter id="WidthLimit">
<default_type>integer</default_type>
<default_value>-1</default_value>
<description lang="en_US">Limit for the window width.</description>
<mixed_type>false</mixed_type>
<multivalue>optional</multivalue>
<sem_type>integer</sem_type>
<type_list>
<item>integer</item>
</type_list>
<values>
<item>300</item>
<item>400</item>
<item>500</item>
<item>600</item>
<item>800</item>
<item>1000</item>
<item>[300,600]</item>
<item>[500,800]</item>
</values>
</parameter>
<parameter id="WindowHandle">
<default_type>integer</default_type>
<description lang="en_US">The window handle of the new graphics window.</description>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>window</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
</parameters>
</docu>
</procedure>
<procedure name="dev_open_window_fit_size">
<interface>
<ic>
<par name="Row" base_type="ctrl" dimension="0"/>
<par name="Column" base_type="ctrl" dimension="0"/>
<par name="Width" base_type="ctrl" dimension="0"/>
<par name="Height" base_type="ctrl" dimension="0"/>
<par name="WidthLimit" base_type="ctrl" dimension="0"/>
<par name="HeightLimit" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="WindowHandle" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c>* This procedure open a new graphic window</c>
<c>* such that it fits into the limits specified by WidthLimit</c>
<c>* and HeightLimit, but also maintains the correct aspect ratio</c>
<c>* given by Width and Height.</c>
<c>* </c>
<c>* If it is impossible to match the minimum and maximum extent requirements</c>
<c>* at the same time (f.e. if the image is very long but narrow),</c>
<c>* the maximum value gets a higher priority.</c>
<c>* </c>
<c>* Parse input tuple WidthLimit</c>
<l>if (|WidthLimit| == 0 or WidthLimit &lt; 0)</l>
<l>    MinWidth := 500</l>
<l>    MaxWidth := 800</l>
<l>elseif (|WidthLimit| == 1)</l>
<l>    MinWidth := 0</l>
<l>    MaxWidth := WidthLimit</l>
<l>else</l>
<l>    MinWidth := WidthLimit[0]</l>
<l>    MaxWidth := WidthLimit[1]</l>
<l>endif</l>
<c>* Parse input tuple HeightLimit</c>
<l>if (|HeightLimit| == 0 or HeightLimit &lt; 0)</l>
<l>    MinHeight := 400</l>
<l>    MaxHeight := 600</l>
<l>elseif (|HeightLimit| == 1)</l>
<l>    MinHeight := 0</l>
<l>    MaxHeight := HeightLimit</l>
<l>else</l>
<l>    MinHeight := HeightLimit[0]</l>
<l>    MaxHeight := HeightLimit[1]</l>
<l>endif</l>
<c>* </c>
<c>* Test, if window size has to be changed.</c>
<l>ResizeFactor := 1</l>
<c>* First, expand window to the minimum extents (if necessary).</c>
<l>if (MinWidth &gt; Width or MinHeight &gt; Height)</l>
<l>    ResizeFactor := max([real(MinWidth) / Width,real(MinHeight) / Height])</l>
<l>endif</l>
<l>TempWidth := Width * ResizeFactor</l>
<l>TempHeight := Height * ResizeFactor</l>
<c>* Then, shrink window to maximum extents (if necessary).</c>
<l>if (MaxWidth &lt; TempWidth or MaxHeight &lt; TempHeight)</l>
<l>    ResizeFactor := ResizeFactor * min([real(MaxWidth) / TempWidth,real(MaxHeight) / TempHeight])</l>
<l>endif</l>
<l>WindowWidth := Width * ResizeFactor</l>
<l>WindowHeight := Height * ResizeFactor</l>
<c>* Resize window</c>
<l>dev_open_window (Row, Column, WindowWidth, WindowHeight, 'black', WindowHandle)</l>
<l>dev_set_part (0, 0, Height - 1, Width - 1)</l>
<l>return ()</l>
</body>
<docu id="dev_open_window_fit_size">
<abstract lang="en_US">The procedure dev_open_window_fit_size opens a new graphics window with a given minimum and maximum extent such that it preserves the aspect ratio of the given image size.

The position of the new graphics window is given by the parameters Row and Column, which define the position of the upper left corner of the graphics window.

The size of the new graphics window is determined such that the limits given in WidthLimit and HeightLimit are fulfilled and that the aspect ratio of the image size that is given in Width and Height is preserved. To restrict only the maximum size of the new graphics window, only one value must be passed in WidthLimit and HeightLimit, respectively. To restrict both the minimum and the maximum size, WidthLimit and HeightLimit must contain a tuple with two elements, each. The first element defines the minimum size and the second element defines the maximum size of the new graphics window.

If it is not possible to set the window size such that all limits (minimum and maximum width and height as well as the aspect ratio of the given image size) are fulfilled, the limit for the minimum window size is neglected.

If WidthLimit is set to -1, the following default value is used: [500,800].
If HeightLimit is set to -1, the following default value is used: [400,600].</abstract>
<alternatives>
<item>dev_open_window_fit_image</item>
<item>dev_open_window</item>
</alternatives>
<chapters lang="de_DE">
<item>Develop</item>
</chapters>
<chapters lang="en_US">
<item>Develop</item>
</chapters>
<example lang="en_US">*
* Open a new graphics window with the default size limits.
dev_open_window_fit_size (0, 0, 640, 480, -1, -1, WindowHandle1)
*
* Open a new graphics window at the position (50,50) with a
* minimum size of 300 x 200 and a maximum size of 600 x 400.
* The window is intended to display a large image with a width
* of 2000 pixel and a height of 15000 pixel while preserving the
* aspect ratio. Note that in this case the minimum width is
* neglected.
dev_open_window_fit_size (50, 50, 2000, 15000, [300,600], [400,800],
                          WindowHandle2)</example>
<keywords lang="de_DE">
<item>Grafikfenster öffnen</item>
<item>Größe eines Grafikfensters setzen</item>
</keywords>
<keywords lang="en_US">
<item>open graphics window</item>
<item>set size of graphics window</item>
</keywords>
<library lang="de_DE">MVTec Standard Procedures</library>
<library lang="en_US">MVTec Standard Procedures</library>
<see_also>
<item>dev_resize_window_fit_size</item>
<item>dev_resize_window_fit_image</item>
</see_also>
<short lang="de_DE">Open a new graphics window that preserves the aspect ratio of the given image size.</short>
<short lang="en_US">Open a new graphics window that preserves the aspect ratio of the given image size.</short>
<successor>
<item>dev_display</item>
</successor>
<parameters>
<parameter id="Column">
<default_type>integer</default_type>
<default_value>0</default_value>
<description lang="en_US">Column coordinate of the upper left corner of the new window.</description>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>integer</sem_type>
<type_list>
<item>integer</item>
</type_list>
<values>
<item>0</item>
<item>10</item>
<item>50</item>
<item>100</item>
<item>150</item>
<item>200</item>
<item>500</item>
</values>
</parameter>
<parameter id="Height">
<default_type>integer</default_type>
<description lang="en_US">The height of the image to be displayed.</description>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>integer</sem_type>
<type_list>
<item>integer</item>
</type_list>
<values>
<item>480</item>
<item>600</item>
<item>768</item>
<item>960</item>
<item>1050</item>
<item>1200</item>
<item>1536</item>
<item>2100</item>
<item>2400</item>
<item>4800</item>
</values>
</parameter>
<parameter id="HeightLimit">
<default_type>integer</default_type>
<default_value>-1</default_value>
<description lang="en_US">Limit for the window height.</description>
<mixed_type>false</mixed_type>
<multivalue>optional</multivalue>
<sem_type>integer</sem_type>
<type_list>
<item>integer</item>
</type_list>
<values>
<item>300</item>
<item>400</item>
<item>500</item>
<item>600</item>
<item>800</item>
<item>1000</item>
<item>[400,600]</item>
<item>[500,800]</item>
</values>
</parameter>
<parameter id="Row">
<default_type>integer</default_type>
<default_value>0</default_value>
<description lang="en_US">Row coordinate of the upper left corner of the new window.</description>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>integer</sem_type>
<type_list>
<item>integer</item>
</type_list>
<values>
<item>0</item>
<item>10</item>
<item>50</item>
<item>100</item>
<item>150</item>
<item>200</item>
<item>500</item>
</values>
</parameter>
<parameter id="Width">
<default_type>integer</default_type>
<description lang="en_US">The width of the image to be displayed.</description>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>integer</sem_type>
<type_list>
<item>integer</item>
</type_list>
<values>
<item>640</item>
<item>800</item>
<item>1024</item>
<item>1280</item>
<item>1400</item>
<item>1600</item>
<item>2048</item>
<item>2800</item>
<item>3200</item>
<item>6400</item>
</values>
</parameter>
<parameter id="WidthLimit">
<default_type>integer</default_type>
<default_value>-1</default_value>
<description lang="en_US">Limit for the window width.</description>
<mixed_type>false</mixed_type>
<multivalue>optional</multivalue>
<sem_type>integer</sem_type>
<type_list>
<item>integer</item>
</type_list>
<values>
<item>300</item>
<item>400</item>
<item>500</item>
<item>600</item>
<item>800</item>
<item>1000</item>
<item>[400,600]</item>
<item>[500,800]</item>
</values>
</parameter>
<parameter id="WindowHandle">
<default_type>integer</default_type>
<description lang="en_US">The window handle of the new graphics window.</description>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>window</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
</parameters>
</docu>
</procedure>
<procedure name="dev_resize_window_fit_image">
<interface>
<io>
<par name="Image" base_type="iconic" dimension="0"/>
</io>
<ic>
<par name="Row" base_type="ctrl" dimension="0"/>
<par name="Column" base_type="ctrl" dimension="0"/>
<par name="WidthLimit" base_type="ctrl" dimension="0"/>
<par name="HeightLimit" base_type="ctrl" dimension="0"/>
</ic>
</interface>
<body>
<c>* This procedure adjusts the size of the current window</c>
<c>* such that it fits into the limits specified by WidthLimit</c>
<c>* and HeightLimit, but also maintains the correct image aspect ratio.</c>
<c>* </c>
<c>* If it is impossible to match the minimum and maximum extent requirements</c>
<c>* at the same time (f.e. if the image is very long but narrow),</c>
<c>* the maximum value gets a higher priority,</c>
<c>* </c>
<c>* Parse input tuple WidthLimit</c>
<l>if (|WidthLimit| == 0 or WidthLimit &lt; 0)</l>
<l>    MinWidth := 500</l>
<l>    MaxWidth := 800</l>
<l>elseif (|WidthLimit| == 1)</l>
<l>    MinWidth := 0</l>
<l>    MaxWidth := WidthLimit</l>
<l>else</l>
<l>    MinWidth := WidthLimit[0]</l>
<l>    MaxWidth := WidthLimit[1]</l>
<l>endif</l>
<c>* Parse input tuple HeightLimit</c>
<l>if (|HeightLimit| == 0 or HeightLimit &lt; 0)</l>
<l>    MinHeight := 400</l>
<l>    MaxHeight := 600</l>
<l>elseif (|HeightLimit| == 1)</l>
<l>    MinHeight := 0</l>
<l>    MaxHeight := HeightLimit</l>
<l>else</l>
<l>    MinHeight := HeightLimit[0]</l>
<l>    MaxHeight := HeightLimit[1]</l>
<l>endif</l>
<c>* </c>
<c>* Test, if window size has to be changed.</c>
<l>ResizeFactor := 1</l>
<l>get_image_pointer1 (Image, Pointer, Type, ImageWidth, ImageHeight)</l>
<c>* First, expand window to the minimum extents (if necessary).</c>
<l>if (MinWidth &gt; ImageWidth or MinHeight &gt; ImageHeight)</l>
<l>    ResizeFactor := max([real(MinWidth) / ImageWidth,real(MinHeight) / ImageHeight])</l>
<l>endif</l>
<l>TempWidth := ImageWidth * ResizeFactor</l>
<l>TempHeight := ImageHeight * ResizeFactor</l>
<c>* Then, shrink window to maximum extents (if necessary).</c>
<l>if (MaxWidth &lt; TempWidth or MaxHeight &lt; TempHeight)</l>
<l>    ResizeFactor := ResizeFactor * min([real(MaxWidth) / TempWidth,real(MaxHeight) / TempHeight])</l>
<l>endif</l>
<l>WindowWidth := ImageWidth * ResizeFactor</l>
<l>WindowHeight := ImageHeight * ResizeFactor</l>
<c>* Resize window</c>
<l>dev_set_window_extents (Row, Column, WindowWidth, WindowHeight)</l>
<l>dev_set_part (0, 0, ImageHeight - 1, ImageWidth - 1)</l>
<l>return ()</l>
</body>
<docu id="dev_resize_window_fit_image">
<abstract lang="en_US">This procedure resizes the current graphics window with a given minimum and maximum extent such that it preserves the aspect ratio of the given image.

The position of the new graphics window is given by the parameters Row and Column, which define the position of the upper left corner of the graphics window.

The size of the new graphics window is determined such that the limits given in WidthLimit and HeightLimit are fulfilled and that the aspect ratio of the given image is preserved. To restrict only the maximum size of the new graphics window, only one value must be passed in WidthLimit and HeightLimit, respectively. To restrict both the minimum and the maximum size, WidthLimit and HeightLimit must contain a tuple with two elements, each. The first element defines the minimum size and the second element defines the maximum size of the new graphics window.

If it is not possible to set the window size such that all limits (minimum and maximum width and height as well as the aspect ratio of the given image) are fulfilled, the limit for the minimum window size is neglected.

If WidthLimit is empty or negative, the following default value is used: [500,800].
If HeightLimit is empty or negative, the following default value is used: [400,600].</abstract>
<alternatives>
<item>dev_resize_window_fit_size</item>
<item>dev_set_window_extents</item>
</alternatives>
<chapters lang="de_DE">
<item>Develop</item>
</chapters>
<chapters lang="en_US">
<item>Develop</item>
</chapters>
<example lang="en_US">dev_open_window (0, 0, 200, 200, 'black', WindowHandle)
*
read_image (Image, 'mreut')
*
dev_resize_window_fit_image (Image, 0, 0, -1, -1)
</example>
<keywords lang="de_DE">
<item>Größe eines Grafikfensters setzen</item>
</keywords>
<keywords lang="en_US">
<item>set size of graphics window</item>
</keywords>
<library lang="de_DE">MVTec Standard Procedures</library>
<library lang="en_US">MVTec Standard Procedures</library>
<predecessor>
<item>dev_open_window</item>
</predecessor>
<see_also>
<item>dev_open_window_fit_image</item>
<item>dev_open_window_fit_size</item>
</see_also>
<short lang="de_DE">Changes the size of a graphics window with a given maximum and minimum extent such that it preserves the aspect ratio of the given image</short>
<short lang="en_US">Changes the size of a graphics window with a given maximum and minimum extent such that it preserves the aspect ratio of the given image</short>
<successor>
<item>dev_display</item>
</successor>
<parameters>
<parameter id="Column">
<default_type>integer</default_type>
<default_value>0</default_value>
<description lang="en_US">Column coordinate of the upper left corner of the window.</description>
<multivalue>false</multivalue>
<sem_type>integer</sem_type>
<type_list>
<item>integer</item>
</type_list>
<values>
<item>0</item>
<item>10</item>
<item>50</item>
<item>100</item>
<item>150</item>
<item>200</item>
<item>500</item>
</values>
</parameter>
<parameter id="HeightLimit">
<default_type>integer</default_type>
<default_value>-1</default_value>
<description lang="en_US">Limit for the window height.</description>
<mixed_type>false</mixed_type>
<multivalue>optional</multivalue>
<sem_type>integer</sem_type>
<type_list>
<item>integer</item>
</type_list>
<values>
<item>300</item>
<item>400</item>
<item>500</item>
<item>600</item>
<item>800</item>
<item>1000</item>
<item>[400,600]</item>
<item>[500,800]</item>
</values>
</parameter>
<parameter id="Image">
<description lang="en_US">Image to the size of which the window is adapted.</description>
<multichannel>optional</multichannel>
<multivalue>false</multivalue>
<sem_type>image</sem_type>
<type_list>
<item>byte</item>
<item>int1</item>
<item>int2</item>
<item>uint2</item>
<item>int4</item>
<item>int8</item>
<item>real</item>
<item>cyclic</item>
<item>direction</item>
<item>complex</item>
<item>vector_field</item>
</type_list>
</parameter>
<parameter id="Row">
<default_type>integer</default_type>
<default_value>0</default_value>
<description lang="en_US">Row coordinate of the upper left corner of the new window.</description>
<multivalue>false</multivalue>
<sem_type>integer</sem_type>
<type_list>
<item>integer</item>
</type_list>
<values>
<item>0</item>
<item>10</item>
<item>50</item>
<item>100</item>
<item>150</item>
<item>200</item>
<item>500</item>
</values>
</parameter>
<parameter id="WidthLimit">
<default_type>integer</default_type>
<default_value>-1</default_value>
<description lang="en_US">Limit for the window width.</description>
<mixed_type>false</mixed_type>
<multivalue>optional</multivalue>
<sem_type>integer</sem_type>
<type_list>
<item>integer</item>
</type_list>
<values>
<item>300</item>
<item>400</item>
<item>500</item>
<item>600</item>
<item>800</item>
<item>1000</item>
<item>[300,600]</item>
<item>[500,800]</item>
</values>
</parameter>
</parameters>
</docu>
</procedure>
<procedure name="dev_resize_window_fit_size">
<interface>
<ic>
<par name="Row" base_type="ctrl" dimension="0"/>
<par name="Column" base_type="ctrl" dimension="0"/>
<par name="Width" base_type="ctrl" dimension="0"/>
<par name="Height" base_type="ctrl" dimension="0"/>
<par name="WidthLimit" base_type="ctrl" dimension="0"/>
<par name="HeightLimit" base_type="ctrl" dimension="0"/>
</ic>
</interface>
<body>
<c>* This procedure adjusts the size of the current window</c>
<c>* such that it fits into the limits specified by WidthLimit</c>
<c>* and HeightLimit, but also maintains the correct aspect ratio</c>
<c>* given by Width and Height.</c>
<c>* </c>
<c>* If it is impossible to match the minimum and maximum extent requirements</c>
<c>* at the same time (f.e. if the image is very long but narrow),</c>
<c>* the maximum value gets a higher priority.</c>
<c>* </c>
<c>* Parse input tuple WidthLimit</c>
<l>if (|WidthLimit| == 0 or WidthLimit &lt; 0)</l>
<l>    MinWidth := 500</l>
<l>    MaxWidth := 800</l>
<l>elseif (|WidthLimit| == 1)</l>
<l>    MinWidth := 0</l>
<l>    MaxWidth := WidthLimit</l>
<l>else</l>
<l>    MinWidth := WidthLimit[0]</l>
<l>    MaxWidth := WidthLimit[1]</l>
<l>endif</l>
<c>* Parse input tuple HeightLimit</c>
<l>if (|HeightLimit| == 0 or HeightLimit &lt; 0)</l>
<l>    MinHeight := 400</l>
<l>    MaxHeight := 600</l>
<l>elseif (|HeightLimit| == 1)</l>
<l>    MinHeight := 0</l>
<l>    MaxHeight := HeightLimit</l>
<l>else</l>
<l>    MinHeight := HeightLimit[0]</l>
<l>    MaxHeight := HeightLimit[1]</l>
<l>endif</l>
<c>* </c>
<c>* Test, if window size has to be changed.</c>
<l>ResizeFactor := 1</l>
<c>* First, expand window to the minimum extents (if necessary).</c>
<l>if (MinWidth &gt; Width or MinHeight &gt; Height)</l>
<l>    ResizeFactor := max([real(MinWidth) / Width,real(MinHeight) / Height])</l>
<l>endif</l>
<l>TempWidth := Width * ResizeFactor</l>
<l>TempHeight := Height * ResizeFactor</l>
<c>* Then, shrink window to maximum extents (if necessary).</c>
<l>if (MaxWidth &lt; TempWidth or MaxHeight &lt; TempHeight)</l>
<l>    ResizeFactor := ResizeFactor * min([real(MaxWidth) / TempWidth,real(MaxHeight) / TempHeight])</l>
<l>endif</l>
<l>WindowWidth := Width * ResizeFactor</l>
<l>WindowHeight := Height * ResizeFactor</l>
<c>* Resize window</c>
<l>dev_set_window_extents (Row, Column, WindowWidth, WindowHeight)</l>
<l>dev_set_part (0, 0, Height - 1, Width - 1)</l>
<l>return ()</l>
</body>
<docu id="dev_resize_window_fit_size">
<abstract lang="en_US">This procedure resizes the current graphics window with a given minimum and maximum extent such that it preserves the aspect ratio of the given image size.

The position of the graphics window is given by the parameters Row and Column, which define the position of the upper left corner of the graphics window.

The size of the new graphics window is determined such that the limits given in WidthLimit and HeightLimit are fulfilled and that the aspect ratio of the image size that is given in Width and Height is preserved. To restrict only the maximum size of the new graphics window, only one value must be passed in WidthLimit and HeightLimit, respectively. To restrict both the minimum and the maximum size, WidthLimit and HeightLimit must contain a tuple with two elements, each. The first element defines the minimum size and the second element defines the maximum size of the new graphics window.

If it is not possible to set the window size such that all limits (minimum and maximum width and height as well as the aspect ratio of the given image size) are fulfilled, the limit for the minimum window size is neglected.

If WidthLimit is empty or negative, the following default value is used: [500,800].
If HeightLimit is empty or negative, the following default value is used: [400,600].</abstract>
<alternatives>
<item>dev_resize_window_fit_image</item>
<item>dev_set_window_extents</item>
</alternatives>
<chapters lang="de_DE">
<item>Develop</item>
</chapters>
<chapters lang="en_US">
<item>Develop</item>
</chapters>
<example lang="en_US">dev_open_window (0, 0, 512, 512, 'black', WindowHandle)
*
gen_image_const (Image, 'byte', 2000, 128)
*
dev_resize_window_fit_size (0, 0, 2000, 128, -1, -1)</example>
<keywords lang="de_DE">
<item>Größe eines Grafikfensters setzen</item>
</keywords>
<keywords lang="en_US">
<item>set size of graphics window</item>
</keywords>
<library lang="de_DE">MVTec Standard Procedures</library>
<library lang="en_US">MVTec Standard Procedures</library>
<predecessor>
<item>dev_open_window</item>
</predecessor>
<see_also>
<item>dev_open_window_fit_size</item>
<item>dev_open_window_fit_image</item>
<item>dev_set_window_extents</item>
</see_also>
<short lang="de_DE">Resizes a graphics window with a given maximum extent such that it preserves the aspect ratio of a given width and height</short>
<short lang="en_US">Resizes a graphics window with a given maximum extent such that it preserves the aspect ratio of a given width and height</short>
<successor>
<item>dev_display</item>
</successor>
<parameters>
<parameter id="Column">
<default_type>integer</default_type>
<default_value>0</default_value>
<description lang="en_US">Column coordinate of the upper left corner of the window.</description>
<multivalue>false</multivalue>
<sem_type>integer</sem_type>
<type_list>
<item>integer</item>
</type_list>
<values>
<item>0</item>
<item>10</item>
<item>50</item>
<item>100</item>
<item>150</item>
<item>200</item>
<item>500</item>
</values>
</parameter>
<parameter id="Height">
<default_type>integer</default_type>
<description lang="en_US">The height of the image to be displayed.</description>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>integer</sem_type>
<type_list>
<item>integer</item>
</type_list>
<values>
<item>480</item>
<item>600</item>
<item>768</item>
<item>960</item>
<item>1050</item>
<item>1200</item>
<item>1536</item>
<item>2100</item>
<item>2400</item>
<item>4800</item>
</values>
</parameter>
<parameter id="HeightLimit">
<default_type>integer</default_type>
<default_value>-1</default_value>
<description lang="en_US">Limit for the window height.</description>
<multivalue>optional</multivalue>
<sem_type>integer</sem_type>
<type_list>
<item>integer</item>
</type_list>
<values>
<item>300</item>
<item>400</item>
<item>500</item>
<item>600</item>
<item>800</item>
<item>1000</item>
<item>[400,600]</item>
<item>[500,800]</item>
</values>
</parameter>
<parameter id="Row">
<default_type>integer</default_type>
<default_value>0</default_value>
<description lang="en_US">Row coordinate of the upper left corner of the window.</description>
<multivalue>false</multivalue>
<sem_type>integer</sem_type>
<type_list>
<item>integer</item>
</type_list>
<values>
<item>0</item>
<item>10</item>
<item>50</item>
<item>100</item>
<item>150</item>
<item>200</item>
<item>500</item>
</values>
</parameter>
<parameter id="Width">
<default_type>integer</default_type>
<description lang="en_US">The width of the image to be displayed.</description>
<multivalue>false</multivalue>
<sem_type>integer</sem_type>
<type_list>
<item>integer</item>
</type_list>
<values>
<item>640</item>
<item>800</item>
<item>1024</item>
<item>1280</item>
<item>1400</item>
<item>1600</item>
<item>2048</item>
<item>2800</item>
<item>3200</item>
<item>6400</item>
</values>
</parameter>
<parameter id="WidthLimit">
<default_type>integer</default_type>
<default_value>-1</default_value>
<description lang="en_US">Limit for the window width.</description>
<multivalue>optional</multivalue>
<sem_type>integer</sem_type>
<type_list>
<item>integer</item>
</type_list>
<values>
<item>300</item>
<item>400</item>
<item>500</item>
<item>600</item>
<item>800</item>
<item>1000</item>
<item>[400,600]</item>
<item>[500,800]</item>
</values>
</parameter>
</parameters>
</docu>
</procedure>
<procedure name="dev_update_off">
<interface/>
<body>
<c>* This procedure sets different update settings to 'off'.</c>
<c>* This is useful to get the best performance and reduce overhead.</c>
<c>* </c>
<l>dev_update_pc ('off')</l>
<l>dev_update_var ('off')</l>
<l>dev_update_window ('off')</l>
<l>return ()</l>
</body>
<docu id="dev_update_off">
<abstract lang="en_US">This procedure sets dev_update_pc, dev_update_var and dev_update_window to 'off'.</abstract>
<alternatives>
<item>dev_update_pc</item>
<item>dev_update_var</item>
<item>dev_update_window</item>
</alternatives>
<chapters lang="de_DE">
<item>Develop</item>
</chapters>
<chapters lang="en_US">
<item>Develop</item>
</chapters>
<example lang="en_US">dev_update_off ()
* do something
dev_update_on ()</example>
<keywords lang="de_DE">
<item>Aktualisierungsmodus setzen</item>
</keywords>
<keywords lang="en_US">
<item>set update mode</item>
</keywords>
<library lang="de_DE">MVTec Standard Procedures</library>
<library lang="en_US">MVTec Standard Procedures</library>
<see_also>
<item>dev_update_on</item>
</see_also>
<short lang="de_DE">Switch dev_update_pc, dev_update_var and dev_update_window to 'off'.</short>
<short lang="en_US">Switch dev_update_pc, dev_update_var and dev_update_window to 'off'.</short>
<parameters/>
</docu>
</procedure>
<procedure name="dev_update_on">
<interface/>
<body>
<c>* This procedure sets different update settings to 'on'.</c>
<c>* </c>
<l>dev_update_pc ('on')</l>
<l>dev_update_var ('on')</l>
<l>dev_update_window ('on')</l>
<l>return ()</l>
</body>
<docu id="dev_update_on">
<abstract lang="en_US">This procedure sets dev_update_pc, dev_update_var and dev_update_window to 'on'.</abstract>
<alternatives>
<item>dev_update_pc</item>
<item>dev_update_var</item>
<item>dev_update_window</item>
</alternatives>
<chapters lang="de_DE">
<item>Develop</item>
</chapters>
<chapters lang="en_US">
<item>Develop</item>
</chapters>
<example lang="en_US">dev_update_off ()
* do something
dev_update_on ()</example>
<keywords lang="de_DE">
<item>Aktualisierungsmodus setzen</item>
</keywords>
<keywords lang="en_US">
<item>set update mode</item>
</keywords>
<library lang="de_DE">MVTec Standard Procedures</library>
<library lang="en_US">MVTec Standard Procedures</library>
<see_also>
<item>dev_update_off</item>
</see_also>
<short lang="de_DE">Switch dev_update_pc, dev_update_var and dev_update_window to 'on'.</short>
<short lang="en_US">Switch dev_update_pc, dev_update_var and dev_update_window to 'on'.</short>
<parameters/>
</docu>
</procedure>
<procedure name="disp_3d_coord_system">
<interface>
<ic>
<par name="WindowHandle" base_type="ctrl" dimension="0"/>
<par name="CamParam" base_type="ctrl" dimension="0"/>
<par name="Pose" base_type="ctrl" dimension="0"/>
<par name="CoordAxesLength" base_type="ctrl" dimension="0"/>
</ic>
</interface>
<body>
<c>* This procedure displays a 3D coordinate system.</c>
<c>* It needs the procedure gen_arrow_contour_xld.</c>
<c>* </c>
<c>* Input parameters:</c>
<c>* WindowHandle: The window where the coordinate system shall be displayed</c>
<c>* CamParam: The camera paramters</c>
<c>* Pose: The pose to be displayed</c>
<c>* CoordAxesLength: The length of the coordinate axes in world coordinates</c>
<c>* </c>
<c>* Check, if Pose is a correct pose tuple.</c>
<l>if (|Pose| != 7)</l>
<l>    return ()</l>
<l>endif</l>
<l>get_cam_par_data (CamParam, 'camera_type', CameraType)</l>
<l>IsTelecentric := strstr(CameraType,'telecentric') != -1</l>
<l>if (Pose[2] == 0.0 and not IsTelecentric)</l>
<c>    * For projective cameras:</c>
<c>    * Poses with Z position zero cannot be projected</c>
<c>    * (that would lead to a division by zero error).</c>
<l>    return ()</l>
<l>endif</l>
<c>* Convert to pose to a transformation matrix</c>
<l>pose_to_hom_mat3d (Pose, TransWorld2Cam)</l>
<c>* Project the world origin into the image</c>
<l>affine_trans_point_3d (TransWorld2Cam, 0, 0, 0, OrigCamX, OrigCamY, OrigCamZ)</l>
<l>project_3d_point (OrigCamX, OrigCamY, OrigCamZ, CamParam, Row0, Column0)</l>
<c>* Project the coordinate axes into the image</c>
<l>affine_trans_point_3d (TransWorld2Cam, CoordAxesLength, 0, 0, X, Y, Z)</l>
<l>project_3d_point (X, Y, Z, CamParam, RowAxX, ColumnAxX)</l>
<l>affine_trans_point_3d (TransWorld2Cam, 0, CoordAxesLength, 0, X, Y, Z)</l>
<l>project_3d_point (X, Y, Z, CamParam, RowAxY, ColumnAxY)</l>
<l>affine_trans_point_3d (TransWorld2Cam, 0, 0, CoordAxesLength, X, Y, Z)</l>
<l>project_3d_point (X, Y, Z, CamParam, RowAxZ, ColumnAxZ)</l>
<c>* </c>
<c>* Generate an XLD contour for each axis</c>
<l>distance_pp ([Row0,Row0,Row0], [Column0,Column0,Column0], [RowAxX,RowAxY,RowAxZ], [ColumnAxX,ColumnAxY,ColumnAxZ], Distance)</l>
<l>HeadLength := int(max([max(Distance) / 12.0,5.0]))</l>
<l>gen_arrow_contour_xld (Arrows, [Row0,Row0,Row0], [Column0,Column0,Column0], [RowAxX,RowAxY,RowAxZ], [ColumnAxX,ColumnAxY,ColumnAxZ], HeadLength, HeadLength)</l>
<c>* </c>
<c>* Display coordinate system</c>
<l>disp_xld (Arrows, WindowHandle)</l>
<c>* </c>
<l>get_rgb (WindowHandle, Red, Green, Blue)</l>
<l>set_rgb (WindowHandle, Red[0], Green[0], Blue[0])</l>
<l>set_tposition (WindowHandle, RowAxX + 3, ColumnAxX + 3)</l>
<l>write_string (WindowHandle, 'X')</l>
<l>set_rgb (WindowHandle, Red[1 % |Red|], Green[1 % |Green|], Blue[1 % |Blue|])</l>
<l>set_tposition (WindowHandle, RowAxY + 3, ColumnAxY + 3)</l>
<l>write_string (WindowHandle, 'Y')</l>
<l>set_rgb (WindowHandle, Red[2 % |Red|], Green[2 % |Green|], Blue[2 % |Blue|])</l>
<l>set_tposition (WindowHandle, RowAxZ + 3, ColumnAxZ + 3)</l>
<l>write_string (WindowHandle, 'Z')</l>
<l>set_rgb (WindowHandle, Red, Green, Blue)</l>
<l>return ()</l>
</body>
<docu id="disp_3d_coord_system">
<abstract lang="en_US">This procedure displays a 3D coordinate system at the given Pose using the camera parameters CamParam in the window WindowHandle. The length of the displayed axes can be specified in world coordinates with the parameter CoordAxesLength. The axes are displayed in the first three currently set colors, which can be checked with get_rgb.
If only a single color is set, this color is used for all three axes.</abstract>
<attention lang="en_US">This procedure needs the procedure gen_arrow_contour_xld.</attention>
<chapters>
<item>Matching-3D</item>
</chapters>
<chapters lang="de_DE">
<item>Graphik</item>
<item>Ausgabe</item>
</chapters>
<chapters lang="en_US">
<item>Graphics</item>
<item>Output</item>
</chapters>
<example lang="en_US">dev_open_window (0, 0, 640, 480, 'black', WindowHandle)
Pose:=[0,0,2.0,-30,-15,60,0]
gen_cam_par_area_scan_division (0.012, 0, 5e-6, 5e-6, 320, 240, 640, 480, CamParam)
disp_3d_coord_system (WindowHandle, CamParam, Pose, 0.1)</example>
<keywords lang="de_DE">
<item>3D-Koordinatensystem anzeigen</item>
</keywords>
<keywords lang="en_US">
<item>display 3D coordinate system</item>
</keywords>
<library lang="de_DE">MVTec Standard Procedures</library>
<library lang="en_US">MVTec Standard Procedures</library>
<predecessor>
<item>dev_set_colored</item>
<item>set_rgb</item>
<item>vector_to_pose</item>
<item>camera_calibration</item>
<item>find_calib_descriptor_model</item>
<item>find_planar_calib_deformable_model</item>
<item>dev_display</item>
<item>find_marks_and_pose</item>
<item>find_shape_model_3d</item>
<item>get_circle_pose</item>
<item>get_rectangle_pose</item>
</predecessor>
<see_also>
<item>create_pose</item>
</see_also>
<short>Display the axes of a 3d coordinate system</short>
<short lang="de_DE">Display the axes of a 3d coordinate system</short>
<short lang="en_US">Display the axes of a 3d coordinate system</short>
<successor>
<item>dev_display</item>
<item>disp_obj</item>
</successor>
<parameters>
<parameter id="CamParam">
<default_type>real</default_type>
<default_value>['area_scan_division',0.012,0.0,5e-6,5e-6,320,240,640,480]</default_value>
<description lang="en_US">Interior camera parameters</description>
<mixed_type>optional</mixed_type>
<multivalue>true</multivalue>
<sem_type>number</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
<item>string</item>
</type_list>
</parameter>
<parameter id="CoordAxesLength">
<default_type>integer</default_type>
<default_value>0.05</default_value>
<description lang="en_US">The length of the coordinate axes in world coordinates.</description>
<multivalue>false</multivalue>
<sem_type>number</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
<values>
<item>0.01</item>
<item>0.02</item>
<item>0.05</item>
<item>0.1</item>
<item>0.2</item>
<item>0.5</item>
</values>
</parameter>
<parameter id="Pose">
<default_type>real</default_type>
<default_value>[0.0,0.0,1.0,0.0,0.0,0.0,0]</default_value>
<description lang="en_US">The pose to be displayed</description>
<mixed_type>optional</mixed_type>
<multivalue>true</multivalue>
<sem_type>pose</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
<parameter id="WindowHandle">
<default_type>integer</default_type>
<description lang="en_US">The window where the coordinate system shall be displayed</description>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>window</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
</parameters>
</docu>
</procedure>
<procedure name="disp_buttons" access="local">
<interface>
<ic>
<par name="Parameters" base_type="ctrl" dimension="0"/>
<par name="WindowHandle" base_type="ctrl" dimension="0"/>
</ic>
</interface>
<body>
<c>* This procedure displays all Buttons in the window.</c>
<c>* </c>
<c>* Input parameters:</c>
<c>* WindowHandle: The window, where the text shall be displayed</c>
<c>* </c>
<c>* Use the buttons set in the global variable gButtons.</c>
<l>get_message_tuple (Parameters, 'gButtons', gButtons)</l>
<c></c>
<l>for idx := 0 to |gButtons| - 1 by 5</l>
<c>    * Display the continue button</c>
<l>    Message := gButtons[idx + 0]</l>
<l>    disp_text_button (WindowHandle, Message, 'window', gButtons[idx + 2], gButtons[idx + 1], 'black', '#f28f26')</l>
<c>    * Debug the computed area</c>
<l>*     gen_rectangle1 (Rectangle, gButtons[idx + 2], gButtons[idx + 1], gButtons[idx + 4], gButtons[idx + 3])</l>
<l>*     set_color (WindowHandle, 'white')</l>
<l>*     set_color (WindowHandle, '#ffffFFEE')</l>
<l>*     disp_obj (Rectangle, WindowHandle)</l>
<l>endfor</l>
<l>return ()</l>
</body>
<docu id="disp_buttons">
<abstract lang="en_US">Displays a continue button at the lower right corner.</abstract>
<chapters lang="de_DE">
<item>Graphik</item>
<item>Ausgabe</item>
</chapters>
<chapters lang="en_US">
<item>Graphics</item>
<item>Output</item>
</chapters>
<library lang="en_US">MVTec Standard Procedures</library>
<short lang="en_US">Displays a continue button.</short>
<parameters>
<parameter id="Parameters">
<default_type>integer</default_type>
<mixed_type>false</mixed_type>
<sem_type>message</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="WindowHandle">
<default_type>integer</default_type>
<description lang="en_US">Window handle in which the button should be displayed.</description>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>window</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
</parameters>
</docu>
</procedure>
<procedure name="disp_continue_button">
<interface>
<ic>
<par name="WindowHandle" base_type="ctrl" dimension="0"/>
</ic>
</interface>
<body>
<c>* This procedure displays a 'Continue' text button</c>
<c>* in the lower right corner of the screen.</c>
<c>* It uses the procedure disp_message.</c>
<c>* </c>
<c>* Input parameters:</c>
<c>* WindowHandle: The window, where the text shall be displayed</c>
<c>* </c>
<c>* Use the continue message set in the global variable gTerminationButtonLabel.</c>
<c>* If this variable is not defined, set a standard text instead.</c>
<l>global tuple gTerminationButtonLabel</l>
<l>try</l>
<l>    ContinueMessage := gTerminationButtonLabel</l>
<l>catch (Exception)</l>
<l>    ContinueMessage := 'Continue'</l>
<l>endtry</l>
<c>* Display the continue button</c>
<l>get_window_extents (WindowHandle, Row, Column, Width, Height)</l>
<l>get_string_extents (WindowHandle, ' ' + ContinueMessage + ' ', Ascent, Descent, TextWidth, TextHeight)</l>
<l>disp_text_button (WindowHandle, ContinueMessage, 'window', Height - TextHeight - 22, Width - TextWidth - 12, 'black', '#f28f26')</l>
<l>return ()</l>
</body>
<docu id="disp_continue_button">
<abstract lang="en_US">Displays a continue button at the lower right corner.</abstract>
<chapters lang="de_DE">
<item>Graphik</item>
<item>Ausgabe</item>
</chapters>
<chapters lang="en_US">
<item>Graphics</item>
<item>Output</item>
</chapters>
<library lang="en_US">MVTec Standard Procedures</library>
<short lang="en_US">Displays a continue button.</short>
<parameters>
<parameter id="WindowHandle">
<default_type>integer</default_type>
<description lang="en_US">Window handle in which the button should be displayed.</description>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>window</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
</parameters>
</docu>
</procedure>
<procedure name="disp_continue_message">
<interface>
<ic>
<par name="WindowHandle" base_type="ctrl" dimension="0"/>
<par name="Color" base_type="ctrl" dimension="0"/>
<par name="Box" base_type="ctrl" dimension="0"/>
</ic>
</interface>
<body>
<c>* This procedure displays 'Press Run (F5) to continue' in the</c>
<c>* lower right corner of the screen.</c>
<c>* It uses the procedure disp_message.</c>
<c>* </c>
<c>* Input parameters:</c>
<c>* WindowHandle: The window, where the text shall be displayed</c>
<c>* Color: defines the text color.</c>
<c>*    If set to '' or 'auto', the currently set color is used.</c>
<c>* Box: If set to 'true', the text is displayed in a box.</c>
<c>* </c>
<c>* Convert the parameter Box to generic parameters.</c>
<l>GenParamName := []</l>
<l>GenParamValue := []</l>
<l>if (|Box| &gt; 0)</l>
<l>    if (Box[0] == 'false')</l>
<c>        * Display no box</c>
<l>        GenParamName := [GenParamName,'box']</l>
<l>        GenParamValue := [GenParamValue,'false']</l>
<l>    elseif (Box[0] != 'true')</l>
<c>        * Set a color other than the default.</c>
<l>        GenParamName := [GenParamName,'box_color']</l>
<l>        GenParamValue := [GenParamValue,Box[0]]</l>
<l>    endif</l>
<l>endif</l>
<l>if (|Box| &gt; 1)</l>
<l>    if (Box[1] == 'false')</l>
<c>        * Display no shadow.</c>
<l>        GenParamName := [GenParamName,'shadow']</l>
<l>        GenParamValue := [GenParamValue,'false']</l>
<l>    elseif (Box[1] != 'true')</l>
<c>        * Set a shadow color other than the default.</c>
<l>        GenParamName := [GenParamName,'shadow_color']</l>
<l>        GenParamValue := [GenParamValue,Box[1]]</l>
<l>    endif</l>
<l>endif</l>
<c>* </c>
<l>if (Color == '')</l>
<c>    * disp_text does not accept an empty string for Color.</c>
<l>    Color := []</l>
<l>endif</l>
<c>* </c>
<c>* Display the message.</c>
<l>ContinueMessage := 'Press Run (F5) to continue'</l>
<l>disp_text (WindowHandle, ContinueMessage, 'window', 'bottom', 'right', Color, GenParamName, GenParamValue)</l>
<l>return ()</l>
</body>
<docu id="disp_continue_message">
<abstract lang="en_US">This procedure displays 'Click 'Run' to continue' in a given Color in the lower right corner of the screen.
If the parameter Box is set to 'true', the text is written within a white box, which is useful on irregular background.</abstract>
<alternatives>
<item>disp_message</item>
<item>write_string</item>
</alternatives>
<attention lang="en_US">This procedure uses the procedure disp_message.
</attention>
<chapters>
<item>Graphics</item>
<item>Text</item>
</chapters>
<chapters lang="de_DE">
<item>Graphik</item>
<item>Text</item>
</chapters>
<chapters lang="en_US">
<item>Graphics</item>
<item>Text</item>
</chapters>
<example lang="en_US">dev_open_window (0, 0, 512, 512, 'black', WindowHandle)
set_display_font (WindowHandle, 16, 'mono', 'true', 'false')
for Index := 1 to 5 by 1
    disp_message (WindowHandle, 'Step '+Index, 'window', 30*Index, -1, 'black', 'true')
    disp_continue_message (WindowHandle, 'black', 'true')
    stop ()
endfor
</example>
<keywords lang="de_DE">
<item>Fortsetzungs-Nachricht anzeigen</item>
</keywords>
<keywords lang="en_US">
<item>display continue message</item>
</keywords>
<library lang="de_DE">MVTec Standard Procedures</library>
<library lang="en_US">MVTec Standard Procedures</library>
<predecessor>
<item>disp_message</item>
<item>set_display_font</item>
<item>write_string</item>
<item>dev_display</item>
<item>disp_obj</item>
<item>disp_image</item>
</predecessor>
<see_also>
<item>disp_message</item>
<item>write_string</item>
</see_also>
<short>This procedure displays 'Press 'Run' to continue' in the lower right corner of the screen.</short>
<short lang="de_DE">This procedure displays 'Click 'Run' to continue' in the lower right corner of the screen.</short>
<short lang="en_US">This procedure displays 'Click 'Run' to continue' in the lower right corner of the screen.</short>
<successor>
<item>stop</item>
</successor>
<parameters>
<parameter id="Box">
<default_type>string</default_type>
<default_value>'true'</default_value>
<description lang="en_US">If set to 'true', the text is written within a white box.</description>
<multivalue>false</multivalue>
<sem_type>attribute.value</sem_type>
<type_list>
<item>string</item>
</type_list>
<value_list>
<item>'true'</item>
<item>'false'</item>
</value_list>
</parameter>
<parameter id="Color">
<default_type>string</default_type>
<default_value>'black'</default_value>
<description lang="en_US">Defines the text color. If set to '' or 'auto', the currently set color is used.
</description>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>color</sem_type>
<type_list>
<item>string</item>
</type_list>
<values>
<item>'black'</item>
<item>'blue'</item>
<item>'yellow'</item>
<item>'red'</item>
<item>'green'</item>
<item>'cyan'</item>
<item>'magenta'</item>
<item>'forest green'</item>
<item>'lime green'</item>
<item>'coral'</item>
<item>'slate blue'</item>
</values>
</parameter>
<parameter id="WindowHandle">
<default_type>integer</default_type>
<description lang="en_US">The handle of the window, where the text shall be displayed.
</description>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>window</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
</parameters>
</docu>
</procedure>
<procedure name="disp_end_of_program_message">
<interface>
<ic>
<par name="WindowHandle" base_type="ctrl" dimension="0"/>
<par name="Color" base_type="ctrl" dimension="0"/>
<par name="Box" base_type="ctrl" dimension="0"/>
</ic>
</interface>
<body>
<c>* This procedure displays 'End of program' in the</c>
<c>* lower right corner of the screen.</c>
<c>* It uses the procedure disp_message.</c>
<c>* </c>
<c>* Input parameters:</c>
<c>* WindowHandle: The window, where the text shall be displayed</c>
<c>* Color: defines the text color.</c>
<c>*    If set to '' or 'auto', the currently set color is used.</c>
<c>* Box: If set to 'true', the text is displayed in a box.</c>
<c>* </c>
<c>* Convert the parameter Box to generic parameters.</c>
<l>GenParamName := []</l>
<l>GenParamValue := []</l>
<l>if (|Box| &gt; 0)</l>
<l>    if (Box[0] == 'false')</l>
<c>        * Display no box</c>
<l>        GenParamName := [GenParamName,'box']</l>
<l>        GenParamValue := [GenParamValue,'false']</l>
<l>    elseif (Box[0] != 'true')</l>
<c>        * Set a color other than the default.</c>
<l>        GenParamName := [GenParamName,'box_color']</l>
<l>        GenParamValue := [GenParamValue,Box[0]]</l>
<l>    endif</l>
<l>endif</l>
<l>if (|Box| &gt; 1)</l>
<l>    if (Box[1] == 'false')</l>
<c>        * Display no shadow.</c>
<l>        GenParamName := [GenParamName,'shadow']</l>
<l>        GenParamValue := [GenParamValue,'false']</l>
<l>    elseif (Box[1] != 'true')</l>
<c>        * Set a shadow color other than the default.</c>
<l>        GenParamName := [GenParamName,'shadow_color']</l>
<l>        GenParamValue := [GenParamValue,Box[1]]</l>
<l>    endif</l>
<l>endif</l>
<c>* </c>
<l>if (Color == '')</l>
<c>    * disp_text does not accept an empty string for Color.</c>
<l>    Color := []</l>
<l>endif</l>
<c>* </c>
<c>* Display the message.</c>
<l>EndMessage := '      End of program      '</l>
<l>disp_text (WindowHandle, EndMessage, 'window', 'bottom', 'right', Color, GenParamName, GenParamValue)</l>
<l>return ()</l>
</body>
<docu id="disp_end_of_program_message">
<abstract lang="en_US">This procedure displays 'End of program' in a given Color in the lower right corner of the screen.
If the parameter Box is set to 'true', the text is written within a white box, which is useful on irregular background.</abstract>
<alternatives>
<item>disp_continue_message</item>
<item>disp_message</item>
<item>write_string</item>
</alternatives>
<attention lang="en_US">This procedure uses the procedure disp_message.
</attention>
<chapters>
<item>Graphics</item>
<item>Text</item>
</chapters>
<chapters lang="de_DE">
<item>Graphik</item>
<item>Text</item>
</chapters>
<chapters lang="en_US">
<item>Graphics</item>
<item>Text</item>
</chapters>
<example lang="en_US">dev_open_window (0, 0, 512, 512, 'black', WindowHandle)
set_display_font (WindowHandle, 16, 'mono', 'true', 'false')
for Index := 1 to 5 by 1
    disp_message (WindowHandle, 'Step '+Index, 'window', 30*Index, -1, 'black', 'true')
    disp_continue_message (WindowHandle, 'black', 'true')
    stop ()
endfor
disp_end_of_program_message (WindowHandle, 'black', 'true')</example>
<keywords lang="en_US">
<item>display end of program message</item>
</keywords>
<library lang="de_DE">MVTec Standard Procedures</library>
<library lang="en_US">MVTec Standard Procedures</library>
<predecessor>
<item>disp_continue_message</item>
<item>disp_message</item>
<item>set_display_font</item>
<item>write_string</item>
<item>dev_display</item>
<item>disp_obj</item>
<item>disp_image</item>
</predecessor>
<see_also>
<item>disp_message</item>
<item>write_string</item>
</see_also>
<short>This procedure displays 'Press 'Run' to continue' in the lower right corner of the screen.</short>
<short lang="de_DE">This procedure displays 'End of program' in the lower right corner of the screen.</short>
<short lang="en_US">This procedure displays 'End of program' in the lower right corner of the screen.</short>
<successor>
<item>stop</item>
</successor>
<parameters>
<parameter id="Box">
<default_type>string</default_type>
<default_value>'true'</default_value>
<description lang="en_US">If set to 'true', the text is written within a white box.</description>
<multivalue>false</multivalue>
<sem_type>attribute.value</sem_type>
<type_list>
<item>string</item>
</type_list>
<value_list>
<item>'true'</item>
<item>'false'</item>
</value_list>
</parameter>
<parameter id="Color">
<default_type>string</default_type>
<default_value>'black'</default_value>
<description lang="en_US">Defines the text color. If set to '' or 'auto', the currently set color is used.
</description>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>color</sem_type>
<type_list>
<item>string</item>
</type_list>
<values>
<item>'black'</item>
<item>'blue'</item>
<item>'yellow'</item>
<item>'red'</item>
<item>'green'</item>
<item>'cyan'</item>
<item>'magenta'</item>
<item>'forest green'</item>
<item>'lime green'</item>
<item>'coral'</item>
<item>'slate blue'</item>
</values>
</parameter>
<parameter id="WindowHandle">
<default_type>integer</default_type>
<description lang="en_US">The handle of the window, where the text shall be displayed.
</description>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>window</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
</parameters>
</docu>
</procedure>
<procedure name="disp_menu_ext" access="local">
<interface>
<io>
<par name="MenuRegions" base_type="iconic" dimension="0"/>
</io>
<ic>
<par name="WindowHandleMenu" base_type="ctrl" dimension="0"/>
<par name="MenuText" base_type="ctrl" dimension="0"/>
<par name="CasesDone" base_type="ctrl" dimension="0"/>
<par name="CurrentCase" base_type="ctrl" dimension="0"/>
<par name="WindowScaling" base_type="ctrl" dimension="0"/>
</ic>
</interface>
<body>
<c>* Display the previously created menu buttons</c>
<l>count_obj (MenuRegions, NumberRegions)</l>
<l>NumberTexts := |MenuText|</l>
<l>if (NumberRegions &lt; NumberTexts)</l>
<l>    throw ('Too few regions for the given number of texts: ' + NumberRegions + ' vs. ' + NumberTexts)</l>
<l>endif</l>
<c></c>
<l>clear_window (WindowHandleMenu)</l>
<l>get_window_extents (WindowHandleMenu, Row, Column, Width1, Height1)</l>
<c></c>
<l>for i := 1 to NumberTexts by 1</l>
<l>    select_obj (MenuRegions, MenuRegion, i)</l>
<l>    Text := MenuText[i - 1]</l>
<l>    MenuButtonColor := '#9a9a9aFF'</l>
<l>    set_color (WindowHandleMenu, MenuButtonColor)</l>
<l>    dev_set_window (WindowHandleMenu)</l>
<l>    dev_set_draw ('fill')</l>
<l>    dev_set_color (MenuButtonColor)</l>
<l>    disp_region (MenuRegion, WindowHandleMenu)</l>
<l>    get_region_contour (MenuRegion, Rows, Cols)</l>
<l>    set_color (WindowHandleMenu, 'dim gray')</l>
<l>    gen_region_points (RegionBorder, Rows, Cols)</l>
<l>    disp_region (RegionBorder, WindowHandleMenu)</l>
<c>    * </c>
<l>    tuple_find (CasesDone, i - 1, Indices)</l>
<l>    Done := false</l>
<l>    if (i - 1 == CurrentCase)</l>
<l>        set_color (WindowHandleMenu, '#FBB900FF')</l>
<l>    elseif (Indices != -1 and Indices != [])</l>
<l>        set_color (WindowHandleMenu, 'yellow')</l>
<l>        Done := true</l>
<l>    else</l>
<l>        set_color (WindowHandleMenu, 'navy')</l>
<l>    endif</l>
<l>    get_string_extents (WindowHandleMenu, Text, Ascent, Descent, Width, Height)</l>
<l>    set_tposition (WindowHandleMenu, min(Rows) + 8 * WindowScaling, (max(Cols) + min(Cols)) / 2 - Width / 2)</l>
<l>    write_string (WindowHandleMenu, Text)</l>
<l>    if (Done)</l>
<l>        Row := 0.5 * (max(Rows) + min(Rows))</l>
<l>        Col := (max(Cols) + min(Cols)) / 2 + Width / 2 + 15</l>
<l>        Scale := max(Rows) - min(Rows)</l>
<l>        gen_contour_polygon_xld (Contour, Row + [-Scale * 0.2,0,-Scale * 0.35], Col + [0,Scale * 0.12,Scale * 0.24])</l>
<l>        set_line_width (WindowHandleMenu, 2)</l>
<l>        disp_obj (Contour, WindowHandleMenu)</l>
<l>    endif</l>
<l>endfor</l>
<l>return ()</l>
</body>
<docu id="disp_menu_ext">
<chapters lang="en_US">
<item>Graphics</item>
<item>Output</item>
</chapters>
<library lang="en_US">MVTec Standard Procedures</library>
<parameters>
<parameter id="CasesDone"/>
<parameter id="CurrentCase"/>
<parameter id="MenuRegions">
<sem_type>region</sem_type>
</parameter>
<parameter id="MenuText">
<default_type>string</default_type>
<sem_type>string</sem_type>
<type_list>
<item>string</item>
</type_list>
</parameter>
<parameter id="WindowHandleMenu">
<default_type>integer</default_type>
<mixed_type>false</mixed_type>
<sem_type>window</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="WindowScaling"/>
</parameters>
</docu>
</procedure>
<procedure name="disp_message">
<interface>
<ic>
<par name="WindowHandle" base_type="ctrl" dimension="0"/>
<par name="String" base_type="ctrl" dimension="0"/>
<par name="CoordSystem" base_type="ctrl" dimension="0"/>
<par name="Row" base_type="ctrl" dimension="0"/>
<par name="Column" base_type="ctrl" dimension="0"/>
<par name="Color" base_type="ctrl" dimension="0"/>
<par name="Box" base_type="ctrl" dimension="0"/>
</ic>
</interface>
<body>
<c>* This procedure displays text in a graphics window.</c>
<c>* </c>
<c>* Input parameters:</c>
<c>* WindowHandle: The WindowHandle of the graphics window, where</c>
<c>*    the message should be displayed</c>
<c>* String: A tuple of strings containing the text message to be displayed</c>
<c>* CoordSystem: If set to 'window', the text position is given</c>
<c>*    with respect to the window coordinate system.</c>
<c>*    If set to 'image', image coordinates are used.</c>
<c>*    (This may be useful in zoomed images.)</c>
<c>* Row: The row coordinate of the desired text position</c>
<c>*    A tuple of values is allowed to display text at different</c>
<c>*    positions.</c>
<c>* Column: The column coordinate of the desired text position</c>
<c>*    A tuple of values is allowed to display text at different</c>
<c>*    positions.</c>
<c>* Color: defines the color of the text as string.</c>
<c>*    If set to [], '' or 'auto' the currently set color is used.</c>
<c>*    If a tuple of strings is passed, the colors are used cyclically...</c>
<c>*    - if |Row| == |Column| == 1: for each new textline</c>
<c>*    = else for each text position.</c>
<c>* Box: If Box[0] is set to 'true', the text is written within an orange box.</c>
<c>*      If set to' false', no box is displayed.</c>
<c>*      If set to a color string (e.g. 'white', '#FF00CC', etc.),</c>
<c>*        the text is written in a box of that color.</c>
<c>*      An optional second value for Box (Box[1]) controls if a shadow is displayed:</c>
<c>*        'true' -&gt; display a shadow in a default color</c>
<c>*        'false' -&gt; display no shadow</c>
<c>*        otherwise -&gt; use given string as color string for the shadow color</c>
<c>* </c>
<c>* It is possible to display multiple text strings in a single call.</c>
<c>* In this case, some restrictions apply:</c>
<c>* - Multiple text positions can be defined by specifying a tuple</c>
<c>*   with multiple Row and/or Column coordinates, i.e.:</c>
<c>*   - |Row| == n, |Column| == n</c>
<c>*   - |Row| == n, |Column| == 1</c>
<c>*   - |Row| == 1, |Column| == n</c>
<c>* - If |Row| == |Column| == 1,</c>
<c>*   each element of String is display in a new textline.</c>
<c>* - If multiple positions or specified, the number of Strings</c>
<c>*   must match the number of positions, i.e.:</c>
<c>*   - Either |String| == n (each string is displayed at the</c>
<c>*                           corresponding position),</c>
<c>*   - or     |String| == 1 (The string is displayed n times).</c>
<c>* </c>
<c>* </c>
<c>* Convert the parameters for disp_text.</c>
<l>if (Row == [] or Column == [])</l>
<l>    return ()</l>
<l>endif</l>
<l>if (Row == -1)</l>
<l>    Row := 12</l>
<l>endif</l>
<l>if (Column == -1)</l>
<l>    Column := 12</l>
<l>endif</l>
<c>* </c>
<c>* Convert the parameter Box to generic parameters.</c>
<l>GenParamName := []</l>
<l>GenParamValue := []</l>
<l>if (|Box| &gt; 0)</l>
<l>    if (Box[0] == 'false')</l>
<c>        * Display no box</c>
<l>        GenParamName := [GenParamName,'box']</l>
<l>        GenParamValue := [GenParamValue,'false']</l>
<l>    elseif (Box[0] != 'true')</l>
<c>        * Set a color other than the default.</c>
<l>        GenParamName := [GenParamName,'box_color']</l>
<l>        GenParamValue := [GenParamValue,Box[0]]</l>
<l>    endif</l>
<l>endif</l>
<l>if (|Box| &gt; 1)</l>
<l>    if (Box[1] == 'false')</l>
<c>        * Display no shadow.</c>
<l>        GenParamName := [GenParamName,'shadow']</l>
<l>        GenParamValue := [GenParamValue,'false']</l>
<l>    elseif (Box[1] != 'true')</l>
<c>        * Set a shadow color other than the default.</c>
<l>        GenParamName := [GenParamName,'shadow_color']</l>
<l>        GenParamValue := [GenParamValue,Box[1]]</l>
<l>    endif</l>
<l>endif</l>
<c>* Restore default CoordSystem behavior.</c>
<l>if (CoordSystem != 'window')</l>
<l>    CoordSystem := 'image'</l>
<l>endif</l>
<c>* </c>
<l>if (Color == '')</l>
<c>    * disp_text does not accept an empty string for Color.</c>
<l>    Color := []</l>
<l>endif</l>
<c>* </c>
<l>disp_text (WindowHandle, String, CoordSystem, Row, Column, Color, GenParamName, GenParamValue)</l>
<l>return ()</l>
</body>
<docu id="disp_message">
<abstract lang="en_US">This procedure displays text in a graphics window WindowHandle at the position (Row,Column).

If only a single position is defined, one text line is displayed for each element of String. Also, '\n' will be interpreted as a newline character, i.e. a line break is performed.

If multiple positions are defined, only a single string or one string for each position is allowed in String. In this case, line breaks have to be forced with '\n'.

The position of the text may be specified in window coordinates (CoordSystem = 'window') or in image coordinates (CoordSystem = 'image'), which is useful when using zoomed images.

In addition to supplying (Row, Column) coordinates, it is also possible to pass predefined values to Row and Column to display the text at a fixed position in the window (only if CoordSystem = 'window').

The parameter Color also accepts tuples of values. In that case, the specified colors are used cyclically for every new text position or for every new textline if a single position is used.

Box:
If set to 'true', the text is written within an orange box.
If set to' false', no box is displayed.
If set to a color string (e.g. 'white', '#FF00CC', etc.), the text is written in a box of that color.
An optional second value for Box controls if a shadow is displayed. Possible values are 'true', 'false', or a valid color string.




</abstract>
<alternatives>
<item>disp_text</item>
<item>write_string</item>
<item>disp_continue_message</item>
</alternatives>
<chapters>
<item>Graphics</item>
<item>Text</item>
</chapters>
<chapters lang="de_DE">
<item>Graphik</item>
<item>Text</item>
</chapters>
<chapters lang="en_US">
<item>Graphics</item>
<item>Text</item>
</chapters>
<example lang="en_US">dev_open_window (0, 0, 512, 512, 'black', WindowHandle)
set_display_font (WindowHandle, 16, 'mono', 'true', 'false')
disp_message (WindowHandle, ['Hello','world!'], 'window', 12, 12, ['black','blue'], 'true')
disp_message (WindowHandle, ['Hello','world!'], 'window', 12, 120, 'white', ['blue','false'])
Angle := [0,90,180,270]
Row := 200 - sin(rad(Angle))*100
Column := 250 + cos(rad(Angle))*100
Color := ['green','red','red','red']
disp_message (WindowHandle, Angle+' deg', 'window', Row, Column, Color, 'false')
gen_cross_contour_xld (Cross, 200, 250, 200, 0)
</example>
<keywords lang="de_DE">
<item>Meldung anzeigen</item>
</keywords>
<keywords lang="en_US">
<item>display message</item>
</keywords>
<library lang="de_DE">MVTec Standard Procedures</library>
<library lang="en_US">MVTec Standard Procedures</library>
<predecessor>
<item>dev_open_window</item>
<item>set_display_font</item>
<item>dev_open_window_fit_image</item>
<item>dev_open_window_fit_size</item>
<item>dev_display</item>
<item>disp_obj</item>
<item>disp_image</item>
</predecessor>
<see_also>
<item>write_string</item>
<item>disp_continue_message</item>
</see_also>
<short>This procedure writes a text message.</short>
<short lang="de_DE">This procedure writes a text message.</short>
<short lang="en_US">This procedure writes a text message.</short>
<successor>
<item>disp_continue_message</item>
<item>dev_display</item>
<item>disp_obj</item>
</successor>
<parameters>
<parameter id="Box">
<default_type>string</default_type>
<default_value>'true'</default_value>
<description lang="en_US">If set to 'true', the text is written within an orange box.
If set to' false', no box is displayed.
If set to a color string (e.g. 'white', '#FF00CC', etc.), the text is written in a box of that color. Optionally, a second value controls the appearance of a box shadow.</description>
<multivalue>optional</multivalue>
<sem_type>attribute.value</sem_type>
<type_list>
<item>string</item>
</type_list>
<value_list>
<item>'true'</item>
<item>'false'</item>
<item>'white'</item>
<item>'red'</item>
<item>'forest green'</item>
<item>'black'</item>
<item>'blue'</item>
</value_list>
</parameter>
<parameter id="Color">
<default_type>string</default_type>
<default_value>'black'</default_value>
<description lang="en_US">Defines the color of the text as string. If set to [], or '' the currently set color is used. If a tuple of strings is passed, the colors are used cyclically for each new position or textline.</description>
<mixed_type>false</mixed_type>
<multivalue>optional</multivalue>
<sem_type>color</sem_type>
<type_list>
<item>string</item>
</type_list>
<values>
<item>''</item>
<item>'black'</item>
<item>'blue'</item>
<item>'yellow'</item>
<item>'red'</item>
<item>'green'</item>
<item>'cyan'</item>
<item>'magenta'</item>
<item>'forest green'</item>
<item>'lime green'</item>
<item>'coral'</item>
<item>'slate blue'</item>
</values>
</parameter>
<parameter id="Column">
<default_type>integer</default_type>
<default_value>12</default_value>
<description lang="en_US">The horizontal text alignment or the column coordinate of the desired text position. -1 is mapped to 12.</description>
<multivalue>optional</multivalue>
<sem_type>point.x</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
<item>string</item>
</type_list>
<values>
<item>10</item>
<item>12</item>
<item>20</item>
<item>30</item>
<item>'center'</item>
<item>'left'</item>
<item>'right'</item>
</values>
</parameter>
<parameter id="CoordSystem">
<default_type>string</default_type>
<default_value>'window'</default_value>
<description lang="en_US">If set to 'window', the text position is given with respect to the window coordinate system. If set to 'image', image coordinates are used (This may be useful in zoomed images).</description>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>attribute.value</sem_type>
<type_list>
<item>string</item>
</type_list>
<value_list>
<item>'window'</item>
<item>'image'</item>
</value_list>
</parameter>
<parameter id="Row">
<default_type>integer</default_type>
<default_value>12</default_value>
<description lang="en_US">The vertical text alignment or the row coordinate of the desired text position. -1 is mapped to 12.</description>
<multivalue>optional</multivalue>
<sem_type>point.y</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
<item>string</item>
</type_list>
<values>
<item>10</item>
<item>12</item>
<item>20</item>
<item>30</item>
<item>'bottom'</item>
<item>'center'</item>
<item>'top'</item>
</values>
</parameter>
<parameter id="String">
<default_type>string</default_type>
<description lang="en_US">A tuple of strings containing the text message to be displayed. Each value of the tuple will be displayed in a single line.
</description>
<mixed_type>optional</mixed_type>
<multivalue>optional</multivalue>
<sem_type>string</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
<item>string</item>
</type_list>
</parameter>
<parameter id="WindowHandle">
<default_type>integer</default_type>
<description lang="en_US">The window handle of the graphics window, where the message should be displayed.</description>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>window</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
</parameters>
</docu>
</procedure>
<procedure name="disp_object_model_3d_safe">
<interface>
<ic>
<par name="WindowHandle" base_type="ctrl" dimension="0"/>
<par name="ObjectModel3D" base_type="ctrl" dimension="0"/>
<par name="CamParam" base_type="ctrl" dimension="0"/>
<par name="Pose" base_type="ctrl" dimension="0"/>
<par name="GenParamName" base_type="ctrl" dimension="0"/>
<par name="GenParamValue" base_type="ctrl" dimension="0"/>
</ic>
</interface>
<body>
<l>try</l>
<l>    disp_object_model_3d (WindowHandle, ObjectModel3D, CamParam, Pose, GenParamName, GenParamValue)</l>
<l>catch (Exception)</l>
<c>    * Read and check the parameter PoseIn for each object</c>
<l>    get_object_models_center (ObjectModel3D, Center)</l>
<l>    CPLength := |CamParam|</l>
<l>    get_window_extents (WindowHandle, RowNotUsed, ColumnNotUsed, Width, Height)</l>
<l>    if (CPLength == 0)</l>
<l>        gen_cam_par_area_scan_division (0.06, 0, 8.5e-6, 8.5e-6, Width / 2, Height / 2, Width, Height, CamParam)</l>
<l>    else</l>
<l>        get_cam_par_data (CamParam, ['sx','sy','cx','cy','image_width','image_height'], CamParamValue)</l>
<l>        CamWidth := real(CamParamValue[4])</l>
<l>        CamHeight := real(CamParamValue[5])</l>
<l>        Scale := min([Width / CamWidth,Height / CamHeight])</l>
<l>        set_cam_par_data (CamParam, 'sx', CamParamValue[0] / Scale, CamParam)</l>
<l>        set_cam_par_data (CamParam, 'sy', CamParamValue[1] / Scale, CamParam)</l>
<l>        set_cam_par_data (CamParam, 'cx', CamParamValue[2] * Scale, CamParam)</l>
<l>        set_cam_par_data (CamParam, 'cy', CamParamValue[3] * Scale, CamParam)</l>
<l>        set_cam_par_data (CamParam, 'image_width', int(CamParamValue[4] * Scale), CamParam)</l>
<l>        set_cam_par_data (CamParam, 'image_height', int(CamParamValue[5] * Scale), CamParam)</l>
<l>    endif</l>
<l>    NumModels := |ObjectModel3D|</l>
<l>    if (|Pose| == 0)</l>
<c>        * If no pose was specified by the caller, automatically calculate</c>
<c>        * a pose that is appropriate for the visualization.</c>
<c>        * Set the initial model reference pose. The orientation is parallel</c>
<c>        * to the object coordinate system, the position is at the center</c>
<c>        * of gravity of all models.</c>
<l>        create_pose (-Center[0], -Center[1], -Center[2], 0, 0, 0, 'Rp+T', 'gba', 'point', Pose)</l>
<l>        determine_optimum_pose_distance (ObjectModel3D, CamParam, 0.9, Pose, PoseEstimated)</l>
<l>        Poses := []</l>
<l>        HomMat3Ds := []</l>
<l>        Sequence := [0:NumModels * 7 - 1]</l>
<l>        Poses := PoseEstimated[Sequence % 7]</l>
<l>    elseif (|Pose| == 7)</l>
<l>        Poses := []</l>
<l>        HomMat3Ds := []</l>
<l>        Sequence := [0:NumModels * 7 - 1]</l>
<l>        Poses := Pose[Sequence % 7]</l>
<l>    else</l>
<l>        if (|Pose| != |ObjectModel3D| * 7)</l>
<c>            * Error: Wrong number of values of input control parameter 'PoseIn'</c>
<l>            stop ()</l>
<l>        else</l>
<l>            Poses := Pose</l>
<l>        endif</l>
<l>    endif</l>
<l>    tuple_find (GenParamName, 'disp_background', Indices)</l>
<l>    if (Indices &gt; 0)</l>
<l>        if (GenParamValue[Indices] == 'true')</l>
<c>            * display background do not clear background</c>
<l>        else</l>
<l>            dev_set_window (WindowHandle)</l>
<l>            dev_clear_window ()</l>
<l>        endif</l>
<l>    else</l>
<c>        * No indication of  'disp_background' clear window</c>
<l>        dev_set_window (WindowHandle)</l>
<l>        dev_clear_window ()</l>
<l>    endif</l>
<l>    disp_object_model_no_opengl (ModelContours, ObjectModel3D, GenParamName, GenParamValue, WindowHandle, CamParam, Poses)</l>
<l>endtry</l>
<l>return ()</l>
</body>
<docu id="disp_object_model_3d_safe">
<abstract lang="en_US">This procedure calls disp_object_model_3d and a fallback solution if there is no OpenGL Available.

See disp_object_model_3d for documentation.</abstract>
<chapters lang="de_DE">
<item>Graphik</item>
<item>Ausgabe</item>
</chapters>
<chapters lang="en_US">
<item>Graphics</item>
<item>Output</item>
</chapters>
<library lang="en_US">MVTec Standard Procedures</library>
<short lang="en_US">This procedure calls disp_object_model_3d and a fallback solution if there is no OpenGL Available.</short>
<parameters>
<parameter id="CamParam">
<default_type>integer</default_type>
<default_value>[]</default_value>
<description lang="en_US">See disp_object_model_3d for documentation.</description>
<mixed_type>false</mixed_type>
<multivalue>optional</multivalue>
<sem_type>any</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
<parameter id="GenParamName">
<default_type>string</default_type>
<default_value>[]</default_value>
<description lang="en_US">See disp_object_model_3d for documentation.</description>
<multivalue>optional</multivalue>
<sem_type>string</sem_type>
<type_list>
<item>string</item>
</type_list>
<values>
<item>'alpha'</item>
<item>'attribute'</item>
<item>'color'</item>
<item>'colored'</item>
<item>'depth_persistence'</item>
<item>'disp_background'</item>
<item>'disp_lines'</item>
<item>'disp_pose'</item>
<item>'light_position'</item>
<item>'line_color'</item>
<item>'object_index_persistence'</item>
<item>'point_size'</item>
<item>'quality'</item>
<item>'intensity'</item>
<item>'intensity_red'</item>
<item>'intensity_green'</item>
<item>'intensity_blue'</item>
<item>'lut'</item>
</values>
</parameter>
<parameter id="GenParamValue">
<default_type>integer</default_type>
<default_value>[]</default_value>
<description lang="en_US">See disp_object_model_3d for documentation.</description>
<multivalue>optional</multivalue>
<sem_type>string</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
<item>string</item>
</type_list>
<values>
<item>'true'</item>
<item>'false'</item>
<item>'coord_x'</item>
<item>'coord_y'</item>
<item>'coord_z'</item>
<item>'normal_x'</item>
<item>'normal_y'</item>
<item>'normal_z'</item>
<item>'red'</item>
<item>'green'</item>
<item>'blue'</item>
<item>'auto'</item>
<item>'faces'</item>
<item>'primitive'</item>
<item>'points'</item>
<item>'lines'</item>
</values>
</parameter>
<parameter id="ObjectModel3D">
<default_type>integer</default_type>
<description lang="en_US">See disp_object_model_3d for documentation.</description>
<mixed_type>false</mixed_type>
<sem_type>object_model_3d</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="Pose">
<default_type>real</default_type>
<default_value>[]</default_value>
<description lang="en_US">See disp_object_model_3d for documentation.</description>
<multivalue>optional</multivalue>
<sem_type>pose</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
<parameter id="WindowHandle">
<default_type>integer</default_type>
<description lang="en_US">See disp_object_model_3d for documentation.</description>
<mixed_type>false</mixed_type>
<sem_type>window</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
</parameters>
</docu>
</procedure>
<procedure name="disp_object_model_no_opengl">
<interface>
<oo>
<par name="ModelContours" base_type="iconic" dimension="0"/>
</oo>
<ic>
<par name="ObjectModel3DID" base_type="ctrl" dimension="0"/>
<par name="GenParamName" base_type="ctrl" dimension="0"/>
<par name="GenParamValue" base_type="ctrl" dimension="0"/>
<par name="WindowHandleBuffer" base_type="ctrl" dimension="0"/>
<par name="CamParam" base_type="ctrl" dimension="0"/>
<par name="PosesOut" base_type="ctrl" dimension="0"/>
</ic>
</interface>
<body>
<c>* This procedure allows to use project_object_model_3d to simulate a disp_object_model_3d</c>
<c>* call for small objects. Large objects are sampled down to display.</c>
<l>Idx := find(GenParamName,'point_size')</l>
<l>if (|Idx| and Idx != -1)</l>
<l>    CustomParamName := 'point_size'</l>
<l>    CustomParamValue := GenParamValue[Idx]</l>
<l>    if (CustomParamValue == 1)</l>
<l>        CustomParamValue := 0</l>
<l>    endif</l>
<l>else</l>
<l>    CustomParamName := []</l>
<l>    CustomParamValue := []</l>
<l>endif</l>
<l>get_font (WindowHandleBuffer, Font)</l>
<l>tuple_find (GenParamName, 'disp_background', IndicesDispBackGround)</l>
<l>if (IndicesDispBackGround != -1)</l>
<l>    tuple_find (GenParamName[IndicesDispBackGround], 'false', Indices)</l>
<l>    if (Indices != -1)</l>
<l>        clear_window (WindowHandleBuffer)</l>
<l>    endif</l>
<l>endif</l>
<l>set_display_font (WindowHandleBuffer, 11, 'mono', 'false', 'false')</l>
<l>get_cam_par_data (CamParam, 'image_width', ImageWidth)</l>
<l>disp_message (WindowHandleBuffer, 'OpenGL missing!', 'image', 5, ImageWidth - 130, 'red', 'false')</l>
<l>set_font (WindowHandleBuffer, Font)</l>
<l>get_object_model_3d_params (ObjectModel3DID, 'has_polygons', HasPolygons)</l>
<l>get_object_model_3d_params (ObjectModel3DID, 'has_triangles', HasTri)</l>
<l>get_object_model_3d_params (ObjectModel3DID, 'has_points', HasPoints)</l>
<l>get_object_model_3d_params (ObjectModel3DID, 'has_lines', HasLines)</l>
<l>get_object_model_3d_params (ObjectModel3DID, 'num_points', NumPoints)</l>
<l>get_object_model_3d_params (ObjectModel3DID, 'has_primitive_data', IsPrimitive)</l>
<l>get_object_model_3d_params (ObjectModel3DID, 'center', Center)</l>
<l>get_object_model_3d_params (ObjectModel3DID, 'diameter', Diameter)</l>
<l>get_system ('opengl_hidden_surface_removal_enable', OpenGlHiddenSurface)</l>
<l>set_system ('opengl_hidden_surface_removal_enable', 'false')</l>
<c>* Sort the objects by inverse z</c>
<l>CenterX := Center[[0:3:|Center| - 1]]</l>
<l>CenterY := Center[[0:3:|Center| - 1] + 1]</l>
<l>CenterZ := Center[[0:3:|Center| - 1] + 2]</l>
<l>PosObjectsZ := []</l>
<l>if (|PosesOut| &gt; 7)</l>
<l>    for I := 0 to |ObjectModel3DID| - 1 by 1</l>
<l>        Pose := PosesOut[I * 7:I * 7 + 6]</l>
<l>        pose_to_hom_mat3d (Pose, HomMat3DObj)</l>
<l>        affine_trans_point_3d (HomMat3DObj, CenterX[I], CenterY[I], CenterZ[I], PosObjCenterX, PosObjCenterY, PosObjCenterZ)</l>
<l>        PosObjectsZ := [PosObjectsZ,PosObjCenterZ]</l>
<l>    endfor</l>
<l>else</l>
<l>    Pose := PosesOut[0:6]</l>
<l>    pose_to_hom_mat3d (Pose, HomMat3DObj)</l>
<l>    affine_trans_point_3d (HomMat3DObj, CenterX, CenterY, CenterZ, PosObjectsX, PosObjectsY, PosObjectsZ)</l>
<l>endif</l>
<l>Idx := inverse(sort_index(PosObjectsZ))</l>
<l>Color := 'white'</l>
<l>set_color (WindowHandleBuffer, Color)</l>
<l>if (|GenParamName| &gt; 0)</l>
<l>    tuple_find (GenParamName, 'colored', Indices1)</l>
<l>    tuple_find (GenParamName, 'color', Indices2)</l>
<l>    if (Indices1[0] != -1)</l>
<l>        if (GenParamValue[Indices1[0]] == 3)</l>
<l>            Color := ['red','green','blue']</l>
<l>        elseif (GenParamValue[Indices1[0]] == 6)</l>
<l>            Color := ['red','green','blue','cyan','magenta','yellow']</l>
<l>        elseif (GenParamValue[Indices1[0]] == 12)</l>
<l>            Color := ['red','green','blue','cyan','magenta','yellow','coral','slate blue','spring green','orange red','pink','gold']</l>
<l>        endif</l>
<l>    elseif (Indices2[0] != -1)</l>
<l>        Color := GenParamValue[Indices2[0]]</l>
<l>    endif</l>
<l>endif</l>
<l>for J := 0 to |ObjectModel3DID| - 1 by 1</l>
<l>    I := Idx[J]</l>
<l>    if (HasPolygons[I] == 'true' or HasTri[I] == 'true' or HasPoints[I] == 'true' or HasLines[I] == 'true')</l>
<l>        if (|GenParamName| &gt; 0)</l>
<l>            tuple_find (GenParamName, 'color_' + I, Indices3)</l>
<l>            if (Indices3[0] != -1)</l>
<l>                set_color (WindowHandleBuffer, GenParamValue[Indices3[0]])</l>
<l>            else</l>
<l>                set_color (WindowHandleBuffer, Color[I % |Color|])</l>
<l>            endif</l>
<l>        endif</l>
<l>        if (|PosesOut| &gt;= I * 7 + 6)</l>
<l>            Pose := PosesOut[I * 7:I * 7 + 6]</l>
<l>        else</l>
<l>            Pose := PosesOut[0:6]</l>
<l>        endif</l>
<l>        if (NumPoints[I] &lt; 10000)</l>
<l>            project_object_model_3d (ModelContours, ObjectModel3DID[I], CamParam, Pose, CustomParamName, CustomParamValue)</l>
<l>            disp_obj (ModelContours, WindowHandleBuffer)</l>
<l>        else</l>
<l>            pose_to_hom_mat3d (Pose, HomMat3D)</l>
<l>            sample_object_model_3d (ObjectModel3DID[I], 'fast', 0.01 * Diameter[I], [], [], SampledObjectModel3D)</l>
<l>            project_object_model_3d (ModelContours, SampledObjectModel3D, CamParam, Pose, 'point_size', 1)</l>
<l>            get_object_model_3d_params (SampledObjectModel3D, 'point_coord_x', X)</l>
<l>            get_object_model_3d_params (SampledObjectModel3D, 'point_coord_y', Y)</l>
<l>            get_object_model_3d_params (SampledObjectModel3D, 'point_coord_z', Z)</l>
<l>            pose_to_hom_mat3d (Pose, HomMat3D1)</l>
<l>            affine_trans_point_3d (HomMat3D1, X, Y, Z, Qx, Qy, Qz)</l>
<l>            project_3d_point (Qx, Qy, Qz, CamParam, Row, Column)</l>
<l>            disp_obj (ModelContours, WindowHandleBuffer)</l>
<l>            clear_object_model_3d (SampledObjectModel3D)</l>
<l>        endif</l>
<l>    else</l>
<l>        if (|GenParamName| &gt; 0)</l>
<l>            tuple_find (GenParamName, 'color_' + I, Indices3)</l>
<l>            if (Indices3[0] != -1)</l>
<l>                set_color (WindowHandleBuffer, GenParamValue[Indices3[0]])</l>
<l>            else</l>
<l>                set_color (WindowHandleBuffer, Color[I % |Color|])</l>
<l>            endif</l>
<l>        endif</l>
<l>        if (|PosesOut| &gt;= I * 7 + 6)</l>
<l>            Pose := PosesOut[I * 7:I * 7 + 6]</l>
<l>        else</l>
<l>            Pose := PosesOut[0:6]</l>
<l>        endif</l>
<l>        if (IsPrimitive[I] == 'true')</l>
<l>            try</l>
<l>                convex_hull_object_model_3d (ObjectModel3DID[I], ObjectModel3DConvexHull)</l>
<l>                if (NumPoints[I] &lt; 10000)</l>
<l>                    project_object_model_3d (ModelContours, ObjectModel3DConvexHull, CamParam, Pose, CustomParamName, CustomParamValue)</l>
<l>                    disp_obj (ModelContours, WindowHandleBuffer)</l>
<l>                else</l>
<l>                    pose_to_hom_mat3d (Pose, HomMat3D)</l>
<l>                    sample_object_model_3d (ObjectModel3DConvexHull, 'fast', 0.01 * Diameter[I], [], [], SampledObjectModel3D)</l>
<l>                    project_object_model_3d (ModelContours, SampledObjectModel3D, CamParam, Pose, 'point_size', 1)</l>
<l>                    disp_obj (ModelContours, WindowHandleBuffer)</l>
<l>                    clear_object_model_3d (SampledObjectModel3D)</l>
<l>                endif</l>
<l>                clear_object_model_3d (ObjectModel3DConvexHull)</l>
<l>            catch (Exception)</l>
<l>            endtry</l>
<l>        endif</l>
<l>    endif</l>
<l>endfor</l>
<l>set_system ('opengl_hidden_surface_removal_enable', OpenGlHiddenSurface)</l>
<l>return ()</l>
</body>
<docu id="disp_object_model_no_opengl">
<abstract lang="en_US">Can replace disp_object_model_3d if there is no OpenGL available.
Projects a Modelcontour and displays this instead of the OpenGL view.

If you have no correct pose or no camera parameters use the disp_object_model_3d_safe instead. For the supported generic parameters  are all which are supported by project_object_model_3d. Additionally, it supports the parameter color_i with i in [0,1,2,...].



</abstract>
<chapters lang="de_DE">
<item>Graphik</item>
<item>Ausgabe</item>
</chapters>
<chapters lang="en_US">
<item>Graphics</item>
<item>Output</item>
</chapters>
<library lang="en_US">MVTec Standard Procedures</library>
<short lang="en_US">Can replace disp_object_model_3d if there is no OpenGL available.</short>
<parameters>
<parameter id="CamParam">
<sem_type>calib_data</sem_type>
</parameter>
<parameter id="GenParamName">
<description lang="en_US">Supports similar parameters as disp_object_model_3d.</description>
<sem_type>any</sem_type>
</parameter>
<parameter id="GenParamValue">
<description lang="en_US">Supports similar parameters as disp_object_model_3d.</description>
<sem_type>any</sem_type>
</parameter>
<parameter id="ModelContours">
<description lang="en_US">Contour of the last object model,</description>
<multivalue>false</multivalue>
<sem_type>xld_cont</sem_type>
</parameter>
<parameter id="ObjectModel3DID">
<default_type>integer</default_type>
<description lang="en_US">The 3D object model to display</description>
<mixed_type>false</mixed_type>
<sem_type>object_model_3d</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="PosesOut">
<sem_type>pose</sem_type>
</parameter>
<parameter id="WindowHandleBuffer">
<default_type>integer</default_type>
<description lang="en_US">Window Handle</description>
<mixed_type>false</mixed_type>
<sem_type>window</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
</parameters>
</docu>
</procedure>
<procedure name="disp_slider" access="local">
<interface>
<ic>
<par name="WindowHandle" base_type="ctrl" dimension="0"/>
<par name="Row" base_type="ctrl" dimension="0"/>
<par name="TotalHeight" base_type="ctrl" dimension="0"/>
<par name="ColLabel" base_type="ctrl" dimension="0"/>
<par name="ColValue" base_type="ctrl" dimension="0"/>
<par name="ColSliderStart" base_type="ctrl" dimension="0"/>
<par name="ColSliderEnd" base_type="ctrl" dimension="0"/>
<par name="Label" base_type="ctrl" dimension="0"/>
<par name="ValueStart" base_type="ctrl" dimension="0"/>
<par name="ValueEnd" base_type="ctrl" dimension="0"/>
<par name="ValueCurr" base_type="ctrl" dimension="0"/>
<par name="FormatString" base_type="ctrl" dimension="0"/>
</ic>
</interface>
<body>
<l>BarHeight := 2</l>
<l>ButtonHeight := TotalHeight * 0.6</l>
<l>ButtonWidth := 3</l>
<c></c>
<l>RowMid := Row + TotalHeight / 2</l>
<l>* dev_get_window (WindowHandle)</l>
<l>* dev_clear_window ()</l>
<c></c>
<c>* The long bar of the slider</c>
<l>set_color (WindowHandle, 'light gray')</l>
<l>disp_line (WindowHandle, RowMid, ColSliderStart, RowMid, ColSliderEnd)</l>
<l>disp_line (WindowHandle, RowMid - ButtonHeight / 2, ColSliderStart, RowMid + ButtonHeight / 2, ColSliderStart)</l>
<l>disp_line (WindowHandle, RowMid - ButtonHeight / 2, ColSliderEnd, RowMid + ButtonHeight / 2, ColSliderEnd)</l>
<c></c>
<c>* The slider itself</c>
<l>SliderPosRel := (ValueCurr - ValueStart) * 1.0 / (ValueEnd - ValueStart)</l>
<l>if (SliderPosRel &lt; 0)</l>
<l>    SliderPosRel := 0</l>
<l>elseif (SliderPosRel &gt; 1)</l>
<l>    SliderPosRel := 1</l>
<l>endif</l>
<l>SliderColMid := ColSliderStart + SliderPosRel * (ColSliderEnd - ColSliderStart)</l>
<l>gen_rectangle1 (ButtonRegion, RowMid - ButtonHeight / 2, SliderColMid - ButtonWidth / 2, RowMid + ButtonHeight / 2, SliderColMid + ButtonWidth / 2)</l>
<l>set_draw (WindowHandle, 'fill')</l>
<l>set_color (WindowHandle, 'dark olive green')</l>
<l>disp_region (ButtonRegion, WindowHandle)</l>
<l>get_region_contour (ButtonRegion, Rows, Cols)</l>
<l>set_color (WindowHandle, 'dim gray')</l>
<l>gen_region_points (RegionBorder, Rows, Cols)</l>
<l>disp_region (RegionBorder, WindowHandle)</l>
<c></c>
<c>* Label</c>
<l>disp_text (WindowHandle, Label, 'window', Row, ColLabel, 'white', 'box', 'false')</l>
<c></c>
<c>* Value</c>
<l>disp_text (WindowHandle, ValueCurr$FormatString, 'window', Row, ColValue, 'white', 'box', 'false')</l>
<c></c>
<l>return ()</l>
<c></c>
</body>
<docu id="disp_slider">
<chapters lang="en_US">
<item>Graphics</item>
<item>Output</item>
</chapters>
<library lang="en_US">MVTec Standard Procedures</library>
<parameters>
<parameter id="ColLabel"/>
<parameter id="ColSliderEnd"/>
<parameter id="ColSliderStart"/>
<parameter id="ColValue"/>
<parameter id="FormatString"/>
<parameter id="Label"/>
<parameter id="Row"/>
<parameter id="TotalHeight"/>
<parameter id="ValueCurr"/>
<parameter id="ValueEnd"/>
<parameter id="ValueStart"/>
<parameter id="WindowHandle">
<default_type>integer</default_type>
<mixed_type>false</mixed_type>
<sem_type>window</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
</parameters>
</docu>
</procedure>
<procedure name="disp_text_button">
<interface>
<ic>
<par name="WindowHandle" base_type="ctrl" dimension="0"/>
<par name="String" base_type="ctrl" dimension="0"/>
<par name="CoordSystem" base_type="ctrl" dimension="0"/>
<par name="Row" base_type="ctrl" dimension="0"/>
<par name="Column" base_type="ctrl" dimension="0"/>
<par name="TextColor" base_type="ctrl" dimension="0"/>
<par name="ButtonColor" base_type="ctrl" dimension="0"/>
</ic>
</interface>
<body>
<c>* This procedure displays text in a graphics window.</c>
<c>* </c>
<c>* Input parameters:</c>
<c>* WindowHandle: The WindowHandle of the graphics window, where</c>
<c>*    the message should be displayed</c>
<c>* String: A tuple of strings containing the text message to be displayed</c>
<c>* CoordSystem: If set to 'window', the text position is given</c>
<c>*    with respect to the window coordinate system.</c>
<c>*    If set to 'image', image coordinates are used.</c>
<c>*    (This may be useful in zoomed images.)</c>
<c>* Row: The row coordinate of the desired text position</c>
<c>*    If set to -1, a default value of 12 is used.</c>
<c>* Column: The column coordinate of the desired text position</c>
<c>*    If set to -1, a default value of 12 is used.</c>
<c>* Color: defines the color of the text as string.</c>
<c>*    If set to [], '' or 'auto' the currently set color is used.</c>
<c>*    If a tuple of strings is passed, the colors are used cyclically</c>
<c>*    for each new textline.</c>
<c>* ButtonColor: Must be set to a color string (e.g. 'white', '#FF00CC', etc.).</c>
<c>*              The text is written in a box of that color.</c>
<c>* </c>
<c>* Prepare window.</c>
<l>get_rgb (WindowHandle, Red, Green, Blue)</l>
<l>get_part (WindowHandle, Row1Part, Column1Part, Row2Part, Column2Part)</l>
<l>get_window_extents (WindowHandle, RowWin, ColumnWin, WidthWin, HeightWin)</l>
<l>set_part (WindowHandle, 0, 0, HeightWin - 1, WidthWin - 1)</l>
<c>* </c>
<c>* Default settings.</c>
<l>if (Row == -1)</l>
<l>    Row := 12</l>
<l>endif</l>
<l>if (Column == -1)</l>
<l>    Column := 12</l>
<l>endif</l>
<l>if (TextColor == [])</l>
<l>    TextColor := ''</l>
<l>endif</l>
<c>* </c>
<l>try</l>
<l>    color_string_to_rgb (ButtonColor, RGB)</l>
<l>catch (Exception)</l>
<l>    Exception := 'Wrong value of control parameter ButtonColor (must be a valid color string)'</l>
<l>    throw (Exception)</l>
<l>endtry</l>
<l>Fac := 0.4</l>
<l>RGBL := RGB + int((255.0 - RGB) * Fac + 0.5)</l>
<l>RGBD := RGB - int(RGB * Fac + 0.5)</l>
<l>ButtonColorBorderL := '#' + sum('' + RGBL$'02x')</l>
<l>ButtonColorBorderD := '#' + sum('' + RGBD$'02x')</l>
<c>* </c>
<l>String := split('' + String + '','\n')</l>
<c>* </c>
<c>* Estimate extentions of text depending on font size.</c>
<l>get_font_extents (WindowHandle, MaxAscent, MaxDescent, MaxWidth, MaxHeight)</l>
<l>if (CoordSystem == 'window')</l>
<l>    R1 := Row</l>
<l>    C1 := Column</l>
<l>else</l>
<c>    * Transform image to window coordinates.</c>
<l>    FactorRow := 1. * HeightWin / (Row2Part - Row1Part + 1)</l>
<l>    FactorColumn := 1. * WidthWin / (Column2Part - Column1Part + 1)</l>
<l>    R1 := (Row - Row1Part + 0.5) * FactorRow</l>
<l>    C1 := (Column - Column1Part + 0.5) * FactorColumn</l>
<l>endif</l>
<c>* </c>
<c>* Display text box depending on text size.</c>
<c>* </c>
<c>* Calculate box extents.</c>
<l>String := ' ' + String + ' '</l>
<l>Width := []</l>
<l>for Index := 0 to |String| - 1 by 1</l>
<l>    get_string_extents (WindowHandle, String[Index], Ascent, Descent, W, H)</l>
<l>    Width := [Width,W]</l>
<l>endfor</l>
<l>FrameHeight := MaxHeight * |String|</l>
<l>FrameWidth := max([0,Width])</l>
<l>R2 := R1 + FrameHeight</l>
<l>C2 := C1 + FrameWidth</l>
<c>* Display rectangles.</c>
<l>get_system ('clip_region', ClipRegion)</l>
<l>set_system ('clip_region', 'false')</l>
<l>get_draw (WindowHandle, DrawMode)</l>
<l>set_draw (WindowHandle, 'fill')</l>
<l>BorderWidth := 2</l>
<l>gen_region_polygon_filled (UpperLeft, [R1 - BorderWidth,R1 - BorderWidth,R1,R2,R2 + BorderWidth], [C1 - BorderWidth,C2 + BorderWidth,C2,C1,C1 - BorderWidth])</l>
<l>gen_region_polygon_filled (LowerRight, [R2 + BorderWidth,R1 - BorderWidth,R1,R2,R2 + BorderWidth], [C2 + BorderWidth,C2 + BorderWidth,C2,C1,C1 - BorderWidth])</l>
<l>gen_rectangle1 (Rectangle, R1, C1, R2, C2)</l>
<l>set_color (WindowHandle, ButtonColorBorderL)</l>
<l>disp_obj (UpperLeft, WindowHandle)</l>
<l>set_color (WindowHandle, ButtonColorBorderD)</l>
<l>disp_obj (LowerRight, WindowHandle)</l>
<l>set_color (WindowHandle, ButtonColor)</l>
<l>disp_obj (Rectangle, WindowHandle)</l>
<l>set_draw (WindowHandle, DrawMode)</l>
<l>set_system ('clip_region', ClipRegion)</l>
<c>* Write text.</c>
<l>for Index := 0 to |String| - 1 by 1</l>
<l>    CurrentColor := TextColor[Index % |TextColor|]</l>
<l>    if (CurrentColor != '' and CurrentColor != 'auto')</l>
<l>        set_color (WindowHandle, CurrentColor)</l>
<l>    else</l>
<l>        set_rgb (WindowHandle, Red, Green, Blue)</l>
<l>    endif</l>
<l>    Row := R1 + MaxHeight * Index</l>
<l>    disp_text (WindowHandle, String[Index], 'window', Row, C1, CurrentColor, 'box', 'false')</l>
<l>endfor</l>
<c>* Reset changed window settings.</c>
<l>set_rgb (WindowHandle, Red, Green, Blue)</l>
<l>set_part (WindowHandle, Row1Part, Column1Part, Row2Part, Column2Part)</l>
<l>return ()</l>
</body>
<docu id="disp_text_button">
<abstract lang="en_US">This procedure displays text in a graphics window WindowHandle at the position (Row,Column).
If String is a tuple, one text line is displayed for each entry. Also, '\n' will be interpreted as a newline character, i.e. a line break is performed. Empty strings (or empty parts before or after a newline) are ignored. To write empty lines, use a whitespace character.

The position of the text may be specified in window coordinates (CoordSystem = 'window') or in image coordinates (CoordSystem = 'image'), which is useful when using zoomed images.

The parameter Color also accepts tuples of values. In that case, the specified colors are used cyclically for every new textline.

If the parameter Box is set to 'true', the text is written within a white box, which is useful on irregular background.

</abstract>
<alternatives>
<item>write_string</item>
<item>disp_continue_message</item>
</alternatives>
<chapters>
<item>Graphics</item>
<item>Text</item>
</chapters>
<chapters lang="de_DE">
<item>Graphik</item>
<item>Text</item>
</chapters>
<chapters lang="en_US">
<item>Graphics</item>
<item>Text</item>
</chapters>
<example lang="en_US">dev_open_window (0, 0, 512, 512, 'black', WindowHandle)
set_display_font (WindowHandle, 16, 'mono', 'true', 'false')
disp_message (WindowHandle, ['Hello','world!'], 'window', -1, -1, ['black','blue'], 'true')
</example>
<keywords lang="de_DE">
<item>Meldung anzeigen</item>
</keywords>
<keywords lang="en_US">
<item>display message</item>
</keywords>
<library lang="de_DE">MVTec Standard Procedures</library>
<library lang="en_US">MVTec Standard Procedures</library>
<predecessor>
<item>dev_open_window</item>
<item>set_display_font</item>
<item>dev_open_window_fit_image</item>
<item>dev_open_window_fit_size</item>
<item>dev_display</item>
<item>disp_obj</item>
<item>disp_image</item>
</predecessor>
<see_also>
<item>write_string</item>
<item>disp_continue_message</item>
</see_also>
<short>This procedure writes a text message.</short>
<short lang="de_DE">This procedure writes a text message.</short>
<short lang="en_US">This procedure writes a text message.</short>
<successor>
<item>disp_continue_message</item>
<item>dev_display</item>
<item>disp_obj</item>
</successor>
<parameters>
<parameter id="ButtonColor">
<default_type>string</default_type>
<default_value>'gray'</default_value>
<description lang="en_US">If set to 'true', the text is written within a white box.</description>
<multivalue>false</multivalue>
<sem_type>attribute.value</sem_type>
<type_list>
<item>string</item>
</type_list>
<values>
<item>'gray'</item>
<item>'blue'</item>
<item>'yellow'</item>
<item>'red'</item>
<item>'green'</item>
<item>'cyan'</item>
<item>'magenta'</item>
<item>'forest green'</item>
<item>'lime green'</item>
<item>'coral'</item>
<item>'slate blue'</item>
</values>
</parameter>
<parameter id="Column">
<default_type>integer</default_type>
<default_value>200</default_value>
<description lang="en_US">The column coordinate of the desired text position. If set to -1, a default value of 12 is used.</description>
<multivalue>false</multivalue>
<sem_type>point.x</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
<values>
<item>[10,12,20,30,40,50,60,70,80,90,100,200,300,400,500,1000]</item>
</values>
</parameter>
<parameter id="CoordSystem">
<default_type>string</default_type>
<default_value>'window'</default_value>
<description lang="en_US">If set to 'window', the text position is given with respect to the window coordinate system. If set to 'image', image coordinates are used (This may be useful in zoomed images).</description>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>attribute.value</sem_type>
<type_list>
<item>string</item>
</type_list>
<value_list>
<item>'window'</item>
<item>'image'</item>
</value_list>
</parameter>
<parameter id="Row">
<default_type>integer</default_type>
<default_value>200</default_value>
<description lang="en_US">The row coordinate of the desired text position. If set to -1, a default value of 12 is used.</description>
<multivalue>false</multivalue>
<sem_type>point.y</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
<values>
<item>[10,12,20,30,40,50,60,70,80,90,100,200,300,400,500,1000]</item>
</values>
</parameter>
<parameter id="String">
<default_type>string</default_type>
<default_value>'Text'</default_value>
<description lang="en_US">A tuple of strings containing the text message to be displayed. Each value of the tuple will be displayed in a single line.
</description>
<mixed_type>optional</mixed_type>
<multivalue>optional</multivalue>
<sem_type>string</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
<item>string</item>
</type_list>
</parameter>
<parameter id="TextColor">
<default_type>string</default_type>
<default_value>'black'</default_value>
<description lang="en_US">Defines the color of the text as string. If set to [], or '' the currently set color is used. If a tuple of strings is passed, the colors are used cyclically for each new textline.</description>
<mixed_type>false</mixed_type>
<multivalue>optional</multivalue>
<sem_type>color</sem_type>
<type_list>
<item>string</item>
</type_list>
<values>
<item>'white'</item>
<item>'black'</item>
<item>'blue'</item>
<item>'yellow'</item>
<item>'red'</item>
<item>'green'</item>
<item>'cyan'</item>
<item>'magenta'</item>
<item>'forest green'</item>
<item>'lime green'</item>
<item>'coral'</item>
<item>'slate blue'</item>
</values>
</parameter>
<parameter id="WindowHandle">
<default_type>integer</default_type>
<description lang="en_US">The window handle of the graphics window, where the message should be displayed.</description>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>window</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
</parameters>
</docu>
</procedure>
<procedure name="disp_title_and_information" access="local">
<interface>
<ic>
<par name="Parameters" base_type="ctrl" dimension="0"/>
<par name="WindowHandle" base_type="ctrl" dimension="0"/>
<par name="Title" base_type="ctrl" dimension="0"/>
<par name="Information" base_type="ctrl" dimension="0"/>
</ic>
</interface>
<body>
<c>* </c>
<l>get_message_tuple (Parameters, 'gInfoDecor', gInfoDecor)</l>
<l>get_message_tuple (Parameters, 'gInfoPos', gInfoPos)</l>
<l>get_message_tuple (Parameters, 'gTitlePos', gTitlePos)</l>
<l>get_message_tuple (Parameters, 'gTitleDecor', gTitleDecor)</l>
<c>* </c>
<l>get_window_extents (WindowHandle, WinRow, WinColumn, WinWidth, WinHeight)</l>
<l>Title := split('' + Title + '','\n')</l>
<l>NumTitleLines := |Title|</l>
<l>if (NumTitleLines &gt; 0)</l>
<l>    Row := 12</l>
<l>    if (gTitlePos == 'UpperLeft')</l>
<l>        Column := 12</l>
<l>    elseif (gTitlePos == 'UpperCenter')</l>
<l>        max_line_width (WindowHandle, Title, TextWidth)</l>
<l>        Column := WinWidth / 2 - TextWidth / 2</l>
<l>    elseif (gTitlePos == 'UpperRight')</l>
<l>        if (gTitleDecor[1] == 'true')</l>
<l>            max_line_width (WindowHandle, Title + '  ', TextWidth)</l>
<l>        else</l>
<l>            max_line_width (WindowHandle, Title, TextWidth)</l>
<l>        endif</l>
<l>        Column := WinWidth - TextWidth - 10</l>
<l>    else</l>
<c>        * Unknown position!</c>
<l>        stop ()</l>
<l>    endif</l>
<l>    disp_message (WindowHandle, Title, 'window', Row, Column, gTitleDecor[0], gTitleDecor[1])</l>
<l>endif</l>
<l>Information := split('' + Information + '','\n')</l>
<l>NumInfoLines := |Information|</l>
<l>if (NumInfoLines &gt; 0)</l>
<l>    if (gInfoPos == 'UpperLeft')</l>
<l>        Row := 12</l>
<l>        Column := 12</l>
<l>    elseif (gInfoPos == 'UpperRight')</l>
<l>        if (gInfoDecor[1] == 'true')</l>
<l>            max_line_width (WindowHandle, Information + '  ', TextWidth)</l>
<l>        else</l>
<l>            max_line_width (WindowHandle, Information, TextWidth)</l>
<l>        endif</l>
<l>        Row := 12</l>
<l>        Column := WinWidth - TextWidth - 12</l>
<l>    elseif (gInfoPos == 'LowerLeft')</l>
<l>        get_string_extents (WindowHandle, Information, Ascent, Descent, Width, Height)</l>
<l>        Row := WinHeight - (max2(0,NumInfoLines - 1) * (Ascent + Descent) + Height) - 70</l>
<l>        Column := 12</l>
<l>    else</l>
<c>        * Unknown position!</c>
<l>        stop ()</l>
<l>    endif</l>
<l>    disp_message (WindowHandle, Information, 'window', Row, Column, gInfoDecor[0], gInfoDecor[1])</l>
<l>endif</l>
<c>* </c>
<l>return ()</l>
</body>
<docu id="disp_title_and_information">
<chapters lang="de_DE">
<item>Graphik</item>
<item>Ausgabe</item>
</chapters>
<chapters lang="en_US">
<item>Graphics</item>
<item>Output</item>
</chapters>
<library lang="en_US">MVTec Standard Procedures</library>
<parameters>
<parameter id="Information"/>
<parameter id="Parameters">
<default_type>integer</default_type>
<mixed_type>false</mixed_type>
<sem_type>message</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="Title"/>
<parameter id="WindowHandle">
<default_type>integer</default_type>
<mixed_type>false</mixed_type>
<sem_type>window</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
</parameters>
</docu>
</procedure>
<procedure name="dump_image_output" access="local">
<interface>
<io>
<par name="BackgroundImage" base_type="iconic" dimension="0"/>
</io>
<ic>
<par name="Parameters" base_type="ctrl" dimension="0"/>
<par name="WindowHandleBuffer" base_type="ctrl" dimension="0"/>
<par name="Scene3D" base_type="ctrl" dimension="0"/>
<par name="AlphaOrig" base_type="ctrl" dimension="0"/>
<par name="ObjectModel3DID" base_type="ctrl" dimension="0"/>
<par name="GenParamName" base_type="ctrl" dimension="0"/>
<par name="GenParamValue" base_type="ctrl" dimension="0"/>
<par name="CamParam" base_type="ctrl" dimension="0"/>
<par name="Poses" base_type="ctrl" dimension="0"/>
<par name="ColorImage" base_type="ctrl" dimension="0"/>
<par name="Title" base_type="ctrl" dimension="0"/>
<par name="Information" base_type="ctrl" dimension="0"/>
<par name="Labels" base_type="ctrl" dimension="0"/>
<par name="VisualizeTrackball" base_type="ctrl" dimension="0"/>
<par name="DisplayButtons" base_type="ctrl" dimension="0"/>
<par name="TrackballCenterRow" base_type="ctrl" dimension="0"/>
<par name="TrackballCenterCol" base_type="ctrl" dimension="0"/>
<par name="TrackballRadiusPixel" base_type="ctrl" dimension="0"/>
<par name="SelectedObject" base_type="ctrl" dimension="0"/>
<par name="VisualizeRotationCenter" base_type="ctrl" dimension="0"/>
<par name="RotationCenter" base_type="ctrl" dimension="0"/>
<par name="Type" base_type="ctrl" dimension="0"/>
<par name="Message" base_type="ctrl" dimension="0"/>
<par name="DispViewPoint" base_type="ctrl" dimension="0"/>
<par name="ViewPoint" base_type="ctrl" dimension="0"/>
</ic>
</interface>
<body>
<l>get_message_tuple (Parameters, 'gUsesOpenGL', gUsesOpenGL)</l>
<l>get_message_tuple (Parameters, 'gAlphaDeselected', gAlphaDeselected)</l>
<l>get_message_tuple (Parameters, 'gButtons', gButtons)</l>
<c></c>
<c>* </c>
<c>* Display background image</c>
<l>clear_window (WindowHandleBuffer)</l>
<l>if (ColorImage)</l>
<l>    disp_color (BackgroundImage, WindowHandleBuffer)</l>
<l>else</l>
<l>    disp_image (BackgroundImage, WindowHandleBuffer)</l>
<l>endif</l>
<c>* </c>
<c>* Display objects</c>
<l>if (sum(SelectedObject) == |SelectedObject|)</l>
<l>    if (gUsesOpenGL == 'true')</l>
<l>        try</l>
<l>            display_scene_3d (WindowHandleBuffer, Scene3D, 0)</l>
<l>        catch (Exception)</l>
<l>            if (Exception[0] == 5185 or Exception[0] == 5188 or Exception[0] == 5187)</l>
<l>                gUsesOpenGL := 'false'</l>
<l>                set_message_tuple (Parameters, 'gUsesOpenGL', gUsesOpenGL)</l>
<l>            else</l>
<l>                throw (Exception)</l>
<l>            endif</l>
<l>        endtry</l>
<l>    endif</l>
<l>    if (gUsesOpenGL == 'false')</l>
<c>        * * NO OpenGL, use fallback</c>
<l>        disp_object_model_no_opengl (ModelContours, ObjectModel3DID, GenParamName, GenParamValue, WindowHandleBuffer, CamParam, Poses)</l>
<l>    endif</l>
<l>else</l>
<l>    for Index := 0 to |AlphaOrig| - 1 by 1</l>
<l>        if (SelectedObject[Index] == 1)</l>
<l>            set_scene_3d_instance_param (Scene3D, Index, 'alpha', AlphaOrig[Index])</l>
<l>        else</l>
<l>            set_scene_3d_instance_param (Scene3D, Index, 'alpha', gAlphaDeselected)</l>
<l>        endif</l>
<l>    endfor</l>
<l>    try</l>
<l>        if (gUsesOpenGL == 'false')</l>
<l>            throw ([])</l>
<l>        endif</l>
<l>        display_scene_3d (WindowHandleBuffer, Scene3D, 0)</l>
<l>    catch (Exception1)</l>
<c>        * * NO OpenGL, use fallback</c>
<l>        DeselectedIdx := find(SelectedObject,0)</l>
<l>        if (DeselectedIdx != -1)</l>
<l>            DeselectedName := 'color_' + DeselectedIdx</l>
<l>            DeselectedValue := gen_tuple_const(|DeselectedName|,'gray')</l>
<l>        endif</l>
<l>        disp_object_model_no_opengl (ModelContours, ObjectModel3DID, [GenParamName,DeselectedName], [GenParamValue,DeselectedValue], WindowHandleBuffer, CamParam, Poses)</l>
<l>    endtry</l>
<l>    for Index := 0 to |AlphaOrig| - 1 by 1</l>
<l>        set_scene_3d_instance_param (Scene3D, Index, 'alpha', AlphaOrig[Index])</l>
<l>    endfor</l>
<l>endif</l>
<c>* </c>
<c>* Display labels</c>
<l>if (Labels != 0)</l>
<l>    get_message_tuple (Parameters, 'gLabelsDecor', gLabelsDecor)</l>
<l>    set_color (WindowHandleBuffer, gLabelsDecor[0])</l>
<l>    for Index := 0 to |ObjectModel3DID| - 1 by 1</l>
<c>        * Project the center point of the current model</c>
<l>        Pose := Poses[Index * 7:Index * 7 + 6]</l>
<l>        pose_to_hom_mat3d (Pose, HomMat3D)</l>
<l>        try</l>
<l>            get_object_model_3d_params (ObjectModel3DID[Index], 'center', Center)</l>
<l>            affine_trans_point_3d (HomMat3D, Center[0], Center[1], Center[2], CenterCamX, CenterCamY, CenterCamZ)</l>
<l>            project_3d_point (CenterCamX, CenterCamY, CenterCamZ, CamParam, CenterRow, CenterCol)</l>
<l>            Label := Labels[Index]</l>
<l>            if (Label != '')</l>
<l>                get_string_extents (WindowHandleBuffer, Label, Ascent, Descent, TextWidth, TextHeight)</l>
<l>                get_message_tuple (Parameters, 'gDispObjOffset', gDispObjOffset)</l>
<l>                disp_message (WindowHandleBuffer, Label, 'window', CenterRow - TextHeight / 2 + gDispObjOffset[0], CenterCol - TextWidth / 2 + gDispObjOffset[1], [], gLabelsDecor[1])</l>
<l>            endif</l>
<l>        catch (Exception)</l>
<c>            * Unable to get the center of the 3D object model. It is probably empty -&gt; do not display any label</c>
<l>        endtry</l>
<l>    endfor</l>
<l>endif</l>
<c>* </c>
<c>* Visualize the trackball if desired</c>
<l>if (VisualizeTrackball)</l>
<l>    set_line_width (WindowHandleBuffer, 1)</l>
<l>    gen_ellipse_contour_xld (TrackballContour, TrackballCenterRow, TrackballCenterCol, 0, TrackballRadiusPixel, TrackballRadiusPixel, 0, 6.28318, 'positive', 1.5)</l>
<l>    set_color (WindowHandleBuffer, 'dim gray')</l>
<l>    disp_xld (TrackballContour, WindowHandleBuffer)</l>
<l>endif</l>
<c>* </c>
<c>* Visualize the rotation center if desired</c>
<l>if (VisualizeRotationCenter != 0 and |RotationCenter| == 3)</l>
<l>    if (RotationCenter[2] &lt; 1e-10)</l>
<l>        RotationCenter[2] := 1e-10</l>
<l>    endif</l>
<l>    project_3d_point (RotationCenter[0], RotationCenter[1], RotationCenter[2], CamParam, RotCenterRow, RotCenterCol)</l>
<l>    Orientation := rad(90)</l>
<l>    if (VisualizeRotationCenter == 1)</l>
<l>        Orientation := rad(45)</l>
<l>    endif</l>
<l>    gen_cross_contour_xld (CrossRotCenter, RotCenterRow, RotCenterCol, TrackballRadiusPixel / 25.0, Orientation)</l>
<l>    set_line_width (WindowHandleBuffer, 3)</l>
<l>    query_color (WindowHandleBuffer, Colors)</l>
<l>    set_color (WindowHandleBuffer, 'light gray')</l>
<l>    disp_xld (CrossRotCenter, WindowHandleBuffer)</l>
<l>    set_line_width (WindowHandleBuffer, 1)</l>
<l>    set_color (WindowHandleBuffer, 'dim gray')</l>
<l>    disp_xld (CrossRotCenter, WindowHandleBuffer)</l>
<l>endif</l>
<c>* </c>
<c>* Display title</c>
<l>if (|Type| == 1)</l>
<l>    Type1 := Type</l>
<l>    Message1 := Message</l>
<l>    write_note (WindowHandleBuffer, Type1, Message1)</l>
<l>elseif (|Type| == 2)</l>
<l>    Type1 := Type[0]</l>
<l>    Type2 := Type[1]</l>
<l>    Message1 := Message[0]</l>
<l>    Message2 := Message[1:|Message| - 1]</l>
<l>    write_note (WindowHandleBuffer, Type1, Message1)</l>
<l>    set_tposition (WindowHandleBuffer, 1, 12)</l>
<l>    write_note (WindowHandleBuffer, Type2, Message2)</l>
<l>endif</l>
<l>if (DispViewPoint == 'true')</l>
<l>    disp_message (WindowHandleBuffer, 'ViewPoint [m]\n   X :' + ViewPoint[0]$'.2f' + '\n   Y: ' + ViewPoint[1]$'.2f' + '\n   Z: ' + ViewPoint[2]$'.2f', 'window', 300, 12, '#FFA500', 'false')</l>
<l>endif</l>
<c></c>
<l>disp_title_and_information (Parameters, WindowHandleBuffer, Title, Information)</l>
<c>* </c>
<c>* Display the 'Exit' button</c>
<l>if (DisplayButtons == 'true')</l>
<l>    disp_buttons (Parameters, WindowHandleBuffer)</l>
<l>endif</l>
<c>* </c>
<l>return ()</l>
</body>
<docu id="dump_image_output">
<chapters lang="de_DE">
<item>Graphik</item>
<item>Ausgabe</item>
</chapters>
<chapters lang="en_US">
<item>Graphics</item>
<item>Output</item>
</chapters>
<library lang="en_US">MVTec Standard Procedures</library>
<short lang="en_US">Renders 3D object models in a buffer window.</short>
<parameters>
<parameter id="AlphaOrig"/>
<parameter id="BackgroundImage">
<multichannel>optional</multichannel>
<multivalue>false</multivalue>
<sem_type>image</sem_type>
</parameter>
<parameter id="CamParam"/>
<parameter id="ColorImage">
<sem_type>string</sem_type>
</parameter>
<parameter id="DispViewPoint"/>
<parameter id="DisplayButtons"/>
<parameter id="GenParamName">
<sem_type>string</sem_type>
</parameter>
<parameter id="GenParamValue">
<default_type>integer</default_type>
<sem_type>string</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
<parameter id="Information">
<sem_type>string</sem_type>
</parameter>
<parameter id="Labels">
<multivalue>optional</multivalue>
<sem_type>string</sem_type>
</parameter>
<parameter id="Message"/>
<parameter id="ObjectModel3DID">
<default_type>integer</default_type>
<mixed_type>false</mixed_type>
<sem_type>object_model_3d</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="Parameters">
<default_type>integer</default_type>
<mixed_type>false</mixed_type>
<sem_type>message</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="Poses">
<sem_type>pose</sem_type>
</parameter>
<parameter id="RotationCenter"/>
<parameter id="Scene3D"/>
<parameter id="SelectedObject">
<multivalue>optional</multivalue>
<sem_type>integer</sem_type>
</parameter>
<parameter id="Title">
<sem_type>string</sem_type>
</parameter>
<parameter id="TrackballCenterCol">
<sem_type>real</sem_type>
</parameter>
<parameter id="TrackballCenterRow">
<sem_type>real</sem_type>
</parameter>
<parameter id="TrackballRadiusPixel">
<sem_type>real</sem_type>
</parameter>
<parameter id="Type"/>
<parameter id="ViewPoint"/>
<parameter id="VisualizeRotationCenter"/>
<parameter id="VisualizeTrackball">
<sem_type>real</sem_type>
</parameter>
<parameter id="WindowHandleBuffer">
<default_type>integer</default_type>
<mixed_type>false</mixed_type>
<sem_type>window</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
</parameters>
</docu>
</procedure>
<procedure name="estimate_bounding_box_3d_reconstruction">
<interface>
<ic>
<par name="StereoModelID" base_type="ctrl" dimension="0"/>
<par name="ObjectHeight" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="BoundingBox" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c>* The goal of this procedure is to estimate bounding box parameters</c>
<c>* for 3D reconstruction. This is done by intersecting the</c>
<c>* cones of sight of the cameras with a plane defined by the pose</c>
<c>* of the reference calibration plate.</c>
<c>* </c>
<l>if (ObjectHeight == 0)</l>
<l>    throw ('Object height must not be zero.')</l>
<l>endif</l>
<c>* Check whether the coordinate system has been moved by setting a pose</c>
<c>* with the parameter 'coord_transf_pose' in set_camera_setup_param.</c>
<c>* If this is not the case, the origin is still in one of the cameras.</c>
<c>* However, this procedures needs the origin to be in a calibration plate.</c>
<l>get_stereo_model_param (StereoModelID, 'camera_setup_model', CameraSetupModelID)</l>
<l>get_camera_setup_param (CameraSetupModelID, 'general', 'reference_camera', ReferenceCamera)</l>
<l>if (ReferenceCamera != -1)</l>
<l>    throw ('Please set the \'coord_transf_pose\' to the pose of an calibration plate that lies horizontally in the image using the get_calib_data and set_camera_setup_param.')</l>
<l>endif</l>
<c>* Check whether the image pairs have been set.</c>
<l>get_stereo_model_image_pairs (StereoModelID, From, To)</l>
<l>if (|From| == 0 or |To| == 0)</l>
<l>    throw ('Please define the image pairs first with \'get_stereo_model_image_pairs.\'')</l>
<l>endif</l>
<c>* </c>
<c>* First, we generate 3D object models that represent the cones of sight of the cameras,</c>
<c>* like in the procedure gen_camera_setup_object_model_3d.</c>
<l>get_camera_setup_param (CameraSetupModelID, 'general', 'num_cameras', NumCameras)</l>
<l>ObjectModel3DCone := []</l>
<l>DistanceCameras := []</l>
<l>for CameraIndex := 0 to NumCameras - 1 by 1</l>
<l>    get_camera_setup_param (CameraSetupModelID, CameraIndex, 'pose', CamPose)</l>
<l>    DistanceCamera := sqrt((CamPose[0] * CamPose[0]) + (CamPose[1] * CamPose[1]) + (CamPose[2] * CamPose[2]))</l>
<l>    DistanceCameras := [DistanceCameras,DistanceCamera]</l>
<l>    ConeLength := DistanceCamera * 2.0</l>
<c>    * Distinguish cases with/without projection center.</c>
<l>    get_camera_setup_param (CameraSetupModelID, CameraIndex, 'type', Type)</l>
<l>    if (Type =~ 'telecentric')</l>
<l>        gen_cone_telecentric_object_model_3d (CameraSetupModelID, CameraIndex, ConeLength, ObjectModel3D)</l>
<l>    else</l>
<l>        gen_cone_perspective_object_model_3d (CameraSetupModelID, CameraIndex, ConeLength, ObjectModel3D)</l>
<l>    endif</l>
<l>    ObjectModel3DCone := [ObjectModel3DCone,ObjectModel3D]</l>
<l>endfor</l>
<c>* </c>
<c>* Then, we intersect these cones of sight with a plane that lies horizontally</c>
<c>* in the origin of the stereo setup. We do this simultaneously for the</c>
<c>* previously defined image pairs.</c>
<l>gen_empty_obj (PlaneConeIntersections)</l>
<l>for Index1 := 0 to |From| - 1 by 1</l>
<l>    intersect_plane_object_model_3d (ObjectModel3DCone[From[Index1]], [0,0,0,0,0,0,0], ObjectModel3DIntersectionFrom)</l>
<l>    intersect_plane_object_model_3d (ObjectModel3DCone[To[Index1]], [0,0,0,0,0,0,0], ObjectModel3DIntersectionTo)</l>
<c>    * </c>
<c>    * Get the coordinates of the 3D object models that represent the intersection.</c>
<l>    get_object_model_3d_params (ObjectModel3DIntersectionFrom, 'point_coord_x', XFrom)</l>
<l>    get_object_model_3d_params (ObjectModel3DIntersectionFrom, 'point_coord_y', YFrom)</l>
<l>    get_object_model_3d_params (ObjectModel3DIntersectionTo, 'point_coord_x', XTo)</l>
<l>    get_object_model_3d_params (ObjectModel3DIntersectionTo, 'point_coord_y', YTo)</l>
<c>    * </c>
<c>    * The, we want to intersect the intersections of the image pair. We do this in 2D using XLDs.</c>
<c>    * Generate the XLD of the 'From' intersection.</c>
<l>    gen_contour_polygon_xld (ContourFrom, XFrom, YFrom)</l>
<c>    * Generate the XLD of the 'To' intersection.</c>
<l>    gen_contour_polygon_xld (ContourTo, XTo, YTo)</l>
<c>    * </c>
<c>    * The order of the coordinates from get_object_model_3d_params might not be ideal.</c>
<c>    * Thus, we compute the smallest rectangle around the created XLD.</c>
<l>    smallest_rectangle2_xld (ContourFrom, Row, Column, Phi, Length1, Length2)</l>
<l>    gen_rectangle2_contour_xld (RectangleFrom, Row, Column, Phi, Length1, Length2)</l>
<l>    smallest_rectangle2_xld (ContourTo, Row, Column, Phi, Length1, Length2)</l>
<l>    gen_rectangle2_contour_xld (RectangleTo, Row, Column, Phi, Length1, Length2)</l>
<c>    * </c>
<c>    * Intersect and concatenate the intersections</c>
<l>    intersection_closed_contours_xld (RectangleFrom, RectangleTo, ContoursIntersection)</l>
<l>    concat_obj (PlaneConeIntersections, ContoursIntersection, PlaneConeIntersections)</l>
<l>    clear_object_model_3d (ObjectModel3DIntersectionFrom)</l>
<l>    clear_object_model_3d (ObjectModel3DIntersectionTo)</l>
<l>endfor</l>
<c>* </c>
<c>* Union all intersections of all image pairs.</c>
<l>gen_empty_obj (PlaneConeIntersectionUnion)</l>
<l>count_obj (PlaneConeIntersections, Number)</l>
<l>for Index2 := 1 to Number by 1</l>
<l>    select_obj (PlaneConeIntersections, ObjectSelected, Index2)</l>
<l>    union2_closed_contours_xld (ObjectSelected, PlaneConeIntersectionUnion, PlaneConeIntersectionUnion)</l>
<l>endfor</l>
<c>* </c>
<c>* Get the coordinates of the resulting XLD, which represents the area</c>
<c>* in 2D where the reconstruction is possible.</c>
<l>get_contour_xld (PlaneConeIntersectionUnion, RowContour, ColumnContour)</l>
<c>* </c>
<c>* Based on this contour, we can easily access the parameters of the bounding box.</c>
<l>if (ObjectHeight &gt; 0)</l>
<l>    BoundingBox := [min(RowContour),min(ColumnContour),-ObjectHeight,max(RowContour),max(ColumnContour),0]</l>
<l>else</l>
<l>    BoundingBox := [min(RowContour),min(ColumnContour),0,max(RowContour),max(ColumnContour),-ObjectHeight]</l>
<l>endif</l>
<c>* </c>
<c>* Clean up.</c>
<l>clear_camera_setup_model (CameraSetupModelID)</l>
<l>clear_object_model_3d (ObjectModel3DCone)</l>
<l>return ()</l>
</body>
<docu id="estimate_bounding_box_3d_reconstruction">
<abstract lang="en_US">estimate_bounding_box_3d_reconstruction estimates a suitable bounding box for the stereo setup given in StereoModelID. The height of the bounding box is specified in ObjectHeight. 
The bounding box is returned as a tuple in the form [X1, Y1, Z1, X2, Y2, Z2], where [X1,Y1,Z1] and [X2,Y2,Z2] are the coordinates of the upper left and lower right corner.

The parameters of the bounding box are calculated based on the intersection of the cones of sight of the cameras with the world plane.The world plane should be the plane where the recontructed objects are placed. Typically, it is defined by the pose of a calibration plate. For this procedure to work, it is necessary to set a suitable plane as reference coordinate system within the camera setup model with the parameter 'coord_transf_pose' of set_camera_setup_param.
For example, if you want to use the image of the first calibration plate for the reference coordinate system, use 

ReferencePoseIndex := 1
get_calib_data (CalibDataID, 'calib_obj_pose', [0,ReferencePoseIndex], 'pose', ReferencePose)
set_camera_setup_param (CameraSetupModelID, 'general', 'coord_transf_pose', ReferencePose)

Additionally, before calling this procedure, you need the set the image pairs of the stereo reconstruction using get_stereo_model_image_pairs.</abstract>
<chapters lang="de_DE">
<item>3D-Rekonstruktion</item>
<item>Mehrbild-Stereo</item>
</chapters>
<chapters lang="en_US">
<item>3D Reconstruction</item>
<item>Multi-View Stereo</item>
</chapters>
<example lang="en_US">dev_open_window (0, 0, 512, 512, 'black', WindowHandle)
* Prepare camera setup and stereo model.
read_camera_setup_model ('cam_setup_model.csm', CameraSetupModelID)
create_stereo_model (CameraSetupModelID, 'surface_fusion', [], [], StereoModelID)
set_stereo_model_image_pairs (StereoModelID, [1, 2], [0, 0])
* Estimate and set bounding box automatically.
estimate_bounding_box_3d_reconstruction (StereoModelID, 0.06, BoundingBox)
set_stereo_model_param (StereoModelID, 'bounding_box', BoundingBox)
* Create and visualize object models that represent the setup.
gen_camera_setup_object_model_3d (CameraSetupModelID, 'auto', 'auto', ObjectModel3DCamera, ObjectModel3DCone)
gen_bounding_box_object_model_3d (StereoModelID, ObjectModel3DBoundingBox)
visualize_object_model_3d (WindowHandle, [ObjectModel3DBoundingBox, ObjectModel3DCamera, ObjectModel3DCone], [], [], ['color_0', 'alpha'], ['red', 0.5], [], [],[] , Pose)</example>
<library lang="en_US">MVTec Standard Procedures</library>
<predecessor>
<item>calibrate_cameras</item>
<item>get_calib_data</item>
<item>set_camera_setup_param</item>
<item>set_stereo_model_image_pairs</item>
<item>create_stereo_model</item>
<item>read_object_model_3d</item>
<item>gen_object_model_3d_from_points</item>
</predecessor>
<short lang="en_US">Estimate a bounding box for 3D reconstruction based on a stereo setup.</short>
<successor>
<item>set_stereo_model_param</item>
<item>reconstruct_surface_stereo</item>
<item>clear_object_model_3d</item>
<item>disp_object_model_3d</item>
</successor>
<parameters>
<parameter id="BoundingBox">
<default_type>real</default_type>
<description lang="en_US">The bounding box parameters.</description>
<multivalue>true</multivalue>
<sem_type>real</sem_type>
<type_list>
<item>real</item>
</type_list>
</parameter>
<parameter id="ObjectHeight">
<default_type>real</default_type>
<default_value>0.05</default_value>
<description lang="en_US">Height of the object that will be reconstructed, in meters.</description>
<multivalue>false</multivalue>
<sem_type>real</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
<values>
<item>0.01</item>
<item>0.02</item>
<item>0.05</item>
<item>0.1</item>
</values>
</parameter>
<parameter id="StereoModelID">
<default_type>integer</default_type>
<description lang="en_US">Handle to the stereo model.</description>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>stereo_model</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
</parameters>
</docu>
</procedure>
<procedure name="estimate_noise_real" access="local">
<interface>
<io>
<par name="Image" base_type="iconic" dimension="0"/>
</io>
<ic>
<par name="OutlierRemovalAmount" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="Sigma" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c>* See documentation of estimate_noise for more information</c>
<c>* about the used immerkaer noise estimation method.</c>
<c></c>
<l>convol_image (Image, ImageFiltered, [3,3,1,1,-2,1,-2,4,-2,1,-2,1], 'mirrored')</l>
<c></c>
<c>* convol_image will use parts of the background, which might have undefined pixels</c>
<c>* Remove those parts</c>
<l>erosion_rectangle1 (Image, RegionErosion, 3, 3)</l>
<c></c>
<l>get_region_points (RegionErosion, Rows, Columns)</l>
<l>if (|Rows| &lt; 30)</l>
<c>    * Too few points for a robust noise estimation</c>
<c>    * This can happen, for example, if the points are very sparse in the XYZ images</c>
<l>    Sigma := -1</l>
<l>else</l>
<l>    get_grayval (ImageFiltered, Rows, Columns, Grayval)</l>
<l>    Grayval := abs(Grayval)</l>
<c>    * Instead of the original formula, we use the more robust median</c>
<c>    * to avoid false negatives</c>
<l>    if (OutlierRemovalAmount &gt; 0)</l>
<l>        tuple_sort (Grayval, Grayval)</l>
<l>        NumToRemove := int(|Grayval| * OutlierRemovalAmount * 0.5)</l>
<c>        * Catch some special cases</c>
<l>        try</l>
<l>            Grayval := Grayval[NumToRemove:|Grayval| - NumToRemove - 1]</l>
<l>        catch (Exception)</l>
<c>            * Catch the special case when we'd remove all values</c>
<l>            Grayval := median(Grayval)</l>
<l>        endtry</l>
<l>    endif</l>
<l>    Sigma := sqrt(rad(180) / 2.0) * (1.0 / 6.0) * mean(abs(Grayval))</l>
<l>endif</l>
<c></c>
<l>return ()</l>
<c></c>
</body>
<docu id="estimate_noise_real">
<chapters lang="en_US">
<item>Image</item>
<item>Features</item>
</chapters>
<library lang="en_US">MVTec Standard Procedures</library>
<parameters>
<parameter id="Image">
<sem_type>image</sem_type>
</parameter>
<parameter id="OutlierRemovalAmount">
<default_type>integer</default_type>
<description lang="en_US">Amount of outlier removal. Set to 0 to not remove any outliers, and to 0.5 to use the median.</description>
<multivalue>false</multivalue>
<sem_type>number</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
<value_max>0.500000000000</value_max>
<value_min>0.000000000000</value_min>
</parameter>
<parameter id="Sigma">
<default_type>real</default_type>
<multivalue>false</multivalue>
<sem_type>real</sem_type>
<type_list>
<item>real</item>
</type_list>
</parameter>
</parameters>
</docu>
</procedure>
<procedure name="estimate_progress">
<interface>
<ic>
<par name="SecondsStart" base_type="ctrl" dimension="0"/>
<par name="ProgressMin" base_type="ctrl" dimension="0"/>
<par name="ProgressCurrent" base_type="ctrl" dimension="0"/>
<par name="ProgressMax" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="SecondsElapsed" base_type="ctrl" dimension="0"/>
<par name="SecondsRemaining" base_type="ctrl" dimension="0"/>
<par name="ProgressPercent" base_type="ctrl" dimension="0"/>
<par name="ProgressPerSecond" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c>* </c>
<c>* This procedure estimates the remaining time in seconds,</c>
<c>* given a start time and a progress value.</c>
<c>* </c>
<c>* Get current time.</c>
<l>count_seconds (SecondsNow)</l>
<c>* </c>
<c>* Get elapsed time span.</c>
<l>SecondsElapsed := SecondsNow - SecondsStart</l>
<c>* </c>
<c>* A very small additive constant to avoid division by zero.</c>
<l>Epsilon := 1e-6</l>
<c>* </c>
<c>* Estimate remaining time based on elapsed time.</c>
<l>ProgressRemaining := ProgressMax - ProgressCurrent</l>
<l>ProgressPerSecond := real(ProgressCurrent - ProgressMin) / (real(SecondsElapsed) + Epsilon)</l>
<l>SecondsRemaining := ProgressRemaining / (ProgressPerSecond + Epsilon)</l>
<c>* </c>
<c>* Get current progress in percent.</c>
<l>ProgressPercent := 100 * real(ProgressCurrent - ProgressMin) / (real(ProgressMax - ProgressMin) + Epsilon)</l>
<l>return ()</l>
</body>
<docu id="estimate_progress">
<abstract lang="en_US">This procedure estimates the remaining time for a task given the current progress.

The progress of a task is given by the minimum, the maximum, and the current progress value. In practice, progress values are usually the range of a loop and the current position within the loop.
In order to estimate the remaining time, the procedure requires the start time of the task to be passed in the 'SecondsStart' parameter. The start time must be the output of a call to the 'count_seconds' operator.</abstract>
<chapters lang="en_US">
<item>Time</item>
</chapters>
<library lang="en_US">MVTec Standard Procedures</library>
<predecessor>
<item>count_seconds</item>
</predecessor>
<short lang="en_US">Estimate the remaining time for a task given the current progress.</short>
<parameters>
<parameter id="ProgressCurrent">
<default_type>integer</default_type>
<default_value>50</default_value>
<description lang="en_US">Current progress value.</description>
<sem_type>number</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
<parameter id="ProgressMax">
<default_type>integer</default_type>
<default_value>100</default_value>
<description lang="en_US">Maximum progress value.</description>
<sem_type>number</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
<parameter id="ProgressMin">
<default_type>integer</default_type>
<default_value>0</default_value>
<description lang="en_US">Minimum progress value.</description>
<sem_type>number</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
<parameter id="ProgressPerSecond">
<default_type>real</default_type>
<description lang="en_US">Speed measured as progress per second.</description>
<sem_type>real</sem_type>
<type_list>
<item>real</item>
</type_list>
</parameter>
<parameter id="ProgressPercent">
<default_type>real</default_type>
<description lang="en_US">Progress in percent.</description>
<sem_type>real</sem_type>
<type_list>
<item>real</item>
</type_list>
</parameter>
<parameter id="SecondsElapsed">
<default_type>real</default_type>
<description lang="en_US">Elapsed time in seconds.</description>
<sem_type>real</sem_type>
<type_list>
<item>real</item>
</type_list>
</parameter>
<parameter id="SecondsRemaining">
<default_type>real</default_type>
<description lang="en_US">Estimated remaining time in seconds.</description>
<sem_type>real</sem_type>
<type_list>
<item>real</item>
</type_list>
</parameter>
<parameter id="SecondsStart">
<default_type>real</default_type>
<description lang="en_US">Start time returned by 'count_seconds'.</description>
<sem_type>real</sem_type>
<type_list>
<item>real</item>
</type_list>
</parameter>
</parameters>
</docu>
</procedure>
<procedure name="estimate_visualization_pose" access="local">
<interface>
<ic>
<par name="SampledModel" base_type="ctrl" dimension="0"/>
<par name="WindowHandleModel" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="PoseEstimated" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<l>get_object_models_center (SampledModel, Center)</l>
<l>if (Center == [])</l>
<l>    Center := [0,0,0]</l>
<l>endif</l>
<l>get_window_extents (WindowHandleModel, RowNotUsed, ColumnNotUsed, Width, Height)</l>
<l>get_part (WindowHandleModel, WPRow1, WPColumn1, WPRow2, WPColumn2)</l>
<l>set_part (WindowHandleModel, 0, 0, Height - 1, Width - 1)</l>
<l>gen_cam_par_area_scan_division (0.06, 0, 8.5e-6, 8.5e-6, Width / 2, Height / 2, Width, Height, CamParam)</l>
<l>create_pose (-Center[0], -Center[1], -Center[2], 0, 0, 0, 'Rp+T', 'gba', 'point', PoseIn)</l>
<c>* </c>
<l>try</l>
<l>    moments_object_model_3d (SampledModel, 'principal_axes', Moments)</l>
<l>catch (Exception)</l>
<l>    Moments := [0,0,0,0,0,0,0]</l>
<l>endtry</l>
<l>pose_invert (Moments, PoseInvert)</l>
<l>rigid_trans_object_model_3d (SampledModel, PoseInvert, ObjectModel3DRigidTrans)</l>
<l>determine_optimum_pose_distance (ObjectModel3DRigidTrans, CamParam, 0.9, PoseIn, PoseEstimated)</l>
<l>PoseEstimated := [PoseEstimated[0],-Moments[2],PoseEstimated[2],PoseEstimated[3] - 90,PoseEstimated[4],PoseEstimated[5],0]</l>
<c></c>
<l>return ()</l>
</body>
<docu id="estimate_visualization_pose">
<chapters lang="en_US">
<item>Graphics</item>
<item>Output</item>
</chapters>
<library lang="en_US">MVTec Standard Procedures</library>
<parameters>
<parameter id="PoseEstimated"/>
<parameter id="SampledModel"/>
<parameter id="WindowHandleModel"/>
</parameters>
</docu>
</procedure>
<procedure name="estimate_visualization_pose_simple" access="local">
<interface>
<ic>
<par name="SampledModel" base_type="ctrl" dimension="0"/>
<par name="WindowHandleModel" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="PoseEstimated" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<l>get_object_models_center (SampledModel, Center)</l>
<l>get_window_extents (WindowHandleModel, RowNotUsed, ColumnNotUsed, Width, Height)</l>
<l>get_part (WindowHandleModel, WPRow1, WPColumn1, WPRow2, WPColumn2)</l>
<l>set_part (WindowHandleModel, 0, 0, Height - 1, Width - 1)</l>
<l>gen_cam_par_area_scan_division (0.06, 0, 8.5e-6, 8.5e-6, Width / 2, Height / 2, Width, Height, CamParam)</l>
<l>create_pose (-Center[0], -Center[1], -Center[2], 0, 0, 0, 'Rp+T', 'gba', 'point', PoseIn)</l>
<c>* </c>
<l>determine_optimum_pose_distance (SampledModel, CamParam, 0.9, PoseIn, PoseEstimated)</l>
<c></c>
<l>return ()</l>
</body>
<docu id="estimate_visualization_pose_simple">
<chapters lang="en_US">
<item>Graphics</item>
<item>Output</item>
</chapters>
<library lang="en_US">MVTec Standard Procedures</library>
<parameters>
<parameter id="PoseEstimated"/>
<parameter id="SampledModel"/>
<parameter id="WindowHandleModel"/>
</parameters>
</docu>
</procedure>
<procedure name="evaluate_dl_classifier">
<interface>
<ic>
<par name="GroundTruthLabels" base_type="ctrl" dimension="0"/>
<par name="DLClassifierHandle" base_type="ctrl" dimension="0"/>
<par name="DLClassifierResultID" base_type="ctrl" dimension="0"/>
<par name="EvaluationMeasureType" base_type="ctrl" dimension="0"/>
<par name="ClassesToEvaluate" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="EvaluationMeasure" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c>* This procedure can be used to compute various evaluation measures</c>
<c>* to check the performance of your trained</c>
<c>* deep-learning-based classifier DLClassifierHandle.</c>
<c>* For this, the GroundTruthLabels must be given. Additionally,</c>
<c>* the results of the classification must be given in DLClassifierResultID,</c>
<c>* as returned by apply_dl_classifier and apply_dl_classifier_batchwise.</c>
<c>* With EvaluationMeasureType, you can choose which evaluation measure</c>
<c>* to return. With ClassesToEvaluate, you can choose whether to return</c>
<c>* the result for a single class, a result for every class, or</c>
<c>* for all classes combined. The result is returned in EvaluationMeasure.</c>
<c>* </c>
<c>* Check input.</c>
<c>* Check whether ClassesToEvaluate is a class or 'global'.</c>
<l>get_dl_classifier_param (DLClassifierHandle, 'classes', Classes)</l>
<c>* </c>
<c>* Convert the class indices to class labels if necessary</c>
<l>if (find(is_int_elem(GroundTruthLabels),0) == -1)</l>
<l>    if (min(GroundTruthLabels) &lt; 0 or max(GroundTruthLabels) &gt; |Classes| - 1)</l>
<l>        throw ('The Indices of the GroundTruthLabels exceed the range of classes. \nPlease check your data split.')</l>
<l>    endif</l>
<l>    GroundTruthLabels := Classes[GroundTruthLabels]</l>
<l>endif</l>
<l>if (uniq(sort(GroundTruthLabels)) != sort(Classes))</l>
<l>    throw ('Not all classes are represented in the GroundTruthLabels. \nPlease check your data split.')</l>
<l>endif</l>
<l>TestClassesToEvaluate := ['global',Classes]</l>
<l>if (difference(ClassesToEvaluate,TestClassesToEvaluate) != [])</l>
<l>    throw ('ClassesToEvaluate invalid.')</l>
<l>endif</l>
<c>* </c>
<c>* Count the measure types and modes of ClassesToEvaluate.</c>
<l>NumEvalMeasureTypes := |EvaluationMeasureType|</l>
<l>NumEvalClasses := |ClassesToEvaluate|</l>
<c>* </c>
<c>* If the numbers are not equal, extend the shorter one.</c>
<l>if (NumEvalMeasureTypes &gt; NumEvalClasses)</l>
<l>    if (NumEvalMeasureTypes &gt; 1 and NumEvalClasses &gt; 1)</l>
<l>        throw ('Invalid number of elements in EvaluationMeasureType/ClassesToEvaluate.')</l>
<l>    else</l>
<l>        ClassesToEvaluate := gen_tuple_const(NumEvalMeasureTypes,ClassesToEvaluate)</l>
<l>    endif</l>
<l>endif</l>
<l>if (NumEvalMeasureTypes &lt; NumEvalClasses)</l>
<l>    if (NumEvalMeasureTypes &gt; 1 and NumEvalClasses &gt; 1)</l>
<l>        throw ('Invalid number of elements in EvaluationMeasureType/ClassesToEvaluate.')</l>
<l>    else</l>
<l>        EvaluationMeasureType := gen_tuple_const(NumEvalClasses,EvaluationMeasureType)</l>
<l>    endif</l>
<l>endif</l>
<c>* </c>
<c>* Check whether we need to compute a confusion matrix.</c>
<c>* We want to do this only once to save run time.</c>
<l>ComputePrecision := EvaluationMeasureType =~ 'precision'</l>
<l>ComputeRecall := EvaluationMeasureType =~ 'recall'</l>
<l>ComputeFScore := EvaluationMeasureType =~ 'f_score'</l>
<l>ComputeConfusionMatrix := ComputePrecision + ComputeRecall + ComputeFScore</l>
<l>if (ComputeConfusionMatrix &gt; 0)</l>
<c>    * Get the top-1 predicted classes from the result handle(s).</c>
<l>    PredictedClasses := []</l>
<l>    for Index := 0 to |DLClassifierResultID| - 1 by 1</l>
<l>        get_dl_classifier_result (DLClassifierResultID[Index], 'all', 'predicted_classes', PredictedClass)</l>
<l>        PredictedClasses := [PredictedClasses,PredictedClass]</l>
<l>    endfor</l>
<c>    * Compute the confusion matrix.</c>
<l>    gen_confusion_matrix (GroundTruthLabels, PredictedClasses, 'display_matrix', 'none', [], ConfusionMatrix)</l>
<l>endif</l>
<c>* </c>
<c>* Loop through all given measure types.</c>
<l>EvaluationMeasure := []</l>
<l>for EvalMeasureTypeIndex := 0 to max([NumEvalMeasureTypes,NumEvalClasses]) - 1 by 1</l>
<c>    * Select the current combination.</c>
<l>    CurrentEvalMeasure := EvaluationMeasureType[EvalMeasureTypeIndex]</l>
<l>    CurrentEvalClass := ClassesToEvaluate[EvalMeasureTypeIndex]</l>
<c>    * Set the output accordingly.</c>
<c>    * Check whether to compute the top-k error.</c>
<l>    RegExpTopKError := 'top([0-9]+)_error'</l>
<l>    ComputeTopKError := CurrentEvalMeasure =~ RegExpTopKError</l>
<c>    * Check whether to compute the precision, recall, F-score.</c>
<l>    ComputePrecision := CurrentEvalMeasure =~ 'precision'</l>
<l>    ComputeRecall := CurrentEvalMeasure =~ 'recall'</l>
<l>    ComputeFScore := CurrentEvalMeasure =~ 'f_score'</l>
<c>    * </c>
<l>    if (ComputeTopKError)</l>
<c>        * Get the K from the input string 'topK_error'.</c>
<l>        K := number(regexp_match(CurrentEvalMeasure,RegExpTopKError))</l>
<c>        * Select all labels or only the labels with the respective class.</c>
<l>        if (CurrentEvalClass == 'global')</l>
<l>            Indices := [0:|GroundTruthLabels| - 1]</l>
<l>        else</l>
<l>            Indices := find(GroundTruthLabels,CurrentEvalClass)</l>
<l>        endif</l>
<l>        compute_top_k_error (DLClassifierHandle, DLClassifierResultID, GroundTruthLabels, Indices, K, TopKError)</l>
<l>        EvaluationMeasure[EvalMeasureTypeIndex] := TopKError</l>
<l>    elseif (ComputePrecision or ComputeRecall or ComputeFScore)</l>
<l>        if (CurrentEvalClass == 'global')</l>
<c>            * Compute the mean of the measures for all classes.</c>
<l>            NumClasses := |Classes|</l>
<l>            IndexClass := [0:NumClasses - 1]</l>
<l>        else</l>
<c>            * Compute the measures for a certain class.</c>
<l>            NumClasses := 1</l>
<l>            IndexClass := find(Classes,CurrentEvalClass)</l>
<l>        endif</l>
<l>        if (ComputePrecision or ComputeFScore)</l>
<l>            ClassPrecisions := []</l>
<l>            sum_matrix (ConfusionMatrix, 'rows', MatrixRowSumID)</l>
<l>            for Index := 0 to NumClasses - 1 by 1</l>
<c>                * Compute the precision for every selected class.</c>
<l>                get_value_matrix (ConfusionMatrix, IndexClass[Index], IndexClass[Index], TruePositive)</l>
<l>                get_value_matrix (MatrixRowSumID, IndexClass[Index], 0, SumPredictedClass)</l>
<l>                if (SumPredictedClass == 0)</l>
<l>                    ClassPrecision := 0</l>
<l>                else</l>
<l>                    ClassPrecision := TruePositive / SumPredictedClass</l>
<l>                endif</l>
<l>                ClassPrecisions := [ClassPrecisions,ClassPrecision]</l>
<l>            endfor</l>
<l>            Precision := mean(ClassPrecisions)</l>
<l>            clear_matrix (MatrixRowSumID)</l>
<l>            if (ComputePrecision)</l>
<l>                EvaluationMeasure[EvalMeasureTypeIndex] := Precision</l>
<l>            endif</l>
<l>        endif</l>
<l>        if (ComputeRecall or ComputeFScore)</l>
<l>            ClassRecalls := []</l>
<l>            sum_matrix (ConfusionMatrix, 'columns', MatrixColumnSumID)</l>
<l>            for Index := 0 to NumClasses - 1 by 1</l>
<c>                * Compute the recall for every class.</c>
<l>                get_value_matrix (ConfusionMatrix, IndexClass[Index], IndexClass[Index], TruePositive)</l>
<l>                get_value_matrix (MatrixColumnSumID, 0, IndexClass[Index], SumLabel)</l>
<l>                ClassRecall := TruePositive / SumLabel</l>
<l>                ClassRecalls := [ClassRecalls,ClassRecall]</l>
<l>            endfor</l>
<l>            Recall := mean(ClassRecalls)</l>
<l>            clear_matrix (MatrixColumnSumID)</l>
<l>            if (ComputeRecall)</l>
<l>                EvaluationMeasure[EvalMeasureTypeIndex] := Recall</l>
<l>            endif</l>
<l>        endif</l>
<l>        if (ComputeFScore)</l>
<c>            * Compute the F-score for a certain class or globally</c>
<c>            * for the averaged precision and recall.</c>
<c>            * Precision and recall were already computed above.</c>
<l>            if (Precision + Recall == 0)</l>
<l>                FScore := 0.0</l>
<l>            else</l>
<l>                FScore := (2 * Precision * Recall) / (Precision + Recall)</l>
<l>            endif</l>
<l>            EvaluationMeasure[EvalMeasureTypeIndex] := FScore</l>
<l>        endif</l>
<l>    else</l>
<l>        throw ('Invalid option for EvaluationMeasureType: \'' + CurrentEvalMeasure + '\'')</l>
<l>    endif</l>
<l>endfor</l>
<l>if (ComputeConfusionMatrix)</l>
<l>    clear_matrix (ConfusionMatrix)</l>
<l>endif</l>
<l>return ()</l>
<c></c>
</body>
<docu id="evaluate_dl_classifier">
<abstract lang="en_US">This procedure can be used to compute evaluation measures of the performance of your trained deep-learning-based classifier DLClassifierHandle on a given data set. For this, the GroundTruthLabels and the classification results DLClassifierResultID, as returned by apply_dl_classifier and apply_dl_classifier_batchwise, are required for every image in the data set. With EvaluationMeasureType, you can choose which evaluation measure shall be returned. With ClassesToEvaluate, you can choose whether the measure shall be applied globally (over all classes) or just to single classes. The result is returned in EvaluationMeasure.

These measures are supported by EvaluationMeasureType (for an explanation, please see the chapter reference of Deep Learning / Classification):
   'topK_error', where K is a number between 1 and the number of classes.
   'precision'
   'recall'
   'f_score' (the F1 score calculated from the corresponding 'precision' and 'recall' measures)

The following modes are supported for ClassesToEvaluate:
   'global': The evaluation measures are calculated  globally over all classes. The top-K-error is computed over the full data set. The other evaluation measures are averaged over all classes.
   '\class_name\': You can enter a single class name, to get the evaluation measure computed for this class.</abstract>
<chapters lang="en_US">
<item>Legacy</item>
<item>DL Classification</item>
</chapters>
<library lang="en_US">MVTec Standard Procedures</library>
<short lang="en_US">Evaluate the performance of a deep-learning-based classifier.</short>
<warning lang="en_US">evaluate_dl_classifier is obsolete and is only provided for reasons of backward compatibility.
New applications should use the general CNN-based procedure evaluate_dl_model.</warning>
<parameters>
<parameter id="ClassesToEvaluate">
<default_type>string</default_type>
<default_value>'global'</default_value>
<description lang="en_US">Select whether evaluation measures for all classes or a single class should be returned.</description>
<mixed_type>false</mixed_type>
<multivalue>optional</multivalue>
<sem_type>string</sem_type>
<type_list>
<item>string</item>
</type_list>
</parameter>
<parameter id="DLClassifierHandle">
<default_type>integer</default_type>
<description lang="en_US">Handle of the deep-learning-based classifier.</description>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>dl_classifier</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="DLClassifierResultID">
<default_type>integer</default_type>
<description lang="en_US">Result handle as returned by apply_dl_classifier and apply_dl_classifier_batchwise.</description>
<mixed_type>false</mixed_type>
<multivalue>optional</multivalue>
<sem_type>dl_classifier_result</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="EvaluationMeasure">
<default_type>string</default_type>
<description lang="en_US">The resulting evaluation measure.</description>
<mixed_type>optional</mixed_type>
<multivalue>optional</multivalue>
<sem_type>number</sem_type>
<type_list>
<item>real</item>
<item>string</item>
</type_list>
</parameter>
<parameter id="EvaluationMeasureType">
<default_type>string</default_type>
<default_value>'top1_error'</default_value>
<description lang="en_US">The evaluation measure that should be returned.</description>
<mixed_type>false</mixed_type>
<multivalue>optional</multivalue>
<sem_type>string</sem_type>
<type_list>
<item>string</item>
</type_list>
<values>
<item>'top1_error'</item>
<item>'top3_error'</item>
<item>'f_score'</item>
<item>'precision'</item>
<item>'recall'</item>
</values>
</parameter>
<parameter id="GroundTruthLabels">
<default_type>string</default_type>
<description lang="en_US">Ground truth labels of the images.</description>
<mixed_type>false</mixed_type>
<multivalue>optional</multivalue>
<sem_type>string</sem_type>
<type_list>
<item>string</item>
</type_list>
</parameter>
</parameters>
</docu>
</procedure>
<procedure name="evaluate_dl_model">
<interface>
<ic>
<par name="DLDataset" base_type="ctrl" dimension="0"/>
<par name="DLModelHandle" base_type="ctrl" dimension="0"/>
<par name="SampleSelectMethod" base_type="ctrl" dimension="0"/>
<par name="SampleSelectValues" base_type="ctrl" dimension="0"/>
<par name="GenParam" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="EvaluationResult" base_type="ctrl" dimension="0"/>
<par name="EvalParams" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c>* This procedure applies the model given by DLModelHandle on the selected samples</c>
<c>* of DLDataset and evaluates the results against the ground truth annotations</c>
<c>* to calculate evaluation measures.</c>
<c>* </c>
<c>* Input:</c>
<c>*  - DLDataset.</c>
<c>*  - DLModelHandle.</c>
<c>*  - SampleSelectMethod: Method by which the samples are selected.</c>
<c>*  - SampleSelectValues: Identifier used to retrieve the samples from the DLDataset</c>
<c>*                        for the corresponding selection method.</c>
<c>*  - GenParam: Parameters of the evaluation that should be changed from the default.</c>
<c>* </c>
<c>* Output:</c>
<c>*  - EvaluationResult: Dictionary containing the output measures.</c>
<c>*  - EvalParams: Dictionary with the used evaluation parameters.</c>
<c>* </c>
<c>* ** Initialization: ***</c>
<c>* </c>
<l>get_dl_model_param (DLModelHandle, 'type', ModelType)</l>
<l>if (ModelType != 'anomaly_detection' and ModelType != 'classification' and ModelType != 'detection' and ModelType != 'segmentation')</l>
<l>    throw ('Unknown model type')</l>
<l>endif</l>
<c>* </c>
<c>* Get the class IDs as set in the model.</c>
<l>if (ModelType == 'anomaly_detection')</l>
<c>    * Default for anomaly detection is 0,1.</c>
<l>    ClassIDs := [0,1]</l>
<l>else</l>
<l>    get_dl_model_param (DLModelHandle, 'class_ids', ClassIDs)</l>
<l>endif</l>
<c>* </c>
<c>* Get the batch size as set in the model.</c>
<l>get_dl_model_param (DLModelHandle, 'batch_size', BatchSize)</l>
<c>* </c>
<c>* Generate default parameters.</c>
<l>create_evaluation_default_param (ModelType, ClassIDs, EvalParams)</l>
<c>* </c>
<c>* Get model specific information.</c>
<l>if (ModelType == 'detection')</l>
<l>    try</l>
<l>        get_dl_model_param (DLModelHandle, 'instance_type', InstanceType)</l>
<l>    catch (Exception)</l>
<l>        InstanceType := 'rectangle1'</l>
<l>    endtry</l>
<c>    * Overwrite the instance_type.</c>
<l>    set_dict_tuple (EvalParams, 'instance_type', InstanceType)</l>
<c>    * For rectangle2 detection with ignore_direction set to false, we also evaluate the</c>
<c>    * precision of the predicted angle using the Score of Angle Precision (SoAP).</c>
<l>    if (InstanceType == 'rectangle2')</l>
<l>        get_dl_model_param (DLModelHandle, 'ignore_direction', IgnoreDirection)</l>
<l>        if (IgnoreDirection == 'false')</l>
<l>            get_dict_tuple (EvalParams, 'measures', Measures)</l>
<l>            set_dict_tuple (EvalParams, 'measures', [Measures,'soap'])</l>
<l>        endif</l>
<l>    endif</l>
<l>elseif (ModelType == 'segmentation')</l>
<l>    get_dl_model_param (DLModelHandle, 'ignore_class_ids', ModelIgnoreClassIDs)</l>
<l>endif</l>
<c>* </c>
<c>* By default we do not show the progress of evaluation.</c>
<l>ShowProgress := false</l>
<c>* </c>
<c>* Set user specified parameters.</c>
<l>if (GenParam != [])</l>
<l>    get_dict_param (GenParam, 'keys', [], GenParamKeys)</l>
<l>    for GenParamIndex := 0 to |GenParamKeys| - 1 by 1</l>
<l>        if (GenParamKeys[GenParamIndex] == 'measures')</l>
<c>            * Set measures.</c>
<l>            get_dict_tuple (GenParam, 'measures', Measures)</l>
<l>            set_dict_tuple (EvalParams, 'measures', Measures)</l>
<l>        elseif (GenParamKeys[GenParamIndex] == 'evaluation_type')</l>
<c>            * Set evaluation type.</c>
<l>            get_dict_tuple (GenParam, 'evaluation_type', EvaluationType)</l>
<l>            set_dict_tuple (EvalParams, 'evaluation_type', EvaluationType)</l>
<l>        elseif (GenParamKeys[GenParamIndex] == 'class_ids')</l>
<c>            * Set class ids.</c>
<l>            get_dict_tuple (GenParam, 'class_ids', ClassIDs)</l>
<l>            set_dict_tuple (EvalParams, 'class_ids', ClassIDs)</l>
<l>        elseif (GenParamKeys[GenParamIndex] == 'num_classes')</l>
<c>            * Set number of classes.</c>
<l>            get_dict_tuple (GenParam, 'num_classes', NumClasses)</l>
<l>            set_dict_tuple (EvalParams, 'num_classes', NumClasses)</l>
<l>        elseif (GenParamKeys[GenParamIndex] == 'evaluate_instances')</l>
<c>            * Set boolean for instance-based evaluation.</c>
<l>            get_dict_tuple (GenParam, 'evaluate_instances', EvaluateInstances)</l>
<l>            set_dict_tuple (EvalParams, 'evaluate_instances', EvaluateInstances)</l>
<l>        elseif (GenParamKeys[GenParamIndex] == 'show_progress')</l>
<c>            * Show the progress of the evaluation.</c>
<l>            get_dict_tuple (GenParam, 'show_progress', ShowProgress)</l>
<l>            ShowProgress := ShowProgress == 'true' or ShowProgress == true</l>
<l>        elseif (GenParamKeys[GenParamIndex] == 'iou_threshold' and ModelType == 'detection')</l>
<c>            * Set IoU threshold.</c>
<l>            get_dict_tuple (GenParam, 'iou_threshold', IoUThreshold)</l>
<l>            set_dict_tuple (EvalParams, 'iou_threshold', IoUThreshold)</l>
<l>        elseif (GenParamKeys[GenParamIndex] == 'max_num_detections' and ModelType == 'detection')</l>
<c>            * Set maximal number detections.</c>
<l>            get_dict_tuple (GenParam, 'max_num_detections', MaxNumDetections)</l>
<l>            set_dict_tuple (EvalParams, 'max_num_detections', MaxNumDetections)</l>
<l>        elseif (GenParamKeys[GenParamIndex] == 'area_ranges' and ModelType == 'detection')</l>
<c>            * Set area ranges.</c>
<l>            get_dict_tuple (GenParam, 'area_ranges', AreaRanges)</l>
<l>            set_dict_tuple (EvalParams, 'area_ranges', AreaRanges)</l>
<l>        elseif (GenParamKeys[GenParamIndex] == 'detailed_evaluation' and ModelType == 'detection')</l>
<c>            * Set detailed evaluation.</c>
<l>            get_dict_tuple (GenParam, 'detailed_evaluation', DetailedEvaluation)</l>
<l>            set_dict_tuple (EvalParams, 'detailed_evaluation', DetailedEvaluation)</l>
<l>        elseif (GenParamKeys[GenParamIndex] == 'allocation_block_length' and ModelType == 'detection')</l>
<c>            * Set length of blocks that are allocated during evaluation.</c>
<l>            get_dict_tuple (GenParam, 'allocation_block_length', AllocationBlockLength)</l>
<l>            set_dict_tuple (EvalParams, 'allocation_block_length', AllocationBlockLength)</l>
<l>        elseif (GenParamKeys[GenParamIndex] == 'ignore_class_ids' and ModelType == 'segmentation')</l>
<c>            * Set ignore class IDs.</c>
<l>            get_dict_tuple (GenParam, 'ignore_class_ids', IgnoreClassIDs)</l>
<c>            * Merge the specified ignore class IDs with the model ignore class IDs.</c>
<l>            AllIgnoreClassIDs := uniq(sort([ModelIgnoreClassIDs,IgnoreClassIDs]))</l>
<l>            set_dict_tuple (EvalParams, 'ignore_class_ids', AllIgnoreClassIDs)</l>
<c>            * Remove the ignore class IDs from the model class IDs.</c>
<l>            tuple_difference (ClassIDs, IgnoreClassIDs, EvaluateClassIDs)</l>
<l>            set_dict_tuple (EvalParams, 'class_ids', EvaluateClassIDs)</l>
<l>            set_dict_tuple (EvalParams, 'num_classes', |EvaluateClassIDs|)</l>
<l>        elseif (GenParamKeys[GenParamIndex] == 'class_names_to_evaluate' and ModelType == 'classification')</l>
<c>            * Class names to be used in evaluation.</c>
<c>            * To transform the names to IDs later, one has to remember the class names.</c>
<l>            get_dict_tuple (GenParam, 'class_names_to_evaluate', ClassesToEvaluate)</l>
<l>            get_dl_model_param (DLModelHandle, 'class_names', ClassNames)</l>
<l>            set_dict_tuple (EvalParams, 'class_names_to_evaluate', ClassesToEvaluate)</l>
<l>            set_dict_tuple (EvalParams, 'class_names', ClassNames)</l>
<l>            get_dict_param (EvalParams, 'key_exists', 'class_ids_to_evaluate', KeyExists)</l>
<l>            if (KeyExists)</l>
<c>                * To avoid inconsistent class names/IDs, remove the older ones.</c>
<l>                remove_dict_key (EvalParams, 'class_ids_to_evaluate')</l>
<l>            endif</l>
<l>        elseif (GenParamKeys[GenParamIndex] == 'class_ids_to_evaluate' and ModelType == 'classification')</l>
<c>            * Class IDs to be used in evaluation.</c>
<l>            get_dict_tuple (GenParam, 'class_ids_to_evaluate', ClassIDsToEvaluate)</l>
<l>            set_dict_tuple (EvalParams, 'class_ids_to_evaluate', ClassIDsToEvaluate)</l>
<l>            get_dict_param (EvalParams, 'key_exists', 'class_names_to_evaluate', KeyExists)</l>
<l>            if (KeyExists)</l>
<c>                * To avoid inconsistent class names/IDs, remove the older ones.</c>
<l>                remove_dict_key (EvalParams, 'class_names_to_evaluate')</l>
<l>            endif</l>
<l>        elseif (GenParamKeys[GenParamIndex] == 'anomaly_num_bins')</l>
<c>            * </c>
<c>            * Set anomaly histogram number of bins.</c>
<l>            get_dict_tuple (GenParam, 'anomaly_num_bins', AnomalyNumBins)</l>
<l>            get_dict_tuple (EvalParams, 'anomaly_score_histogram', AnomalyHistogram)</l>
<l>            set_dict_tuple (AnomalyHistogram, 'num_bins', AnomalyNumBins)</l>
<l>        elseif (GenParamKeys[GenParamIndex] == 'anomaly_min_value')</l>
<c>            * </c>
<c>            * Set anomaly histogram minimum value.</c>
<l>            get_dict_tuple (GenParam, 'anomaly_min_value', AnomalyMinValue)</l>
<l>            get_dict_tuple (EvalParams, 'anomaly_score_histogram', AnomalyHistogram)</l>
<l>            set_dict_tuple (AnomalyHistogram, 'min', AnomalyMinValue)</l>
<l>        elseif (GenParamKeys[GenParamIndex] == 'anomaly_max_value')</l>
<c>            * </c>
<c>            * Set anomaly histogram maximum value.</c>
<l>            get_dict_tuple (GenParam, 'anomaly_max_value', AnomalyMaxValue)</l>
<l>            get_dict_tuple (EvalParams, 'anomaly_score_histogram', AnomalyHistogram)</l>
<l>            set_dict_tuple (AnomalyHistogram, 'max', AnomalyMaxValue)</l>
<l>        else</l>
<l>            throw ('Unknown parameter : \'' + GenParamKeys[GenParamIndex] + '\'')</l>
<l>        endif</l>
<l>    endfor</l>
<l>endif</l>
<c>* </c>
<c>* Get the class names from the dataset if present.</c>
<l>get_dict_param (DLDataset, 'key_exists', ['class_names','class_ids'], ClassInfoExists)</l>
<l>if (sum(ClassInfoExists) == |ClassInfoExists|)</l>
<l>    get_dict_tuple (DLDataset, 'class_names', ClassNames)</l>
<l>    get_dict_tuple (DLDataset, 'class_ids', DatasetClassIDs)</l>
<c>    * Set the class names only for the class IDs that are evaluated.</c>
<l>    get_dict_tuple (EvalParams, 'class_ids', EvaluateClassIDs)</l>
<l>    ClassIDsToClassNames := gen_tuple_const(max(DatasetClassIDs) + 1,'')</l>
<l>    ClassIDsToClassNames[DatasetClassIDs] := ClassNames</l>
<l>    EvaluateClassNames := ClassIDsToClassNames[EvaluateClassIDs]</l>
<c>    * Set the class names to EvalParams.</c>
<l>    set_dict_tuple (EvalParams, 'class_names', EvaluateClassNames)</l>
<l>endif</l>
<c>* </c>
<c>* Get indices of samples to read from the dataset.</c>
<l>get_dict_tuple (DLDataset, 'samples', DLSamples)</l>
<c>* </c>
<c>* Check if there are samples present in the dataset.</c>
<l>if (|DLSamples| == 0)</l>
<l>    throw ('The provided set of samples in the dataset must be non-empty.')</l>
<l>endif</l>
<c>* </c>
<c>* Check for empty SampleSelectValues.</c>
<l>if (|SampleSelectValues| == 0)</l>
<l>    if (SampleSelectMethod == 'image_ids')</l>
<l>        throw ('The provided set of samples of the \'image_ids\' selection must be non-empty.')</l>
<l>    elseif (SampleSelectMethod == 'sample_indices')</l>
<l>        throw ('The provided set of samples of the \'sample_indices\' selection must be non-empty.')</l>
<l>    else</l>
<l>        throw ('Provide a name for \'split\' selection.')</l>
<l>    endif</l>
<l>endif</l>
<c>* </c>
<c>* </c>
<c>* Get the sample indices according to the sample selection method.</c>
<l>SampleIndices := []</l>
<l>if (SampleSelectMethod == 'split')</l>
<c>    * Get the samples of the split specified.</c>
<l>    find_dl_samples (DLSamples, 'split', SampleSelectValues, 'or', SampleIndices)</l>
<l>elseif (SampleSelectMethod == 'image_ids')</l>
<c>    * Get the samples specified by 'image_ids'.</c>
<l>    if (|SampleSelectValues| &gt; |DLSamples|)</l>
<l>        throw ('The number of the image ids provided through \'image_id\' is invalid.')</l>
<l>    endif</l>
<l>    find_dl_samples (DLSamples, 'image_id', SampleSelectValues, 'or', SampleIndices)</l>
<l>elseif (SampleSelectMethod == 'sample_indices')</l>
<c>    * Get the samples specified by 'sample_indices'.</c>
<l>    if (min(SampleSelectValues) &lt; 0 or max(SampleSelectValues) &gt; |DLSamples| - 1)</l>
<l>        throw ('The range of the indices provided through \'sample_indices\' is invalid.')</l>
<l>    endif</l>
<l>    SampleIndices := SampleSelectValues</l>
<l>else</l>
<l>    throw ('Unknown sample selection method : \'' + SampleSelectMethod + '\'')</l>
<l>endif</l>
<c>* </c>
<c>* Get the number of batches.</c>
<l>NumSamples := |SampleIndices|</l>
<l>NumBatches := int(ceil(NumSamples / real(BatchSize)))</l>
<c>* </c>
<c>* Check for empty samples selected by the selection method.</c>
<l>if (NumSamples == 0)</l>
<l>    throw ('No samples present in the dataset that are part of the \'' + SampleSelectMethod + '\' selection.')</l>
<l>endif</l>
<c>* </c>
<c>* </c>
<c>* ** Running measures are initialized according to evaluation method.</c>
<c>* </c>
<l>init_running_evaluation_measures (EvalParams, RunningMeasures)</l>
<c>* </c>
<c>* </c>
<c>* ** Apply model to each image and gather evaluation information: ***</c>
<c>* </c>
<c>* Initialize progress variables.</c>
<l>if (ShowProgress)</l>
<l>    Progress := ['Procedure: evaluate_dl_model','','','']</l>
<l>    if (ModelType == 'detection')</l>
<l>        TaskInfo := 'Task: 1/2: Applying the model and collecting running evaluation measures'</l>
<l>        Progress := [Progress,TaskInfo]</l>
<l>    endif</l>
<l>    count_seconds (SecondsStart)</l>
<l>    dev_inspect_ctrl (Progress)</l>
<l>endif</l>
<c>* </c>
<c>* Loop batchwise over the samples to be evaluated.</c>
<l>for BatchIndex := 0 to NumBatches - 1 by 1</l>
<l>    BatchStart := BatchIndex * BatchSize</l>
<l>    BatchEnd := min2(BatchStart + BatchSize - 1,NumSamples - 1)</l>
<l>    SamplesIndicesBatch := SampleIndices[BatchStart:BatchEnd]</l>
<c>    * </c>
<c>    * Read samples</c>
<l>    read_dl_samples (DLDataset, SamplesIndicesBatch, DLSamplesBatch)</l>
<c>    * </c>
<c>    * Apply the model.</c>
<l>    apply_dl_model (DLModelHandle, DLSamplesBatch, [], DLResultsBatch)</l>
<c>    * </c>
<c>    * Update the running measures.</c>
<l>    update_running_evaluation_measures (DLSamplesBatch, DLResultsBatch, EvalParams, RunningMeasures)</l>
<c>    * </c>
<c>    * Provide progress information.</c>
<l>    if (ShowProgress and (BatchIndex % 10 == 1 or BatchIndex == NumBatches - 1))</l>
<l>        estimate_progress (SecondsStart, 0, BatchIndex, NumBatches - 1, SecondsElapsed, SecondsRemaining, ProgressPercent, ProgressPerSecond)</l>
<l>        timespan_string (SecondsElapsed, 'auto', TimeElapsedString)</l>
<l>        timespan_string (SecondsRemaining, 'top2', TimeRemainingString)</l>
<l>        Progress[1] := 'Progress: ' + round(ProgressPercent) + ' %'</l>
<l>        Progress[2] := 'Time elapsed: ' + TimeElapsedString</l>
<l>        Progress[3] := 'Time left: ' + TimeRemainingString</l>
<l>    endif</l>
<l>endfor</l>
<c>* </c>
<c>* Provide progress information.</c>
<l>if (ShowProgress and ModelType == 'detection')</l>
<l>    Progress := ['Procedure: evaluate_dl_model','','']</l>
<l>    Progress[1] := 'Please wait...'</l>
<l>    Progress[2] := 'Task: 2/2: Calculating final evaluation measures'</l>
<l>endif</l>
<c>* </c>
<c>* </c>
<c>* ** Do the actual calculation of measures: ***</c>
<c>* </c>
<l>calculate_evaluation_measures (RunningMeasures, EvalParams, EvaluationResult)</l>
<c>* </c>
<c>* Close progress inspect.</c>
<l>if (ShowProgress)</l>
<l>    Progress := 'Done.'</l>
<l>    dev_close_inspect_ctrl (Progress)</l>
<l>endif</l>
<c>* </c>
<l>return ()</l>
</body>
<docu id="evaluate_dl_model">
<abstract lang="en_US">This procedure applies the model given by DLModelHandle on the selected samples of DLDataset and evaluates the results against the ground truth annotations to calculate evaluation measures.
SampleSelectMethod and the SampleSelectValue determine, how and which samples are selected. 

The procedure returns a dictionary EvalParams with the evaluation parameters and a dictionary EvaluationResults with the accordingly calculated evaluation measures.

To be more specific, this procedure performs the following tasks:
- initializes running measures (see init_running_evaluation_measures).
- evaluates the samples SampleSelectValues selected via SampleSelectMethod of the DLDataset batch by batch.
- updates the running measures using update_running_evaluation_measures.
- calculates the overall EvaluationResult by summarizing the running measures using calculate_evaluation_measures.

In the following, different parameters and their options are explained:

You can determine, which set of samples you select according to a specified selection method. Thereby you have the following options to choose a method SampleSelectMethod and the identifier SampleSelectValue to retrieve the samples from the dataset for the corresponding selection method:
- 'split' (default): 'train', 'validation', or 'test' (default).
- 'image_ids': IDs of the selected images.
- 'sample_indices': Indices the selected images have in DLDataset.

The dictionary EvalParams specifies the evaluation parameters, which depend on the 'type' of the model. The applicable default parameters and values are set by the procedure create_evaluation_default_param.

The dictionary GenParam is used to set evaluation parameters to non-default values. 
Thereby you have the following options, set as 'key': 'value' pair, depending on the 'type' of the model:
- for all types:
   -- 'show_progress': If set to true, the progress of evaluation is displayed in a window. The default is false.
   -- 'measures': Evaluation measures. The values this key can obtain depend on the 'type' of the model, see the entries listed below.
   -- 'evaluation_type': Type of evaluation set to EvaluationType.
   -- 'class_ids': Class IDs of the classes that are used during the evaluation.
   -- 'num_classes': Number of classes that the model can predict.
   -- 'evaluate_instances': Determines if the evaluation is done instance-based. This parameter has the following values:
      --- 'true': For EvaluationType 'detection'.
      --- 'false': For EvaluationType 'anomaly_detection, 'classification' and 'segmentation'.

- for models of type 'anomaly_detection':
  -- 'measures': Evaluation measures to be calculated. You can set the following values:
     --- 'anomaly_score_histogram' (default): The cumulative histogram of wrongly classified images.
  -- 'anomaly_num_bins': Number of bins in the histogram. The default value is -1.
  -- 'anomaly_min_value': The minimum value in the histogram. The default value is 0.0.
  -- 'anomaly_max_value': The maximum value in the histogram. The default value is 1.0.

- for models of type 'classification':
  -- 'measures': Evaluation measures to be calculated. You can set the following values:
    --- 'absolute_confusion_matrix': Confusion matrix, where entry (i,j) is the number of images with ground truth class_ids[j] predicted as class_ids[i].
    --- 'relative_confusion_matrix': Confusion matrix, but every entry (i,j) is normalized by the number of ground truth labels of the class in column j.
    --- 'topK_error': Top-K error, where K is a number from 1 to number of classes, e.g., 'top1_error'.
    --- 'precision': Proportion of all correct predicted positives to all predicted positives (true and false ones).
    --- 'recall': Proportion of all correct predicted positives to all real positives.
    --- 'f_score': Harmonic mean of precision and recall.
    --- 'all': Same as specifying all measures. For the top-K error, only K=1 is used.
    The default measure is 'top1_error'.
  -- 'class_ids_to_evaluate': IDs of the classes to be evaluated. You can set the following values:
    --- 'global': The evaluation measures are calculated globally over all classes. The topK-error is computed over all selected samples, all other measures are averaged over all classes.
    -- '\class_id\': Single ID specifying the class for which the evaluation measures are to be computed.
  -- 'class_names_to_evaluate': Names of the classes to be evaluated. You can set the following values:
    --- 'global': The evaluation measures are calculated globally over all classes. The top-K error is computed over all selected samples, all other measures are averaged over all classes.
    --- '\class_name\': Single Name specifying the class for which the evaluation measures are to be computed.
  Note that for any measure 'topK_error', one has to guarantee that every class to be evaluated (set by 'class_ids_to_evaluate' or 'class_names_to_evaluate') is part of the set of selected samples. For measures 'absolute_confusion_matrix' and 'relative_confusion_matrix', all classes have to be represented in the set of selected samples.

- for models of type 'detection':
   -- 'measures':  Evaluation measures to be calculated. You can set the following values:
      --- 'mean_ap' (default): Mean average precision, i.e. the mean of the per class average precision. The average precision is obtained from the area under the (interpolated) precision-recall-curve. The value is given per IoU threshold and as a mean over the given IoU thresholds.
      --- 'soap' (only for instance_type 'rectangle2'): Score of Angle Precision. The score is has a value range from 0 (meaning that the orientations of all instances are maximally wrong) to 1 (the orientations of all instances are totally correct). The value is given per IoU threshold and as a mean over the given IoU thresholds.
      --- 'all': Same as specifying all measures.
   -- 'iou_threshold':Intersection over union (IoU) thresholds to be used.
      A result instance is a true positive if it has the correct class and the highest confidence of all results that have
      an IoU&gt;threshold with one of the ground truth instances.
      The default value is [0.5, 0.55, 0.6, 0.65, 0.7, 0.75, 0.8, 0.85, 0.9, 0.95].
   -- 'area_ranges': Dictionary that specifies the area range of ground truth and result instances that should be used for the evaluation. 
      Thereby, false positive result instances that are outside the area range are ignored.
      All ground truth instances that have an area that is not within ['min', 'max'] are ignored.
      All detections, that are true positive for an ignored ground truth are ignored and all false positive detections with an area not within ['min', 'max'] are ignored.
      The areas are defined within this dictionary over the tuples:
      --- 'name': Name of the area_range (e.g., 'all','small', 'medium', 'large'). The default value is ['all'].
      --- 'min': Minimal area. The default value is [0].
      --- 'max': Maximal area. The default value is [2e8].
   -- 'detailed_evaluation': Optional parameter. You can set the following values:
      --- 'true': The evaluation will additionally return the number of true positive (TP), false positive (FP), and false negative (FN) detections. 
          It will also give back the image IDs of samples where FP or FN occur and subdivides the FP group (see the documentation of calculate_evaluation_measures).
          There are different reasons for false positive detections (FPs), so this group is subdivided kinds of false positives (see calculate_evaluation_measures).
          A detection confusion matrix is given.
          Note that setting this parameter to true significantly slows down the evaluation process.
      --- 'false' (default): The detailed evaluation is not performed.
   -- 'allocation_block_length': As some instance RunningMeasures are tuples of changing length,
      they are allocated in blocks of this length. The default value is 200.

- for models of type 'segmentation':
   -- 'ignore_class_ids': Class IDs of regions that should be ignored during the evaluation.
      Pixels assigned to a 'ignore' class are ignored by the loss as well as for all measures and evaluations. 
      The default value is [].
   -- 'measures': Measures to be calculated. You can set the following values:
      --- 'class_iou' (per-class): Intersection over union between the ground truth and the result regions.
      --- 'mean_iou' (overall): Mean (over classes) of 'class_iou'.
      --- 'frequency_weighted_iou' (overall): Average (over classes) of 'class_iou', where each class is weighted by the ratio of pixels belonging to that class.
      --- 'class_pixel_accuracy' (per-class): Ratio of pixels predicted with the correct class-label.
      --- 'pixel_accuracy' (overall): Ratio of pixels predicted with the correct class-label, accumulated over classes.
      --- 'mean_accuracy' (overall): Mean (over classes) of 'class_pixel_accuracy'.
      --- 'pixel_confusion_matrix' (overall): Confusion matrix, where entry (i,j) is the number of pixels with ground truth class_ids[j] predicted as class_ids[i].
          Note, the use of this measure slows down the evaluation process.
      --- 'all': Same as specifying all measures.
      The default value is  ['pixel_accuracy', 'mean_accuracy', 'mean_iou'].
      Note that classes without any ground truth pixels are ignored in the mean/average calculations. Their individual per-class measures are set to -1.

The output dictionary EvaluationResult has a structure and keys depending on the 'type' of the model and the specified 'measures':
- for models of type 'detection' (instance-wise evaluation, 'evaluate_instances' is true):
  The measures are nested in the following way, depending on the values for different EvalParams keys:
  There is a dictionary for each 'max_num_detections'-value that contains a dictionary for each 'area_ranges'-entry.
   Inside the area-related dictionaries the measures are given per 'iou_threshold' and averaged over 'iou_theshold'-values, both per class and averaged over classes.
   If in GenParam the key 'detailed_evaluation' has a value true, additional, more detailed evaluation results are returned (see calculate_evaluation_measures).

- for models of type 'segmentation' (pixel-wise evaluation, 'evaluate_instances' is false):
  The measures are just given by their key-names, for per-class-results there is a dictionary that contains the measures per class ID.</abstract>
<chapters lang="de_DE">
<item>Deep Learning</item>
<item>Evaluierung</item>
</chapters>
<chapters lang="en_US">
<item>Deep Learning</item>
<item>Evaluation</item>
</chapters>
<library lang="en_US">MVTec Standard Procedures</library>
<short lang="en_US">Evaluate the model given by DLModelHandle on the selected samples of DLDataset.</short>
<parameters>
<parameter id="DLDataset">
<default_type>integer</default_type>
<default_value>DLDataset</default_value>
<description lang="en_US">Dictionary containing the dataset.</description>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>dict</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="DLModelHandle">
<default_type>integer</default_type>
<default_value>DLModelHandle</default_value>
<description lang="en_US">Handle of the deep-learning-based model to be used in order to generate the results.</description>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>dl_model</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="EvalParams">
<default_type>integer</default_type>
<description lang="en_US">Dictionary with the used evaluation parameters.</description>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>dict</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="EvaluationResult">
<default_type>integer</default_type>
<description lang="en_US">Dictionary containing the evaluation results.</description>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>dict</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="GenParam">
<default_type>integer</default_type>
<default_value>[]</default_value>
<description lang="en_US">The dictionary GenParam is used to specify non-default evaluation parameters.</description>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>any</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="SampleSelectMethod">
<default_type>string</default_type>
<default_value>'split'</default_value>
<description lang="en_US">Method used to select the samples to be evaluated out of the dataset DLDataset.</description>
<multivalue>false</multivalue>
<sem_type>string</sem_type>
<type_list>
<item>string</item>
</type_list>
<values>
<item>'split'</item>
<item>'image_ids'</item>
<item>'sample_indices'</item>
</values>
</parameter>
<parameter id="SampleSelectValues">
<default_type>string</default_type>
<default_value>'test'</default_value>
<description lang="en_US">Identifier by which the samples are selected out of the dataset DLDataset using the method SampleSelectMethod.</description>
<multivalue>optional</multivalue>
<sem_type>any</sem_type>
<type_list>
<item>integer</item>
<item>string</item>
</type_list>
</parameter>
</parameters>
</docu>
</procedure>
<procedure name="find_dl_samples">
<interface>
<ic>
<par name="Samples" base_type="ctrl" dimension="0"/>
<par name="KeyName" base_type="ctrl" dimension="0"/>
<par name="KeyValue" base_type="ctrl" dimension="0"/>
<par name="Mode" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="SampleIndices" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c>* </c>
<c>* This procedure gets the indices of the samples that contain the</c>
<c>* requested KeyName matching the requested KeyValue according to the Mode.</c>
<c>* If there is no match, an empty tuple [] will be returned.</c>
<c>* </c>
<c>* Check input parameters.</c>
<l>if (|KeyName| != 1)</l>
<l>    throw ('Invalid KeyName size: ' + |KeyName|)</l>
<l>endif</l>
<l>if (|Mode| != 1)</l>
<l>    throw ('Invalid Mode size: ' + |Mode|)</l>
<l>endif</l>
<l>if (Mode != 'match' and Mode != 'or' and Mode != 'contain')</l>
<l>    throw ('Invalid Mode value: ' + Mode)</l>
<l>endif</l>
<l>NumKeyValues := |KeyValue|</l>
<l>if (Mode == 'contain' and NumKeyValues &lt; 1)</l>
<l>    throw ('Invalid KeyValue size for contain Mode: ' + NumKeyValues)</l>
<l>endif</l>
<c>* </c>
<c>* Find the indices.</c>
<l>SampleIndices := []</l>
<l>for SampleIndex := 0 to |Samples| - 1 by 1</l>
<l>    Sample := Samples[SampleIndex]</l>
<l>    get_dict_param (Sample, 'key_exists', KeyName, KeyExists)</l>
<l>    if (KeyExists)</l>
<l>        get_dict_tuple (Sample, KeyName, Tuple)</l>
<l>        if (Mode == 'match')</l>
<c>            * Mode 'match': Tuple must be equal KeyValue.</c>
<l>            Hit := Tuple == KeyValue</l>
<l>        elseif (Mode == 'or' and |Tuple| == 1)</l>
<c>            * Mode 'or': Tuple must have only 1 element and it has to be equal to any of KeyValues elements.</c>
<l>            Hit := find_first(KeyValue,Tuple) &gt;= 0</l>
<l>        elseif (Mode == 'contain')</l>
<c>            * Mode 'contain': Tuple must contain any of the elements in KeyValue.</c>
<l>            for ValueIndex := 0 to NumKeyValues - 1 by 1</l>
<l>                Value := KeyValue[ValueIndex]</l>
<l>                Hit := find_first(Tuple,Value) &gt;= 0</l>
<l>                if (Hit)</l>
<l>                    break</l>
<l>                endif</l>
<l>            endfor</l>
<l>        else</l>
<c>            * Unsupported configuration.</c>
<l>            Hit := false</l>
<l>        endif</l>
<l>        if (Hit)</l>
<l>            SampleIndices := [SampleIndices,SampleIndex]</l>
<l>        endif</l>
<l>    endif</l>
<l>endfor</l>
<l>return ()</l>
</body>
<docu id="find_dl_samples">
<abstract lang="en_US">This procedure retrieves the indices of Samples with KeyName matching KeyValue according to the mode set.

As a result, the tuple SampleIndices is returned, giving the indices of the samples where the search matched according to the mode set. If there is no match, the empty tuple [] is returned. This will be also the case if Samples is [].

KeyValue can be a number, a string or a mixed tuple value. 

Mode defines the search behavior. It can take the following values:
- 'match': The value of the sample under the entry KeyName matches exactly KeyValue.
- 'or': The value of the sample under the entry KeyName must have only a single element and it matches any of the elements in the tuple KeyValue.
- 'contain': Any element in the value of the sample under the entry KeyName matches any of the elements in the tuple KeyValue.</abstract>
<chapters lang="de_DE">
<item>Deep Learning</item>
<item>Modell</item>
</chapters>
<chapters lang="en_US">
<item>Deep Learning</item>
<item>Model</item>
</chapters>
<library lang="en_US">MVTec Standard Procedures</library>
<short lang="en_US">Retrieve the indices of Samples that contain KeyName matching KeyValue according to the Mode set.</short>
<parameters>
<parameter id="KeyName">
<default_type>string</default_type>
<default_value>'split'</default_value>
<description lang="en_US">Key name specifying the entry looked through.</description>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>string</sem_type>
<type_list>
<item>string</item>
</type_list>
</parameter>
<parameter id="KeyValue">
<default_type>integer</default_type>
<default_value>[]</default_value>
<description lang="en_US">Values looked for under the entry with KeyName.</description>
<mixed_type>optional</mixed_type>
<multivalue>optional</multivalue>
<sem_type>any</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
<item>string</item>
</type_list>
<values>
<item>1</item>
<item>2.2</item>
<item>'string'</item>
<item>[1,2.2, 'mixed']</item>
</values>
</parameter>
<parameter id="Mode">
<default_type>string</default_type>
<default_value>'match'</default_value>
<description lang="en_US">Mode defines the search behavior.</description>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>string</sem_type>
<type_list>
<item>string</item>
</type_list>
<value_list>
<item>'match'</item>
<item>'or'</item>
<item>'contain'</item>
</value_list>
</parameter>
<parameter id="SampleIndices">
<default_type>integer</default_type>
<description lang="en_US">Indices of the samples where the search matched according to the mode set.</description>
<mixed_type>false</mixed_type>
<multivalue>optional</multivalue>
<sem_type>integer</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="Samples">
<default_type>integer</default_type>
<description lang="en_US">Dictionary or tuple with the dictionaries of the samples, which are browsed through.</description>
<mixed_type>false</mixed_type>
<multivalue>optional</multivalue>
<sem_type>dict</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
</parameters>
</docu>
</procedure>
<procedure name="gen_arrow_contour_xld">
<interface>
<oo>
<par name="Arrow" base_type="iconic" dimension="0"/>
</oo>
<ic>
<par name="Row1" base_type="ctrl" dimension="0"/>
<par name="Column1" base_type="ctrl" dimension="0"/>
<par name="Row2" base_type="ctrl" dimension="0"/>
<par name="Column2" base_type="ctrl" dimension="0"/>
<par name="HeadLength" base_type="ctrl" dimension="0"/>
<par name="HeadWidth" base_type="ctrl" dimension="0"/>
</ic>
</interface>
<body>
<c>* This procedure generates arrow shaped XLD contours,</c>
<c>* pointing from (Row1, Column1) to (Row2, Column2).</c>
<c>* If starting and end point are identical, a contour consisting</c>
<c>* of a single point is returned.</c>
<c>* </c>
<c>* input parameteres:</c>
<c>* Row1, Column1: Coordinates of the arrows' starting points</c>
<c>* Row2, Column2: Coordinates of the arrows' end points</c>
<c>* HeadLength, HeadWidth: Size of the arrow heads in pixels</c>
<c>* </c>
<c>* output parameter:</c>
<c>* Arrow: The resulting XLD contour</c>
<c>* </c>
<c>* The input tuples Row1, Column1, Row2, and Column2 have to be of</c>
<c>* the same length.</c>
<c>* HeadLength and HeadWidth either have to be of the same length as</c>
<c>* Row1, Column1, Row2, and Column2 or have to be a single element.</c>
<c>* If one of the above restrictions is violated, an error will occur.</c>
<c>* </c>
<c>* </c>
<c>* Init</c>
<l>gen_empty_obj (Arrow)</l>
<c>* </c>
<c>* Calculate the arrow length</c>
<l>distance_pp (Row1, Column1, Row2, Column2, Length)</l>
<c>* </c>
<c>* Mark arrows with identical start and end point</c>
<c>* (set Length to -1 to avoid division-by-zero exception)</c>
<l>ZeroLengthIndices := find(Length,0)</l>
<l>if (ZeroLengthIndices != -1)</l>
<l>    Length[ZeroLengthIndices] := -1</l>
<l>endif</l>
<c>* </c>
<c>* Calculate auxiliary variables.</c>
<l>DR := 1.0 * (Row2 - Row1) / Length</l>
<l>DC := 1.0 * (Column2 - Column1) / Length</l>
<l>HalfHeadWidth := HeadWidth / 2.0</l>
<c>* </c>
<c>* Calculate end points of the arrow head.</c>
<l>RowP1 := Row1 + (Length - HeadLength) * DR + HalfHeadWidth * DC</l>
<l>ColP1 := Column1 + (Length - HeadLength) * DC - HalfHeadWidth * DR</l>
<l>RowP2 := Row1 + (Length - HeadLength) * DR - HalfHeadWidth * DC</l>
<l>ColP2 := Column1 + (Length - HeadLength) * DC + HalfHeadWidth * DR</l>
<c>* </c>
<c>* Finally create output XLD contour for each input point pair</c>
<l>for Index := 0 to |Length| - 1 by 1</l>
<l>    if (Length[Index] == -1)</l>
<c>        * Create_ single points for arrows with identical start and end point</c>
<l>        gen_contour_polygon_xld (TempArrow, Row1[Index], Column1[Index])</l>
<l>    else</l>
<c>        * Create arrow contour</c>
<l>        gen_contour_polygon_xld (TempArrow, [Row1[Index],Row2[Index],RowP1[Index],Row2[Index],RowP2[Index],Row2[Index]], [Column1[Index],Column2[Index],ColP1[Index],Column2[Index],ColP2[Index],Column2[Index]])</l>
<l>    endif</l>
<l>    concat_obj (Arrow, TempArrow, Arrow)</l>
<l>endfor</l>
<l>return ()</l>
</body>
<docu id="gen_arrow_contour_xld">
<abstract lang="en_US">This procedure creates arrow shaped XLD contours, which point from the coordinates (Row1, Column1) to the coordinates (Row2, Coordinates2). The shape of the arrow head can be specified with the parameters HeadLength and HeadWidth (in pixels).

If starting and end point are identical, a contour consisting of a single point is returned.

The input tuples Row1, Column1, Row2, and Column2 have to be of the same length. HeadLength and HeadWidth either have to be of the same length as Row1, Column1, Row2, and Column2 or have to be a single element. If one of the above restrictions is violated, an error will occur.
</abstract>
<alternatives>
<item>disp_arrow</item>
<item>gen_contour_polygon_xld</item>
</alternatives>
<chapters lang="de_DE">
<item>XLD</item>
<item>Generierung</item>
</chapters>
<chapters lang="en_US">
<item>XLD</item>
<item>Creation</item>
</chapters>
<example lang="en_US">StartPointRows:=[100,100]
StartPointColumns:=[100,100]
EndPointRows:=[200,50]
EndPointColumns:=[200,150]
dev_set_colored (3)
gen_arrow_contour_xld (Arrow, StartPointRows, StartPointColumns, EndPointRows, EndPointColumns, [10,20], [20,10])
</example>
<keywords lang="de_DE">
<item>XLD-Konturen erzeugen</item>
<item>XLD-Kontur eines Pfeils erzeugen</item>
</keywords>
<keywords lang="en_US">
<item>create XLD contours</item>
<item>create XLD contour of arrow</item>
</keywords>
<library lang="de_DE">MVTec Standard Procedures</library>
<library lang="en_US">MVTec Standard Procedures</library>
<see_also>
<item>gen_contour_nurbs_xld</item>
</see_also>
<short lang="de_DE">Creates an arrow shaped XLD contour.</short>
<short lang="en_US">Creates an arrow shaped XLD contour.</short>
<successor>
<item>dev_display</item>
<item>disp_obj</item>
</successor>
<parameters>
<parameter id="Arrow">
<description lang="en_US">The generated xld</description>
<multivalue>optional</multivalue>
<sem_type>xld_cont</sem_type>
</parameter>
<parameter id="Column1">
<default_type>integer</default_type>
<default_value>100</default_value>
<description lang="en_US">The column coordinate of the starting point</description>
<mixed_type>optional</mixed_type>
<multivalue>optional</multivalue>
<sem_type>point.x</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
<parameter id="Column2">
<default_type>integer</default_type>
<default_value>200</default_value>
<description lang="en_US">The column coordinate of the end point</description>
<mixed_type>optional</mixed_type>
<multivalue>optional</multivalue>
<sem_type>point.x</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
<parameter id="HeadLength">
<default_type>integer</default_type>
<default_value>5</default_value>
<description lang="en_US">The length of the arrow head in pixels</description>
<mixed_type>optional</mixed_type>
<multivalue>optional</multivalue>
<sem_type>number</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
<values>
<item>[2,3,5,10,20]</item>
</values>
</parameter>
<parameter id="HeadWidth">
<default_type>integer</default_type>
<default_value>5</default_value>
<description lang="en_US">The width of the arrow head in pixels</description>
<mixed_type>optional</mixed_type>
<multivalue>optional</multivalue>
<sem_type>number</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
<values>
<item>[2,3,5,10,20]</item>
</values>
</parameter>
<parameter id="Row1">
<default_type>integer</default_type>
<default_value>100</default_value>
<description lang="en_US">The row coordinate of the starting point</description>
<mixed_type>optional</mixed_type>
<multivalue>optional</multivalue>
<sem_type>point.y</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
<parameter id="Row2">
<default_type>integer</default_type>
<default_value>200</default_value>
<description lang="en_US">The row coordinate of the end point</description>
<mixed_type>optional</mixed_type>
<multivalue>optional</multivalue>
<sem_type>point.y</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
</parameters>
</docu>
</procedure>
<procedure name="gen_arrow_object_model_3d">
<interface>
<ic>
<par name="ArrowThickness" base_type="ctrl" dimension="0"/>
<par name="ArrowStart" base_type="ctrl" dimension="0"/>
<par name="ArrowEnd" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="OM3DArrow" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c>* </c>
<c>* This procedure draws an arrow that starts at the point ArrowStart and ends at ArrowEnd.</c>
<c>* </c>
<c>* Get parameters.</c>
<l>DirectionVector := ArrowEnd[0:2] - ArrowStart[0:2]</l>
<l>ArrowLength := sqrt(DirectionVector[0] * DirectionVector[0] + DirectionVector[1] * DirectionVector[1] + DirectionVector[2] * DirectionVector[2])</l>
<l>ConeRadius := 2.0 * ArrowThickness</l>
<l>ConeLength := min([2.0 * ConeRadius,ArrowLength * 0.9])</l>
<l>CylinderLength := ArrowLength - ConeLength</l>
<c>* </c>
<c>* Create cone.</c>
<l>pi := rad(180)</l>
<l>X := 0</l>
<l>Y := 0</l>
<l>Z := CylinderLength + ConeLength</l>
<l>for Index := 0 to 2 * pi by 0.1</l>
<l>    X := [X,ConeRadius * cos(Index)]</l>
<l>    Y := [Y,ConeRadius * sin(Index)]</l>
<l>    Z := [Z,CylinderLength]</l>
<l>endfor</l>
<l>gen_object_model_3d_from_points (X, Y, Z, OM3DConeTmp)</l>
<l>convex_hull_object_model_3d (OM3DConeTmp, OM3DCone)</l>
<l>clear_object_model_3d (OM3DConeTmp)</l>
<c>* </c>
<c>* Create cylinder.</c>
<l>X := []</l>
<l>Y := []</l>
<l>for Index := 0 to 2 * pi by 0.1</l>
<l>    X := [X,ArrowThickness * cos(Index)]</l>
<l>    Y := [Y,ArrowThickness * sin(Index)]</l>
<l>endfor</l>
<l>tuple_gen_const (|Y|, 0, ZZero)</l>
<l>tuple_gen_const (|Y|, CylinderLength, ZTop)</l>
<l>gen_object_model_3d_from_points ([X,X], [Y,Y], [ZZero,ZTop], OM3DCylinderTmp)</l>
<l>convex_hull_object_model_3d (OM3DCylinderTmp, OM3DCylinder)</l>
<l>clear_object_model_3d (OM3DCylinderTmp)</l>
<c>* </c>
<c>* Union cone and cylinder Create arrow.</c>
<l>union_object_model_3d ([OM3DCone,OM3DCylinder], 'points_surface', OM3DArrowTmp)</l>
<l>clear_object_model_3d (OM3DCone)</l>
<l>clear_object_model_3d (OM3DCylinder)</l>
<l>Scale := CylinderLength / ArrowLength</l>
<l>OriginX := [0,0,0]</l>
<l>OriginY := [0,0,0]</l>
<l>OriginZ := [0,CylinderLength,ArrowLength]</l>
<l>TargetX := [ArrowStart[0],ArrowStart[0] + Scale * DirectionVector[0],ArrowEnd[0]]</l>
<l>TargetY := [ArrowStart[1],ArrowStart[1] + Scale * DirectionVector[1],ArrowEnd[1]]</l>
<l>TargetZ := [ArrowStart[2],ArrowStart[2] + Scale * DirectionVector[2],ArrowEnd[2]]</l>
<l>vector_to_hom_mat3d ('rigid', OriginX, OriginY, OriginZ, TargetX, TargetY, TargetZ, HomMat3D)</l>
<l>affine_trans_object_model_3d (OM3DArrowTmp, HomMat3D, OM3DArrow)</l>
<l>clear_object_model_3d (OM3DArrowTmp)</l>
<l>return ()</l>
</body>
<docu id="gen_arrow_object_model_3d">
<chapters lang="de_DE">
<item>3D-Objektmodell</item>
<item>Generierung</item>
</chapters>
<chapters lang="en_US">
<item>3D Object Model</item>
<item>Creation</item>
</chapters>
<library lang="en_US">MVTec Standard Procedures</library>
<parameters>
<parameter id="ArrowEnd">
<default_type>real</default_type>
<default_value>[0.05, 0.0, 0.0, 0.0, 0.0, 0.0, 0]</default_value>
<mixed_type>false</mixed_type>
<multivalue>true</multivalue>
<sem_type>pose</sem_type>
<type_list>
<item>real</item>
</type_list>
</parameter>
<parameter id="ArrowStart">
<default_type>real</default_type>
<default_value>[0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0]</default_value>
<mixed_type>false</mixed_type>
<multivalue>true</multivalue>
<sem_type>pose</sem_type>
<type_list>
<item>real</item>
</type_list>
</parameter>
<parameter id="ArrowThickness">
<default_type>real</default_type>
<default_value>0.005</default_value>
<multivalue>false</multivalue>
<sem_type>real</sem_type>
<type_list>
<item>real</item>
</type_list>
</parameter>
<parameter id="OM3DArrow">
<default_type>integer</default_type>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>object_model_3d</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
</parameters>
</docu>
</procedure>
<procedure name="gen_blank_dl_train_samples" access="local">
<interface>
<ic>
<par name="DLModelHandle" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="TrainSamples" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c>* </c>
<c>* This procedure generates blank input data for the given model.</c>
<c>* </c>
<c>* Get model parameters.</c>
<l>get_dl_model_param (DLModelHandle, 'batch_size', BatchSize)</l>
<l>get_dl_model_param (DLModelHandle, 'image_width', ImageWidth)</l>
<l>get_dl_model_param (DLModelHandle, 'image_height', ImageHeight)</l>
<l>get_dl_model_param (DLModelHandle, 'image_num_channels', ImageNumChannels)</l>
<l>get_dl_model_param (DLModelHandle, 'class_ids', ClassIDs)</l>
<l>get_dl_model_param (DLModelHandle, 'type', ModelType)</l>
<c>* </c>
<c>* Collect train inputs.</c>
<l>TrainSamples := []</l>
<c>* </c>
<l>for I := 0 to BatchSize - 1 by 1</l>
<c>    * Create blank image.</c>
<l>    gen_empty_obj (Images)</l>
<l>    for Index := 0 to ImageNumChannels - 1 by 1</l>
<l>        gen_image_const (Image, 'real', ImageWidth, ImageHeight)</l>
<l>        concat_obj (Images, Image, Images)</l>
<l>    endfor</l>
<l>    channels_to_image (Images, Image)</l>
<c>    * </c>
<c>    * Create train data.</c>
<l>    create_dict (TrainInput)</l>
<l>    set_dict_object (Image, TrainInput, 'image')</l>
<c>    * </c>
<c>    * Add model specific blank training data.</c>
<l>    if (ModelType == 'classification')</l>
<c>        * Assign arbitrary label for image.</c>
<l>        set_dict_tuple (TrainInput, 'image_label_id', 0)</l>
<l>    elseif (ModelType == 'detection')</l>
<c>        * Generate blank bounding box labels depending on the instance type.</c>
<l>        InstanceType := 'rectangle1'</l>
<l>        try</l>
<l>            get_dl_model_param (DLModelHandle, 'instance_type', InstanceType)</l>
<l>        catch (Exception)</l>
<l>        endtry</l>
<l>        if (InstanceType == 'rectangle1')</l>
<l>            set_dict_tuple (TrainInput, 'bbox_label_id', [])</l>
<l>            set_dict_tuple (TrainInput, 'bbox_row1', [])</l>
<l>            set_dict_tuple (TrainInput, 'bbox_row2', [])</l>
<l>            set_dict_tuple (TrainInput, 'bbox_col1', [])</l>
<l>            set_dict_tuple (TrainInput, 'bbox_col2', [])</l>
<l>        elseif (InstanceType == 'rectangle2')</l>
<l>            set_dict_tuple (TrainInput, 'bbox_label_id', [])</l>
<l>            set_dict_tuple (TrainInput, 'bbox_row', [])</l>
<l>            set_dict_tuple (TrainInput, 'bbox_col', [])</l>
<l>            set_dict_tuple (TrainInput, 'bbox_length1', [])</l>
<l>            set_dict_tuple (TrainInput, 'bbox_length2', [])</l>
<l>            set_dict_tuple (TrainInput, 'bbox_phi', [])</l>
<l>        else</l>
<l>            throw ('The current instance type is not supported: "' + InstanceType + '"')</l>
<l>        endif</l>
<l>    elseif (ModelType == 'segmentation')</l>
<c>        * Generate blank weights and targets.</c>
<l>        gen_image_const (Target, 'real', ImageWidth, ImageHeight)</l>
<l>        gen_image_const (Weight, 'real', ImageWidth, ImageHeight)</l>
<c>        * Fill with first color background.</c>
<l>        overpaint_region (Target, Target, ClassIDs[0], 'fill')</l>
<l>        overpaint_region (Weight, Weight, 1, 'fill')</l>
<l>        set_dict_object (Target, TrainInput, 'segmentation_image')</l>
<l>        set_dict_object (Weight, TrainInput, 'weight_image')</l>
<l>    else</l>
<l>        throw ('The current model type is not supported: "' + ModelType + '"')</l>
<l>    endif</l>
<l>    TrainSamples := [TrainSamples,TrainInput]</l>
<l>endfor</l>
<l>return ()</l>
</body>
<docu id="gen_blank_dl_train_samples">
<abstract lang="en_US">Create blank train sample dicts for a given model.</abstract>
<chapters lang="de_DE">
<item>Deep Learning</item>
<item>Modell</item>
</chapters>
<chapters lang="en_US">
<item>Deep Learning</item>
<item>Model</item>
</chapters>
<library lang="en_US">MVTec Standard Procedures</library>
<short lang="en_US">Create blank train sample dicts for a given model.</short>
<parameters>
<parameter id="DLModelHandle">
<default_type>integer</default_type>
<description lang="en_US">Model handle to generate the blank samples for. Only 'segmentation' and 'detection' models are supported.</description>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>dl_model</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="TrainSamples">
<default_type>integer</default_type>
<description lang="en_US">This output can be used in an train_dl_model call in combination with the DLModelHandle.</description>
<mixed_type>false</mixed_type>
<multivalue>optional</multivalue>
<sem_type>dict</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
</parameters>
</docu>
</procedure>
<procedure name="gen_bounding_box_object_model_3d">
<interface>
<ic>
<par name="StereoModelID" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="ObjectModel3DBoundingBox" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c>* </c>
<c>* Consistency check:</c>
<l>get_stereo_model_param (StereoModelID, 'bounding_box', BoundingBox)</l>
<l>if ((BoundingBox[3] &lt; BoundingBox[0]) or (BoundingBox[4] &lt; BoundingBox[1]) or (BoundingBox[5] &lt; BoundingBox[2]))</l>
<l>    throw ('Invalid bounding box or bounding box not set yet.')</l>
<l>endif</l>
<c>* </c>
<c>* Get the eight corner points from the min/max representation.</c>
<l>Points := {[]}</l>
<l>Points.at(0) := [BoundingBox[0],BoundingBox[1],BoundingBox[2]]</l>
<l>Points.at(1) := [BoundingBox[3],BoundingBox[1],BoundingBox[2]]</l>
<l>Points.at(2) := [BoundingBox[3],BoundingBox[4],BoundingBox[2]]</l>
<l>Points.at(3) := [BoundingBox[0],BoundingBox[4],BoundingBox[2]]</l>
<l>Points.at(4) := [BoundingBox[0],BoundingBox[1],BoundingBox[5]]</l>
<l>Points.at(5) := [BoundingBox[3],BoundingBox[1],BoundingBox[5]]</l>
<l>Points.at(6) := [BoundingBox[3],BoundingBox[4],BoundingBox[5]]</l>
<l>Points.at(7) := [BoundingBox[0],BoundingBox[4],BoundingBox[5]]</l>
<c>* </c>
<c>* Sort the corner points by coordinate direction.</c>
<l>PX := []</l>
<l>PY := []</l>
<l>PZ := []</l>
<l>for Index := 0 to 7 by 1</l>
<l>    PX := [PX,Points.at(Index)[0]]</l>
<l>    PY := [PY,Points.at(Index)[1]]</l>
<l>    PZ := [PZ,Points.at(Index)[2]]</l>
<l>endfor</l>
<l>gen_object_model_3d_from_points (PX, PY, PZ, ObjectModel3DBoundingBox)</l>
<c>* </c>
<c>* Set the sides of the cuboid.</c>
<l>Faces := []</l>
<l>Faces := [Faces,4,0,1,5,4]</l>
<l>Faces := [Faces,4,1,2,6,5]</l>
<l>Faces := [Faces,4,2,3,7,6]</l>
<l>Faces := [Faces,4,3,0,4,7]</l>
<l>Faces := [Faces,4,0,1,2,3]</l>
<l>Faces := [Faces,4,4,5,6,7]</l>
<l>set_object_model_3d_attrib_mod (ObjectModel3DBoundingBox, 'polygons', [], Faces)</l>
<l>return ()</l>
</body>
<docu id="gen_bounding_box_object_model_3d">
<abstract lang="en_US">The procedure gen_bounding_box_object_model_3d generates a 3D object model which visualizes the bounding box of a stereo model. The extent of the bounding box is also returned. 

The procedure can be used, e.g., to visualize the setup of the stereo model with its bounding box and cameras which is particularly helpful while adjusting the bounding box. The procedure gen_camera_setup_object_model_3d creates the according 3D object models for cameras and their cones of sight.

Note that if a 3D object model is no longer needed or should be overwritten, the memory has to be freed first by calling the operator clear_object_model_3d.
</abstract>
<chapters lang="de_DE">
<item>3D-Objektmodell</item>
<item>Generierung</item>
</chapters>
<chapters lang="en_US">
<item>3D Object Model</item>
<item>Creation</item>
</chapters>
<example lang="en_US">dev_open_window (0, 0, 512, 512, 'black', WindowHandle)
* Prepare camera setup and stereo model.
read_camera_setup_model ('cam_setup_model.csm', CameraSetupModelID)
create_stereo_model (CameraSetupModelID, 'surface_fusion', [], [], StereoModelID)
set_stereo_model_image_pairs (StereoModelID, [1, 2], [0, 0])
* Estimate and set bounding box automatically.
estimate_bounding_box_3d_reconstruction (StereoModelID, 0.06, BoundingBox)
set_stereo_model_param (StereoModelID, 'bounding_box', BoundingBox)
* Create and visualize object models that represent the setup.
gen_camera_setup_object_model_3d (CameraSetupModelID, 'auto', 'auto', ObjectModel3DCamera, ObjectModel3DCone)
gen_bounding_box_object_model_3d (StereoModelID, ObjectModel3DBoundingBox)
visualize_object_model_3d (WindowHandle, [ObjectModel3DBoundingBox, ObjectModel3DCamera, ObjectModel3DCone], [], [], ['color_0', 'alpha'], ['red', 0.5], [], [],[] , Pose)</example>
<library lang="de_DE">MVTec Standard Procedures</library>
<library lang="en_US">MVTec Standard Procedures</library>
<predecessor>
<item>create_stereo_model</item>
<item>set_stereo_model_param</item>
</predecessor>
<see_also>
<item>reconstruct_surface_stereo</item>
</see_also>
<short lang="en_US">Generate a 3D object model which visualizes the bounding box of a stereo model.</short>
<successor>
<item>visualize_object_model_3d</item>
<item>dev_inspect_ctrl</item>
</successor>
<parameters>
<parameter id="ObjectModel3DBoundingBox">
<default_type>integer</default_type>
<description lang="en_US">Handle of the 3D object model.</description>
<mixed_type>false</mixed_type>
<sem_type>object_model_3d</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="StereoModelID">
<default_type>integer</default_type>
<description lang="en_US">Handle of the stereo model.</description>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>stereo_model</sem_type>
<type_list>
<item>integer</item>
</type_list>
<value_min>0</value_min>
</parameter>
</parameters>
</docu>
</procedure>
<procedure name="gen_cam_par_area_scan_division">
<interface>
<ic>
<par name="Focus" base_type="ctrl" dimension="0"/>
<par name="Kappa" base_type="ctrl" dimension="0"/>
<par name="Sx" base_type="ctrl" dimension="0"/>
<par name="Sy" base_type="ctrl" dimension="0"/>
<par name="Cx" base_type="ctrl" dimension="0"/>
<par name="Cy" base_type="ctrl" dimension="0"/>
<par name="ImageWidth" base_type="ctrl" dimension="0"/>
<par name="ImageHeight" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="CameraParam" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c>* Generate a camera parameter tuple for an area scan camera</c>
<c>* with distortions modeled by the division model.</c>
<c>* </c>
<l>CameraParam := ['area_scan_division',Focus,Kappa,Sx,Sy,Cx,Cy,ImageWidth,ImageHeight]</l>
<l>return ()</l>
</body>
<docu id="gen_cam_par_area_scan_division">
<abstract lang="en_US">gen_cam_par_area_scan_division generates the camera parameter tuple CameraParam for an area scan camera with distortions modeled by the division model.  For this, the camera parameters must be passed in Focus (m), Kappa (m^-2), Sx (m/px), Sy (m/px), Cx (px), Cy (px), ImageWidth (px), and ImageHeight (px), where we indicate the HALCON default units in brackets. For a detailed explanation of the parameters, see the reference manual chapter Calibration / Multi-View.</abstract>
<chapters lang="de_DE">
<item>Kalibrierung</item>
<item>Kameraparameter</item>
</chapters>
<chapters lang="en_US">
<item>Calibration</item>
<item>Camera Parameters</item>
</chapters>
<keywords lang="de_DE">
<item>Kameraparameter kalibrieren</item>
<item>Kamera-Kalibrierparameter erhalten</item>
<item>Kameramodell</item>
<item>interne Kameraparameter</item>
<item>interne Kameraparameter kalibrieren</item>
<item>kalibrierte interne Kameraparameter erhalten</item>
</keywords>
<keywords lang="en_US">
<item>camera calibration parameters</item>
<item>camera calibration result</item>
<item>calibrate camera parameters</item>
<item>calibrate internal camera parameters</item>
<item>calibrated internal camera parameters</item>
</keywords>
<library lang="en_US">MVTec Standard Procedures</library>
<see_also>
<item>calibrate_cameras</item>
<item>get_cam_par_data</item>
<item>set_cam_par_data</item>
<item>get_cam_par_names</item>
<item>gen_cam_par_area_scan_polynomial</item>
<item>gen_cam_par_area_scan_telecentric_division</item>
<item>gen_cam_par_area_scan_telecentric_polynomial</item>
<item>gen_cam_par_area_scan_tilt_division</item>
<item>gen_cam_par_area_scan_tilt_polynomial</item>
<item>gen_cam_par_area_scan_tilt_image_side_telecentric_division</item>
<item>gen_cam_par_area_scan_tilt_image_side_telecentric_polynomial</item>
<item>gen_cam_par_area_scan_tilt_bilateral_telecentric_division</item>
<item>gen_cam_par_area_scan_tilt_bilateral_telecentric_polynomial</item>
<item>gen_cam_par_area_scan_tilt_object_side_telecentric_division</item>
<item>gen_cam_par_area_scan_tilt_object_side_telecentric_polynomial</item>
<item>gen_cam_par_area_scan_hypercentric_division</item>
<item>gen_cam_par_area_scan_hypercentric_polynomial</item>
<item>gen_cam_par_line_scan_division</item>
<item>gen_cam_par_line_scan_polynomial</item>
<item>gen_cam_par_line_scan_telecentric_division</item>
<item>gen_cam_par_line_scan_telecentric_polynomial</item>
</see_also>
<short lang="en_US">Generate a camera parameter tuple for an area scan camera with distortions modeled by the division model.</short>
<successor>
<item>set_calib_data_cam_param</item>
</successor>
<parameters>
<parameter id="CameraParam">
<default_type>real</default_type>
<description lang="en_US">Output camera parameter tuple.</description>
<mixed_type>optional</mixed_type>
<multivalue>true</multivalue>
<sem_type>campar</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
<item>string</item>
</type_list>
</parameter>
<parameter id="Cx">
<default_type>real</default_type>
<default_value>640</default_value>
<description lang="en_US">Column coordinate of the principal point in the image.</description>
<multivalue>false</multivalue>
<sem_type>real</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
<parameter id="Cy">
<default_type>real</default_type>
<default_value>512</default_value>
<description lang="en_US">Row coordinate of the principal point in the image.</description>
<multivalue>false</multivalue>
<sem_type>real</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
<parameter id="Focus">
<default_type>real</default_type>
<default_value>0.008</default_value>
<description lang="en_US">Principal distance.</description>
<multivalue>false</multivalue>
<sem_type>real</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
<parameter id="ImageHeight">
<default_type>integer</default_type>
<default_value>1024</default_value>
<description lang="en_US">Image height.</description>
<multivalue>false</multivalue>
<sem_type>integer</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="ImageWidth">
<default_type>integer</default_type>
<default_value>1280</default_value>
<description lang="en_US">Image width.</description>
<multivalue>false</multivalue>
<sem_type>integer</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="Kappa">
<default_type>real</default_type>
<default_value>0.0</default_value>
<description lang="en_US">Distortion coefficient to model the radial lens distortions.</description>
<multivalue>false</multivalue>
<sem_type>real</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
<parameter id="Sx">
<default_type>real</default_type>
<default_value>5.2e-6</default_value>
<description lang="en_US">Horizontal distance between two neighboring cells on the sensor.</description>
<multivalue>false</multivalue>
<sem_type>real</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
<parameter id="Sy">
<default_type>real</default_type>
<default_value>5.2e-6</default_value>
<description lang="en_US">Vertical distance between two neighboring cells on the sensor.</description>
<multivalue>false</multivalue>
<sem_type>real</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
</parameters>
</docu>
</procedure>
<procedure name="gen_cam_par_area_scan_hypercentric_division">
<interface>
<ic>
<par name="Focus" base_type="ctrl" dimension="0"/>
<par name="Kappa" base_type="ctrl" dimension="0"/>
<par name="Sx" base_type="ctrl" dimension="0"/>
<par name="Sy" base_type="ctrl" dimension="0"/>
<par name="Cx" base_type="ctrl" dimension="0"/>
<par name="Cy" base_type="ctrl" dimension="0"/>
<par name="ImageWidth" base_type="ctrl" dimension="0"/>
<par name="ImageHeight" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="CameraParam" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c>* Generate a camera parameter tuple for an area scan camera</c>
<c>* with a hypercentric lens and with distortions modeled by the</c>
<c>* division model.</c>
<c>* </c>
<l>CameraParam := ['area_scan_hypercentric_division',Focus,Kappa,Sx,Sy,Cx,Cy,ImageWidth,ImageHeight]</l>
<l>return ()</l>
</body>
<docu id="gen_cam_par_area_scan_hypercentric_division">
<abstract lang="en_US">gen_cam_par_area_scan_hypercentric_division generates the camera parameter tuple CameraParam for an area scan camera with a hypercentric lens with distortions modeled by the division model.  For this, the camera parameters must be passed in Focus (m), Kappa (m^-2), Sx (m/px), Sy (m/px), Cx (px), Cy (px), ImageWidth (px), and ImageHeight (px), where we indicate the HALCON default units in brackets. For a detailed explanation of the parameters, see the reference manual chapter Calibration / Multi-View.</abstract>
<chapters lang="de_DE">
<item>Kalibrierung</item>
<item>Kameraparameter</item>
</chapters>
<chapters lang="en_US">
<item>Calibration</item>
<item>Camera Parameters</item>
</chapters>
<keywords lang="de_DE">
<item>Kameraparameter kalibrieren</item>
<item>Kamera-Kalibrierparameter erhalten</item>
<item>Kameramodell</item>
<item>interne Kameraparameter</item>
<item>interne Kameraparameter kalibrieren</item>
<item>kalibrierte interne Kameraparameter erhalten</item>
</keywords>
<keywords lang="en_US">
<item>camera calibration parameters</item>
<item>camera calibration result</item>
<item>calibrate camera parameters</item>
<item>calibrate internal camera parameters</item>
<item>calibrated internal camera parameters</item>
</keywords>
<library lang="en_US">MVTec Standard Procedures</library>
<see_also>
<item>calibrate_cameras</item>
<item>get_cam_par_data</item>
<item>set_cam_par_data</item>
<item>get_cam_par_names</item>
<item>gen_cam_par_area_scan_division</item>
<item>gen_cam_par_area_scan_polynomial</item>
<item>gen_cam_par_area_scan_telecentric_division</item>
<item>gen_cam_par_area_scan_telecentric_polynomial</item>
<item>gen_cam_par_area_scan_tilt_division</item>
<item>gen_cam_par_area_scan_tilt_polynomial</item>
<item>gen_cam_par_area_scan_tilt_image_side_telecentric_division</item>
<item>gen_cam_par_area_scan_tilt_image_side_telecentric_polynomial</item>
<item>gen_cam_par_area_scan_tilt_bilateral_telecentric_division</item>
<item>gen_cam_par_area_scan_tilt_bilateral_telecentric_polynomial</item>
<item>gen_cam_par_area_scan_tilt_object_side_telecentric_division</item>
<item>gen_cam_par_area_scan_tilt_object_side_telecentric_polynomial</item>
<item>gen_cam_par_area_scan_hypercentric_polynomial</item>
<item>gen_cam_par_line_scan_division</item>
<item>gen_cam_par_line_scan_polynomial</item>
<item>gen_cam_par_line_scan_telecentric_division</item>
<item>gen_cam_par_line_scan_telecentric_polynomial</item>
</see_also>
<short lang="en_US">Generate a camera parameter tuple for an area scan camera with distortions modeled by the division model.</short>
<successor>
<item>set_calib_data_cam_param</item>
</successor>
<parameters>
<parameter id="CameraParam">
<default_type>real</default_type>
<description lang="en_US">Output camera parameter tuple.</description>
<mixed_type>optional</mixed_type>
<multivalue>true</multivalue>
<sem_type>campar</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
<item>string</item>
</type_list>
</parameter>
<parameter id="Cx">
<default_type>real</default_type>
<default_value>640</default_value>
<description lang="en_US">Column coordinate of the principal point in the image.</description>
<multivalue>false</multivalue>
<sem_type>real</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
<parameter id="Cy">
<default_type>real</default_type>
<default_value>512</default_value>
<description lang="en_US">Row coordinate of the principal point in the image.</description>
<multivalue>false</multivalue>
<sem_type>real</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
<parameter id="Focus">
<default_type>real</default_type>
<default_value>0.008</default_value>
<description lang="en_US">Principal distance.</description>
<multivalue>false</multivalue>
<sem_type>real</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
<parameter id="ImageHeight">
<default_type>integer</default_type>
<default_value>1024</default_value>
<description lang="en_US">Image height.</description>
<multivalue>false</multivalue>
<sem_type>integer</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="ImageWidth">
<default_type>integer</default_type>
<default_value>1280</default_value>
<description lang="en_US">Image width.</description>
<multivalue>false</multivalue>
<sem_type>integer</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="Kappa">
<default_type>real</default_type>
<default_value>0.0</default_value>
<description lang="en_US">Distortion coefficient to model the radial lens distortions.</description>
<multivalue>false</multivalue>
<sem_type>real</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
<parameter id="Sx">
<default_type>real</default_type>
<default_value>5.2e-6</default_value>
<description lang="en_US">Horizontal distance between two neighboring cells on the sensor.</description>
<multivalue>false</multivalue>
<sem_type>real</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
<parameter id="Sy">
<default_type>real</default_type>
<default_value>5.2e-6</default_value>
<description lang="en_US">Vertical distance between two neighboring cells on the sensor.</description>
<multivalue>false</multivalue>
<sem_type>real</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
</parameters>
</docu>
</procedure>
<procedure name="gen_cam_par_area_scan_hypercentric_polynomial">
<interface>
<ic>
<par name="Focus" base_type="ctrl" dimension="0"/>
<par name="K1" base_type="ctrl" dimension="0"/>
<par name="K2" base_type="ctrl" dimension="0"/>
<par name="K3" base_type="ctrl" dimension="0"/>
<par name="P1" base_type="ctrl" dimension="0"/>
<par name="P2" base_type="ctrl" dimension="0"/>
<par name="Sx" base_type="ctrl" dimension="0"/>
<par name="Sy" base_type="ctrl" dimension="0"/>
<par name="Cx" base_type="ctrl" dimension="0"/>
<par name="Cy" base_type="ctrl" dimension="0"/>
<par name="ImageWidth" base_type="ctrl" dimension="0"/>
<par name="ImageHeight" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="CameraParam" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c>* Generate a camera parameter tuple for an area scan camera</c>
<c>* with a hypercentric lens and with distortions modeled by the</c>
<c>* polynomial model.</c>
<c>* </c>
<l>CameraParam := ['area_scan_hypercentric_polynomial',Focus,K1,K2,K3,P1,P2,Sx,Sy,Cx,Cy,ImageWidth,ImageHeight]</l>
<l>return ()</l>
</body>
<docu id="gen_cam_par_area_scan_hypercentric_polynomial">
<abstract lang="en_US">gen_cam_par_area_scan_polynomial generates the camera parameter tuple CameraParam for an area scan camera with a hypercentric lens and with distortions modeled by the polynomial model. For this, the camera parameters must be passed in Focus (m), K1 (m^-2), K2 (m^-4), K3 (m^-6), P1 (m^-1), P2 (m^-1), Sx (m/px), Sy (m/px), Cx (px), Cy (px), ImageWidth (px), and ImageHeight (px), where we indicate the HALCON default units in brackets. For a detailed explanation of the parameters, see the reference manual chapter Calibration / Multi-View.</abstract>
<chapters lang="de_DE">
<item>Kalibrierung</item>
<item>Kameraparameter</item>
</chapters>
<chapters lang="en_US">
<item>Calibration</item>
<item>Camera Parameters</item>
</chapters>
<keywords lang="de_DE">
<item>Kameraparameter kalibrieren</item>
<item>Kamera-Kalibrierparameter erhalten</item>
<item>Kameramodell</item>
<item>interne Kameraparameter</item>
<item>interne Kameraparameter kalibrieren</item>
<item>kalibrierte interne Kameraparameter erhalten</item>
</keywords>
<keywords lang="en_US">
<item>camera calibration parameters</item>
<item>camera calibration result</item>
<item>calibrate camera parameters</item>
<item>calibrate internal camera parameters</item>
<item>calibrated internal camera parameters</item>
</keywords>
<library lang="en_US">MVTec Standard Procedures</library>
<see_also>
<item>calibrate_cameras</item>
<item>get_cam_par_data</item>
<item>set_cam_par_data</item>
<item>get_cam_par_names</item>
<item>gen_cam_par_area_scan_division</item>
<item>gen_cam_par_area_scan_telecentric_division</item>
<item>gen_cam_par_area_scan_telecentric_polynomial</item>
<item>gen_cam_par_area_scan_tilt_division</item>
<item>gen_cam_par_area_scan_tilt_polynomial</item>
<item>gen_cam_par_area_scan_tilt_image_side_telecentric_division</item>
<item>gen_cam_par_area_scan_tilt_image_side_telecentric_polynomial</item>
<item>gen_cam_par_area_scan_tilt_bilateral_telecentric_division</item>
<item>gen_cam_par_area_scan_tilt_bilateral_telecentric_polynomial</item>
<item>gen_cam_par_area_scan_tilt_object_side_telecentric_division</item>
<item>gen_cam_par_area_scan_tilt_object_side_telecentric_polynomial</item>
<item>gen_cam_par_area_scan_hypercentric_division</item>
<item>gen_cam_par_line_scan_division</item>
<item>gen_cam_par_line_scan_polynomial</item>
<item>gen_cam_par_line_scan_telecentric_division</item>
<item>gen_cam_par_line_scan_telecentric_polynomial</item>
</see_also>
<short lang="en_US">Generate a camera parameter tuple for an area scan camera with a hypercentric lens and with distortions modeled by the polynomial model.</short>
<successor>
<item>set_calib_data_cam_param</item>
</successor>
<parameters>
<parameter id="CameraParam">
<default_type>real</default_type>
<description lang="en_US">Output camera parameter tuple.</description>
<mixed_type>optional</mixed_type>
<multivalue>true</multivalue>
<sem_type>campar</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
<item>string</item>
</type_list>
</parameter>
<parameter id="Cx">
<default_type>real</default_type>
<default_value>640</default_value>
<description lang="en_US">Column coordinate of the principal point in the image.</description>
<multivalue>false</multivalue>
<sem_type>real</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
<parameter id="Cy">
<default_type>real</default_type>
<default_value>512</default_value>
<description lang="en_US">Row coordinate of the principal point in the image.</description>
<multivalue>false</multivalue>
<sem_type>real</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
<parameter id="Focus">
<default_type>real</default_type>
<default_value>0.008</default_value>
<description lang="en_US">Principal distance.</description>
<multivalue>false</multivalue>
<sem_type>real</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
<parameter id="ImageHeight">
<default_type>integer</default_type>
<default_value>1024</default_value>
<description lang="en_US">Image height.</description>
<multivalue>false</multivalue>
<sem_type>integer</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="ImageWidth">
<default_type>integer</default_type>
<default_value>1280</default_value>
<description lang="en_US">Image width.</description>
<multivalue>false</multivalue>
<sem_type>integer</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="K1">
<default_type>real</default_type>
<default_value>0.0</default_value>
<description lang="en_US">Distortion coefficient to model radial lens distortions.</description>
<multivalue>false</multivalue>
<sem_type>real</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
<parameter id="K2">
<default_type>real</default_type>
<default_value>0.0</default_value>
<description lang="en_US">Distortion coefficient to model radial lens distortions.</description>
<multivalue>false</multivalue>
<sem_type>real</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
<parameter id="K3">
<default_type>real</default_type>
<default_value>0.0</default_value>
<description lang="en_US">Distortion coefficient to model radial lens distortions.</description>
<multivalue>false</multivalue>
<sem_type>real</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
<parameter id="P1">
<default_type>real</default_type>
<default_value>0.0</default_value>
<description lang="en_US">Distortion coefficient to model decentering lens distortions.</description>
<multivalue>false</multivalue>
<sem_type>real</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
<parameter id="P2">
<default_type>real</default_type>
<default_value>0.0</default_value>
<description lang="en_US">Distortion coefficient to model decentering lens distortions.</description>
<multivalue>false</multivalue>
<sem_type>real</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
<parameter id="Sx">
<default_type>real</default_type>
<default_value>5.2e-6</default_value>
<description lang="en_US">Horizontal distance between two neighboring cells on the sensor.</description>
<multivalue>false</multivalue>
<sem_type>real</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
<parameter id="Sy">
<default_type>real</default_type>
<default_value>5.2e-6</default_value>
<description lang="en_US">Vertical distance between two neighboring cells on the sensor.</description>
<multivalue>false</multivalue>
<sem_type>real</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
</parameters>
</docu>
</procedure>
<procedure name="gen_cam_par_area_scan_polynomial">
<interface>
<ic>
<par name="Focus" base_type="ctrl" dimension="0"/>
<par name="K1" base_type="ctrl" dimension="0"/>
<par name="K2" base_type="ctrl" dimension="0"/>
<par name="K3" base_type="ctrl" dimension="0"/>
<par name="P1" base_type="ctrl" dimension="0"/>
<par name="P2" base_type="ctrl" dimension="0"/>
<par name="Sx" base_type="ctrl" dimension="0"/>
<par name="Sy" base_type="ctrl" dimension="0"/>
<par name="Cx" base_type="ctrl" dimension="0"/>
<par name="Cy" base_type="ctrl" dimension="0"/>
<par name="ImageWidth" base_type="ctrl" dimension="0"/>
<par name="ImageHeight" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="CameraParam" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c>* Generate a camera parameter tuple for an area scan camera</c>
<c>* with distortions modeled by the polynomial model.</c>
<c>* </c>
<l>CameraParam := ['area_scan_polynomial',Focus,K1,K2,K3,P1,P2,Sx,Sy,Cx,Cy,ImageWidth,ImageHeight]</l>
<l>return ()</l>
</body>
<docu id="gen_cam_par_area_scan_polynomial">
<abstract lang="en_US">gen_cam_par_area_scan_polynomial generates the camera parameter tuple CameraParam for an area scan camera with distortions modeled by the polynomial model. For this, the camera parameters must be passed in Focus (m), K1 (m^-2), K2 (m^-4), K3 (m^-6), P1 (m^-1), P2 (m^-1), Sx (m/px), Sy (m/px), Cx (px), Cy (px), ImageWidth (px), and ImageHeight (px), where we indicate the HALCON default units in brackets.. For a detailed explanation of the parameters, see the reference manual chapter Calibration / Multi-View.</abstract>
<chapters lang="de_DE">
<item>Kalibrierung</item>
<item>Kameraparameter</item>
</chapters>
<chapters lang="en_US">
<item>Calibration</item>
<item>Camera Parameters</item>
</chapters>
<keywords lang="de_DE">
<item>Kameraparameter kalibrieren</item>
<item>Kamera-Kalibrierparameter erhalten</item>
<item>Kameramodell</item>
<item>interne Kameraparameter</item>
<item>interne Kameraparameter kalibrieren</item>
<item>kalibrierte interne Kameraparameter erhalten</item>
</keywords>
<keywords lang="en_US">
<item>camera calibration parameters</item>
<item>camera calibration result</item>
<item>calibrate camera parameters</item>
<item>calibrate internal camera parameters</item>
<item>calibrated internal camera parameters</item>
</keywords>
<library lang="en_US">MVTec Standard Procedures</library>
<see_also>
<item>calibrate_cameras</item>
<item>get_cam_par_data</item>
<item>set_cam_par_data</item>
<item>get_cam_par_names</item>
<item>gen_cam_par_area_scan_division</item>
<item>gen_cam_par_area_scan_telecentric_division</item>
<item>gen_cam_par_area_scan_telecentric_polynomial</item>
<item>gen_cam_par_area_scan_tilt_division</item>
<item>gen_cam_par_area_scan_tilt_polynomial</item>
<item>gen_cam_par_area_scan_tilt_image_side_telecentric_division</item>
<item>gen_cam_par_area_scan_tilt_image_side_telecentric_polynomial</item>
<item>gen_cam_par_area_scan_tilt_bilateral_telecentric_division</item>
<item>gen_cam_par_area_scan_tilt_bilateral_telecentric_polynomial</item>
<item>gen_cam_par_area_scan_tilt_object_side_telecentric_division</item>
<item>gen_cam_par_area_scan_tilt_object_side_telecentric_polynomial</item>
<item>gen_cam_par_area_scan_hypercentric_division</item>
<item>gen_cam_par_area_scan_hypercentric_polynomial</item>
<item>gen_cam_par_line_scan_division</item>
<item>gen_cam_par_line_scan_polynomial</item>
<item>gen_cam_par_line_scan_telecentric_division</item>
<item>gen_cam_par_line_scan_telecentric_polynomial</item>
</see_also>
<short lang="en_US">Generate a camera parameter tuple for an area scan camera with distortions modeled by the polynomial model.</short>
<successor>
<item>set_calib_data_cam_param</item>
</successor>
<parameters>
<parameter id="CameraParam">
<default_type>real</default_type>
<description lang="en_US">Output camera parameter tuple.</description>
<mixed_type>optional</mixed_type>
<multivalue>true</multivalue>
<sem_type>campar</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
<item>string</item>
</type_list>
</parameter>
<parameter id="Cx">
<default_type>real</default_type>
<default_value>640</default_value>
<description lang="en_US">Column coordinate of the principal point in the image.</description>
<multivalue>false</multivalue>
<sem_type>real</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
<parameter id="Cy">
<default_type>real</default_type>
<default_value>512</default_value>
<description lang="en_US">Row coordinate of the principal point in the image.</description>
<multivalue>false</multivalue>
<sem_type>real</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
<parameter id="Focus">
<default_type>real</default_type>
<default_value>0.008</default_value>
<description lang="en_US">Principal distance.</description>
<multivalue>false</multivalue>
<sem_type>real</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
<parameter id="ImageHeight">
<default_type>integer</default_type>
<default_value>1024</default_value>
<description lang="en_US">Image height.</description>
<multivalue>false</multivalue>
<sem_type>integer</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="ImageWidth">
<default_type>integer</default_type>
<default_value>1280</default_value>
<description lang="en_US">Image width.</description>
<multivalue>false</multivalue>
<sem_type>integer</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="K1">
<default_type>real</default_type>
<default_value>0.0</default_value>
<description lang="en_US">Distortion coefficient to model radial lens distortions.</description>
<multivalue>false</multivalue>
<sem_type>real</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
<parameter id="K2">
<default_type>real</default_type>
<default_value>0.0</default_value>
<description lang="en_US">Distortion coefficient to model radial lens distortions.</description>
<multivalue>false</multivalue>
<sem_type>real</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
<parameter id="K3">
<default_type>real</default_type>
<default_value>0.0</default_value>
<description lang="en_US">Distortion coefficient to model radial lens distortions.</description>
<multivalue>false</multivalue>
<sem_type>real</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
<parameter id="P1">
<default_type>real</default_type>
<default_value>0.0</default_value>
<description lang="en_US">Distortion coefficient to model decentering lens distortions.</description>
<multivalue>false</multivalue>
<sem_type>real</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
<parameter id="P2">
<default_type>real</default_type>
<default_value>0.0</default_value>
<description lang="en_US">Distortion coefficient to model decentering lens distortions.</description>
<multivalue>false</multivalue>
<sem_type>real</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
<parameter id="Sx">
<default_type>real</default_type>
<default_value>5.2e-6</default_value>
<description lang="en_US">Horizontal distance between two neighboring cells on the sensor.</description>
<multivalue>false</multivalue>
<sem_type>real</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
<parameter id="Sy">
<default_type>real</default_type>
<default_value>5.2e-6</default_value>
<description lang="en_US">Vertical distance between two neighboring cells on the sensor.</description>
<multivalue>false</multivalue>
<sem_type>real</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
</parameters>
</docu>
</procedure>
<procedure name="gen_cam_par_area_scan_telecentric_division">
<interface>
<ic>
<par name="Magnification" base_type="ctrl" dimension="0"/>
<par name="Kappa" base_type="ctrl" dimension="0"/>
<par name="Sx" base_type="ctrl" dimension="0"/>
<par name="Sy" base_type="ctrl" dimension="0"/>
<par name="Cx" base_type="ctrl" dimension="0"/>
<par name="Cy" base_type="ctrl" dimension="0"/>
<par name="ImageWidth" base_type="ctrl" dimension="0"/>
<par name="ImageHeight" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="CameraParam" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c>* Generate a camera parameter tuple for an area scan camera</c>
<c>* with a telecentric lens and with distortions modeled by the</c>
<c>* division model.</c>
<c>* </c>
<l>CameraParam := ['area_scan_telecentric_division',Magnification,Kappa,Sx,Sy,Cx,Cy,ImageWidth,ImageHeight]</l>
<l>return ()</l>
</body>
<docu id="gen_cam_par_area_scan_telecentric_division">
<abstract lang="en_US">gen_cam_par_area_scan_telecentric_division generates the camera parameter tuple CameraParam for an area scan camera with a telecentric lens and with distortions modeled by the division model. For this, the camera parameters must be passed in Magnification (-), Kappa (m^-2), Sx (m/px), Sy (m/px), Cx (px), Cy (px), ImageWidth (px), and ImageHeight (px), where we indicate the HALCON default units in brackets. For a detailed explanation of the parameters, see the reference manual chapter Calibration / Multi-View.</abstract>
<chapters lang="de_DE">
<item>Kalibrierung</item>
<item>Kameraparameter</item>
</chapters>
<chapters lang="en_US">
<item>Calibration</item>
<item>Camera Parameters</item>
</chapters>
<keywords lang="de_DE">
<item>Kameraparameter kalibrieren</item>
<item>Kamera-Kalibrierparameter erhalten</item>
<item>Kameramodell</item>
<item>interne Kameraparameter</item>
<item>interne Kameraparameter kalibrieren</item>
<item>kalibrierte interne Kameraparameter erhalten</item>
</keywords>
<keywords lang="en_US">
<item>camera calibration parameters</item>
<item>camera calibration result</item>
<item>calibrate camera parameters</item>
<item>calibrate internal camera parameters</item>
<item>calibrated internal camera parameters</item>
</keywords>
<library lang="en_US">MVTec Standard Procedures</library>
<see_also>
<item>calibrate_cameras</item>
<item>get_cam_par_data</item>
<item>set_cam_par_data</item>
<item>get_cam_par_names</item>
<item>gen_cam_par_area_scan_division</item>
<item>gen_cam_par_area_scan_polynomial</item>
<item>gen_cam_par_area_scan_telecentric_polynomial</item>
<item>gen_cam_par_area_scan_tilt_division</item>
<item>gen_cam_par_area_scan_tilt_polynomial</item>
<item>gen_cam_par_area_scan_tilt_image_side_telecentric_division</item>
<item>gen_cam_par_area_scan_tilt_image_side_telecentric_polynomial</item>
<item>gen_cam_par_area_scan_tilt_bilateral_telecentric_division</item>
<item>gen_cam_par_area_scan_tilt_bilateral_telecentric_polynomial</item>
<item>gen_cam_par_area_scan_tilt_object_side_telecentric_division</item>
<item>gen_cam_par_area_scan_tilt_object_side_telecentric_polynomial</item>
<item>gen_cam_par_area_scan_hypercentric_division</item>
<item>gen_cam_par_area_scan_hypercentric_polynomial</item>
<item>gen_cam_par_line_scan_division</item>
<item>gen_cam_par_line_scan_polynomial</item>
<item>gen_cam_par_line_scan_telecentric_division</item>
<item>gen_cam_par_line_scan_telecentric_polynomial</item>
</see_also>
<short lang="en_US">Generate a camera parameter tuple for an area scan camera with a telecentric lens and with distortions modeled by the division model.</short>
<successor>
<item>set_calib_data_cam_param</item>
</successor>
<parameters>
<parameter id="CameraParam">
<default_type>real</default_type>
<description lang="en_US">Output camera parameter tuple.</description>
<mixed_type>optional</mixed_type>
<multivalue>true</multivalue>
<sem_type>campar</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
<item>string</item>
</type_list>
</parameter>
<parameter id="Cx">
<default_type>real</default_type>
<default_value>640</default_value>
<description lang="en_US">Column coordinate of the principal point in the image.</description>
<multivalue>false</multivalue>
<sem_type>real</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
<parameter id="Cy">
<default_type>real</default_type>
<default_value>512</default_value>
<description lang="en_US">Row coordinate of the principal point in the image.</description>
<multivalue>false</multivalue>
<sem_type>real</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
<parameter id="ImageHeight">
<default_type>integer</default_type>
<default_value>1024</default_value>
<description lang="en_US">Image height.</description>
<multivalue>false</multivalue>
<sem_type>integer</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="ImageWidth">
<default_type>integer</default_type>
<default_value>1280</default_value>
<description lang="en_US">Image width.</description>
<multivalue>false</multivalue>
<sem_type>integer</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="Kappa">
<default_type>real</default_type>
<default_value>0.0</default_value>
<description lang="en_US">Distortion coefficient to model the radial lens distortions.</description>
<multivalue>false</multivalue>
<sem_type>real</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
<parameter id="Magnification">
<default_type>real</default_type>
<default_value>0.2</default_value>
<description lang="en_US">Magnification of the lens.</description>
<multivalue>false</multivalue>
<sem_type>real</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
<values>
<item>0.1</item>
<item>0.2</item>
<item>0.3</item>
<item>0.4</item>
<item>0.5</item>
<item>1.0</item>
<item>2.0</item>
</values>
</parameter>
<parameter id="Sx">
<default_type>real</default_type>
<default_value>5.2e-6</default_value>
<description lang="en_US">Horizontal size of a pixel in world coordinates.</description>
<multivalue>false</multivalue>
<sem_type>real</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
<parameter id="Sy">
<default_type>real</default_type>
<default_value>5.2e-6</default_value>
<description lang="en_US">Vertical size of a pixel in world coordinates.</description>
<multivalue>false</multivalue>
<sem_type>real</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
</parameters>
</docu>
</procedure>
<procedure name="gen_cam_par_area_scan_telecentric_polynomial">
<interface>
<ic>
<par name="Magnification" base_type="ctrl" dimension="0"/>
<par name="K1" base_type="ctrl" dimension="0"/>
<par name="K2" base_type="ctrl" dimension="0"/>
<par name="K3" base_type="ctrl" dimension="0"/>
<par name="P1" base_type="ctrl" dimension="0"/>
<par name="P2" base_type="ctrl" dimension="0"/>
<par name="Sx" base_type="ctrl" dimension="0"/>
<par name="Sy" base_type="ctrl" dimension="0"/>
<par name="Cx" base_type="ctrl" dimension="0"/>
<par name="Cy" base_type="ctrl" dimension="0"/>
<par name="ImageWidth" base_type="ctrl" dimension="0"/>
<par name="ImageHeight" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="CameraParam" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c>* Generate a camera parameter tuple for an area scan camera</c>
<c>* with a telecentric lens and with distortions modeled by the</c>
<c>* polynomial model.</c>
<c>* </c>
<l>CameraParam := ['area_scan_telecentric_polynomial',Magnification,K1,K2,K3,P1,P2,Sx,Sy,Cx,Cy,ImageWidth,ImageHeight]</l>
<l>return ()</l>
</body>
<docu id="gen_cam_par_area_scan_telecentric_polynomial">
<abstract lang="en_US">gen_cam_par_area_scan_telecentric_polynomial generates the camera parameter tuple CameraParam for an area scan camera with a telecentric lens and with distortions modeled by the polynomial model. For this, the camera parameters must be passed in Magnification (-), K1 (m^-2), K2 (m^-4), K3 (m^-6), P1 (m^-1), P2 (m^-1), Sx (m/px), Sy (m/px), Cx (px), Cy (px), ImageWidth (px), and ImageHeight (px), where we indicate the HALCON default units in brackets. For a detailed explanation of the parameters, see the reference manual chapter Calibration / Multi-View.</abstract>
<chapters lang="de_DE">
<item>Kalibrierung</item>
<item>Kameraparameter</item>
</chapters>
<chapters lang="en_US">
<item>Calibration</item>
<item>Camera Parameters</item>
</chapters>
<keywords lang="de_DE">
<item>Kameraparameter kalibrieren</item>
<item>Kamera-Kalibrierparameter erhalten</item>
<item>Kameramodell</item>
<item>interne Kameraparameter</item>
<item>interne Kameraparameter kalibrieren</item>
<item>kalibrierte interne Kameraparameter erhalten</item>
</keywords>
<keywords lang="en_US">
<item>camera calibration parameters</item>
<item>camera calibration result</item>
<item>calibrate camera parameters</item>
<item>calibrate internal camera parameters</item>
<item>calibrated internal camera parameters</item>
</keywords>
<library lang="en_US">MVTec Standard Procedures</library>
<see_also>
<item>calibrate_cameras</item>
<item>get_cam_par_data</item>
<item>set_cam_par_data</item>
<item>get_cam_par_names</item>
<item>gen_cam_par_area_scan_division</item>
<item>gen_cam_par_area_scan_polynomial</item>
<item>gen_cam_par_area_scan_telecentric_division</item>
<item>gen_cam_par_area_scan_tilt_division</item>
<item>gen_cam_par_area_scan_tilt_polynomial</item>
<item>gen_cam_par_area_scan_tilt_image_side_telecentric_division</item>
<item>gen_cam_par_area_scan_tilt_image_side_telecentric_polynomial</item>
<item>gen_cam_par_area_scan_tilt_bilateral_telecentric_division</item>
<item>gen_cam_par_area_scan_tilt_bilateral_telecentric_polynomial</item>
<item>gen_cam_par_area_scan_tilt_object_side_telecentric_division</item>
<item>gen_cam_par_area_scan_tilt_object_side_telecentric_polynomial</item>
<item>gen_cam_par_area_scan_hypercentric_division</item>
<item>gen_cam_par_area_scan_hypercentric_polynomial</item>
<item>gen_cam_par_line_scan_division</item>
<item>gen_cam_par_line_scan_polynomial</item>
<item>gen_cam_par_line_scan_telecentric_division</item>
<item>gen_cam_par_line_scan_telecentric_polynomial</item>
</see_also>
<short lang="en_US">Generate a camera parameter tuple for an area scan camera with a telecentric lens and with distortions modeled by the polynomial model.</short>
<successor>
<item>set_calib_data_cam_param</item>
</successor>
<parameters>
<parameter id="CameraParam">
<default_type>real</default_type>
<description lang="en_US">Output camera parameter tuple.</description>
<mixed_type>optional</mixed_type>
<multivalue>true</multivalue>
<sem_type>campar</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
<item>string</item>
</type_list>
</parameter>
<parameter id="Cx">
<default_type>real</default_type>
<default_value>640</default_value>
<description lang="en_US">Column coordinate of the principal point in the image.</description>
<multivalue>false</multivalue>
<sem_type>real</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
<parameter id="Cy">
<default_type>real</default_type>
<default_value>512</default_value>
<description lang="en_US">Row coordinate of the principal point in the image.</description>
<multivalue>false</multivalue>
<sem_type>real</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
<parameter id="ImageHeight">
<default_type>integer</default_type>
<default_value>1024</default_value>
<description lang="en_US">Image height.</description>
<multivalue>false</multivalue>
<sem_type>integer</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="ImageWidth">
<default_type>integer</default_type>
<default_value>1280</default_value>
<description lang="en_US">Image width.</description>
<multivalue>false</multivalue>
<sem_type>integer</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="K1">
<default_type>real</default_type>
<default_value>0.0</default_value>
<description lang="en_US">Distortion coefficient to model radial lens distortions.</description>
<multivalue>false</multivalue>
<sem_type>real</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
<parameter id="K2">
<default_type>real</default_type>
<default_value>0.0</default_value>
<description lang="en_US">Distortion coefficient to model radial lens distortions.</description>
<multivalue>false</multivalue>
<sem_type>real</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
<parameter id="K3">
<default_type>real</default_type>
<default_value>0.0</default_value>
<description lang="en_US">Distortion coefficient to model radial lens distortions.</description>
<multivalue>false</multivalue>
<sem_type>real</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
<parameter id="Magnification">
<default_type>real</default_type>
<default_value>0.2</default_value>
<description lang="en_US">Magnification of the lens.</description>
<multivalue>false</multivalue>
<sem_type>real</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
<values>
<item>0.1</item>
<item>0.2</item>
<item>0.3</item>
<item>0.4</item>
<item>0.5</item>
<item>1.0</item>
<item>2.0</item>
</values>
</parameter>
<parameter id="P1">
<default_type>real</default_type>
<default_value>0.0</default_value>
<description lang="en_US">Distortion coefficient to model decentering lens distortions.</description>
<multivalue>false</multivalue>
<sem_type>real</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
<parameter id="P2">
<default_type>real</default_type>
<default_value>0.0</default_value>
<description lang="en_US">Distortion coefficient to model decentering lens distortions.</description>
<multivalue>false</multivalue>
<sem_type>real</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
<parameter id="Sx">
<default_type>real</default_type>
<default_value>5.2e-6</default_value>
<description lang="en_US">Horizontal size of a pixel in world coordinates.</description>
<multivalue>false</multivalue>
<sem_type>real</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
<parameter id="Sy">
<default_type>real</default_type>
<default_value>5.2e-6</default_value>
<description lang="en_US">Vertical size of a pixel in world coordinates.</description>
<multivalue>false</multivalue>
<sem_type>real</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
</parameters>
</docu>
</procedure>
<procedure name="gen_cam_par_area_scan_tilt_bilateral_telecentric_division">
<interface>
<ic>
<par name="Magnification" base_type="ctrl" dimension="0"/>
<par name="Kappa" base_type="ctrl" dimension="0"/>
<par name="Tilt" base_type="ctrl" dimension="0"/>
<par name="Rot" base_type="ctrl" dimension="0"/>
<par name="Sx" base_type="ctrl" dimension="0"/>
<par name="Sy" base_type="ctrl" dimension="0"/>
<par name="Cx" base_type="ctrl" dimension="0"/>
<par name="Cy" base_type="ctrl" dimension="0"/>
<par name="ImageWidth" base_type="ctrl" dimension="0"/>
<par name="ImageHeight" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="CameraParam" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c>* Generate a camera parameter tuple for an area scan camera with</c>
<c>* a bilateral telecentric tilt lens and with distortions modeled</c>
<c>* by the division model.</c>
<c>* </c>
<l>CameraParam := ['area_scan_tilt_bilateral_telecentric_division',Magnification,Kappa,Tilt,Rot,Sx,Sy,Cx,Cy,ImageWidth,ImageHeight]</l>
<l>return ()</l>
</body>
<docu id="gen_cam_par_area_scan_tilt_bilateral_telecentric_division">
<abstract lang="en_US">gen_cam_par_area_scan_tilt_bilateral_telecentric_division generates the camera parameter tuple CameraParam for an area scan camera with a bilateral telecentric tilt lens and with distortions modeled by the division model. For this, the camera parameters must be passed in Magnification (-), Kappa (m^-2), Tilt (deg), Rot (deg), Sx (m/px), Sy (m/px), Cx (px), Cy (px), ImageWidth (px), and ImageHeight (px), where we indicate the HALCON default units in brackets. For a detailed explanation of the parameters, see the reference manual chapter Calibration / Multi-View.</abstract>
<chapters lang="de_DE">
<item>Kalibrierung</item>
<item>Kameraparameter</item>
</chapters>
<chapters lang="en_US">
<item>Calibration</item>
<item>Camera Parameters</item>
</chapters>
<keywords lang="de_DE">
<item>Kameraparameter kalibrieren</item>
<item>Kamera-Kalibrierparameter erhalten</item>
<item>Kameramodell</item>
<item>interne Kameraparameter</item>
<item>interne Kameraparameter kalibrieren</item>
<item>kalibrierte interne Kameraparameter erhalten</item>
</keywords>
<keywords lang="en_US">
<item>camera calibration parameters</item>
<item>camera calibration result</item>
<item>calibrate camera parameters</item>
<item>calibrate internal camera parameters</item>
<item>calibrated internal camera parameters</item>
</keywords>
<library lang="en_US">MVTec Standard Procedures</library>
<see_also>
<item>calibrate_cameras</item>
<item>get_cam_par_data</item>
<item>set_cam_par_data</item>
<item>get_cam_par_names</item>
<item>gen_cam_par_area_scan_division</item>
<item>gen_cam_par_area_scan_polynomial</item>
<item>gen_cam_par_area_scan_telecentric_division</item>
<item>gen_cam_par_area_scan_telecentric_polynomial</item>
<item>gen_cam_par_area_scan_tilt_division</item>
<item>gen_cam_par_area_scan_tilt_polynomial</item>
<item>gen_cam_par_area_scan_tilt_image_side_telecentric_division</item>
<item>gen_cam_par_area_scan_tilt_image_side_telecentric_polynomial</item>
<item>gen_cam_par_area_scan_tilt_bilateral_telecentric_polynomial</item>
<item>gen_cam_par_area_scan_tilt_object_side_telecentric_division</item>
<item>gen_cam_par_area_scan_tilt_object_side_telecentric_polynomial</item>
<item>gen_cam_par_area_scan_hypercentric_division</item>
<item>gen_cam_par_area_scan_hypercentric_polynomial</item>
<item>gen_cam_par_line_scan_division</item>
<item>gen_cam_par_line_scan_polynomial</item>
<item>gen_cam_par_line_scan_telecentric_division</item>
<item>gen_cam_par_line_scan_telecentric_polynomial</item>
</see_also>
<short lang="en_US">Generate a camera parameter tuple for an area scan camera with a bilateral telecentric tilt lens and with distortions modeled by the division model.</short>
<successor>
<item>set_calib_data_cam_param</item>
</successor>
<parameters>
<parameter id="CameraParam">
<default_type>real</default_type>
<description lang="de_DE">Output camera parameter tuple.</description>
<description lang="en_US">Output camera parameter tuple.</description>
<mixed_type>optional</mixed_type>
<multivalue>true</multivalue>
<sem_type>campar</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
<item>string</item>
</type_list>
</parameter>
<parameter id="Cx">
<default_type>real</default_type>
<default_value>640</default_value>
<description lang="en_US">Column coordinate of the principal point in the image.</description>
<multivalue>false</multivalue>
<sem_type>real</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
<parameter id="Cy">
<default_type>real</default_type>
<default_value>512</default_value>
<description lang="en_US">Row coordinate of the principal point in the image.</description>
<multivalue>false</multivalue>
<sem_type>real</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
<parameter id="ImageHeight">
<default_type>integer</default_type>
<default_value>1024</default_value>
<description lang="en_US">Image height.</description>
<multivalue>false</multivalue>
<sem_type>integer</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="ImageWidth">
<default_type>integer</default_type>
<default_value>1280</default_value>
<description lang="en_US">Image width.</description>
<multivalue>false</multivalue>
<sem_type>integer</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="Kappa">
<default_type>real</default_type>
<default_value>0.0</default_value>
<description lang="en_US">Distortion coefficient to model the radial lens distortions.</description>
<multivalue>false</multivalue>
<sem_type>real</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
<parameter id="Magnification">
<default_type>real</default_type>
<default_value>0.2</default_value>
<description lang="en_US">Magnification of the lens.</description>
<multivalue>false</multivalue>
<sem_type>real</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
<values>
<item>0.1</item>
<item>0.2</item>
<item>0.3</item>
<item>0.4</item>
<item>0.5</item>
<item>1.0</item>
<item>2.0</item>
</values>
</parameter>
<parameter id="Rot">
<default_type>real</default_type>
<default_value>90.0</default_value>
<description lang="en_US">Rotation angle (in degrees), i.e., the direction, in which the optical axis is tilted.</description>
<multivalue>false</multivalue>
<sem_type>real</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
<parameter id="Sx">
<default_type>real</default_type>
<default_value>5.2e-6</default_value>
<description lang="en_US">Horizontal size of a pixel in world coordinates.</description>
<multivalue>false</multivalue>
<sem_type>real</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
<parameter id="Sy">
<default_type>real</default_type>
<default_value>5.2e-6</default_value>
<description lang="en_US">Vertical size of a pixel in world coordinates.</description>
<multivalue>false</multivalue>
<sem_type>real</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
<parameter id="Tilt">
<default_type>real</default_type>
<default_value>10.0</default_value>
<description lang="en_US">Tilt angle (in degrees).</description>
<multivalue>false</multivalue>
<sem_type>real</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
</parameters>
</docu>
</procedure>
<procedure name="gen_cam_par_area_scan_tilt_bilateral_telecentric_polynomial">
<interface>
<ic>
<par name="Magnification" base_type="ctrl" dimension="0"/>
<par name="K1" base_type="ctrl" dimension="0"/>
<par name="K2" base_type="ctrl" dimension="0"/>
<par name="K3" base_type="ctrl" dimension="0"/>
<par name="P1" base_type="ctrl" dimension="0"/>
<par name="P2" base_type="ctrl" dimension="0"/>
<par name="Tilt" base_type="ctrl" dimension="0"/>
<par name="Rot" base_type="ctrl" dimension="0"/>
<par name="Sx" base_type="ctrl" dimension="0"/>
<par name="Sy" base_type="ctrl" dimension="0"/>
<par name="Cx" base_type="ctrl" dimension="0"/>
<par name="Cy" base_type="ctrl" dimension="0"/>
<par name="ImageWidth" base_type="ctrl" dimension="0"/>
<par name="ImageHeight" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="CameraParam" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c>* Generate a camera parameter tuple for an area scan camera with</c>
<c>* a bilateral telecentric tilt lens and with distortions modeled</c>
<c>* by the polynomial model.</c>
<c>* </c>
<l>CameraParam := ['area_scan_tilt_bilateral_telecentric_polynomial',Magnification,K1,K2,K3,P1,P2,Tilt,Rot,Sx,Sy,Cx,Cy,ImageWidth,ImageHeight]</l>
<l>return ()</l>
</body>
<docu id="gen_cam_par_area_scan_tilt_bilateral_telecentric_polynomial">
<abstract lang="en_US">gen_cam_par_area_scan_tilt_bilateral_telecentric_polynomial generates the camera parameter tuple CameraParam for an area scan camera with a bilateral telecentric tilt lens and with distortions modeled by the polynomial model. For this, the camera parameters must be passed in Magnification (-), K1 (m^-2), K2 (m^-4), K3 (m^-6), P1 (m^-1), P2 (m^-1), Tilt (deg), Rot (deg), Sx (m/px), Sy (m/px), Cx (px), Cy (px), ImageWidth (px), and ImageHeight (px), where we indicate the HALCON default units in brackets. For a detailed explanation of the parameters, see the reference manual chapter Calibration / Multi-View.</abstract>
<chapters lang="de_DE">
<item>Kalibrierung</item>
<item>Kameraparameter</item>
</chapters>
<chapters lang="en_US">
<item>Calibration</item>
<item>Camera Parameters</item>
</chapters>
<keywords lang="de_DE">
<item>Kameraparameter kalibrieren</item>
<item>Kamera-Kalibrierparameter erhalten</item>
<item>Kameramodell</item>
<item>interne Kameraparameter</item>
<item>interne Kameraparameter kalibrieren</item>
<item>kalibrierte interne Kameraparameter erhalten</item>
</keywords>
<keywords lang="en_US">
<item>camera calibration parameters</item>
<item>camera calibration result</item>
<item>calibrate camera parameters</item>
<item>calibrate internal camera parameters</item>
<item>calibrated internal camera parameters</item>
</keywords>
<library lang="en_US">MVTec Standard Procedures</library>
<see_also>
<item>calibrate_cameras</item>
<item>get_cam_par_data</item>
<item>set_cam_par_data</item>
<item>get_cam_par_names</item>
<item>gen_cam_par_area_scan_division</item>
<item>gen_cam_par_area_scan_polynomial</item>
<item>gen_cam_par_area_scan_telecentric_division</item>
<item>gen_cam_par_area_scan_telecentric_polynomial</item>
<item>gen_cam_par_area_scan_tilt_division</item>
<item>gen_cam_par_area_scan_tilt_polynomial</item>
<item>gen_cam_par_area_scan_tilt_image_side_telecentric_division</item>
<item>gen_cam_par_area_scan_tilt_image_side_telecentric_polynomial</item>
<item>gen_cam_par_area_scan_tilt_bilateral_telecentric_division</item>
<item>gen_cam_par_area_scan_tilt_object_side_telecentric_division</item>
<item>gen_cam_par_area_scan_tilt_object_side_telecentric_polynomial</item>
<item>gen_cam_par_area_scan_hypercentric_division</item>
<item>gen_cam_par_area_scan_hypercentric_polynomial</item>
<item>gen_cam_par_line_scan_division</item>
<item>gen_cam_par_line_scan_polynomial</item>
<item>gen_cam_par_line_scan_telecentric_division</item>
<item>gen_cam_par_line_scan_telecentric_polynomial</item>
</see_also>
<short lang="en_US">Generate a camera parameter tuple for an area scan camera with a bilateral telecentric tilt lens and with distortions modeled by the polynomial model.</short>
<successor>
<item>set_calib_data_cam_param</item>
</successor>
<parameters>
<parameter id="CameraParam">
<default_type>real</default_type>
<description lang="en_US">Output camera parameter tuple.</description>
<mixed_type>optional</mixed_type>
<multivalue>true</multivalue>
<sem_type>campar</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
<item>string</item>
</type_list>
</parameter>
<parameter id="Cx">
<default_type>real</default_type>
<default_value>640</default_value>
<description lang="en_US">Column coordinate of the principal point in the image.</description>
<multivalue>false</multivalue>
<sem_type>real</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
<parameter id="Cy">
<default_type>real</default_type>
<default_value>512</default_value>
<description lang="en_US">Row coordinate of the principal point in the image.</description>
<multivalue>false</multivalue>
<sem_type>real</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
<parameter id="ImageHeight">
<default_type>integer</default_type>
<default_value>1024</default_value>
<description lang="en_US">Image height.</description>
<multivalue>false</multivalue>
<sem_type>integer</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="ImageWidth">
<default_type>integer</default_type>
<default_value>1280</default_value>
<description lang="en_US">Image width.</description>
<multivalue>false</multivalue>
<sem_type>integer</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="K1">
<default_type>real</default_type>
<default_value>0.0</default_value>
<description lang="en_US">Distortion coefficient to model the radial lens distortions.</description>
<multivalue>false</multivalue>
<sem_type>real</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
<parameter id="K2">
<default_type>real</default_type>
<default_value>0.0</default_value>
<description lang="en_US">Distortion coefficient to model the radial lens distortions.</description>
<multivalue>false</multivalue>
<sem_type>real</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
<parameter id="K3">
<default_type>real</default_type>
<default_value>0.0</default_value>
<description lang="en_US">Distortion coefficient to model the radial lens distortions.</description>
<multivalue>false</multivalue>
<sem_type>real</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
<parameter id="Magnification">
<default_type>real</default_type>
<default_value>0.2</default_value>
<description lang="en_US">Magnification of the lens.</description>
<multivalue>false</multivalue>
<sem_type>real</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
<values>
<item>0.1</item>
<item>0.2</item>
<item>0.3</item>
<item>0.4</item>
<item>0.5</item>
<item>1.0</item>
<item>2.0</item>
</values>
</parameter>
<parameter id="P1">
<default_type>real</default_type>
<default_value>0.0</default_value>
<description lang="en_US">Distortion coefficient to model decentering lens distortions.</description>
<multivalue>false</multivalue>
<sem_type>real</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
<parameter id="P2">
<default_type>real</default_type>
<default_value>0.0</default_value>
<description lang="en_US">Distortion coefficient to model decentering lens distortions.</description>
<multivalue>false</multivalue>
<sem_type>real</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
<parameter id="Rot">
<default_type>real</default_type>
<default_value>90.0</default_value>
<description lang="en_US">Rotation angle (in degrees), i.e., the direction, in which the optical axis is tilted.</description>
<multivalue>false</multivalue>
<sem_type>real</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
<parameter id="Sx">
<default_type>real</default_type>
<default_value>5.2e-6</default_value>
<description lang="en_US">Horizontal size of a pixel in world coordinates.</description>
<multivalue>false</multivalue>
<sem_type>real</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
<parameter id="Sy">
<default_type>real</default_type>
<default_value>5.2e-6</default_value>
<description lang="en_US">Vertical size of a pixel in world coordinates.</description>
<multivalue>false</multivalue>
<sem_type>real</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
<parameter id="Tilt">
<default_type>real</default_type>
<default_value>10.0</default_value>
<description lang="en_US">Tilt angle (in degrees).</description>
<multivalue>false</multivalue>
<sem_type>real</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
</parameters>
</docu>
</procedure>
<procedure name="gen_cam_par_area_scan_tilt_division">
<interface>
<ic>
<par name="Focus" base_type="ctrl" dimension="0"/>
<par name="Kappa" base_type="ctrl" dimension="0"/>
<par name="ImagePlaneDist" base_type="ctrl" dimension="0"/>
<par name="Tilt" base_type="ctrl" dimension="0"/>
<par name="Rot" base_type="ctrl" dimension="0"/>
<par name="Sx" base_type="ctrl" dimension="0"/>
<par name="Sy" base_type="ctrl" dimension="0"/>
<par name="Cx" base_type="ctrl" dimension="0"/>
<par name="Cy" base_type="ctrl" dimension="0"/>
<par name="ImageWidth" base_type="ctrl" dimension="0"/>
<par name="ImageHeight" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="CameraParam" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c>* Generate a camera parameter tuple for an area scan camera with</c>
<c>* a tilt lens and with distortions modeled by the division model.</c>
<c>* </c>
<l>CameraParam := ['area_scan_tilt_division',Focus,Kappa,ImagePlaneDist,Tilt,Rot,Sx,Sy,Cx,Cy,ImageWidth,ImageHeight]</l>
<l>return ()</l>
</body>
<docu id="gen_cam_par_area_scan_tilt_division">
<abstract lang="en_US">gen_cam_par_area_scan_tilt_division generates the camera parameter tuple CameraParam for an area scan camera with a tilt lens and with distortions modeled by the division model. For this, the camera parameters must be passed in Focus (m), Kappa (m^-2), ImagePlaneDist (m), Tilt (deg), Rot (deg), Sx (m/px), Sy (m/px), Cx (px), Cy (px), ImageWidth (px), and ImageHeight (px), where we indicate the HALCON default units in brackets. For a detailed explanation of the parameters, see the reference manual chapter Calibration / Multi-View.</abstract>
<chapters lang="de_DE">
<item>Kalibrierung</item>
<item>Kameraparameter</item>
</chapters>
<chapters lang="en_US">
<item>Calibration</item>
<item>Camera Parameters</item>
</chapters>
<keywords lang="de_DE">
<item>Kameraparameter kalibrieren</item>
<item>Kamera-Kalibrierparameter erhalten</item>
<item>Kameramodell</item>
<item>interne Kameraparameter</item>
<item>interne Kameraparameter kalibrieren</item>
<item>kalibrierte interne Kameraparameter erhalten</item>
</keywords>
<keywords lang="en_US">
<item>camera calibration parameters</item>
<item>camera calibration result</item>
<item>calibrate camera parameters</item>
<item>calibrate internal camera parameters</item>
<item>calibrated internal camera parameters</item>
</keywords>
<library lang="en_US">MVTec Standard Procedures</library>
<see_also>
<item>calibrate_cameras</item>
<item>get_cam_par_data</item>
<item>set_cam_par_data</item>
<item>get_cam_par_names</item>
<item>gen_cam_par_area_scan_division</item>
<item>gen_cam_par_area_scan_polynomial</item>
<item>gen_cam_par_area_scan_telecentric_division</item>
<item>gen_cam_par_area_scan_telecentric_polynomial</item>
<item>gen_cam_par_area_scan_tilt_polynomial</item>
<item>gen_cam_par_area_scan_tilt_image_side_telecentric_division</item>
<item>gen_cam_par_area_scan_tilt_image_side_telecentric_polynomial</item>
<item>gen_cam_par_area_scan_tilt_bilateral_telecentric_division</item>
<item>gen_cam_par_area_scan_tilt_bilateral_telecentric_polynomial</item>
<item>gen_cam_par_area_scan_tilt_object_side_telecentric_division</item>
<item>gen_cam_par_area_scan_tilt_object_side_telecentric_polynomial</item>
<item>gen_cam_par_area_scan_hypercentric_division</item>
<item>gen_cam_par_area_scan_hypercentric_polynomial</item>
<item>gen_cam_par_line_scan_division</item>
<item>gen_cam_par_line_scan_polynomial</item>
<item>gen_cam_par_line_scan_telecentric_division</item>
<item>gen_cam_par_line_scan_telecentric_polynomial</item>
</see_also>
<short lang="en_US">Generate a camera parameter tuple for an area scan camera with a tilt lens and with distortions modeled by the division model.</short>
<successor>
<item>set_calib_data_cam_param</item>
</successor>
<parameters>
<parameter id="CameraParam">
<default_type>real</default_type>
<description lang="en_US">Output camera parameter tuple.</description>
<mixed_type>optional</mixed_type>
<multivalue>true</multivalue>
<sem_type>campar</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
<item>string</item>
</type_list>
</parameter>
<parameter id="Cx">
<default_type>real</default_type>
<default_value>640</default_value>
<description lang="en_US">Column coordinate of the principal point in the image.</description>
<multivalue>false</multivalue>
<sem_type>real</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
<parameter id="Cy">
<default_type>real</default_type>
<default_value>512</default_value>
<description lang="en_US">Row coordinate of the principal point in the image.</description>
<multivalue>false</multivalue>
<sem_type>real</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
<parameter id="Focus">
<default_type>real</default_type>
<default_value>0.008</default_value>
<description lang="en_US">Principal distance.</description>
<multivalue>false</multivalue>
<sem_type>real</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
<parameter id="ImageHeight">
<default_type>integer</default_type>
<default_value>1024</default_value>
<description lang="en_US">Image height.</description>
<multivalue>false</multivalue>
<sem_type>integer</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="ImagePlaneDist">
<default_type>real</default_type>
<default_value>0.02</default_value>
<description lang="en_US">Image plane distance.</description>
<multivalue>false</multivalue>
<sem_type>real</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
<parameter id="ImageWidth">
<default_type>integer</default_type>
<default_value>1280</default_value>
<description lang="en_US">Image width.</description>
<multivalue>false</multivalue>
<sem_type>integer</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="Kappa">
<default_type>real</default_type>
<default_value>0.0</default_value>
<description lang="en_US">Distortion coefficient to model the radial lens distortions.</description>
<multivalue>false</multivalue>
<sem_type>real</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
<parameter id="Rot">
<default_type>real</default_type>
<default_value>90.0</default_value>
<description lang="en_US">Rotation angle (in degrees), i.e., the direction, in which the optical axis is tilted.</description>
<multivalue>false</multivalue>
<sem_type>real</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
<parameter id="Sx">
<default_type>real</default_type>
<default_value>5.2e-6</default_value>
<description lang="en_US">Horizontal distance between two neighboring cells on the sensor.</description>
<multivalue>false</multivalue>
<sem_type>real</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
<parameter id="Sy">
<default_type>real</default_type>
<default_value>5.2e-6</default_value>
<description lang="en_US">Vertical distance between two neighboring cells on the sensor.</description>
<multivalue>false</multivalue>
<sem_type>real</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
<parameter id="Tilt">
<default_type>real</default_type>
<default_value>10.0</default_value>
<description lang="en_US">Tilt angle (in degrees).</description>
<multivalue>false</multivalue>
<sem_type>real</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
</parameters>
</docu>
</procedure>
<procedure name="gen_cam_par_area_scan_tilt_image_side_telecentric_division">
<interface>
<ic>
<par name="Focus" base_type="ctrl" dimension="0"/>
<par name="Kappa" base_type="ctrl" dimension="0"/>
<par name="Tilt" base_type="ctrl" dimension="0"/>
<par name="Rot" base_type="ctrl" dimension="0"/>
<par name="Sx" base_type="ctrl" dimension="0"/>
<par name="Sy" base_type="ctrl" dimension="0"/>
<par name="Cx" base_type="ctrl" dimension="0"/>
<par name="Cy" base_type="ctrl" dimension="0"/>
<par name="ImageWidth" base_type="ctrl" dimension="0"/>
<par name="ImageHeight" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="CameraParam" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c>* Generate a camera parameter tuple for an area scan camera with</c>
<c>* an image-side telecentric tilt lens and with distortions modeled</c>
<c>* by the division model.</c>
<c>* </c>
<l>CameraParam := ['area_scan_tilt_image_side_telecentric_division',Focus,Kappa,Tilt,Rot,Sx,Sy,Cx,Cy,ImageWidth,ImageHeight]</l>
<l>return ()</l>
</body>
<docu id="gen_cam_par_area_scan_tilt_image_side_telecentric_division">
<abstract lang="en_US">gen_cam_par_area_scan_tilt_image_side_telecentric_division generates the camera parameter tuple CameraParam for an area scan camera with an image-side telecentric tilt lens and with distortions modeled by the division model. For this, the camera parameters must be passed in Focus (m), Kappa (m^-2), Tilt (deg), Rot (deg), Sx (m/px), Sy (m/px), Cx (px), Cy (px), ImageWidth (px), and ImageHeight (px), where we indicate the HALCON default units in brackets. For a detailed explanation of the parameters, see the reference manual chapter Calibration / Multi-View.</abstract>
<chapters lang="de_DE">
<item>Kalibrierung</item>
<item>Kameraparameter</item>
</chapters>
<chapters lang="en_US">
<item>Calibration</item>
<item>Camera Parameters</item>
</chapters>
<keywords lang="de_DE">
<item>Kameraparameter kalibrieren</item>
<item>Kamera-Kalibrierparameter erhalten</item>
<item>Kameramodell</item>
<item>interne Kameraparameter</item>
<item>interne Kameraparameter kalibrieren</item>
<item>kalibrierte interne Kameraparameter erhalten</item>
</keywords>
<keywords lang="en_US">
<item>camera calibration parameters</item>
<item>camera calibration result</item>
<item>calibrate camera parameters</item>
<item>calibrate internal camera parameters</item>
<item>calibrated internal camera parameters</item>
</keywords>
<library lang="en_US">MVTec Standard Procedures</library>
<see_also>
<item>calibrate_cameras</item>
<item>get_cam_par_data</item>
<item>set_cam_par_data</item>
<item>get_cam_par_names</item>
<item>gen_cam_par_area_scan_division</item>
<item>gen_cam_par_area_scan_polynomial</item>
<item>gen_cam_par_area_scan_telecentric_division</item>
<item>gen_cam_par_area_scan_telecentric_polynomial</item>
<item>gen_cam_par_area_scan_tilt_division</item>
<item>gen_cam_par_area_scan_tilt_polynomial</item>
<item>gen_cam_par_area_scan_tilt_image_side_telecentric_polynomial</item>
<item>gen_cam_par_area_scan_tilt_bilateral_telecentric_division</item>
<item>gen_cam_par_area_scan_tilt_bilateral_telecentric_polynomial</item>
<item>gen_cam_par_area_scan_tilt_object_side_telecentric_division</item>
<item>gen_cam_par_area_scan_tilt_object_side_telecentric_polynomial</item>
<item>gen_cam_par_area_scan_hypercentric_division</item>
<item>gen_cam_par_area_scan_hypercentric_polynomial</item>
<item>gen_cam_par_line_scan_division</item>
<item>gen_cam_par_line_scan_polynomial</item>
<item>gen_cam_par_line_scan_telecentric_division</item>
<item>gen_cam_par_line_scan_telecentric_polynomial</item>
</see_also>
<short lang="en_US">Generate a camera parameter tuple for an area scan camera with an image-side telecentric tilt lens and with distortions modeled by the division model.</short>
<successor>
<item>set_calib_data_cam_param</item>
</successor>
<parameters>
<parameter id="CameraParam">
<default_type>real</default_type>
<description lang="en_US">Output camera parameter tuple.</description>
<mixed_type>optional</mixed_type>
<multivalue>true</multivalue>
<sem_type>campar</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
<item>string</item>
</type_list>
</parameter>
<parameter id="Cx">
<default_type>real</default_type>
<default_value>640</default_value>
<description lang="en_US">Column coordinate of the principal point in the image.</description>
<multivalue>false</multivalue>
<sem_type>real</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
<parameter id="Cy">
<default_type>real</default_type>
<default_value>512</default_value>
<description lang="en_US">Row coordinate of the principal point in the image.</description>
<multivalue>false</multivalue>
<sem_type>real</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
<parameter id="Focus">
<default_type>real</default_type>
<default_value>0.008</default_value>
<description lang="en_US">Principal distance.</description>
<multivalue>false</multivalue>
<sem_type>real</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
<parameter id="ImageHeight">
<default_type>integer</default_type>
<default_value>1024</default_value>
<description lang="en_US">Image height.</description>
<multivalue>false</multivalue>
<sem_type>integer</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="ImageWidth">
<default_type>integer</default_type>
<default_value>1280</default_value>
<description lang="en_US">Image width.</description>
<multivalue>false</multivalue>
<sem_type>integer</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="Kappa">
<default_type>real</default_type>
<default_value>0.0</default_value>
<description lang="en_US">Distortion coefficient to model the radial lens distortions.</description>
<multivalue>false</multivalue>
<sem_type>real</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
<parameter id="Rot">
<default_type>real</default_type>
<default_value>90.0</default_value>
<description lang="en_US">Rotation angle (in degrees), i.e., the direction, in which the optical axis is tilted.</description>
<multivalue>false</multivalue>
<sem_type>real</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
<parameter id="Sx">
<default_type>real</default_type>
<default_value>5.2e-6</default_value>
<description lang="en_US">Horizontal distance between two neighboring cells on the sensor.</description>
<multivalue>false</multivalue>
<sem_type>real</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
<parameter id="Sy">
<default_type>real</default_type>
<default_value>5.2e-6</default_value>
<description lang="en_US">Vertical distance between two neighboring cells on the sensor.</description>
<multivalue>false</multivalue>
<sem_type>real</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
<parameter id="Tilt">
<default_type>real</default_type>
<default_value>10.0</default_value>
<description lang="en_US">Tilt angle (in degrees).</description>
<multivalue>false</multivalue>
<sem_type>real</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
</parameters>
</docu>
</procedure>
<procedure name="gen_cam_par_area_scan_tilt_image_side_telecentric_polynomial">
<interface>
<ic>
<par name="Focus" base_type="ctrl" dimension="0"/>
<par name="K1" base_type="ctrl" dimension="0"/>
<par name="K2" base_type="ctrl" dimension="0"/>
<par name="K3" base_type="ctrl" dimension="0"/>
<par name="P1" base_type="ctrl" dimension="0"/>
<par name="P2" base_type="ctrl" dimension="0"/>
<par name="Tilt" base_type="ctrl" dimension="0"/>
<par name="Rot" base_type="ctrl" dimension="0"/>
<par name="Sx" base_type="ctrl" dimension="0"/>
<par name="Sy" base_type="ctrl" dimension="0"/>
<par name="Cx" base_type="ctrl" dimension="0"/>
<par name="Cy" base_type="ctrl" dimension="0"/>
<par name="ImageWidth" base_type="ctrl" dimension="0"/>
<par name="ImageHeight" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="CameraParam" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c>* Generate a camera parameter tuple for an area scan camera with</c>
<c>* an image-side telecentric tilt lens and with distortions modeled</c>
<c>* by the polynomial model.</c>
<c>* </c>
<l>CameraParam := ['area_scan_tilt_image_side_telecentric_polynomial',Focus,K1,K2,K3,P1,P2,Tilt,Rot,Sx,Sy,Cx,Cy,ImageWidth,ImageHeight]</l>
<l>return ()</l>
</body>
<docu id="gen_cam_par_area_scan_tilt_image_side_telecentric_polynomial">
<abstract lang="en_US">gen_cam_par_area_scan_tilt_image_side_telecentric_polynomial generates the camera parameter tuple CameraParam for an area scan camera with an image-side telecentric tilt lens and with distortions modeled by the polynomial model. For this, the camera parameters must be passed in Focus (m), K1 (m^-2), K2 (m^-4), K3 (m^-6), P1 (m^-1), P2 (m^-1), Tilt (deg), Rot (deg), Sx (m/px), Sy (m/px), Cx (px), Cy (px), ImageWidth (px), and ImageHeight (px), where we indicate the HALCON default units in brackets. For a detailed explanation of the parameters, see the reference manual chapter Calibration / Multi-View.</abstract>
<chapters lang="de_DE">
<item>Kalibrierung</item>
<item>Kameraparameter</item>
</chapters>
<chapters lang="en_US">
<item>Calibration</item>
<item>Camera Parameters</item>
</chapters>
<keywords lang="de_DE">
<item>Kameraparameter kalibrieren</item>
<item>Kamera-Kalibrierparameter erhalten</item>
<item>Kameramodell</item>
<item>interne Kameraparameter</item>
<item>interne Kameraparameter kalibrieren</item>
<item>kalibrierte interne Kameraparameter erhalten</item>
</keywords>
<keywords lang="en_US">
<item>camera calibration parameters</item>
<item>camera calibration result</item>
<item>calibrate camera parameters</item>
<item>calibrate internal camera parameters</item>
<item>calibrated internal camera parameters</item>
</keywords>
<library lang="en_US">MVTec Standard Procedures</library>
<see_also>
<item>calibrate_cameras</item>
<item>get_cam_par_data</item>
<item>set_cam_par_data</item>
<item>get_cam_par_names</item>
<item>gen_cam_par_area_scan_division</item>
<item>gen_cam_par_area_scan_polynomial</item>
<item>gen_cam_par_area_scan_telecentric_division</item>
<item>gen_cam_par_area_scan_telecentric_polynomial</item>
<item>gen_cam_par_area_scan_tilt_division</item>
<item>gen_cam_par_area_scan_tilt_polynomial</item>
<item>gen_cam_par_area_scan_tilt_image_side_telecentric_division</item>
<item>gen_cam_par_area_scan_tilt_bilateral_telecentric_division</item>
<item>gen_cam_par_area_scan_tilt_bilateral_telecentric_polynomial</item>
<item>gen_cam_par_area_scan_tilt_object_side_telecentric_division</item>
<item>gen_cam_par_area_scan_tilt_object_side_telecentric_polynomial</item>
<item>gen_cam_par_area_scan_hypercentric_division</item>
<item>gen_cam_par_area_scan_hypercentric_polynomial</item>
<item>gen_cam_par_line_scan_division</item>
<item>gen_cam_par_line_scan_polynomial</item>
<item>gen_cam_par_line_scan_telecentric_division</item>
<item>gen_cam_par_line_scan_telecentric_polynomial</item>
</see_also>
<short lang="en_US">Generate a camera parameter tuple for an area scan camera with an image-side telecentric tilt lens and with distortions modeled by the polynomial model.</short>
<successor>
<item>set_calib_data_cam_param</item>
</successor>
<parameters>
<parameter id="CameraParam">
<default_type>real</default_type>
<description lang="en_US">Output camera parameter tuple.</description>
<mixed_type>optional</mixed_type>
<multivalue>true</multivalue>
<sem_type>campar</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
<item>string</item>
</type_list>
</parameter>
<parameter id="Cx">
<default_type>real</default_type>
<default_value>640</default_value>
<description lang="en_US">Column coordinate of the principal point in the image.</description>
<multivalue>false</multivalue>
<sem_type>real</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
<parameter id="Cy">
<default_type>real</default_type>
<default_value>512</default_value>
<description lang="en_US">Row coordinate of the principal point in the image.</description>
<multivalue>false</multivalue>
<sem_type>real</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
<parameter id="Focus">
<default_type>real</default_type>
<default_value>0.008</default_value>
<description lang="en_US">Principal distance.</description>
<multivalue>false</multivalue>
<sem_type>real</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
<parameter id="ImageHeight">
<default_type>integer</default_type>
<default_value>1024</default_value>
<description lang="en_US">Image height.</description>
<multivalue>false</multivalue>
<sem_type>integer</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="ImageWidth">
<default_type>integer</default_type>
<default_value>1280</default_value>
<description lang="en_US">Image width.</description>
<multivalue>false</multivalue>
<sem_type>integer</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="K1">
<default_type>real</default_type>
<default_value>0.0</default_value>
<description lang="en_US">Distortion coefficient to model the radial lens distortions.</description>
<multivalue>false</multivalue>
<sem_type>real</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
<parameter id="K2">
<default_type>real</default_type>
<default_value>0.0</default_value>
<description lang="en_US">Distortion coefficient to model the radial lens distortions.</description>
<multivalue>false</multivalue>
<sem_type>real</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
<parameter id="K3">
<default_type>real</default_type>
<default_value>0.0</default_value>
<description lang="en_US">Distortion coefficient to model the radial lens distortions.</description>
<multivalue>false</multivalue>
<sem_type>real</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
<parameter id="P1">
<default_type>real</default_type>
<default_value>0.0</default_value>
<description lang="en_US">Distortion coefficient to model decentering lens distortions.</description>
<multivalue>false</multivalue>
<sem_type>real</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
<parameter id="P2">
<default_type>real</default_type>
<default_value>0.0</default_value>
<description lang="en_US">Distortion coefficient to model decentering lens distortions.</description>
<multivalue>false</multivalue>
<sem_type>real</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
<parameter id="Rot">
<default_type>real</default_type>
<default_value>90.0</default_value>
<description lang="en_US">Rotation angle (in degrees), i.e., the direction, in which the optical axis is tilted.</description>
<multivalue>false</multivalue>
<sem_type>real</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
<parameter id="Sx">
<default_type>real</default_type>
<default_value>5.2e-6</default_value>
<description lang="en_US">Horizontal distance between two neighboring cells on the sensor.</description>
<multivalue>false</multivalue>
<sem_type>real</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
<parameter id="Sy">
<default_type>real</default_type>
<default_value>5.2e-6</default_value>
<description lang="en_US">Vertical distance between two neighboring cells on the sensor.</description>
<multivalue>false</multivalue>
<sem_type>real</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
<parameter id="Tilt">
<default_type>real</default_type>
<default_value>10.0</default_value>
<description lang="en_US">Tilt angle (in degrees).</description>
<multivalue>false</multivalue>
<sem_type>real</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
</parameters>
</docu>
</procedure>
<procedure name="gen_cam_par_area_scan_tilt_object_side_telecentric_division">
<interface>
<ic>
<par name="Magnification" base_type="ctrl" dimension="0"/>
<par name="Kappa" base_type="ctrl" dimension="0"/>
<par name="ImagePlaneDist" base_type="ctrl" dimension="0"/>
<par name="Tilt" base_type="ctrl" dimension="0"/>
<par name="Rot" base_type="ctrl" dimension="0"/>
<par name="Sx" base_type="ctrl" dimension="0"/>
<par name="Sy" base_type="ctrl" dimension="0"/>
<par name="Cx" base_type="ctrl" dimension="0"/>
<par name="Cy" base_type="ctrl" dimension="0"/>
<par name="ImageWidth" base_type="ctrl" dimension="0"/>
<par name="ImageHeight" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="CameraParam" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c>* Generate a camera parameter tuple for an area scan camera with</c>
<c>* an object-side telecentric tilt lens and with distortions modeled</c>
<c>* by the division model.</c>
<c>* </c>
<l>CameraParam := ['area_scan_tilt_object_side_telecentric_division',Magnification,Kappa,ImagePlaneDist,Tilt,Rot,Sx,Sy,Cx,Cy,ImageWidth,ImageHeight]</l>
<l>return ()</l>
</body>
<docu id="gen_cam_par_area_scan_tilt_object_side_telecentric_division">
<abstract lang="en_US">gen_cam_par_area_scan_tilt_object_side_telecentric_division generates the camera parameter tuple CameraParam for an area scan camera with an object-side telecentric tilt lens and with distortions modeled by the division model. For this, the camera parameters must be passed in Magnification (-), Kappa (m^-2), ImagePlaneDist (m), Tilt (deg), Rot (deg), Sx (m/px), Sy (m/px), Cx (px), Cy (px), ImageWidth (px), and ImageHeight (px), where we indicate the HALCON default units in brackets. For a detailed explanation of the parameters, see the reference manual chapter Calibration / Multi-View.</abstract>
<chapters lang="de_DE">
<item>Kalibrierung</item>
<item>Kameraparameter</item>
</chapters>
<chapters lang="en_US">
<item>Calibration</item>
<item>Camera Parameters</item>
</chapters>
<keywords lang="de_DE">
<item>Kameraparameter kalibrieren</item>
<item>Kamera-Kalibrierparameter erhalten</item>
<item>Kameramodell</item>
<item>interne Kameraparameter</item>
<item>interne Kameraparameter kalibrieren</item>
<item>kalibrierte interne Kameraparameter erhalten</item>
</keywords>
<keywords lang="en_US">
<item>camera calibration parameters</item>
<item>camera calibration result</item>
<item>calibrate camera parameters</item>
<item>calibrate internal camera parameters</item>
<item>calibrated internal camera parameters</item>
</keywords>
<library lang="en_US">MVTec Standard Procedures</library>
<see_also>
<item>calibrate_cameras</item>
<item>get_cam_par_data</item>
<item>set_cam_par_data</item>
<item>get_cam_par_names</item>
<item>gen_cam_par_area_scan_division</item>
<item>gen_cam_par_area_scan_polynomial</item>
<item>gen_cam_par_area_scan_telecentric_division</item>
<item>gen_cam_par_area_scan_telecentric_polynomial</item>
<item>gen_cam_par_area_scan_tilt_division</item>
<item>gen_cam_par_area_scan_tilt_polynomial</item>
<item>gen_cam_par_area_scan_tilt_image_side_telecentric_division</item>
<item>gen_cam_par_area_scan_tilt_image_side_telecentric_polynomial</item>
<item>gen_cam_par_area_scan_tilt_bilateral_telecentric_division</item>
<item>gen_cam_par_area_scan_tilt_bilateral_telecentric_polynomial</item>
<item>gen_cam_par_area_scan_tilt_object_side_telecentric_polynomial</item>
<item>gen_cam_par_area_scan_hypercentric_division</item>
<item>gen_cam_par_area_scan_hypercentric_polynomial</item>
<item>gen_cam_par_line_scan_division</item>
<item>gen_cam_par_line_scan_polynomial</item>
<item>gen_cam_par_line_scan_telecentric_division</item>
<item>gen_cam_par_line_scan_telecentric_polynomial</item>
</see_also>
<short lang="en_US">Generate a camera parameter tuple for an area scan camera with an object-side telecentric tilt lens and with distortions modeled by the division model.</short>
<successor>
<item>set_calib_data_cam_param</item>
</successor>
<parameters>
<parameter id="CameraParam">
<default_type>real</default_type>
<description lang="de_DE">Output camera parameter tuple.</description>
<description lang="en_US">Output camera parameter tuple.</description>
<mixed_type>optional</mixed_type>
<multivalue>true</multivalue>
<sem_type>campar</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
<item>string</item>
</type_list>
</parameter>
<parameter id="Cx">
<default_type>real</default_type>
<default_value>640</default_value>
<description lang="en_US">Column coordinate of the principal point in the image.</description>
<multivalue>false</multivalue>
<sem_type>real</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
<parameter id="Cy">
<default_type>real</default_type>
<default_value>512</default_value>
<description lang="en_US">Row coordinate of the principal point in the image.</description>
<multivalue>false</multivalue>
<sem_type>real</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
<parameter id="ImageHeight">
<default_type>integer</default_type>
<default_value>1024</default_value>
<description lang="en_US">Image height.</description>
<multivalue>false</multivalue>
<sem_type>integer</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="ImagePlaneDist">
<default_type>real</default_type>
<default_value>0.02</default_value>
<description lang="en_US">Image plane distance.</description>
<multivalue>false</multivalue>
<sem_type>real</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
<parameter id="ImageWidth">
<default_type>integer</default_type>
<default_value>1280</default_value>
<description lang="en_US">Image width.</description>
<multivalue>false</multivalue>
<sem_type>integer</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="Kappa">
<default_type>real</default_type>
<default_value>0.0</default_value>
<description lang="en_US">Distortion coefficient to model the radial lens distortions.</description>
<multivalue>false</multivalue>
<sem_type>real</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
<parameter id="Magnification">
<default_type>real</default_type>
<default_value>0.2</default_value>
<description lang="en_US">Magnification of the lens.</description>
<multivalue>false</multivalue>
<sem_type>real</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
<values>
<item>0.1</item>
<item>0.2</item>
<item>0.3</item>
<item>0.4</item>
<item>0.5</item>
<item>1.0</item>
<item>2.0</item>
</values>
</parameter>
<parameter id="Rot">
<default_type>real</default_type>
<default_value>90.0</default_value>
<description lang="en_US">Rotation angle (in degrees), i.e., the direction, in which the optical axis is tilted.</description>
<multivalue>false</multivalue>
<sem_type>real</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
<parameter id="Sx">
<default_type>real</default_type>
<default_value>5.2e-6</default_value>
<description lang="en_US">Horizontal size of a pixel in world coordinates.</description>
<multivalue>false</multivalue>
<sem_type>real</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
<parameter id="Sy">
<default_type>real</default_type>
<default_value>5.2e-6</default_value>
<description lang="en_US">Vertical size of a pixel in world coordinates.</description>
<multivalue>false</multivalue>
<sem_type>real</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
<parameter id="Tilt">
<default_type>real</default_type>
<default_value>10.0</default_value>
<description lang="en_US">Tilt angle (in degrees).</description>
<multivalue>false</multivalue>
<sem_type>real</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
</parameters>
</docu>
</procedure>
<procedure name="gen_cam_par_area_scan_tilt_object_side_telecentric_polynomial">
<interface>
<ic>
<par name="Magnification" base_type="ctrl" dimension="0"/>
<par name="K1" base_type="ctrl" dimension="0"/>
<par name="K2" base_type="ctrl" dimension="0"/>
<par name="K3" base_type="ctrl" dimension="0"/>
<par name="P1" base_type="ctrl" dimension="0"/>
<par name="P2" base_type="ctrl" dimension="0"/>
<par name="ImagePlaneDist" base_type="ctrl" dimension="0"/>
<par name="Tilt" base_type="ctrl" dimension="0"/>
<par name="Rot" base_type="ctrl" dimension="0"/>
<par name="Sx" base_type="ctrl" dimension="0"/>
<par name="Sy" base_type="ctrl" dimension="0"/>
<par name="Cx" base_type="ctrl" dimension="0"/>
<par name="Cy" base_type="ctrl" dimension="0"/>
<par name="ImageWidth" base_type="ctrl" dimension="0"/>
<par name="ImageHeight" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="CameraParam" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c>* Generate a camera parameter tuple for an area scan camera with</c>
<c>* an object-side telecentric tilt lens and with distortions modeled</c>
<c>* by the polynomial model.</c>
<c>* </c>
<l>CameraParam := ['area_scan_tilt_object_side_telecentric_polynomial',Magnification,K1,K2,K3,P1,P2,ImagePlaneDist,Tilt,Rot,Sx,Sy,Cx,Cy,ImageWidth,ImageHeight]</l>
<l>return ()</l>
</body>
<docu id="gen_cam_par_area_scan_tilt_object_side_telecentric_polynomial">
<abstract lang="en_US">gen_cam_par_area_scan_tilt_object_side_telecentric_polynomial generates the camera parameter tuple CameraParam for an area scan camera with an object-side telecentric tilt lens and with distortions modeled by the polynomial model. For this, the camera parameters must be passed in Magnification (-), K1 (m^-2), K2 (m^-4), K3 (m^-6), P1 (m^-1), P2 (m^-1), ImagePlaneDist (m), Tilt (deg), Rot (deg), Sx (m/px), Sy (m/px), Cx (px), Cy (px), ImageWidth (px), and ImageHeight (px), where we indicate the HALCON default units in brackets. For a detailed explanation of the parameters, see the reference manual chapter Calibration / Multi-View.</abstract>
<chapters lang="de_DE">
<item>Kalibrierung</item>
<item>Kameraparameter</item>
</chapters>
<chapters lang="en_US">
<item>Calibration</item>
<item>Camera Parameters</item>
</chapters>
<keywords lang="de_DE">
<item>Kameraparameter kalibrieren</item>
<item>Kamera-Kalibrierparameter erhalten</item>
<item>Kameramodell</item>
<item>interne Kameraparameter</item>
<item>interne Kameraparameter kalibrieren</item>
<item>kalibrierte interne Kameraparameter erhalten</item>
</keywords>
<keywords lang="en_US">
<item>camera calibration parameters</item>
<item>camera calibration result</item>
<item>calibrate camera parameters</item>
<item>calibrate internal camera parameters</item>
<item>calibrated internal camera parameters</item>
</keywords>
<library lang="en_US">MVTec Standard Procedures</library>
<see_also>
<item>calibrate_cameras</item>
<item>get_cam_par_data</item>
<item>set_cam_par_data</item>
<item>get_cam_par_names</item>
<item>gen_cam_par_area_scan_division</item>
<item>gen_cam_par_area_scan_polynomial</item>
<item>gen_cam_par_area_scan_telecentric_division</item>
<item>gen_cam_par_area_scan_telecentric_polynomial</item>
<item>gen_cam_par_area_scan_tilt_division</item>
<item>gen_cam_par_area_scan_tilt_polynomial</item>
<item>gen_cam_par_area_scan_tilt_image_side_telecentric_division</item>
<item>gen_cam_par_area_scan_tilt_image_side_telecentric_polynomial</item>
<item>gen_cam_par_area_scan_tilt_bilateral_telecentric_division</item>
<item>gen_cam_par_area_scan_tilt_bilateral_telecentric_polynomial</item>
<item>gen_cam_par_area_scan_tilt_object_side_telecentric_division</item>
<item>gen_cam_par_area_scan_hypercentric_division</item>
<item>gen_cam_par_area_scan_hypercentric_polynomial</item>
<item>gen_cam_par_line_scan_division</item>
<item>gen_cam_par_line_scan_polynomial</item>
<item>gen_cam_par_line_scan_telecentric_division</item>
<item>gen_cam_par_line_scan_telecentric_polynomial</item>
</see_also>
<short lang="en_US">Generate a camera parameter tuple for an area scan camera with an object-side telecentric tilt lens and with distortions modeled by the polynomial model.</short>
<successor>
<item>set_calib_data_cam_param</item>
</successor>
<parameters>
<parameter id="CameraParam">
<default_type>real</default_type>
<description lang="en_US">Output camera parameter tuple.</description>
<mixed_type>optional</mixed_type>
<multivalue>true</multivalue>
<sem_type>campar</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
<item>string</item>
</type_list>
</parameter>
<parameter id="Cx">
<default_type>real</default_type>
<default_value>640</default_value>
<description lang="en_US">Column coordinate of the principal point in the image.</description>
<multivalue>false</multivalue>
<sem_type>real</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
<parameter id="Cy">
<default_type>real</default_type>
<default_value>512</default_value>
<description lang="en_US">Row coordinate of the principal point in the image.</description>
<multivalue>false</multivalue>
<sem_type>real</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
<parameter id="ImageHeight">
<default_type>integer</default_type>
<default_value>1024</default_value>
<description lang="en_US">Image height.</description>
<multivalue>false</multivalue>
<sem_type>integer</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="ImagePlaneDist">
<default_type>real</default_type>
<default_value>0.02</default_value>
<description lang="en_US">Image plane distance.</description>
<multivalue>false</multivalue>
<sem_type>real</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
<parameter id="ImageWidth">
<default_type>integer</default_type>
<default_value>1280</default_value>
<description lang="en_US">Image width.</description>
<multivalue>false</multivalue>
<sem_type>integer</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="K1">
<default_type>real</default_type>
<default_value>0.0</default_value>
<description lang="en_US">Distortion coefficient to model the radial lens distortions.</description>
<multivalue>false</multivalue>
<sem_type>real</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
<parameter id="K2">
<default_type>real</default_type>
<default_value>0.0</default_value>
<description lang="en_US">Distortion coefficient to model the radial lens distortions.</description>
<multivalue>false</multivalue>
<sem_type>real</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
<parameter id="K3">
<default_type>real</default_type>
<default_value>0.0</default_value>
<description lang="en_US">Distortion coefficient to model the radial lens distortions.</description>
<multivalue>false</multivalue>
<sem_type>real</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
<parameter id="Magnification">
<default_type>real</default_type>
<default_value>0.2</default_value>
<description lang="en_US">Magnification of the lens.</description>
<multivalue>false</multivalue>
<sem_type>real</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
<values>
<item>0.1</item>
<item>0.2</item>
<item>0.3</item>
<item>0.4</item>
<item>0.5</item>
<item>1.0</item>
<item>2.0</item>
</values>
</parameter>
<parameter id="P1">
<default_type>real</default_type>
<default_value>0.0</default_value>
<description lang="en_US">Distortion coefficient to model decentering lens distortions.</description>
<multivalue>false</multivalue>
<sem_type>real</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
<parameter id="P2">
<default_type>real</default_type>
<default_value>0.0</default_value>
<description lang="en_US">Distortion coefficient to model decentering lens distortions.</description>
<multivalue>false</multivalue>
<sem_type>real</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
<parameter id="Rot">
<default_type>real</default_type>
<default_value>90.0</default_value>
<description lang="en_US">Rotation angle (in degrees), i.e., the direction, in which the optical axis is tilted.</description>
<multivalue>false</multivalue>
<sem_type>real</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
<parameter id="Sx">
<default_type>real</default_type>
<default_value>5.2e-6</default_value>
<description lang="en_US">Horizontal size of a pixel in world coordinates.</description>
<multivalue>false</multivalue>
<sem_type>real</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
<parameter id="Sy">
<default_type>real</default_type>
<default_value>5.2e-6</default_value>
<description lang="en_US">Vertical size of a pixel in world coordinates.</description>
<multivalue>false</multivalue>
<sem_type>real</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
<parameter id="Tilt">
<default_type>real</default_type>
<default_value>10.0</default_value>
<description lang="en_US">Tilt angle (in degrees).</description>
<multivalue>false</multivalue>
<sem_type>real</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
</parameters>
</docu>
</procedure>
<procedure name="gen_cam_par_area_scan_tilt_polynomial">
<interface>
<ic>
<par name="Focus" base_type="ctrl" dimension="0"/>
<par name="K1" base_type="ctrl" dimension="0"/>
<par name="K2" base_type="ctrl" dimension="0"/>
<par name="K3" base_type="ctrl" dimension="0"/>
<par name="P1" base_type="ctrl" dimension="0"/>
<par name="P2" base_type="ctrl" dimension="0"/>
<par name="ImagePlaneDist" base_type="ctrl" dimension="0"/>
<par name="Tilt" base_type="ctrl" dimension="0"/>
<par name="Rot" base_type="ctrl" dimension="0"/>
<par name="Sx" base_type="ctrl" dimension="0"/>
<par name="Sy" base_type="ctrl" dimension="0"/>
<par name="Cx" base_type="ctrl" dimension="0"/>
<par name="Cy" base_type="ctrl" dimension="0"/>
<par name="ImageWidth" base_type="ctrl" dimension="0"/>
<par name="ImageHeight" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="CameraParam" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c>* Generate a camera parameter tuple for an area scan camera with</c>
<c>* a tilt lens and with distortions modeled by the polynomial model.</c>
<c>* </c>
<l>CameraParam := ['area_scan_tilt_polynomial',Focus,K1,K2,K3,P1,P2,ImagePlaneDist,Tilt,Rot,Sx,Sy,Cx,Cy,ImageWidth,ImageHeight]</l>
<l>return ()</l>
</body>
<docu id="gen_cam_par_area_scan_tilt_polynomial">
<abstract lang="en_US">gen_cam_par_area_scan_tilt_polynomial generates the camera parameter tuple CameraParam for an area scan camera with a tilt lens and with distortions modeled by the polynomial model. For this, the camera parameters must be passed in Focus (m), K1 (m^-2), K2 (m^-4), K3 (m^-6), P1 (m^-1), P2 (m^-1), ImagePlaneDist (m), Tilt (deg), Rot (deg), Sx (m/px), Sy (m/px), Cx (px), Cy (px), ImageWidth (px), and ImageHeight (px), where we indicate the HALCON default units in brackets. For a detailed explanation of the parameters, see the reference manual chapter Calibration / Multi-View.</abstract>
<chapters lang="de_DE">
<item>Kalibrierung</item>
<item>Kameraparameter</item>
</chapters>
<chapters lang="en_US">
<item>Calibration</item>
<item>Camera Parameters</item>
</chapters>
<keywords lang="de_DE">
<item>Kameraparameter kalibrieren</item>
<item>Kamera-Kalibrierparameter erhalten</item>
<item>Kameramodell</item>
<item>interne Kameraparameter</item>
<item>interne Kameraparameter kalibrieren</item>
<item>kalibrierte interne Kameraparameter erhalten</item>
</keywords>
<keywords lang="en_US">
<item>camera calibration parameters</item>
<item>camera calibration result</item>
<item>calibrate camera parameters</item>
<item>calibrate internal camera parameters</item>
<item>calibrated internal camera parameters</item>
</keywords>
<library lang="en_US">MVTec Standard Procedures</library>
<see_also>
<item>calibrate_cameras</item>
<item>get_cam_par_data</item>
<item>set_cam_par_data</item>
<item>get_cam_par_names</item>
<item>gen_cam_par_area_scan_division</item>
<item>gen_cam_par_area_scan_polynomial</item>
<item>gen_cam_par_area_scan_telecentric_division</item>
<item>gen_cam_par_area_scan_telecentric_polynomial</item>
<item>gen_cam_par_area_scan_tilt_division</item>
<item>gen_cam_par_area_scan_tilt_image_side_telecentric_division</item>
<item>gen_cam_par_area_scan_tilt_image_side_telecentric_polynomial</item>
<item>gen_cam_par_area_scan_tilt_bilateral_telecentric_division</item>
<item>gen_cam_par_area_scan_tilt_bilateral_telecentric_polynomial</item>
<item>gen_cam_par_area_scan_tilt_object_side_telecentric_division</item>
<item>gen_cam_par_area_scan_tilt_object_side_telecentric_polynomial</item>
<item>gen_cam_par_area_scan_hypercentric_division</item>
<item>gen_cam_par_area_scan_hypercentric_polynomial</item>
<item>gen_cam_par_line_scan_division</item>
<item>gen_cam_par_line_scan_polynomial</item>
<item>gen_cam_par_line_scan_telecentric_division</item>
<item>gen_cam_par_line_scan_telecentric_polynomial</item>
</see_also>
<short lang="en_US">Generate a camera parameter tuple for an area scan camera with a tilt lens and with distortions modeled by the polynomial model.</short>
<successor>
<item>set_calib_data_cam_param</item>
</successor>
<parameters>
<parameter id="CameraParam">
<default_type>real</default_type>
<description lang="en_US">Output camera parameter tuple.</description>
<mixed_type>optional</mixed_type>
<multivalue>true</multivalue>
<sem_type>campar</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
<item>string</item>
</type_list>
</parameter>
<parameter id="Cx">
<default_type>real</default_type>
<default_value>640</default_value>
<description lang="en_US">Column coordinate of the principal point in the image.</description>
<multivalue>false</multivalue>
<sem_type>real</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
<parameter id="Cy">
<default_type>real</default_type>
<default_value>512</default_value>
<description lang="en_US">Row coordinate of the principal point in the image.</description>
<multivalue>false</multivalue>
<sem_type>real</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
<parameter id="Focus">
<default_type>real</default_type>
<default_value>0.008</default_value>
<description lang="en_US">Principal distance.</description>
<multivalue>false</multivalue>
<sem_type>real</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
<parameter id="ImageHeight">
<default_type>integer</default_type>
<default_value>1024</default_value>
<description lang="en_US">Image height.</description>
<multivalue>false</multivalue>
<sem_type>integer</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="ImagePlaneDist">
<default_type>real</default_type>
<default_value>0.02</default_value>
<description lang="en_US">Image plane distance.</description>
<sem_type>real</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
<parameter id="ImageWidth">
<default_type>integer</default_type>
<default_value>1280</default_value>
<description lang="en_US">Image width.</description>
<multivalue>false</multivalue>
<sem_type>integer</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="K1">
<default_type>real</default_type>
<default_value>0.0</default_value>
<description lang="en_US">Distortion coefficient to model the radial lens distortions.</description>
<multivalue>false</multivalue>
<sem_type>real</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
<parameter id="K2">
<default_type>real</default_type>
<default_value>0.0</default_value>
<description lang="en_US">Distortion coefficient to model the radial lens distortions.</description>
<multivalue>false</multivalue>
<sem_type>real</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
<parameter id="K3">
<default_type>real</default_type>
<default_value>0.0</default_value>
<description lang="en_US">Distortion coefficient to model the radial lens distortions.</description>
<multivalue>false</multivalue>
<sem_type>real</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
<parameter id="P1">
<default_type>real</default_type>
<default_value>0.0</default_value>
<description lang="en_US">Distortion coefficient to model decentering lens distortions.</description>
<multivalue>false</multivalue>
<sem_type>real</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
<parameter id="P2">
<default_type>real</default_type>
<default_value>0.0</default_value>
<description lang="en_US">Distortion coefficient to model decentering lens distortions.</description>
<multivalue>false</multivalue>
<sem_type>real</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
<parameter id="Rot">
<default_type>real</default_type>
<default_value>90.0</default_value>
<description lang="en_US">Rotation angle (in degrees), i.e., the direction, in which the optical axis is tilted.</description>
<multivalue>false</multivalue>
<sem_type>real</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
<parameter id="Sx">
<default_type>real</default_type>
<default_value>5.2e-6</default_value>
<description lang="en_US">Horizontal distance between two neighboring cells on the sensor.</description>
<multivalue>false</multivalue>
<sem_type>real</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
<parameter id="Sy">
<default_type>real</default_type>
<default_value>5.2e-6</default_value>
<description lang="en_US">Vertical distance between two neighboring cells on the sensor.</description>
<multivalue>false</multivalue>
<sem_type>real</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
<parameter id="Tilt">
<default_type>real</default_type>
<default_value>10.0</default_value>
<description lang="en_US">Tilt angle (in degrees).</description>
<multivalue>false</multivalue>
<sem_type>real</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
</parameters>
</docu>
</procedure>
<procedure name="gen_cam_par_line_scan">
<interface>
<ic>
<par name="Focus" base_type="ctrl" dimension="0"/>
<par name="Kappa" base_type="ctrl" dimension="0"/>
<par name="Sx" base_type="ctrl" dimension="0"/>
<par name="Sy" base_type="ctrl" dimension="0"/>
<par name="Cx" base_type="ctrl" dimension="0"/>
<par name="Cy" base_type="ctrl" dimension="0"/>
<par name="ImageWidth" base_type="ctrl" dimension="0"/>
<par name="ImageHeight" base_type="ctrl" dimension="0"/>
<par name="Vx" base_type="ctrl" dimension="0"/>
<par name="Vy" base_type="ctrl" dimension="0"/>
<par name="Vz" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="CameraParam" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c>* Generate a camera parameter tuple for a line scan camera.</c>
<c>* </c>
<l>CameraParam := ['line_scan',Focus,Kappa,Sx,Sy,Cx,Cy,ImageWidth,ImageHeight,Vx,Vy,Vz]</l>
<l>return ()</l>
</body>
<docu id="gen_cam_par_line_scan">
<abstract lang="en_US">gen_cam_par_line_scan generates the camera parameter tuple CameraParam for a line scan camera. For this, the camera parameters must be passed in Focus (m), Kappa (m^-2), Sx (m/px), Sy (m/px), Cx (px), Cy (px), ImageWidth (px), ImageHeight (px), Vx (m/scanline), Vy (m/scanline), Vz (m/scanline), where we indicate the HALCON default units in brackets. For a detailed explanation of the parameters, see the reference manual chapter Calibration / Multi-View.</abstract>
<alternatives>
<item>gen_cam_par_line_scan_division</item>
<item>gen_cam_par_line_scan_polynomial</item>
<item>gen_cam_par_line_scan_telecentric_division</item>
<item>gen_cam_par_line_scan_telecentric_polynomial</item>
</alternatives>
<chapters lang="de_DE">
<item>Kalibrierung</item>
<item>Kameraparameter</item>
</chapters>
<chapters lang="en_US">
<item>Calibration</item>
<item>Camera Parameters</item>
</chapters>
<keywords lang="de_DE">
<item>Kameraparameter kalibrieren</item>
<item>Kamera-Kalibrierparameter erhalten</item>
<item>Kameramodell</item>
<item>interne Kameraparameter</item>
<item>interne Kameraparameter kalibrieren</item>
<item>kalibrierte interne Kameraparameter erhalten</item>
</keywords>
<keywords lang="en_US">
<item>camera calibration parameters</item>
<item>camera calibration result</item>
<item>calibrate camera parameters</item>
<item>calibrate internal camera parameters</item>
<item>calibrated internal camera parameters</item>
</keywords>
<library lang="en_US">MVTec Standard Procedures</library>
<see_also>
<item>calibrate_cameras</item>
<item>get_cam_par_data</item>
<item>set_cam_par_data</item>
<item>get_cam_par_names</item>
<item>gen_cam_par_area_scan_division</item>
<item>gen_cam_par_area_scan_polynomial</item>
<item>gen_cam_par_area_scan_telecentric_division</item>
<item>gen_cam_par_area_scan_telecentric_polynomial</item>
<item>gen_cam_par_area_scan_tilt_division</item>
<item>gen_cam_par_area_scan_tilt_polynomial</item>
<item>gen_cam_par_area_scan_tilt_image_side_telecentric_division</item>
<item>gen_cam_par_area_scan_tilt_image_side_telecentric_polynomial</item>
<item>gen_cam_par_area_scan_tilt_bilateral_telecentric_division</item>
<item>gen_cam_par_area_scan_tilt_bilateral_telecentric_polynomial</item>
<item>gen_cam_par_area_scan_tilt_object_side_telecentric_division</item>
<item>gen_cam_par_area_scan_tilt_object_side_telecentric_polynomial</item>
<item>gen_cam_par_area_scan_hypercentric_division</item>
<item>gen_cam_par_area_scan_hypercentric_polynomial</item>
</see_also>
<short lang="en_US">Generate a camera parameter tuple for a line scan camera.</short>
<successor>
<item>set_calib_data_cam_param</item>
</successor>
<warning lang="en_US">gen_cam_par_line_scan is obsolete and only provided for backwards compatibility. It may be removed in future HALCON versions. Please use gen_cam_par_line_scan_division instead.</warning>
<parameters>
<parameter id="CameraParam">
<default_type>real</default_type>
<description lang="en_US">Output camera parameter tuple.</description>
<mixed_type>optional</mixed_type>
<multivalue>true</multivalue>
<sem_type>campar</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
<item>string</item>
</type_list>
</parameter>
<parameter id="Cx">
<default_type>real</default_type>
<default_value>1024</default_value>
<description lang="en_US">Column coordinate of the principal point in the image.</description>
<multivalue>false</multivalue>
<sem_type>real</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
<parameter id="Cy">
<default_type>real</default_type>
<default_value>0</default_value>
<description lang="en_US">Distance of the principal point from the sensor line in scanlines.</description>
<multivalue>false</multivalue>
<sem_type>real</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
<parameter id="Focus">
<default_type>real</default_type>
<default_value>0.008</default_value>
<description lang="en_US">Principal distance.</description>
<multivalue>false</multivalue>
<sem_type>real</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
<parameter id="ImageHeight">
<default_type>integer</default_type>
<default_value>3840</default_value>
<description lang="en_US">Image height.</description>
<multivalue>false</multivalue>
<sem_type>integer</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="ImageWidth">
<default_type>integer</default_type>
<default_value>2048</default_value>
<description lang="en_US">Image width.</description>
<multivalue>false</multivalue>
<sem_type>integer</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="Kappa">
<default_type>real</default_type>
<default_value>0.0</default_value>
<description lang="en_US">Distortion coefficient to model the radial lens distortions.</description>
<multivalue>false</multivalue>
<sem_type>real</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
<parameter id="Sx">
<default_type>real</default_type>
<default_value>1e-5</default_value>
<description lang="en_US">Horizontal size of the cells on the sensor.</description>
<multivalue>false</multivalue>
<sem_type>real</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
<parameter id="Sy">
<default_type>real</default_type>
<default_value>1e-5</default_value>
<description lang="en_US">Vertical size of the cells on the sensor.</description>
<multivalue>false</multivalue>
<sem_type>real</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
<parameter id="Vx">
<default_type>real</default_type>
<default_value>0.0</default_value>
<description lang="en_US">X component of the motion vector.</description>
<multivalue>false</multivalue>
<sem_type>real</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
<parameter id="Vy">
<default_type>real</default_type>
<default_value>5e-5</default_value>
<description lang="en_US">Y component of the motion vector.</description>
<multivalue>false</multivalue>
<sem_type>real</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
<parameter id="Vz">
<default_type>real</default_type>
<default_value>0.0</default_value>
<description lang="en_US">Z component of the motion vector.</description>
<multivalue>false</multivalue>
<sem_type>real</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
</parameters>
</docu>
</procedure>
<procedure name="gen_cam_par_line_scan_division">
<interface>
<ic>
<par name="Focus" base_type="ctrl" dimension="0"/>
<par name="Kappa" base_type="ctrl" dimension="0"/>
<par name="Sx" base_type="ctrl" dimension="0"/>
<par name="Sy" base_type="ctrl" dimension="0"/>
<par name="Cx" base_type="ctrl" dimension="0"/>
<par name="Cy" base_type="ctrl" dimension="0"/>
<par name="ImageWidth" base_type="ctrl" dimension="0"/>
<par name="ImageHeight" base_type="ctrl" dimension="0"/>
<par name="Vx" base_type="ctrl" dimension="0"/>
<par name="Vy" base_type="ctrl" dimension="0"/>
<par name="Vz" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="CameraParam" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c>* Generate a camera parameter tuple for a line scan camera</c>
<c>* with distortions modeled by the division model.</c>
<c>* </c>
<l>CameraParam := ['line_scan_division',Focus,Kappa,Sx,Sy,Cx,Cy,ImageWidth,ImageHeight,Vx,Vy,Vz]</l>
<l>return ()</l>
</body>
<docu id="gen_cam_par_line_scan_division">
<abstract lang="en_US">gen_cam_par_line_scan_division generates the camera parameter tuple CameraParam for a line scan camera with distortions modeled by the division model. For this, the camera parameters must be passed in Focus (m), Kappa (m^-2), Sx (m/px), Sy (m/px), Cx (px), Cy (px), ImageWidth (px), ImageHeight (px), Vx (m/scanline), Vy (m/scanline), Vz (m/scanline), where we indicate the HALCON default units in brackets. For a detailed explanation of the parameters, see the reference manual chapter Calibration / Multi-View.</abstract>
<chapters lang="de_DE">
<item>Kalibrierung</item>
<item>Kameraparameter</item>
</chapters>
<chapters lang="en_US">
<item>Calibration</item>
<item>Camera Parameters</item>
</chapters>
<keywords lang="de_DE">
<item>Kameraparameter kalibrieren</item>
<item>Kamera-Kalibrierparameter erhalten</item>
<item>Kameramodell</item>
<item>interne Kameraparameter</item>
<item>interne Kameraparameter kalibrieren</item>
<item>kalibrierte interne Kameraparameter erhalten</item>
</keywords>
<keywords lang="en_US">
<item>camera calibration parameters</item>
<item>camera calibration result</item>
<item>calibrate camera parameters</item>
<item>calibrate internal camera parameters</item>
<item>calibrated internal camera parameters</item>
</keywords>
<library lang="en_US">MVTec Standard Procedures</library>
<see_also>
<item>calibrate_cameras</item>
<item>get_cam_par_data</item>
<item>set_cam_par_data</item>
<item>get_cam_par_names</item>
<item>gen_cam_par_area_scan_division</item>
<item>gen_cam_par_area_scan_polynomial</item>
<item>gen_cam_par_area_scan_telecentric_division</item>
<item>gen_cam_par_area_scan_telecentric_polynomial</item>
<item>gen_cam_par_area_scan_tilt_division</item>
<item>gen_cam_par_area_scan_tilt_polynomial</item>
<item>gen_cam_par_area_scan_tilt_image_side_telecentric_division</item>
<item>gen_cam_par_area_scan_tilt_image_side_telecentric_polynomial</item>
<item>gen_cam_par_area_scan_tilt_bilateral_telecentric_division</item>
<item>gen_cam_par_area_scan_tilt_bilateral_telecentric_polynomial</item>
<item>gen_cam_par_area_scan_tilt_object_side_telecentric_division</item>
<item>gen_cam_par_area_scan_tilt_object_side_telecentric_polynomial</item>
<item>gen_cam_par_area_scan_hypercentric_division</item>
<item>gen_cam_par_area_scan_hypercentric_polynomial</item>
<item>gen_cam_par_line_scan_polynomial</item>
<item>gen_cam_par_line_scan_telecentric_division</item>
<item>gen_cam_par_line_scan_telecentric_polynomial</item>
</see_also>
<short lang="en_US">Generate a camera parameter tuple for a line scan camera with distortions modeled by the division model.</short>
<successor>
<item>set_calib_data_cam_param</item>
</successor>
<parameters>
<parameter id="CameraParam">
<default_type>real</default_type>
<description lang="en_US">Output camera parameter tuple.</description>
<mixed_type>optional</mixed_type>
<multivalue>true</multivalue>
<sem_type>campar</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
<item>string</item>
</type_list>
</parameter>
<parameter id="Cx">
<default_type>real</default_type>
<default_value>1024</default_value>
<description lang="en_US">Column coordinate of the principal point in the image.</description>
<multivalue>false</multivalue>
<sem_type>real</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
<parameter id="Cy">
<default_type>real</default_type>
<default_value>0</default_value>
<description lang="en_US">Distance of the principal point from the sensor line in scanlines.</description>
<multivalue>false</multivalue>
<sem_type>real</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
<parameter id="Focus">
<default_type>real</default_type>
<default_value>0.008</default_value>
<description lang="en_US">Principal distance.</description>
<multivalue>false</multivalue>
<sem_type>real</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
<parameter id="ImageHeight">
<default_type>integer</default_type>
<default_value>3840</default_value>
<description lang="en_US">Image height.</description>
<multivalue>false</multivalue>
<sem_type>integer</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="ImageWidth">
<default_type>integer</default_type>
<default_value>2048</default_value>
<description lang="en_US">Image width.</description>
<multivalue>false</multivalue>
<sem_type>integer</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="Kappa">
<default_type>real</default_type>
<default_value>0.0</default_value>
<description lang="en_US">Distortion coefficient to model the radial lens distortions.</description>
<multivalue>false</multivalue>
<sem_type>real</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
<parameter id="Sx">
<default_type>real</default_type>
<default_value>1e-5</default_value>
<description lang="en_US">Horizontal size of the cells on the sensor.</description>
<multivalue>false</multivalue>
<sem_type>real</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
<parameter id="Sy">
<default_type>real</default_type>
<default_value>1e-5</default_value>
<description lang="en_US">Vertical size of the cells on the sensor.</description>
<multivalue>false</multivalue>
<sem_type>real</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
<parameter id="Vx">
<default_type>real</default_type>
<default_value>0.0</default_value>
<description lang="en_US">X component of the motion vector.</description>
<multivalue>false</multivalue>
<sem_type>real</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
<parameter id="Vy">
<default_type>real</default_type>
<default_value>5e-5</default_value>
<description lang="en_US">Y component of the motion vector.</description>
<multivalue>false</multivalue>
<sem_type>real</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
<parameter id="Vz">
<default_type>real</default_type>
<default_value>0.0</default_value>
<description lang="en_US">Z component of the motion vector.</description>
<multivalue>false</multivalue>
<sem_type>real</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
</parameters>
</docu>
</procedure>
<procedure name="gen_cam_par_line_scan_polynomial">
<interface>
<ic>
<par name="Focus" base_type="ctrl" dimension="0"/>
<par name="K1" base_type="ctrl" dimension="0"/>
<par name="K2" base_type="ctrl" dimension="0"/>
<par name="K3" base_type="ctrl" dimension="0"/>
<par name="P1" base_type="ctrl" dimension="0"/>
<par name="P2" base_type="ctrl" dimension="0"/>
<par name="Sx" base_type="ctrl" dimension="0"/>
<par name="Sy" base_type="ctrl" dimension="0"/>
<par name="Cx" base_type="ctrl" dimension="0"/>
<par name="Cy" base_type="ctrl" dimension="0"/>
<par name="ImageWidth" base_type="ctrl" dimension="0"/>
<par name="ImageHeight" base_type="ctrl" dimension="0"/>
<par name="Vx" base_type="ctrl" dimension="0"/>
<par name="Vy" base_type="ctrl" dimension="0"/>
<par name="Vz" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="CameraParam" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c>* Generate a camera parameter tuple for a line scan camera</c>
<c>* with distortions modeled by the polynomial model.</c>
<c>* </c>
<l>CameraParam := ['line_scan_polynomial',Focus,K1,K2,K3,P1,P2,Sx,Sy,Cx,Cy,ImageWidth,ImageHeight,Vx,Vy,Vz]</l>
<l>return ()</l>
</body>
<docu id="gen_cam_par_line_scan_polynomial">
<abstract lang="en_US">gen_cam_par_line_scan_polynomial generates the camera parameter tuple CameraParam for a line scan camera with distortions modeled by the polynomial model. For this, the camera parameters must be passed in Focus (m), K1 (m^-2), K2 (m^-4), K3 (m^-6), P1 (m^-1), P2 (m^-1), Sx (m/px), Sy (m/px), Cx (px), Cy (px), ImageWidth (px), ImageHeight (px), Vx (m/scanline), Vy (m/scanline), Vz (m/scanline), where we indicate the HALCON default units in brackets. For a detailed explanation of the parameters, see the reference manual chapter Calibration / Multi-View.</abstract>
<chapters lang="de_DE">
<item>Kalibrierung</item>
<item>Kameraparameter</item>
</chapters>
<chapters lang="en_US">
<item>Calibration</item>
<item>Camera Parameters</item>
</chapters>
<keywords lang="de_DE">
<item>Kameraparameter kalibrieren</item>
<item>Kamera-Kalibrierparameter erhalten</item>
<item>Kameramodell</item>
<item>interne Kameraparameter</item>
<item>interne Kameraparameter kalibrieren</item>
<item>kalibrierte interne Kameraparameter erhalten</item>
</keywords>
<keywords lang="en_US">
<item>camera calibration parameters</item>
<item>camera calibration result</item>
<item>calibrate camera parameters</item>
<item>calibrate internal camera parameters</item>
<item>calibrated internal camera parameters</item>
</keywords>
<library lang="en_US">MVTec Standard Procedures</library>
<see_also>
<item>calibrate_cameras</item>
<item>get_cam_par_data</item>
<item>set_cam_par_data</item>
<item>get_cam_par_names</item>
<item>gen_cam_par_area_scan_division</item>
<item>gen_cam_par_area_scan_polynomial</item>
<item>gen_cam_par_area_scan_telecentric_division</item>
<item>gen_cam_par_area_scan_telecentric_polynomial</item>
<item>gen_cam_par_area_scan_tilt_division</item>
<item>gen_cam_par_area_scan_tilt_polynomial</item>
<item>gen_cam_par_area_scan_tilt_image_side_telecentric_division</item>
<item>gen_cam_par_area_scan_tilt_image_side_telecentric_polynomial</item>
<item>gen_cam_par_area_scan_tilt_bilateral_telecentric_division</item>
<item>gen_cam_par_area_scan_tilt_bilateral_telecentric_polynomial</item>
<item>gen_cam_par_area_scan_tilt_object_side_telecentric_division</item>
<item>gen_cam_par_area_scan_tilt_object_side_telecentric_polynomial</item>
<item>gen_cam_par_area_scan_hypercentric_division</item>
<item>gen_cam_par_area_scan_hypercentric_polynomial</item>
<item>gen_cam_par_line_scan_division</item>
<item>gen_cam_par_line_scan_telecentric_division</item>
<item>gen_cam_par_line_scan_telecentric_polynomial</item>
</see_also>
<short lang="en_US">Generate a camera parameter tuple for a line scan camera with distortions modeled by the polynomial model.</short>
<successor>
<item>set_calib_data_cam_param</item>
</successor>
<parameters>
<parameter id="CameraParam">
<default_type>real</default_type>
<description lang="en_US">Output camera parameter tuple.</description>
<mixed_type>optional</mixed_type>
<multivalue>true</multivalue>
<sem_type>campar</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
<item>string</item>
</type_list>
</parameter>
<parameter id="Cx">
<default_type>real</default_type>
<default_value>1024</default_value>
<description lang="en_US">Column coordinate of the principal point in the image.</description>
<multivalue>false</multivalue>
<sem_type>real</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
<parameter id="Cy">
<default_type>real</default_type>
<default_value>0</default_value>
<description lang="en_US">Distance of the principal point from the sensor line in scanlines.</description>
<multivalue>false</multivalue>
<sem_type>real</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
<parameter id="Focus">
<default_type>real</default_type>
<default_value>0.008</default_value>
<description lang="en_US">Principal distance.</description>
<multivalue>false</multivalue>
<sem_type>real</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
<parameter id="ImageHeight">
<default_type>integer</default_type>
<default_value>3840</default_value>
<description lang="en_US">Image height.</description>
<multivalue>false</multivalue>
<sem_type>integer</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="ImageWidth">
<default_type>integer</default_type>
<default_value>2048</default_value>
<description lang="en_US">Image width.</description>
<multivalue>false</multivalue>
<sem_type>integer</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="K1">
<default_type>real</default_type>
<default_value>0.0</default_value>
<description lang="en_US">Distortion coefficient to model radial lens distortions.</description>
<multivalue>false</multivalue>
<sem_type>real</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
<parameter id="K2">
<default_type>real</default_type>
<default_value>0.0</default_value>
<description lang="en_US">Distortion coefficient to model radial lens distortions.</description>
<multivalue>false</multivalue>
<sem_type>real</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
<parameter id="K3">
<default_type>real</default_type>
<default_value>0.0</default_value>
<description lang="en_US">Distortion coefficient to model radial lens distortions.</description>
<multivalue>false</multivalue>
<sem_type>real</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
<parameter id="P1">
<default_type>real</default_type>
<default_value>0.0</default_value>
<description lang="en_US">Distortion coefficient to model decentering lens distortions.</description>
<multivalue>false</multivalue>
<sem_type>real</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
<parameter id="P2">
<default_type>real</default_type>
<default_value>0.0</default_value>
<description lang="en_US">Distortion coefficient to model decentering lens distortions.</description>
<multivalue>false</multivalue>
<sem_type>real</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
<parameter id="Sx">
<default_type>real</default_type>
<default_value>1e-5</default_value>
<description lang="en_US">Horizontal size of the cells on the sensor.</description>
<multivalue>false</multivalue>
<sem_type>real</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
<parameter id="Sy">
<default_type>real</default_type>
<default_value>1e-5</default_value>
<description lang="en_US">Vertical size of the cells on the sensor.</description>
<multivalue>false</multivalue>
<sem_type>real</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
<parameter id="Vx">
<default_type>real</default_type>
<default_value>0.0</default_value>
<description lang="en_US">X component of the motion vector.</description>
<multivalue>false</multivalue>
<sem_type>real</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
<parameter id="Vy">
<default_type>real</default_type>
<default_value>5e-5</default_value>
<description lang="en_US">Y component of the motion vector.</description>
<multivalue>false</multivalue>
<sem_type>real</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
<parameter id="Vz">
<default_type>real</default_type>
<default_value>0.0</default_value>
<description lang="en_US">Z component of the motion vector.</description>
<multivalue>false</multivalue>
<sem_type>real</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
</parameters>
</docu>
</procedure>
<procedure name="gen_cam_par_line_scan_telecentric_division">
<interface>
<ic>
<par name="Magnification" base_type="ctrl" dimension="0"/>
<par name="Kappa" base_type="ctrl" dimension="0"/>
<par name="Sx" base_type="ctrl" dimension="0"/>
<par name="Sy" base_type="ctrl" dimension="0"/>
<par name="Cx" base_type="ctrl" dimension="0"/>
<par name="Cy" base_type="ctrl" dimension="0"/>
<par name="ImageWidth" base_type="ctrl" dimension="0"/>
<par name="ImageHeight" base_type="ctrl" dimension="0"/>
<par name="Vx" base_type="ctrl" dimension="0"/>
<par name="Vy" base_type="ctrl" dimension="0"/>
<par name="Vz" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="CameraParam" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c>* Generate a camera parameter tuple for a telecentric line scan camera</c>
<c>* with distortions modeled by the division model.</c>
<c>* </c>
<l>CameraParam := ['line_scan_telecentric_division',Magnification,Kappa,Sx,Sy,Cx,Cy,ImageWidth,ImageHeight,Vx,Vy,Vz]</l>
<l>return ()</l>
</body>
<docu id="gen_cam_par_line_scan_telecentric_division">
<abstract lang="en_US">gen_cam_par_line_scan_telecentric_division generates the camera parameter tuple CameraParam for a line scan camera with a telecentric lens and with distortions modeled by the division model. For this, the camera parameters must be passed in Magnification (-), Kappa (m^-2), Sx (m/px), Sy (m/px), Cx (px), Cy (px), ImageWidth (px), ImageHeight (px), Vx (m/scanline), Vy (m/scanline), Vz (m/scanline), where we indicate the HALCON default units in brackets. For a detailed explanation of the parameters, see the reference manual chapter Calibration / Multi-View.</abstract>
<chapters lang="de_DE">
<item>Kalibrierung</item>
<item>Kameraparameter</item>
</chapters>
<chapters lang="en_US">
<item>Calibration</item>
<item>Camera Parameters</item>
</chapters>
<keywords lang="de_DE">
<item>Kameraparameter kalibrieren</item>
<item>Kamera-Kalibrierparameter erhalten</item>
<item>Kameramodell</item>
<item>interne Kameraparameter</item>
<item>interne Kameraparameter kalibrieren</item>
<item>kalibrierte interne Kameraparameter erhalten</item>
</keywords>
<keywords lang="en_US">
<item>camera calibration parameters</item>
<item>camera calibration result</item>
<item>calibrate camera parameters</item>
<item>calibrate internal camera parameters</item>
<item>calibrated internal camera parameters</item>
</keywords>
<library lang="en_US">MVTec Standard Procedures</library>
<see_also>
<item>calibrate_cameras</item>
<item>get_cam_par_data</item>
<item>set_cam_par_data</item>
<item>get_cam_par_names</item>
<item>gen_cam_par_area_scan_division</item>
<item>gen_cam_par_area_scan_polynomial</item>
<item>gen_cam_par_area_scan_telecentric_division</item>
<item>gen_cam_par_area_scan_telecentric_polynomial</item>
<item>gen_cam_par_area_scan_tilt_division</item>
<item>gen_cam_par_area_scan_tilt_polynomial</item>
<item>gen_cam_par_area_scan_tilt_image_side_telecentric_division</item>
<item>gen_cam_par_area_scan_tilt_image_side_telecentric_polynomial</item>
<item>gen_cam_par_area_scan_tilt_bilateral_telecentric_division</item>
<item>gen_cam_par_area_scan_tilt_bilateral_telecentric_polynomial</item>
<item>gen_cam_par_area_scan_tilt_object_side_telecentric_division</item>
<item>gen_cam_par_area_scan_tilt_object_side_telecentric_polynomial</item>
<item>gen_cam_par_area_scan_hypercentric_division</item>
<item>gen_cam_par_area_scan_hypercentric_polynomial</item>
<item>gen_cam_par_line_scan_division</item>
<item>gen_cam_par_line_scan_polynomial</item>
<item>gen_cam_par_line_scan_telecentric_polynomial</item>
</see_also>
<short lang="en_US">Generate a camera parameter tuple for a line scan camera with a telecentric lens and with distortions modeled by the division model.</short>
<successor>
<item>set_calib_data_cam_param</item>
</successor>
<parameters>
<parameter id="CameraParam">
<default_type>real</default_type>
<description lang="en_US">Output camera parameter tuple.</description>
<mixed_type>optional</mixed_type>
<multivalue>true</multivalue>
<sem_type>campar</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
<item>string</item>
</type_list>
</parameter>
<parameter id="Cx">
<default_type>real</default_type>
<default_value>1024</default_value>
<description lang="en_US">Column coordinate of the principal point in the image.</description>
<multivalue>false</multivalue>
<sem_type>real</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
<parameter id="Cy">
<default_type>real</default_type>
<default_value>0</default_value>
<description lang="en_US">Distance of the principal point from the sensor line in scanlines.</description>
<multivalue>false</multivalue>
<sem_type>real</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
<parameter id="ImageHeight">
<default_type>integer</default_type>
<default_value>3840</default_value>
<description lang="en_US">Image height.</description>
<multivalue>false</multivalue>
<sem_type>integer</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="ImageWidth">
<default_type>integer</default_type>
<default_value>2048</default_value>
<description lang="en_US">Image width.</description>
<multivalue>false</multivalue>
<sem_type>integer</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="Kappa">
<default_type>real</default_type>
<default_value>0.0</default_value>
<description lang="en_US">Distortion coefficient to model the radial lens distortions.</description>
<multivalue>false</multivalue>
<sem_type>real</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
<parameter id="Magnification">
<default_type>real</default_type>
<default_value>0.2</default_value>
<description lang="en_US">Magnification of the lens.</description>
<multivalue>false</multivalue>
<sem_type>real</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
<values>
<item>0.1</item>
<item>0.2</item>
<item>0.3</item>
<item>0.4</item>
<item>0.5</item>
<item>1.0</item>
<item>2.0</item>
</values>
</parameter>
<parameter id="Sx">
<default_type>real</default_type>
<default_value>1e-5</default_value>
<description lang="en_US">Horizontal size of the cells on the sensor.</description>
<multivalue>false</multivalue>
<sem_type>real</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
<parameter id="Sy">
<default_type>real</default_type>
<default_value>1e-5</default_value>
<description lang="en_US">Vertical size of the cells on the sensor.</description>
<multivalue>false</multivalue>
<sem_type>real</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
<parameter id="Vx">
<default_type>real</default_type>
<default_value>0.0</default_value>
<description lang="en_US">X component of the motion vector.</description>
<multivalue>false</multivalue>
<sem_type>real</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
<parameter id="Vy">
<default_type>real</default_type>
<default_value>5e-5</default_value>
<description lang="en_US">Y component of the motion vector.</description>
<multivalue>false</multivalue>
<sem_type>real</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
<parameter id="Vz">
<default_type>real</default_type>
<default_value>0.0</default_value>
<description lang="en_US">Z component of the motion vector.</description>
<multivalue>false</multivalue>
<sem_type>real</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
</parameters>
</docu>
</procedure>
<procedure name="gen_cam_par_line_scan_telecentric_polynomial">
<interface>
<ic>
<par name="Magnification" base_type="ctrl" dimension="0"/>
<par name="K1" base_type="ctrl" dimension="0"/>
<par name="K2" base_type="ctrl" dimension="0"/>
<par name="K3" base_type="ctrl" dimension="0"/>
<par name="P1" base_type="ctrl" dimension="0"/>
<par name="P2" base_type="ctrl" dimension="0"/>
<par name="Sx" base_type="ctrl" dimension="0"/>
<par name="Sy" base_type="ctrl" dimension="0"/>
<par name="Cx" base_type="ctrl" dimension="0"/>
<par name="Cy" base_type="ctrl" dimension="0"/>
<par name="ImageWidth" base_type="ctrl" dimension="0"/>
<par name="ImageHeight" base_type="ctrl" dimension="0"/>
<par name="Vx" base_type="ctrl" dimension="0"/>
<par name="Vy" base_type="ctrl" dimension="0"/>
<par name="Vz" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="CameraParam" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c>* Generate a camera parameter tuple for a telecentric line scan camera</c>
<c>* with distortions modeled by the polynomial model.</c>
<c>* </c>
<l>CameraParam := ['line_scan_telecentric_polynomial',Magnification,K1,K2,K3,P1,P2,Sx,Sy,Cx,Cy,ImageWidth,ImageHeight,Vx,Vy,Vz]</l>
<l>return ()</l>
</body>
<docu id="gen_cam_par_line_scan_telecentric_polynomial">
<abstract lang="en_US">gen_cam_par_line_scan_telecentric_polynomial generates the camera parameter tuple CameraParam for a line scan camera with a telecentric lens and with distortions modeled by the polynomial model. For this, the camera parameters must be passed in Magnification (-), K1 (m^-2), K2 (m^-4), K3 (m^-6), P1 (m^-1), P2 (m^-1), Sx (m/px), Sy (m/px), Cx (px), Cy (px), ImageWidth (px), ImageHeight (px), Vx (m/scanline), Vy (m/scanline), Vz (m/scanline), where we indicate the HALCON default units in brackets. For a detailed explanation of the parameters, see the reference manual chapter Calibration / Multi-View.</abstract>
<chapters lang="de_DE">
<item>Kalibrierung</item>
<item>Kameraparameter</item>
</chapters>
<chapters lang="en_US">
<item>Calibration</item>
<item>Camera Parameters</item>
</chapters>
<keywords lang="de_DE">
<item>Kameraparameter kalibrieren</item>
<item>Kamera-Kalibrierparameter erhalten</item>
<item>Kameramodell</item>
<item>interne Kameraparameter</item>
<item>interne Kameraparameter kalibrieren</item>
<item>kalibrierte interne Kameraparameter erhalten</item>
</keywords>
<keywords lang="en_US">
<item>camera calibration parameters</item>
<item>camera calibration result</item>
<item>calibrate camera parameters</item>
<item>calibrate internal camera parameters</item>
<item>calibrated internal camera parameters</item>
</keywords>
<library lang="en_US">MVTec Standard Procedures</library>
<see_also>
<item>calibrate_cameras</item>
<item>get_cam_par_data</item>
<item>set_cam_par_data</item>
<item>get_cam_par_names</item>
<item>gen_cam_par_area_scan_division</item>
<item>gen_cam_par_area_scan_polynomial</item>
<item>gen_cam_par_area_scan_telecentric_division</item>
<item>gen_cam_par_area_scan_telecentric_polynomial</item>
<item>gen_cam_par_area_scan_tilt_division</item>
<item>gen_cam_par_area_scan_tilt_polynomial</item>
<item>gen_cam_par_area_scan_tilt_image_side_telecentric_division</item>
<item>gen_cam_par_area_scan_tilt_image_side_telecentric_polynomial</item>
<item>gen_cam_par_area_scan_tilt_bilateral_telecentric_division</item>
<item>gen_cam_par_area_scan_tilt_bilateral_telecentric_polynomial</item>
<item>gen_cam_par_area_scan_tilt_object_side_telecentric_division</item>
<item>gen_cam_par_area_scan_tilt_object_side_telecentric_polynomial</item>
<item>gen_cam_par_area_scan_hypercentric_division</item>
<item>gen_cam_par_area_scan_hypercentric_polynomial</item>
<item>gen_cam_par_line_scan_division</item>
<item>gen_cam_par_line_scan_polynomial</item>
<item>gen_cam_par_line_scan_telecentric_division</item>
</see_also>
<short lang="en_US">Generate a camera parameter tuple for a line scan camera with a telecentric lens and with distortions modeled by the polynomial model.</short>
<successor>
<item>set_calib_data_cam_param</item>
</successor>
<parameters>
<parameter id="CameraParam">
<default_type>real</default_type>
<description lang="en_US">Output camera parameter tuple.</description>
<mixed_type>optional</mixed_type>
<multivalue>true</multivalue>
<sem_type>campar</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
<item>string</item>
</type_list>
</parameter>
<parameter id="Cx">
<default_type>real</default_type>
<default_value>1024</default_value>
<description lang="en_US">Column coordinate of the principal point in the image.</description>
<multivalue>false</multivalue>
<sem_type>real</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
<parameter id="Cy">
<default_type>real</default_type>
<default_value>0</default_value>
<description lang="en_US">Distance of the principal point from the sensor line in scanlines.</description>
<multivalue>false</multivalue>
<sem_type>real</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
<parameter id="ImageHeight">
<default_type>integer</default_type>
<default_value>3840</default_value>
<description lang="en_US">Image height.</description>
<multivalue>false</multivalue>
<sem_type>integer</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="ImageWidth">
<default_type>integer</default_type>
<default_value>2048</default_value>
<description lang="en_US">Image width.</description>
<multivalue>false</multivalue>
<sem_type>integer</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="K1">
<default_type>real</default_type>
<default_value>0.0</default_value>
<description lang="en_US">Distortion coefficient to model radial lens distortions.</description>
<multivalue>false</multivalue>
<sem_type>real</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
<parameter id="K2">
<default_type>real</default_type>
<default_value>0.0</default_value>
<description lang="en_US">Distortion coefficient to model radial lens distortions.</description>
<multivalue>false</multivalue>
<sem_type>real</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
<parameter id="K3">
<default_type>real</default_type>
<default_value>0.0</default_value>
<description lang="en_US">Distortion coefficient to model radial lens distortions.</description>
<multivalue>false</multivalue>
<sem_type>real</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
<parameter id="Magnification">
<default_type>real</default_type>
<default_value>0.2</default_value>
<description lang="en_US">Magnification of the lens.</description>
<multivalue>false</multivalue>
<sem_type>real</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
<values>
<item>0.1</item>
<item>0.2</item>
<item>0.3</item>
<item>0.4</item>
<item>0.5</item>
<item>1.0</item>
<item>2.0</item>
</values>
</parameter>
<parameter id="P1">
<default_type>real</default_type>
<default_value>0.0</default_value>
<description lang="en_US">Distortion coefficient to model decentering lens distortions.</description>
<multivalue>false</multivalue>
<sem_type>real</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
<item>string</item>
</type_list>
</parameter>
<parameter id="P2">
<default_type>real</default_type>
<default_value>0.0</default_value>
<description lang="en_US">Distortion coefficient to model decentering lens distortions.</description>
<sem_type>real</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
<parameter id="Sx">
<default_type>real</default_type>
<default_value>1e-5</default_value>
<description lang="en_US">Horizontal size of the cells on the sensor.</description>
<multivalue>false</multivalue>
<sem_type>real</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
<parameter id="Sy">
<default_type>real</default_type>
<default_value>1e-5</default_value>
<description lang="en_US">Vertical size of the cells on the sensor.</description>
<multivalue>false</multivalue>
<sem_type>real</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
<parameter id="Vx">
<default_type>real</default_type>
<default_value>0.0</default_value>
<description lang="en_US">X component of the motion vector.</description>
<multivalue>false</multivalue>
<sem_type>real</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
<parameter id="Vy">
<default_type>real</default_type>
<default_value>5e-5</default_value>
<description lang="en_US">Y component of the motion vector.</description>
<multivalue>false</multivalue>
<sem_type>real</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
<parameter id="Vz">
<default_type>real</default_type>
<default_value>0.0</default_value>
<description lang="en_US">Z component of the motion vector.</description>
<multivalue>false</multivalue>
<sem_type>real</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
</parameters>
</docu>
</procedure>
<procedure name="gen_camera_and_tool_moving_cam_object_model_3d">
<interface>
<ic>
<par name="ToolInCamPose" base_type="ctrl" dimension="0"/>
<par name="ToolInBasePose" base_type="ctrl" dimension="0"/>
<par name="CameraSize" base_type="ctrl" dimension="0"/>
<par name="ConeLength" base_type="ctrl" dimension="0"/>
<par name="OM3DToolOrig" base_type="ctrl" dimension="0"/>
<par name="CamParam" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="OM3DCamera" base_type="ctrl" dimension="0"/>
<par name="OM3DTool" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c>* This procedure helps visualize the camera and its cone, as well</c>
<c>* as the robot's tool in their current positions.</c>
<c>* </c>
<c>* Visualize Tool.</c>
<l>rigid_trans_object_model_3d (OM3DToolOrig, ToolInBasePose, OM3DTool)</l>
<c>* </c>
<c>* Visualize Camera.</c>
<l>create_pose (0, 0, 0, 0, 0, 0, 'Rp+T', 'gba', 'point', IdentityPose)</l>
<l>create_camera_setup_model (1, CameraSetupModelID)</l>
<l>set_camera_setup_cam_param (CameraSetupModelID, 0, [], CamParam, IdentityPose)</l>
<l>gen_camera_setup_object_model_3d (CameraSetupModelID, CameraSize, ConeLength, OM3DCameraOrigin, OM3DConeOrig)</l>
<l>clear_camera_setup_model (CameraSetupModelID)</l>
<l>OM3DCameraOrigin := [OM3DCameraOrigin,OM3DConeOrig]</l>
<c>* </c>
<l>pose_invert (ToolInCamPose, CamInToolPose)</l>
<l>pose_compose (ToolInBasePose, CamInToolPose, CamInBasePose)</l>
<l>rigid_trans_object_model_3d (OM3DCameraOrigin, CamInBasePose, OM3DCamera)</l>
<l>clear_object_model_3d (OM3DCameraOrigin)</l>
<l>return ()</l>
</body>
<docu id="gen_camera_and_tool_moving_cam_object_model_3d">
<abstract lang="en_US">This procedure generates 3D object models for the camera and its cone, as well as the robot's tool in their current positions.

The input parameter ToolInCamPose is directly obtained through hand-eye calibration. ToolInBasePose is the current position of the robot's tool. CameraSize determines the size of the camera. ConeLength specifies the length of the camera's cone. OM3DToolOrig is the 3D object model of the robot's tool in its initial position. CamParam contains the camera parameters, obtained through calibration.

The output parameters OM3DCamera and OM3DTool are respectively the 3D object models of the camera and the robot's tool in their current positions.</abstract>
<chapters lang="de_DE">
<item>3D-Objektmodell</item>
<item>Generierung</item>
</chapters>
<chapters lang="en_US">
<item>3D Object Model</item>
<item>Creation</item>
</chapters>
<library lang="en_US">MVTec Standard Procedures</library>
<short lang="en_US">Generate 3D object models for the camera and the robot's tool.</short>
<parameters>
<parameter id="CamParam">
<default_type>integer</default_type>
<default_value>[]</default_value>
<description lang="en_US">Camera parameters.</description>
<sem_type>any</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
<parameter id="CameraSize">
<default_type>real</default_type>
<description lang="en_US">Visualization factor.</description>
<sem_type>real</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
<parameter id="ConeLength">
<default_type>integer</default_type>
<description lang="en_US">Length of the camera's cone.</description>
<sem_type>number</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
<parameter id="OM3DCamera">
<default_type>integer</default_type>
<description lang="en_US">3D object model of the camera and its cone.</description>
<mixed_type>false</mixed_type>
<sem_type>object_model_3d</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="OM3DTool">
<default_type>integer</default_type>
<description lang="en_US">3D object model of the robot's tool in its current position.</description>
<mixed_type>false</mixed_type>
<sem_type>object_model_3d</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="OM3DToolOrig">
<default_type>integer</default_type>
<description lang="en_US">Initial 3D object model of the robot's tool.</description>
<mixed_type>false</mixed_type>
<sem_type>object_model_3d</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="ToolInBasePose">
<default_type>real</default_type>
<default_value>[]</default_value>
<description lang="en_US">Pose of the tool in the base coordinate system.</description>
<sem_type>pose</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
<parameter id="ToolInCamPose">
<default_type>real</default_type>
<default_value>[]</default_value>
<description lang="en_US">Pose of the tool in the camera coordinate system.</description>
<sem_type>pose</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
</parameters>
</docu>
</procedure>
<procedure name="gen_camera_facing_scene" access="local">
<interface>
<ic>
<par name="Viewpoint" base_type="ctrl" dimension="0"/>
<par name="Center" base_type="ctrl" dimension="0"/>
<par name="DiameterModel" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="OM3DCamera" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<l>Direction := Viewpoint - Center</l>
<l>DirectionLength := sqrt(sum(Direction * Direction))</l>
<l>if (DirectionLength &lt; 1e-1 * DiameterModel)</l>
<l>    DirectionLength := 0</l>
<l>    gen_sphere_object_model_3d ([Viewpoint,0,0,0,0], DiameterModel * 0.1, OM3DCamera)</l>
<l>else</l>
<c>    * Create a rotation such that the camera faces the center of gravity of the scene</c>
<l>    DirNorm := Direction / DirectionLength</l>
<l>    if (sum(DirNorm * [0,0,-1]) &gt; -0.99999)</l>
<c>        * Angle between the vectors is &gt; 0.25°</c>
<l>        Axis := DirNorm + [0,0,-1]</l>
<l>        AxisNorm := Axis / sqrt(sum(Axis * Axis))</l>
<l>    else</l>
<l>        Axis := [0,1,0]</l>
<l>    endif</l>
<l>    hom_mat3d_identity (HomMat3DIdentity)</l>
<l>    hom_mat3d_rotate_local (HomMat3DIdentity, rad(180), Axis, HomMat3DRotate)</l>
<l>    hom_mat3d_to_pose (HomMat3DRotate, Pose)</l>
<l>    Pose[0:2] := Viewpoint</l>
<l>    gen_camera_object_model_3d (Pose, DiameterModel * 0.1, OM3DCamera)</l>
<l>endif</l>
<l>return ()</l>
</body>
<docu id="gen_camera_facing_scene">
<chapters lang="en_US">
<item>Graphics</item>
<item>3D Scene</item>
</chapters>
<library lang="en_US">MVTec Standard Procedures</library>
<parameters>
<parameter id="Center">
<default_type>integer</default_type>
<sem_type>number</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
<parameter id="DiameterModel">
<default_type>integer</default_type>
<sem_type>number</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
<parameter id="OM3DCamera">
<default_type>integer</default_type>
<mixed_type>false</mixed_type>
<sem_type>object_model_3d</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="Viewpoint">
<default_type>real</default_type>
<sem_type>number</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
</parameters>
</docu>
</procedure>
<procedure name="gen_camera_object_model_3d" access="local">
<interface>
<ic>
<par name="Pose" base_type="ctrl" dimension="0"/>
<par name="Size" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="OM3DCamera" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c>* </c>
<c>* Create the box</c>
<l>gen_box_object_model_3d ([0,0,0,0,0,0,0], Size, Size, Size, OM3DBox)</l>
<l>triangulate_object_model_3d (OM3DBox, 'greedy', [], [], OM3DBoxTriangulated, Information)</l>
<c>* Create the cone frustum</c>
<l>gen_cylinder_object_model_3d ([0,0,0,0,0,0,0], Size * 0.5, Size * 0.5, Size * 1, OM3DCylinder)</l>
<l>sample_object_model_3d (OM3DCylinder, 'fast', Size * 0.02, [], [], OMSampledCylinder)</l>
<l>get_object_model_3d_params (OMSampledCylinder, 'point_coord_x', CX)</l>
<l>get_object_model_3d_params (OMSampledCylinder, 'point_coord_y', CY)</l>
<l>get_object_model_3d_params (OMSampledCylinder, 'point_coord_z', CZ)</l>
<l>Lin := (CZ - Size * 0.5) / (max(CZ) - min(CZ))</l>
<l>Fac := Lin * 0.5 + 0.5</l>
<l>set_object_model_3d_attrib_mod (OMSampledCylinder, 'point_coord_x', [], CX * Fac)</l>
<l>set_object_model_3d_attrib_mod (OMSampledCylinder, 'point_coord_y', [], CY * Fac)</l>
<l>convex_hull_object_model_3d (OMSampledCylinder, OM3DCylinder2)</l>
<c>* </c>
<c>* Make it a single model and move to desired pose</c>
<l>union_object_model_3d ([OM3DBoxTriangulated,OM3DCylinder2], 'points_surface', OM3DCamera)</l>
<l>rigid_trans_object_model_3d (OM3DCamera, Pose, OM3DCamera)</l>
<l>return ()</l>
</body>
<docu id="gen_camera_object_model_3d">
<abstract lang="en_US">Create a 3D object model that resembles a camera.</abstract>
<chapters lang="en_US">
<item>3D Object Model</item>
<item>Transformations</item>
</chapters>
<library lang="en_US">MVTec Standard Procedures</library>
<short lang="en_US">Create a 3D object model that resembles a camera</short>
<parameters>
<parameter id="OM3DCamera">
<default_type>integer</default_type>
<mixed_type>false</mixed_type>
<sem_type>object_model_3d</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="Pose">
<default_type>real</default_type>
<sem_type>pose</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
<parameter id="Size">
<default_type>real</default_type>
<sem_type>number</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
</parameters>
</docu>
</procedure>
<procedure name="gen_camera_setup_object_model_3d">
<interface>
<ic>
<par name="CameraSetupModelID" base_type="ctrl" dimension="0"/>
<par name="CameraSize" base_type="ctrl" dimension="0"/>
<par name="ConeLength" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="ObjectModel3DCamera" base_type="ctrl" dimension="0"/>
<par name="ObjectModel3DCone" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<l>get_camera_setup_param (CameraSetupModelID, 'general', 'num_cameras', NumCameras)</l>
<c>* </c>
<c>* Consistency check:</c>
<l>if (NumCameras &lt; 1)</l>
<l>    throw ('No camera set.')</l>
<l>endif</l>
<l>if (is_number(CameraSize))</l>
<l>    if (CameraSize &lt;= 0.0)</l>
<l>        throw ('Invalid value for CameraSize. CameraSize must be positive or \'auto\'.')</l>
<l>    endif</l>
<l>elseif (CameraSize != 'auto')</l>
<l>    throw ('Invalid value for CameraSize. CameraSize must be positive or \'auto\'.')</l>
<l>endif</l>
<l>if (is_number(ConeLength))</l>
<l>    if (ConeLength &lt;= 0.0)</l>
<l>        throw ('Invalid value for ConeLength. ConeLength must be positive or \'auto\'.')</l>
<l>    endif</l>
<l>elseif (ConeLength != 'auto')</l>
<l>    throw ('Invalid value for ConeLength. ConeLength must be positive or \'auto\'.')</l>
<l>endif</l>
<c>* </c>
<l>AutoConeLength := ConeLength == 'auto'</l>
<c>* </c>
<l>ObjectModel3DCamera := []</l>
<l>ObjectModel3DCone := []</l>
<l>AllCameras := [0:NumCameras - 1]</l>
<l>for CurrentCamera := 0 to NumCameras - 1 by 1</l>
<l>    ConcatZ := []</l>
<l>    if (AutoConeLength)</l>
<l>        if (NumCameras &lt; 2)</l>
<l>            throw ('You need at least two cameras for ConeLength == auto.')</l>
<l>        endif</l>
<c>        * Intersect the line of sight of each camera with all other cameras.</c>
<l>        OtherCameras := remove(AllCameras,find(AllCameras,CurrentCamera))</l>
<l>        for Index := 0 to |OtherCameras| - 1 by 1</l>
<l>            get_camera_setup_param (CameraSetupModelID, CurrentCamera, 'params', CamParam0)</l>
<l>            get_camera_setup_param (CameraSetupModelID, CurrentCamera, 'pose', Pose0)</l>
<l>            get_camera_setup_param (CameraSetupModelID, OtherCameras[Index], 'params', CamParam1)</l>
<l>            get_camera_setup_param (CameraSetupModelID, OtherCameras[Index], 'pose', Pose1)</l>
<c>            * Intersect the lines of sight of the camera pair.</c>
<l>            pose_invert (Pose1, PoseInvert)</l>
<l>            pose_compose (PoseInvert, Pose0, RelPose)</l>
<l>            get_cam_par_data (CamParam0, 'cx', CX0)</l>
<l>            get_cam_par_data (CamParam0, 'cy', CY0)</l>
<l>            get_cam_par_data (CamParam1, 'cx', CX1)</l>
<l>            get_cam_par_data (CamParam1, 'cy', CY1)</l>
<l>            try</l>
<l>                intersect_lines_of_sight (CamParam0, CamParam1, RelPose, CY0, CX0, CY1, CX1, X, Y, Z, Dist)</l>
<l>            catch (Exception)</l>
<l>                throw ('Estimating a value for ConeLength automatically was not possible. Please use a number instead.')</l>
<l>            endtry</l>
<l>            ConcatZ := [ConcatZ,Z]</l>
<l>        endfor</l>
<c>        * Use the Z value of the determined coordinates as basis for the ConeLength.</c>
<l>        ConeLength := max(ConcatZ) * 1.05</l>
<l>    endif</l>
<c>    * </c>
<c>    * Create cone of sight 3D object models.</c>
<c>    * Distinguish cases with/without projection center.</c>
<l>    get_camera_setup_param (CameraSetupModelID, CurrentCamera, 'type', CameraType)</l>
<l>    if (CameraType =~ 'telecentric')</l>
<l>        gen_cone_telecentric_object_model_3d (CameraSetupModelID, CurrentCamera, ConeLength, ObjectModel3DConeTmp)</l>
<l>    else</l>
<l>        gen_cone_perspective_object_model_3d (CameraSetupModelID, CurrentCamera, ConeLength, ObjectModel3DConeTmp)</l>
<l>    endif</l>
<l>    ObjectModel3DCone := [ObjectModel3DCone,ObjectModel3DConeTmp]</l>
<c>    * </c>
<c>    * Create camera 3D object models.</c>
<l>    if (CameraSize == 'auto')</l>
<c>        * In auto mode, the camera size for all cameras</c>
<c>        * is defined by the first camera's cone length.</c>
<l>        CameraSize := ConeLength * 0.1</l>
<l>    endif</l>
<l>    gen_camera_object_model_3d (CameraSetupModelID, CurrentCamera, CameraSize, ObjectModel3DCameraTmp)</l>
<l>    ObjectModel3DCamera := [ObjectModel3DCamera,ObjectModel3DCameraTmp]</l>
<l>endfor</l>
<l>return ()</l>
</body>
<docu id="gen_camera_setup_object_model_3d">
<abstract lang="en_US">The procedure gen_camera_setup_object_model_3d generates 3D object models which visualize the cameras of a camera setup as well as their fields of view. 

The procedure can be used, e.g., to visualize a stereo setup with its bounding box and cameras which is particularly helpful while adjusting the bounding box. The procedure gen_bounding_box_object_model_3d creates the according 3D object model for the bounding box.

Note that if a 3D object model is no longer needed or should be overwritten, the memory has to be freed first by calling the operator clear_object_model_3d.</abstract>
<chapters lang="de_DE">
<item>3D-Objektmodell</item>
<item>Generierung</item>
</chapters>
<chapters lang="en_US">
<item>3D Object Model</item>
<item>Creation</item>
</chapters>
<example lang="en_US">dev_open_window (0, 0, 512, 512, 'black', WindowHandle)
* Prepare camera setup and stereo model.
read_camera_setup_model ('cam_setup_model.csm', CameraSetupModelID)
create_stereo_model (CameraSetupModelID, 'surface_fusion', [], [], StereoModelID)
set_stereo_model_image_pairs (StereoModelID, [1, 2], [0, 0])
* Estimate and set bounding box automatically.
estimate_bounding_box_3d_reconstruction (StereoModelID, 0.06, BoundingBox)
set_stereo_model_param (StereoModelID, 'bounding_box', BoundingBox)
* Create and visualize object models that represent the setup.
gen_camera_setup_object_model_3d (CameraSetupModelID, 'auto', 'auto', ObjectModel3DCamera, ObjectModel3DCone)
gen_bounding_box_object_model_3d (StereoModelID, ObjectModel3DBoundingBox)
visualize_object_model_3d (WindowHandle, [ObjectModel3DBoundingBox, ObjectModel3DCamera, ObjectModel3DCone], [], [], ['color_0', 'alpha'], ['red', 0.5], [], [],[] , Pose)</example>
<library lang="de_DE">MVTec Standard Procedures</library>
<library lang="en_US">MVTec Standard Procedures</library>
<predecessor>
<item>create_stereo_model</item>
<item>set_stereo_model_param</item>
</predecessor>
<see_also>
<item>reconstruct_surface_stereo</item>
</see_also>
<short lang="en_US">Generate 3D object models which visualize the cameras of a stereo model.</short>
<successor>
<item>visualize_object_model_3d</item>
<item>dev_inspect_ctrl</item>
<item>gen_bounding_box_object_model_3d</item>
</successor>
<parameters>
<parameter id="CameraSetupModelID">
<default_type>integer</default_type>
<description lang="en_US">Handle of the stereo model.</description>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>camera_setup_model</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="CameraSize">
<default_type>string</default_type>
<default_value>'auto'</default_value>
<description lang="en_US">Size of represented cameras.</description>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>number</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
<item>string</item>
</type_list>
<values>
<item>'auto'</item>
<item>0.01</item>
<item>0.04</item>
<item>0.08</item>
<item>0.1</item>
<item>0.4</item>
<item>0.8</item>
<item>1</item>
<item>4</item>
<item>8</item>
</values>
</parameter>
<parameter id="ConeLength">
<default_type>string</default_type>
<default_value>'auto'</default_value>
<description lang="en_US">Depth of represented fields of view. </description>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>number</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
<item>string</item>
</type_list>
<values>
<item>'auto'</item>
<item>0.01</item>
<item>0.04</item>
<item>0.08</item>
<item>0.1</item>
<item>0.4</item>
<item>0.8</item>
<item>1</item>
<item>4</item>
<item>8</item>
</values>
</parameter>
<parameter id="ObjectModel3DCamera">
<default_type>integer</default_type>
<description lang="en_US">Handles of the 3D object models representing cameras.</description>
<mixed_type>false</mixed_type>
<sem_type>object_model_3d</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="ObjectModel3DCone">
<default_type>integer</default_type>
<description lang="en_US">Handles of the 3D object models representing fields of view.</description>
<mixed_type>false</mixed_type>
<sem_type>object_model_3d</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
</parameters>
</docu>
</procedure>
<procedure name="gen_cone_perspective_object_model_3d" access="local">
<interface>
<ic>
<par name="CameraSetupModelID" base_type="ctrl" dimension="0"/>
<par name="CameraIndex" base_type="ctrl" dimension="0"/>
<par name="ConeLength" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="ObjectModel3D" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<l>get_camera_setup_param (CameraSetupModelID, CameraIndex, 'pose', CamPose)</l>
<l>pose_to_hom_mat3d (CamPose, HomMat3D)</l>
<l>get_camera_setup_param (CameraSetupModelID, CameraIndex, 'params', CamParam)</l>
<c>* </c>
<c>* Get the lines of sight of the four corner points of the image.</c>
<c>* Scale them to the given length and transform into world coordinates.</c>
<l>Points := {[]}</l>
<c>* First corner.</c>
<l>get_line_of_sight (0, 0, CamParam, PX, PY, PZ, QX, QY, QZ)</l>
<l>QXT := QX / QZ * ConeLength</l>
<l>QYT := QY / QZ * ConeLength</l>
<l>QZT := ConeLength</l>
<l>affine_trans_point_3d (HomMat3D, QXT, QYT, QZT, QX1, QY1, QZ1)</l>
<l>Points.at(0) := [QX1,QY1,QZ1]</l>
<c>* Second corner.</c>
<l>get_line_of_sight (CamParam[|CamParam| - 1] - 1, 0, CamParam, PX, PY, PZ, QX, QY, QZ)</l>
<l>QXT := QX / QZ * ConeLength</l>
<l>QYT := QY / QZ * ConeLength</l>
<l>QZT := ConeLength</l>
<l>affine_trans_point_3d (HomMat3D, QXT, QYT, QZT, QX1, QY1, QZ1)</l>
<l>Points.at(1) := [QX1,QY1,QZ1]</l>
<c>* Third corner.</c>
<l>get_line_of_sight (CamParam[|CamParam| - 1] - 1, CamParam[|CamParam| - 2] - 1, CamParam, PX, PY, PZ, QX, QY, QZ)</l>
<l>QXT := QX / QZ * ConeLength</l>
<l>QYT := QY / QZ * ConeLength</l>
<l>QZT := ConeLength</l>
<l>affine_trans_point_3d (HomMat3D, QXT, QYT, QZT, QX1, QY1, QZ1)</l>
<l>Points.at(2) := [QX1,QY1,QZ1]</l>
<c>* Fourth corner.</c>
<l>get_line_of_sight (0, CamParam[|CamParam| - 2] - 1, CamParam, PX, PY, PZ, QX, QY, QZ)</l>
<l>QXT := QX / QZ * ConeLength</l>
<l>QYT := QY / QZ * ConeLength</l>
<l>QZT := ConeLength</l>
<l>affine_trans_point_3d (HomMat3D, QXT, QYT, QZT, QX1, QY1, QZ1)</l>
<l>Points.at(3) := [QX1,QY1,QZ1]</l>
<c>* </c>
<c>* Get camera center.</c>
<l>affine_trans_point_3d (HomMat3D, 0, 0, 0, QX1, QY1, QZ1)</l>
<l>Points.at(4) := [QX1,QY1,QZ1]</l>
<c>* </c>
<c>* Sort the points by coordinate direction.</c>
<l>PX := []</l>
<l>PY := []</l>
<l>PZ := []</l>
<l>for Index := 0 to 4 by 1</l>
<l>    PX := [PX,Points.at(Index)[0]]</l>
<l>    PY := [PY,Points.at(Index)[1]]</l>
<l>    PZ := [PZ,Points.at(Index)[2]]</l>
<l>endfor</l>
<l>gen_object_model_3d_from_points (PX, PY, PZ, ObjectModel3D)</l>
<c>* </c>
<c>* Set the sides of the cone.</c>
<l>Faces := []</l>
<l>Faces := [Faces,4,0,1]</l>
<l>Faces := [Faces,4,1,2]</l>
<l>Faces := [Faces,4,2,3]</l>
<l>Faces := [Faces,4,3,0]</l>
<l>set_object_model_3d_attrib_mod (ObjectModel3D, 'triangles', [], Faces)</l>
<l>return ()</l>
</body>
<docu id="gen_cone_perspective_object_model_3d">
<chapters lang="de_DE">
<item>3D-Objektmodell</item>
<item>Generierung</item>
</chapters>
<chapters lang="en_US">
<item>3D Object Model</item>
<item>Creation</item>
</chapters>
<library lang="en_US">MVTec Standard Procedures</library>
<short lang="en_US">Generate a 3D object model representing the view cone of a perspective camera.</short>
<parameters>
<parameter id="CameraIndex">
<default_type>integer</default_type>
<sem_type>integer</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="CameraSetupModelID">
<default_type>integer</default_type>
<mixed_type>false</mixed_type>
<sem_type>camera_setup_model</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="ConeLength">
<default_type>integer</default_type>
<sem_type>number</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
<parameter id="ObjectModel3D">
<default_type>integer</default_type>
<mixed_type>false</mixed_type>
<sem_type>object_model_3d</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
</parameters>
</docu>
</procedure>
<procedure name="gen_cone_telecentric_object_model_3d" access="local">
<interface>
<ic>
<par name="CameraSetupModelID" base_type="ctrl" dimension="0"/>
<par name="CameraIndex" base_type="ctrl" dimension="0"/>
<par name="ConeLength" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="ObjectModel3D" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<l>get_camera_setup_param (CameraSetupModelID, CameraIndex, 'pose', CamPose)</l>
<l>pose_to_hom_mat3d (CamPose, HomMat3D)</l>
<l>get_camera_setup_param (CameraSetupModelID, CameraIndex, 'params', CamParam)</l>
<c>* </c>
<c>* Get the lines of sight of the four corner points of the image.</c>
<c>* Scale them to the given length and transform into world coordinates.</c>
<l>Points := {[]}</l>
<c>* First corner.</c>
<l>get_line_of_sight (0, 0, CamParam, PX, PY, PZ, QX, QY, QZ)</l>
<l>affine_trans_point_3d (HomMat3D, PX, PY, PZ, QX1, QY1, QZ1)</l>
<l>Points.at(0) := [QX1,QY1,QZ1]</l>
<l>QZT := ConeLength</l>
<l>affine_trans_point_3d (HomMat3D, QX, QY, QZT, QX1, QY1, QZ1)</l>
<l>Points.at(1) := [QX1,QY1,QZ1]</l>
<c>* Second corner.</c>
<l>get_line_of_sight (CamParam[|CamParam| - 1] - 1, 0, CamParam, PX, PY, PZ, QX, QY, QZ)</l>
<l>affine_trans_point_3d (HomMat3D, PX, PY, PZ, QX1, QY1, QZ1)</l>
<l>Points.at(2) := [QX1,QY1,QZ1]</l>
<l>QZT := ConeLength</l>
<l>affine_trans_point_3d (HomMat3D, QX, QY, QZT, QX1, QY1, QZ1)</l>
<l>Points.at(3) := [QX1,QY1,QZ1]</l>
<c>* Third corner.</c>
<l>get_line_of_sight (CamParam[|CamParam| - 1] - 1, CamParam[|CamParam| - 2] - 1, CamParam, PX, PY, PZ, QX, QY, QZ)</l>
<l>affine_trans_point_3d (HomMat3D, PX, PY, PZ, QX1, QY1, QZ1)</l>
<l>Points.at(4) := [QX1,QY1,QZ1]</l>
<l>QZT := ConeLength</l>
<l>affine_trans_point_3d (HomMat3D, QX, QY, QZT, QX1, QY1, QZ1)</l>
<l>Points.at(5) := [QX1,QY1,QZ1]</l>
<c>* Fourth corner.</c>
<l>get_line_of_sight (0, CamParam[|CamParam| - 2] - 1, CamParam, PX, PY, PZ, QX, QY, QZ)</l>
<l>affine_trans_point_3d (HomMat3D, PX, PY, PZ, QX1, QY1, QZ1)</l>
<l>Points.at(6) := [QX1,QY1,QZ1]</l>
<l>QZT := ConeLength</l>
<l>affine_trans_point_3d (HomMat3D, QX, QY, QZT, QX1, QY1, QZ1)</l>
<l>Points.at(7) := [QX1,QY1,QZ1]</l>
<c>* </c>
<c>* Sort the points by coordinate direction.</c>
<l>PX := []</l>
<l>PY := []</l>
<l>PZ := []</l>
<l>for Index := 0 to 7 by 1</l>
<l>    PX := [PX,Points.at(Index)[0]]</l>
<l>    PY := [PY,Points.at(Index)[1]]</l>
<l>    PZ := [PZ,Points.at(Index)[2]]</l>
<l>endfor</l>
<l>gen_object_model_3d_from_points (PX, PY, PZ, ObjectModel3D)</l>
<c>* </c>
<c>* Set the sides of the cone.</c>
<l>Faces := []</l>
<l>Faces := [Faces,4,0,1,3,2]</l>
<l>Faces := [Faces,4,2,3,5,4]</l>
<l>Faces := [Faces,4,4,5,7,6]</l>
<l>Faces := [Faces,4,6,7,1,0]</l>
<l>set_object_model_3d_attrib_mod (ObjectModel3D, 'polygons', [], Faces)</l>
<l>return ()</l>
</body>
<docu id="gen_cone_telecentric_object_model_3d">
<chapters lang="de_DE">
<item>3D-Objektmodell</item>
<item>Generierung</item>
</chapters>
<chapters lang="en_US">
<item>3D Object Model</item>
<item>Creation</item>
</chapters>
<library lang="en_US">MVTec Standard Procedures</library>
<short lang="en_US">Generate a 3D object model representing the view cone of a telecentric camera.</short>
<parameters>
<parameter id="CameraIndex">
<default_type>integer</default_type>
<sem_type>integer</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="CameraSetupModelID">
<default_type>integer</default_type>
<mixed_type>false</mixed_type>
<sem_type>camera_setup_model</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="ConeLength">
<default_type>integer</default_type>
<sem_type>number</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
<parameter id="ObjectModel3D">
<default_type>integer</default_type>
<mixed_type>false</mixed_type>
<sem_type>object_model_3d</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
</parameters>
</docu>
</procedure>
<procedure name="gen_confusion_matrix">
<interface>
<ic>
<par name="GroundTruthLabels" base_type="ctrl" dimension="0"/>
<par name="PredictedClasses" base_type="ctrl" dimension="0"/>
<par name="GenParamName" base_type="ctrl" dimension="0"/>
<par name="GenParamValue" base_type="ctrl" dimension="0"/>
<par name="WindowHandle" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="ConfusionMatrix" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c>* This procedure computes a confusion matrix.</c>
<c>* Therefore, it compares the classes</c>
<c>* assigned in GroundTruthLabels and PredictedClasses.</c>
<c>* The resulting confusion matrix can be</c>
<c>* visualized, returned, or both.</c>
<c>* In each case, the output can be changed</c>
<c>* via generic parameters using GenParamName and GenParamValue.</c>
<c>* For the visualization, the graphics window</c>
<c>* must be specified with WindowHandle.</c>
<c>* </c>
<l>if (|GroundTruthLabels| != |PredictedClasses|)</l>
<l>    throw ('Number of ground truth labels and predicted classes must be equal.')</l>
<l>endif</l>
<c>* </c>
<c>* Set generic parameter defaults.</c>
<l>DisplayMatrix := 'absolute'</l>
<l>ReturnMatrix := 'absolute'</l>
<l>DisplayColor := 'true'</l>
<l>DisplayColumnWidth := 'minimal'</l>
<c>* </c>
<c>* Parse generic parameters.</c>
<l>for GenParamIndex := 0 to |GenParamName| - 1 by 1</l>
<l>    if (GenParamName[GenParamIndex] == 'display_matrix')</l>
<c>        * Set 'display_matrix'.</c>
<l>        DisplayMatrix := GenParamValue[GenParamIndex]</l>
<l>    elseif (GenParamName[GenParamIndex] == 'return_matrix')</l>
<c>        * Set 'return_matrix'.</c>
<l>        ReturnMatrix := GenParamValue[GenParamIndex]</l>
<l>    elseif (GenParamName[GenParamIndex] == 'display_color')</l>
<c>        * Set 'display_color'.</c>
<l>        DisplayColor := GenParamValue[GenParamIndex]</l>
<l>    elseif (GenParamName[GenParamIndex] == 'display_column_width')</l>
<c>        * Set 'display_column_width'.</c>
<l>        DisplayColumnWidth := GenParamValue[GenParamIndex]</l>
<l>    else</l>
<l>        throw ('Unknown generic parameter: \'' + GenParamName[GenParamIndex] + '\'')</l>
<l>    endif</l>
<l>endfor</l>
<c>* </c>
<l>if (DisplayMatrix == 'relative' or ReturnMatrix == 'relative' or DisplayColor == 'true')</l>
<l>    CalculateRelativeMatrix := 1</l>
<l>else</l>
<l>    CalculateRelativeMatrix := 0</l>
<l>endif</l>
<c>* </c>
<c>* Calculate the confusion matrix with absolute values</c>
<c>* and the confusion matrix with relative errors.</c>
<c>* We start with an empty matrix</c>
<c>* and add the number of matching labels.</c>
<l>Classes := uniq(sort(GroundTruthLabels))</l>
<l>NumClasses := |Classes|</l>
<l>create_matrix (NumClasses, NumClasses, 0, AbsoluteMatrixID)</l>
<l>if (CalculateRelativeMatrix)</l>
<l>    create_matrix (NumClasses, NumClasses, 0, RelativeMatrixID)</l>
<l>endif</l>
<l>for ColumnMatrix := 0 to NumClasses - 1 by 1</l>
<l>    Class := Classes[ColumnMatrix]</l>
<l>    ThisLabel := GroundTruthLabels [==] Class</l>
<l>    if (CalculateRelativeMatrix)</l>
<c>        * Obtain the number of ground truth labels per class.</c>
<l>        NumClassGroundTruth := sum(ThisLabel)</l>
<l>    endif</l>
<l>    for RowMatrix := 0 to NumClasses - 1 by 1</l>
<c>        * Select classes for this row/column.</c>
<l>        PredictedClass := Classes[RowMatrix]</l>
<c>        * Check whether the input data</c>
<c>        * corresponds to these classes.</c>
<l>        ThisPredictedClass := PredictedClasses [==] PredictedClass</l>
<c>        * Count the number of elements where the predicted class</c>
<c>        * matches the ground truth label.</c>
<l>        NumMatches := sum((ThisLabel + ThisPredictedClass) [==] 2)</l>
<c>        * Set value in matrix.</c>
<l>        set_value_matrix (AbsoluteMatrixID, RowMatrix, ColumnMatrix, NumMatches)</l>
<l>        if (CalculateRelativeMatrix)</l>
<l>            if (NumClassGroundTruth &gt; 0)</l>
<l>                RelativeError := real(NumMatches) / NumClassGroundTruth</l>
<l>            else</l>
<l>                RelativeError := 0</l>
<l>            endif</l>
<l>            set_value_matrix (RelativeMatrixID, RowMatrix, ColumnMatrix, RelativeError)</l>
<l>        endif</l>
<l>    endfor</l>
<l>endfor</l>
<c>* </c>
<c>* Return the result.</c>
<l>if (ReturnMatrix == 'absolute')</l>
<l>    copy_matrix (AbsoluteMatrixID, ConfusionMatrix)</l>
<l>elseif (ReturnMatrix == 'relative')</l>
<l>    copy_matrix (RelativeMatrixID, ConfusionMatrix)</l>
<l>elseif (ReturnMatrix == 'none')</l>
<c>    * No matrix is returned.</c>
<l>else</l>
<l>    throw ('Unsupported mode for \'return_matrix\'')</l>
<l>endif</l>
<c>* </c>
<c>* Display the matrix.</c>
<l>if (DisplayMatrix != 'none')</l>
<c>    * </c>
<c>    * Find maximal string width and set display position parameters.</c>
<l>    StringWidths := []</l>
<c>    * Get the string width of each class.</c>
<l>    for StringIndex := 0 to |Classes| - 1 by 1</l>
<l>        String := Classes[StringIndex]</l>
<l>        get_string_extents (WindowHandle, String, Ascent, Descent, StringWidth, StringHeight)</l>
<l>        StringWidths := [StringWidths,StringWidth]</l>
<l>    endfor</l>
<c>    * The columns should have a minimum width for 4 characters.</c>
<l>    get_string_extents (WindowHandle, 'test', Ascent, Descent, StringWidth, StringHeight)</l>
<l>    MaxStringWidth := max2(max(StringWidths),StringWidth)</l>
<c>    * Get the maximum string width</c>
<c>    * and resize the window accordingly.</c>
<l>    RowStart := 80</l>
<l>    RowDistance := StringHeight + 10</l>
<l>    RowEnd := StringHeight * 7</l>
<l>    ColumnStart := 50 + MaxStringWidth</l>
<l>    ColumnOffset := 20</l>
<l>    ColumnEnd := ColumnOffset</l>
<c>    * </c>
<c>    * Adapt the window size to fit the confusion matrix.</c>
<l>    if (DisplayColumnWidth == 'minimal')</l>
<c>        * Every column of the confusion matrix is as narrow as possible</c>
<c>        * based to the respective string widths.</c>
<l>        Width := sum(StringWidths) + ColumnOffset * NumClasses + ColumnStart + ColumnEnd</l>
<l>    elseif (DisplayColumnWidth == 'equal')</l>
<c>        * Every column of the confusion matrix should have the same width.</c>
<c>        * based on the maximum string width.</c>
<l>        Width := (MaxStringWidth + ColumnOffset) * NumClasses + ColumnStart + ColumnEnd</l>
<l>    else</l>
<l>        throw ('')</l>
<l>    endif</l>
<l>    Height := RowDistance * NumClasses + RowStart + RowEnd</l>
<l>    dev_set_window (WindowHandle)</l>
<l>    dev_clear_window ()</l>
<c>    * </c>
<c>    * Set reasonable limits for graphics window (adapt if necessary).</c>
<l>    WidthLimit := [450,1920]</l>
<l>    HeightLimit := [250,1080]</l>
<l>    if (Width &gt; WidthLimit[1] or Height &gt; HeightLimit[1])</l>
<l>        throw ('Confusion Matrix does not fit into graphics window. Please adapt font and/or size limits.')</l>
<l>    endif</l>
<l>    dev_resize_window_fit_size (0, 0, Width, Height, WidthLimit, HeightLimit)</l>
<c>    * </c>
<c>    * Get display coordinates.</c>
<c>    * Get row coordinates for display.</c>
<l>    TextRow := []</l>
<l>    for ColumnMatrix := 0 to NumClasses - 1 by 1</l>
<l>        TextRow := [TextRow,[0:RowDistance:(NumClasses - 1) * RowDistance]]</l>
<l>    endfor</l>
<c>    * Get column coordinates for display.</c>
<l>    TextColumn := []</l>
<l>    for Index := 0 to NumClasses - 1 by 1</l>
<l>        TextColumn := [TextColumn,gen_tuple_const(NumClasses,ColumnStart)]</l>
<l>        if (DisplayColumnWidth == 'minimal')</l>
<l>            ColumnStart := ColumnStart + StringWidths[Index] + ColumnOffset</l>
<l>        elseif (DisplayColumnWidth == 'equal')</l>
<l>            ColumnStart := ColumnStart + MaxStringWidth + ColumnOffset</l>
<l>        endif</l>
<l>    endfor</l>
<c>    * Display the confusion matrix with a margin from the top.</c>
<l>    TextRow := TextRow + RowStart</l>
<c>    * Display axis titles.</c>
<l>    dev_disp_text ('Ground truth labels', 'window', 'top', 'right', 'white', 'box', 'false')</l>
<l>    dev_disp_text ('Predicted classes', 'window', 'bottom', 'left', 'white', 'box', 'false')</l>
<l>    for Index := 0 to |Classes| - 1 by 1</l>
<l>        Text := Classes[Index]</l>
<c>        * Display predicted class names.</c>
<l>        Row := TextRow[Index]</l>
<l>        Column := TextColumn[0] - MaxStringWidth - ColumnOffset</l>
<l>        dev_disp_text (Text, 'window', Row, Column, 'light gray', 'box', 'false')</l>
<c>        * Display ground truth label names.</c>
<l>        Row := TextRow[0] - RowDistance</l>
<l>        Column := TextColumn[Index * NumClasses]</l>
<l>        dev_disp_text (Text, 'window', Row, Column, 'light gray', 'box', 'false')</l>
<l>    endfor</l>
<c>    * </c>
<c>    * Get the confusion matrix values for display.</c>
<l>    if (DisplayMatrix == 'absolute')</l>
<c>        * Displayed matrix corresponds to the transposed returned matrix.</c>
<l>        transpose_matrix (AbsoluteMatrixID, AbsoluteTransposedMatrixID)</l>
<l>        get_full_matrix (AbsoluteTransposedMatrixID, MatrixText)</l>
<l>        clear_matrix (AbsoluteTransposedMatrixID)</l>
<c>        * Align the numbers right.</c>
<l>        max_matrix (AbsoluteMatrixID, 'full', MatrixMaxID)</l>
<l>        get_full_matrix (MatrixMaxID, MaxValue)</l>
<l>        clear_matrix (MatrixMaxID)</l>
<l>        StringConversion := int(ceil(log10(MaxValue))) + '.0f'</l>
<l>        MatrixText := MatrixText$StringConversion</l>
<l>    else</l>
<c>        * Displayed matrix corresponds to the transposed returned matrix.</c>
<l>        transpose_matrix (RelativeMatrixID, RelativeTransposedMatrixID)</l>
<l>        get_full_matrix (RelativeTransposedMatrixID, MatrixText)</l>
<l>        clear_matrix (RelativeTransposedMatrixID)</l>
<l>        MatrixText := MatrixText$'.2f'</l>
<l>    endif</l>
<c>    * Set color for displayed confusion matrix.</c>
<l>    if (DisplayColor == 'true')</l>
<l>        tuple_gen_const (|MatrixText|, '#666666', TextColor)</l>
<c>        * Use the relative values to adapt the color of the text.</c>
<l>        transpose_matrix (RelativeMatrixID, RelativeTransposedMatrixID)</l>
<l>        get_full_matrix (RelativeTransposedMatrixID, RelativeValues)</l>
<l>        clear_matrix (RelativeTransposedMatrixID)</l>
<c>        * Set the colors and respective thresholds for the off-diagonal values.</c>
<l>        Thresholds := [0.0,0.05,0.1,0.2]</l>
<l>        Colors := ['#8C4D4D','#B33333','#D91A1A','#FF0000']</l>
<l>        for Index := 0 to |Thresholds| - 1 by 1</l>
<l>            tuple_greater_elem (RelativeValues, Thresholds[Index], Greater)</l>
<l>            tuple_find (Greater, 1, Indices)</l>
<l>            if (Indices != -1)</l>
<l>                tuple_replace (TextColor, Indices, Colors[Index], TextColor)</l>
<l>            else</l>
<l>                break</l>
<l>            endif</l>
<l>        endfor</l>
<c>        * Set the colors and respective thresholds for the diagonal values.</c>
<l>        Thresholds := [-0.01,0.60,0.80,0.90,0.95,0.98]</l>
<l>        Colors := ['#666666','#508650','#419C41','#2BBD2B','#15DE15','#00FF00']</l>
<l>        for DiagonalIndex := 0 to NumClasses - 1 by 1</l>
<l>            get_value_matrix (RelativeMatrixID, DiagonalIndex, DiagonalIndex, Value)</l>
<l>            for Index := 0 to |Thresholds| - 1 by 1</l>
<l>                if (Value &gt; Thresholds[Index])</l>
<l>                    TextColor[DiagonalIndex * (NumClasses + 1)] := Colors[Index]</l>
<l>                else</l>
<l>                    break</l>
<l>                endif</l>
<l>            endfor</l>
<l>        endfor</l>
<l>    else</l>
<c>        * Default value for the text color.</c>
<l>        tuple_gen_const (|MatrixText|, 'white', TextColor)</l>
<l>    endif</l>
<c>    * </c>
<c>    * Display confusion matrix.</c>
<l>    dev_disp_text (MatrixText, 'window', TextRow, TextColumn, TextColor, 'box', 'false')</l>
<c>    * </c>
<c>    * Clean up.</c>
<l>    if (CalculateRelativeMatrix)</l>
<l>        clear_matrix (RelativeMatrixID)</l>
<l>    endif</l>
<l>    clear_matrix (AbsoluteMatrixID)</l>
<l>endif</l>
<l>return ()</l>
</body>
<docu id="gen_confusion_matrix">
<abstract lang="en_US">This procedure computes a confusion matrix, which can be visualized, returned, or both.
For this, the classes assigned in GroundTruthLabels and PredictedClasses are compared.

WindowHandle determines the graphics window used for the display. 
ConfusionMatrix is a handle for the returned confusion matrix, see the parameter 'return_matrix'.

Using GenParamName and GenParamValue, you can configure the visualization. The following entries are possible for GenParamName:
- 'display_matrix' (default: 'absolute'): Determine if the displayed matrix shows absolute (value 'absolute') or relative (value 'relative') numbers. If 'none' is chosen, no visualization is performed.
- 'return_matrix' (default: 'absolute'): Determine if the returned ConfusionMatrix shows absolute (value 'absolute') or relative (value 'relative') numbers. If 'none' is chosen, no matrix is returned.
- 'display_color' (default: 'true'): Display values in confusion matrix colored in green (diagonal) and red (off-diagonal) or only in white ('false').
- 'display_column_width': This key can have the following associated values:
   -- 'equal' (default): All columns have the same width that equals the width of the longest row or column-name.
   -- 'minimal': The columns are just as wide as the column-name string plus a small offset.</abstract>
<chapters lang="de_DE">
<item>Deep Learning</item>
<item>Klassifikation</item>
</chapters>
<chapters lang="en_US">
<item>Deep Learning</item>
<item>Classification</item>
</chapters>
<library lang="en_US">MVTec Standard Procedures</library>
<short lang="de_DE">Visualisieren und Zurückgeben der Konfusionsmatrix für die übergebenen Labels.</short>
<short lang="en_US">Compute a confusion matrix, which an be visualized and/or returned.</short>
<successor>
<item>get_full_matrix</item>
<item>get_value_matrix</item>
<item>sum_matrix</item>
</successor>
<parameters>
<parameter id="ConfusionMatrix">
<default_type>integer</default_type>
<description lang="de_DE">Die resultierende Konfusionsmatrix.</description>
<description lang="en_US">Handle of the resulting confusion matrix.</description>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>matrix</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="GenParamName">
<default_type>string</default_type>
<description lang="de_DE">Name des generischen Parameters.</description>
<description lang="en_US">Name of the generic parameter.</description>
<mixed_type>false</mixed_type>
<multivalue>optional</multivalue>
<sem_type>attribute.name</sem_type>
<type_list>
<item>string</item>
</type_list>
<values>
<item>'display_matrix'</item>
<item>'return_matrix'</item>
<item>'display_color'</item>
<item>'display_column_width'</item>
</values>
</parameter>
<parameter id="GenParamValue">
<default_type>string</default_type>
<description lang="de_DE">Wert des generischen Parameters.</description>
<description lang="en_US">Value of the generic parameter.</description>
<mixed_type>false</mixed_type>
<multivalue>optional</multivalue>
<sem_type>attribute.value</sem_type>
<type_list>
<item>string</item>
</type_list>
<values>
<item>'absolute'</item>
<item>'relative'</item>
<item>'true'</item>
<item>'false'</item>
<item>'minimal'</item>
<item>'equal'</item>
<item>'none'</item>
</values>
</parameter>
<parameter id="GroundTruthLabels">
<default_type>string</default_type>
<description lang="de_DE">Die tatsächlich korrekten Labels.</description>
<description lang="en_US">Tuple with the ground truth labels.</description>
<mixed_type>false</mixed_type>
<multivalue>optional</multivalue>
<sem_type>string</sem_type>
<type_list>
<item>string</item>
</type_list>
</parameter>
<parameter id="PredictedClasses">
<default_type>string</default_type>
<description lang="de_DE">Die vom Klassifikator vorhergesagten Klassen.</description>
<description lang="en_US">Tuple with inferred classes.</description>
<mixed_type>false</mixed_type>
<multivalue>optional</multivalue>
<sem_type>string</sem_type>
<type_list>
<item>string</item>
</type_list>
</parameter>
<parameter id="WindowHandle">
<default_type>integer</default_type>
<description lang="de_DE">Handle des Grafikfensters.</description>
<description lang="en_US">Handle of the window.</description>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>window</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
</parameters>
</docu>
</procedure>
<procedure name="gen_current_setup_moving_cam_object_model_3d">
<interface>
<ic>
<par name="CameraSize" base_type="ctrl" dimension="0"/>
<par name="ToolInBasePose" base_type="ctrl" dimension="0"/>
<par name="HandEyeCalibData" base_type="ctrl" dimension="0"/>
<par name="OM3DToolOrigin" base_type="ctrl" dimension="0"/>
<par name="OM3DBase" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="OM3DCamera" base_type="ctrl" dimension="0"/>
<par name="OM3DTool" base_type="ctrl" dimension="0"/>
<par name="OM3DPlane" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c>* This procedure visualizes the camera, tool, and plane in their</c>
<c>* current positions.</c>
<c>* </c>
<l>read_dict_tuple (HandEyeCalibData, 'ToolInCamPose', ToolInCamPose)</l>
<l>read_dict_tuple (HandEyeCalibData, 'CamParam', CamParam)</l>
<l>read_dict_tuple (HandEyeCalibData, 'PlaneInBasePose0', PlaneInBasePose0)</l>
<c>* </c>
<l>if (CameraSize &lt;= 0)</l>
<l>    throw ('CameraSize should be &gt; 0')</l>
<l>endif</l>
<c>* </c>
<c>* Visualize current camera and tool position.</c>
<c>* </c>
<c>* Get the intersection of the optical axis of the camera and the plane</c>
<l>pose_invert (ToolInBasePose, BaseInToolPose)</l>
<l>pose_compose (BaseInToolPose, PlaneInBasePose0, PlaneInToolPose)</l>
<l>pose_compose (ToolInCamPose, PlaneInToolPose, PlaneInCamPose)</l>
<l>get_cam_par_data (CamParam, 'cx', CX)</l>
<l>get_cam_par_data (CamParam, 'cy', CY)</l>
<l>image_points_to_world_plane (CamParam, PlaneInCamPose, CY, CX, 'm', OptAxisPlaneX, OptAxisPlaneY)</l>
<c>* Transform to camera coordinates</c>
<l>pose_to_hom_mat3d (PlaneInCamPose, HomMat3D)</l>
<l>affine_trans_point_3d (HomMat3D, OptAxisPlaneX, OptAxisPlaneY, 0, OptAxisCamX, OptAxisCamY, OptAxisCamZ)</l>
<l>ConeLength := OptAxisCamZ * 1.1</l>
<c>* If the optical axis does not intersect the plane, we still want to visualize the camera.</c>
<l>if (ConeLength &lt;= 0.0)</l>
<l>    ConeLength := CameraSize</l>
<l>endif</l>
<l>gen_camera_and_tool_moving_cam_object_model_3d (ToolInCamPose, ToolInBasePose, CameraSize, ConeLength, OM3DToolOrigin, CamParam, OM3DCamera, OM3DTool)</l>
<c>* </c>
<c>* Create 3D object model of plane.</c>
<l>FactorBorder := 1.5</l>
<l>gen_ground_plane_object_model_3d (OM3DTool, OM3DCamera, OM3DBase, FactorBorder, PlaneInBasePose0, OM3DPlane)</l>
<l>return ()</l>
</body>
<docu id="gen_current_setup_moving_cam_object_model_3d">
<abstract lang="en_US">This procedure generates the 3D object models for the camera, robot's tool and plane in their current positions.

CameraSize determines the size of generated 3D object model of the camera.
ToolInBasePose is the current position of the robot's tool. HandEyeCalibData must contain the ToolInCamPose and CamParam as obtained through hand-eye calibration, as well as the PlaneInBasePose.

The input parameters OM3DToolOrigin and OM3DBase are 3D object models of the robot's tool and base respectively.

The output parameter OM3DCamera is a 3D object model of the camera and its cone. OM3DTool is the 3D object model of the robot's tool in its current position. OM3DPlane is the 3D model of the plane.</abstract>
<chapters lang="de_DE">
<item>3D-Objektmodell</item>
<item>Generierung</item>
</chapters>
<chapters lang="en_US">
<item>3D Object Model</item>
<item>Creation</item>
</chapters>
<library lang="de_DE">MVTec Standard Procedures</library>
<library lang="en_US">MVTec Standard Procedures</library>
<predecessor>
<item>prepare_moving_cam_for_model_creation</item>
<item>gen_moving_cam_robot_3d</item>
</predecessor>
<short lang="en_US">Generate 3D object models for the camera, robot's tool and plane.</short>
<parameters>
<parameter id="CameraSize">
<default_type>real</default_type>
<description lang="en_US">Visualization factor.</description>
<multivalue>false</multivalue>
<sem_type>real</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
<parameter id="HandEyeCalibData">
<default_type>integer</default_type>
<description lang="en_US">Hand-eye calibration data.</description>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>dict</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="OM3DBase">
<default_type>integer</default_type>
<description lang="en_US">3D models representing the robot's base.</description>
<mixed_type>false</mixed_type>
<multivalue>true</multivalue>
<sem_type>object_model_3d</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="OM3DCamera">
<default_type>integer</default_type>
<description lang="en_US">3D model of the camera and its cone.</description>
<mixed_type>false</mixed_type>
<multivalue>true</multivalue>
<sem_type>object_model_3d</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="OM3DPlane">
<default_type>integer</default_type>
<description lang="en_US">3D model of the plane.</description>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>object_model_3d</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="OM3DTool">
<default_type>integer</default_type>
<description lang="en_US">3D model of the robot's tool in its current position.</description>
<mixed_type>false</mixed_type>
<multivalue>true</multivalue>
<sem_type>object_model_3d</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="OM3DToolOrigin">
<default_type>integer</default_type>
<description lang="en_US">Initial 3D object model of the robot's tool.</description>
<mixed_type>false</mixed_type>
<multivalue>true</multivalue>
<sem_type>object_model_3d</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="ToolInBasePose">
<default_type>real</default_type>
<default_value>[]</default_value>
<description lang="en_US">Pose of the tool in the base coordinate system.</description>
<multivalue>true</multivalue>
<sem_type>pose</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
</parameters>
</docu>
</procedure>
<procedure name="gen_current_setup_stationary_cam_object_model_3d">
<interface>
<ic>
<par name="ArrowThickness" base_type="ctrl" dimension="0"/>
<par name="ArrowLength" base_type="ctrl" dimension="0"/>
<par name="CameraSize" base_type="ctrl" dimension="0"/>
<par name="HandEyeCalibData" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="OM3DCamera" base_type="ctrl" dimension="0"/>
<par name="OM3DPlane" base_type="ctrl" dimension="0"/>
<par name="OM3DBase" base_type="ctrl" dimension="0"/>
<par name="OM3DToolOrigin" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c>* This procedure generates the 3D object models of the camera and its</c>
<c>* cone, the plane, the robot's base and the robot's tool at its</c>
<c>* initial position.</c>
<c>* </c>
<l>read_dict_tuple (HandEyeCalibData, 'CamParam', CamParam)</l>
<l>read_dict_tuple (HandEyeCalibData, 'PlaneInCamPose0', PlaneInCamPose0)</l>
<l>read_dict_tuple (HandEyeCalibData, 'BaseInCamPose', BaseInCamPose)</l>
<c>* </c>
<c>* Visualize base and tool in the origin.</c>
<l>gen_robot_tool_and_base_object_model_3d (ArrowThickness, ArrowLength, OM3DToolOrigin, OM3DBase)</l>
<c>* Visualize camera.</c>
<l>get_cam_par_data (CamParam, 'cx', CX)</l>
<l>get_cam_par_data (CamParam, 'cy', CY)</l>
<l>image_points_to_world_plane (CamParam, PlaneInCamPose0, CY, CX, 'm', OptAxisPlaneX, OptAxisPlaneY)</l>
<l>pose_to_hom_mat3d (PlaneInCamPose0, HomMat3D)</l>
<l>affine_trans_point_3d (HomMat3D, OptAxisPlaneX, OptAxisPlaneY, 0, OptAxisCamX, OptAxisCamY, OptAxisCamZ)</l>
<l>ConeLength := OptAxisCamZ * 1.1</l>
<c>* If the optical axis does not intersect the plane, we still want to visualize the camera.</c>
<l>if (ConeLength &lt;= 0.0)</l>
<l>    ConeLength := CameraSize</l>
<l>endif</l>
<l>create_pose (0, 0, 0, 0, 0, 0, 'Rp+T', 'gba', 'point', IdentityPose)</l>
<l>create_camera_setup_model (1, CameraSetupModelID)</l>
<l>set_camera_setup_cam_param (CameraSetupModelID, 0, [], CamParam, IdentityPose)</l>
<l>gen_camera_setup_object_model_3d (CameraSetupModelID, CameraSize, ConeLength, OM3DCameraOrigin, OM3DConeOrig)</l>
<l>clear_camera_setup_model (CameraSetupModelID)</l>
<l>OM3DCameraOrigin := [OM3DCameraOrigin,OM3DConeOrig]</l>
<l>pose_invert (BaseInCamPose, CamInBasePose)</l>
<l>rigid_trans_object_model_3d (OM3DCameraOrigin, CamInBasePose, OM3DCamera)</l>
<l>clear_object_model_3d (OM3DCameraOrigin)</l>
<c>* </c>
<c>* Create 3D object model of plane.</c>
<l>FactorBorder := 1.5</l>
<l>pose_compose (CamInBasePose, PlaneInCamPose0, PlaneInBasePose)</l>
<l>gen_ground_plane_object_model_3d (OM3DToolOrigin, OM3DCamera, OM3DBase, FactorBorder, PlaneInBasePose, OM3DPlane)</l>
<l>return ()</l>
<c></c>
</body>
<docu id="gen_current_setup_stationary_cam_object_model_3d">
<abstract lang="en_US">This procedure generates the 3D object model for the camera, the plane, the robot's base and the robot's tool in their positions. A stationary camera setup is assumed.

The parameters CameraSize, ArrowThickness and ArrowLength determine the size of generated 3D object models.HandEyeCalibData must contain the BaseInCamPose and CamParam as obtained through hand-eye calibration, as well as the PlaneInBasePose. 

The output parameter OM3DCamera is the 3D object models of the camera and its cone. OM3DPlane is the 3D object of the plane. OM3DBase is the 3D object models defining the robot's base; a lower plane as well as a coordinate system represent the current position of the base. OM3DToolOrigin is the coordinate system at the origin of the robot's tool.</abstract>
<chapters lang="de_DE">
<item>3D-Objektmodell</item>
<item>Generierung</item>
</chapters>
<chapters lang="en_US">
<item>3D Object Model</item>
<item>Creation</item>
</chapters>
<library lang="en_US">MVTec Standard Procedures</library>
<short lang="en_US">Generate 3D object models for the camera, the plane, the robot's base and the robot's tool in a stationary camera setup.</short>
<parameters>
<parameter id="ArrowLength">
<default_type>real</default_type>
<description lang="en_US">Length of the arrows.</description>
<multivalue>false</multivalue>
<sem_type>real</sem_type>
<type_list>
<item>real</item>
</type_list>
</parameter>
<parameter id="ArrowThickness">
<default_type>real</default_type>
<description lang="en_US">Thickness of the arrows.</description>
<multivalue>false</multivalue>
<sem_type>real</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
<parameter id="CameraSize">
<default_type>real</default_type>
<description lang="en_US">Size of the 3D object model of the camera.</description>
<multivalue>false</multivalue>
<sem_type>real</sem_type>
<type_list>
<item>real</item>
</type_list>
</parameter>
<parameter id="HandEyeCalibData">
<default_type>integer</default_type>
<description lang="en_US">Hand-eye calibration data.</description>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>dict</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="OM3DBase">
<default_type>integer</default_type>
<description lang="en_US">3D models representing the robot's base.</description>
<mixed_type>false</mixed_type>
<sem_type>object_model_3d</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="OM3DCamera">
<default_type>integer</default_type>
<description lang="en_US">3D model of the camera and its cone.</description>
<mixed_type>false</mixed_type>
<sem_type>object_model_3d</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="OM3DPlane">
<default_type>integer</default_type>
<description lang="en_US">3D model of the plane.</description>
<mixed_type>false</mixed_type>
<sem_type>object_model_3d</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="OM3DToolOrigin">
<default_type>integer</default_type>
<description lang="en_US">3D models representing the robot's tool.</description>
<mixed_type>false</mixed_type>
<sem_type>object_model_3d</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
</parameters>
</docu>
</procedure>
<procedure name="gen_dl_classifier_heatmap">
<interface>
<io>
<par name="Image" base_type="iconic" dimension="0"/>
</io>
<oo>
<par name="HeatmapRegions" base_type="iconic" dimension="0"/>
</oo>
<ic>
<par name="DLClassifierHandle" base_type="ctrl" dimension="0"/>
<par name="GenParamName" base_type="ctrl" dimension="0"/>
<par name="GenParamValue" base_type="ctrl" dimension="0"/>
<par name="WindowHandle" base_type="ctrl" dimension="0"/>
</ic>
</interface>
<body>
<c>* The procedure gen_dl_classifier_heatmap has been revised and renamed.</c>
<c>* From now on the heatmap functionality is available in the procedure</c>
<c>* dev_display_dl_classifier_heatmap.</c>
<c>* This procedure now displays a text to guide the user to the correct procedure.</c>
<c>* </c>
<l>Text := []</l>
<l>Text[|Text|] := 'ERROR: This procedure (gen_dl_classifier_heatmap) '</l>
<l>Text[|Text|] := 'has been revised and renamed.'</l>
<l>Text[|Text|] := 'Please use the procedure dev_display_dl_classifier_heatmap'</l>
<l>dev_disp_text (Text, 'window', 'center', 'center', ['red','red'], [], [])</l>
<l>return ()</l>
</body>
<docu id="gen_dl_classifier_heatmap">
<abstract lang="en_US">The procedure gen_dl_classifier_heatmap has been revised and renamed. From now on the heatmap functionality is available in the procedure dev_display_dl_classifier_heatmap. 

This procedure only displays a text to indicate the correct procedure name.</abstract>
<chapters lang="en_US">
<item>Legacy</item>
<item>DL Classification</item>
</chapters>
<library lang="en_US">MVTec Standard Procedures</library>
<short lang="en_US">Do not use this procedure, use dev_display_dl_classifier_heatmap.</short>
<warning lang="en_US">gen_dl_classifier_heatmap is obsolete and is only provided for reasons of backward compatibility.
New applications should use the general CNN-based procedure gen_dl_model_classification_heatmap.</warning>
<parameters>
<parameter id="DLClassifierHandle"/>
<parameter id="GenParamName"/>
<parameter id="GenParamValue"/>
<parameter id="HeatmapRegions"/>
<parameter id="Image"/>
<parameter id="WindowHandle"/>
</parameters>
</docu>
</procedure>
<procedure name="gen_dl_model_classification_heatmap">
<interface>
<ic>
<par name="DLModelHandle" base_type="ctrl" dimension="0"/>
<par name="DLSample" base_type="ctrl" dimension="0"/>
<par name="DLResult" base_type="ctrl" dimension="0"/>
<par name="GenParam" base_type="ctrl" dimension="0"/>
</ic>
</interface>
<body>
<c>* </c>
<c>* This procedure generates a heatmap for an image which is classified</c>
<c>* with the deep learning model DLModelHandle. The generated heatmap is</c>
<c>* returned in DLResult and can be displayed in the procedure</c>
<c>* dev_display_dl_data afterwards.</c>
<c>* The procedure can be adjusted with generic parameters using</c>
<c>* the dict GenParam.</c>
<c>* The calculation of this heatmap bases on the confidence value differences.</c>
<c>* </c>
<c>* Please note that the heatmap is intended for visual inspection.</c>
<c>* Therefore, the resulting regions and confidence values are not</c>
<c>* returned.</c>
<c>* </c>
<c>* Set default parameters.</c>
<l>FeatureSize := 30</l>
<l>SamplingSize := 7</l>
<l>TargetClassID := []</l>
<c>* </c>
<c>* Set user specific parameters.</c>
<l>if (GenParam != [])</l>
<l>    GenParamKeys := ['feature_size','sampling_size','target_class_id']</l>
<l>    get_dict_param (GenParam, 'keys', [], Keys)</l>
<l>    for KeyIndex := 0 to |Keys| - 1 by 1</l>
<c>        * Check the key is allowed.</c>
<l>        if (find(GenParamKeys,Keys[KeyIndex]) == -1)</l>
<l>            throw ('Invalid GenParam key \'' + Keys[KeyIndex] + '\'')</l>
<c>            * Retrieve the set value.</c>
<l>        elseif (Keys[KeyIndex] == 'feature_size')</l>
<c>            * Set feature size.</c>
<l>            get_dict_tuple (GenParam, 'feature_size', FeatureSize)</l>
<l>        elseif (Keys[KeyIndex] == 'sampling_size')</l>
<c>            * Set sampling size.</c>
<l>            get_dict_tuple (GenParam, 'sampling_size', SamplingSize)</l>
<l>        elseif (Keys[KeyIndex] == 'target_class_id')</l>
<c>            * Set target class ID.</c>
<l>            get_dict_tuple (GenParam, 'target_class_id', TargetClassID)</l>
<l>            if (TargetClassID != [])</l>
<c>                * Check if target class ID is an integer.</c>
<l>                tuple_is_int (TargetClassID, IsInteger)</l>
<l>                if (not IsInteger)</l>
<l>                    throw ('The "target_class_id" must be an integer.')</l>
<l>                endif</l>
<l>            endif</l>
<l>        endif</l>
<l>    endfor</l>
<l>endif</l>
<c>* </c>
<c>* Check the input parameters.</c>
<l>if (|DLSample| != 1)</l>
<l>    throw ('Please use only a single sample dictionary as input.')</l>
<l>endif</l>
<l>if (SamplingSize &lt; 1)</l>
<l>    throw ('The "sampling_size" (' + SamplingSize + ') must be greater than zero.')</l>
<l>endif</l>
<l>if (FeatureSize &lt; 1)</l>
<l>    throw ('The "feature_size" (' + FeatureSize + ') must be greater than zero.')</l>
<l>endif</l>
<l>if (SamplingSize &gt;= FeatureSize)</l>
<l>    throw ('The "sampling_size" (' + SamplingSize + ') must be smaller than the "feature_size" (' + FeatureSize + ')')</l>
<l>endif</l>
<l>get_dl_model_param (DLModelHandle, 'image_num_channels', NumInputChannels)</l>
<l>get_dict_object (Image, DLSample, 'image')</l>
<l>count_channels (Image, NumImageChannels)</l>
<l>if (NumImageChannels != NumInputChannels)</l>
<l>    throw ('The number of image channels (' + NumImageChannels + ') does not match ' + 'the number of input channels expected by the classifier (' + NumInputChannels + ')')</l>
<l>endif</l>
<l>dev_update_off ()</l>
<c>* </c>
<c>* Check if the result dictionary contains confidence values.</c>
<c>* In case it does not, an additional inference step is needed.</c>
<c>* Else we can skip this step and directly read out the values.</c>
<l>get_dict_param (DLResult, 'key_exists', 'confidences', ConfidenceValuesExist)</l>
<l>if (not ConfidenceValuesExist)</l>
<l>    apply_dl_model (DLModelHandle, DLSample, [], DLResultTmp)</l>
<l>    get_dict_param (DLResultTmp, 'keys', [], DLResultKeys)</l>
<c>    * The operator apply_dl_model creates a new result dictionary.</c>
<c>    * The results need to be copied in order to have them in the procedure parameter dictionary.</c>
<l>    for KeyIndex := 0 to |DLResultKeys| - 1 by 1</l>
<l>        try</l>
<l>            get_dict_tuple (DLResultTmp, DLResultKeys[KeyIndex], KeyValueTuple)</l>
<l>            set_dict_tuple (DLResult, DLResultKeys[KeyIndex], KeyValueTuple)</l>
<l>        catch (Exception)</l>
<l>            get_dict_object (KeyValueObject, DLResultTmp, DLResultKeys[KeyIndex])</l>
<l>            set_dict_object (KeyValueObject, DLResult, DLResultKeys[KeyIndex])</l>
<l>        endtry</l>
<l>    endfor</l>
<l>endif</l>
<c>* Get the predicted class and its confidence value</c>
<c>* for the original (unoccluded) image.</c>
<l>get_dict_tuple (DLResult, 'classification_class_ids', SampleClassIds)</l>
<l>if (TargetClassID == [])</l>
<l>    TargetClassIDIndex := 0</l>
<l>    TargetClassID := SampleClassIds[0]</l>
<l>else</l>
<l>    TargetClassIDIndex := find(SampleClassIds,TargetClassID)</l>
<l>    if (TargetClassIDIndex == -1)</l>
<l>        throw ('Selected "target_class_id" ' + TargetClassID + ' must be in the range of the classification_class_ids of DLResult.')</l>
<l>    endif</l>
<l>endif</l>
<l>TargetClassID := SampleClassIds[TargetClassIDIndex]</l>
<l>get_dict_tuple (DLResult, 'classification_class_names', SampleClassNames)</l>
<l>TargetClassName := SampleClassNames[TargetClassIDIndex]</l>
<l>get_dict_tuple (DLResult, 'classification_confidences', SampleConfidences)</l>
<l>TargetConfidence := SampleConfidences[TargetClassIDIndex]</l>
<l>get_system ('clip_region', ClipRegionSettingBefore)</l>
<l>set_system ('clip_region', 'false')</l>
<c>* </c>
<c>* Partition the image into rectangular regions. The height and width of the</c>
<c>* rectangles are approximately equal to sampling_size.</c>
<l>partition_rectangle (Image, Partition, SamplingSize, SamplingSize)</l>
<l>height_width_ratio (Partition, HeightRegion, WidthRegion, RatioRegion)</l>
<c>* </c>
<c>* Generate a set of regions to be occluded based on the center coordinates</c>
<c>* and the dimensions of these rectangles. Depending on the values of</c>
<c>* feature_size and sampling_size, these regions may overlap.</c>
<l>SamplingSizeUsed := median([HeightRegion,WidthRegion])</l>
<l>get_image_size (Image, Width, Height)</l>
<l>gen_grid_region (RegionGrid, SamplingSizeUsed, SamplingSizeUsed, 'points', Width + 1, Height + 1)</l>
<l>get_region_points (RegionGrid, CenterRows, CenterColumns)</l>
<l>NumRegions := |CenterRows|</l>
<l>gen_circle (OccludedRegions, CenterRows, CenterColumns, gen_tuple_const(NumRegions,FeatureSize / 2))</l>
<c>* </c>
<c>* Generate and classify the occluded images.</c>
<l>Confidences := []</l>
<l>if (NumInputChannels == 1)</l>
<l>    intensity (OccludedRegions, Image, MeanGray, DeviationGray)</l>
<l>else</l>
<l>    decompose3 (Image, ImageR, ImageG, ImageB)</l>
<l>    intensity (OccludedRegions, ImageR, MeanRed, DeviationRed)</l>
<l>    intensity (OccludedRegions, ImageG, MeanGreen, DeviationGreen)</l>
<l>    intensity (OccludedRegions, ImageB, MeanBlue, DeviationBlue)</l>
<l>endif</l>
<l>get_dl_model_param (DLModelHandle, 'batch_size', BatchSize)</l>
<l>for BatchIndex := 0 to int(NumRegions / BatchSize) by 1</l>
<l>    gen_empty_obj (ImagesOccluded)</l>
<l>    tuple_gen_sequence (BatchIndex * BatchSize + 1, min([(BatchIndex + 1) * BatchSize,NumRegions]), 1, BatchIndices)</l>
<l>    for Index := 0 to |BatchIndices| - 1 by 1</l>
<l>        select_obj (OccludedRegions, OccludedRegion, BatchIndices[Index])</l>
<l>        if (NumInputChannels == 1)</l>
<l>            Mean := MeanGray[BatchIndices[Index] - 1]</l>
<l>        else</l>
<l>            Mean := [MeanRed[BatchIndices[Index] - 1],MeanGreen[BatchIndices[Index] - 1],MeanBlue[BatchIndices[Index] - 1]]</l>
<l>        endif</l>
<l>        paint_region (OccludedRegion, Image, ImageOccluded, Mean, 'fill')</l>
<l>        concat_obj (ImagesOccluded, ImageOccluded, ImagesOccluded)</l>
<l>    endfor</l>
<c>    * </c>
<c>    * For each occluded image, get the confidence</c>
<c>    * for the predicted class of the original image.</c>
<l>    count_obj (ImagesOccluded, NumImagesOccluded)</l>
<l>    if (NumImagesOccluded &gt; 0)</l>
<l>        gen_dl_samples_from_images (ImagesOccluded, DLSampleImagesOccluded)</l>
<l>        apply_dl_model (DLModelHandle, DLSampleImagesOccluded, [], DLResultImagesOccluded)</l>
<l>        for IndexOccluded := 0 to NumImagesOccluded - 1 by 1</l>
<l>            get_dict_tuple (DLResultImagesOccluded[IndexOccluded], 'classification_class_ids', OccSampleClassIDs)</l>
<l>            get_dict_tuple (DLResultImagesOccluded[IndexOccluded], 'classification_confidences', OccSampleConfidences)</l>
<l>            Confidences := [Confidences,OccSampleConfidences[find(OccSampleClassIDs,TargetClassID)]]</l>
<l>        endfor</l>
<l>    endif</l>
<l>endfor</l>
<c>* </c>
<c>* Since it is too expensive to compute the confidence value</c>
<c>* for each individual pixel, we work with a subsampling of the image.</c>
<c>* The distance between two sampling points is controlled</c>
<c>* by the parameter 'sampling_size'. For each sampling point,</c>
<c>* we average over the confidence values of all images</c>
<c>* which were occluded with a regions to which this point belongs.</c>
<l>area_center (Partition, Area, AveragingCenterRows, AveragingCenterColumns)</l>
<l>tuple_gen_const (|AveragingCenterRows|, 0, PartitionConfidences)</l>
<l>for PartIndex := 0 to |AveragingCenterRows| - 1 by 1</l>
<l>    get_region_index (OccludedRegions, int(AveragingCenterRows[PartIndex]), int(AveragingCenterColumns[PartIndex]), ConfidenceIndices)</l>
<l>    PartitionConfidences[PartIndex] := mean(Confidences[ConfidenceIndices - 1])</l>
<l>endfor</l>
<c>* </c>
<c>* Compute the deviation from the original confidence value and its maximum absolute value.</c>
<l>ConfidenceDeviations := TargetConfidence - PartitionConfidences</l>
<l>MaxDeviation := max(abs(ConfidenceDeviations))</l>
<c>* </c>
<c>* The heatmap is categorized into 'bins'. The regions where the deviation</c>
<c>* is highest are in the first bin, the regions where the deviation</c>
<c>* is lowest are in the last bin. This is done separately for deviations with</c>
<c>* positive and negative sign.</c>
<l>NumBins := 10</l>
<l>Step := 1 / real(NumBins)</l>
<l>End := 1 - (NumBins - 1) * Step</l>
<l>gen_empty_obj (HeatmapRegions)</l>
<l>for Factor := 1 to End by -Step</l>
<l>    Lesser := ConfidenceDeviations [&lt;=] MaxDeviation * Factor</l>
<l>    Greater := ConfidenceDeviations [&gt;] MaxDeviation * (Factor - Step)</l>
<l>    IndicesInBin := find(Lesser + Greater,2)</l>
<l>    if (IndicesInBin != -1)</l>
<l>        select_obj (Partition, PartsSelected, IndicesInBin + 1)</l>
<l>        union1 (PartsSelected, HeatmapRegion)</l>
<l>    else</l>
<l>        gen_empty_region (HeatmapRegion)</l>
<l>    endif</l>
<l>    concat_obj (HeatmapRegions, HeatmapRegion, HeatmapRegions)</l>
<l>endfor</l>
<l>gen_empty_obj (HeatmapRegionsNegative)</l>
<l>for Factor := 1 to End by -Step</l>
<l>    Lesser := ConfidenceDeviations [&lt;] -MaxDeviation * (Factor - Step)</l>
<l>    Greater := ConfidenceDeviations [&gt;=] -MaxDeviation * Factor</l>
<l>    IndicesInBin := find(Lesser + Greater,2)</l>
<l>    if (IndicesInBin != -1)</l>
<l>        select_obj (Partition, PartsSelected, IndicesInBin + 1)</l>
<l>        union1 (PartsSelected, HeatmapRegionNegative)</l>
<l>    else</l>
<l>        gen_empty_region (HeatmapRegionNegative)</l>
<l>    endif</l>
<l>    concat_obj (HeatmapRegionsNegative, HeatmapRegionNegative, HeatmapRegionsNegative)</l>
<l>endfor</l>
<c>* </c>
<c>* Visualize the heatmap.</c>
<l>get_image_size (Image, WidthImage, HeightImage)</l>
<l>open_window (0, 0, WidthImage, HeightImage, 0, 'buffer', '', WindowHandleTmp)</l>
<l>set_part (WindowHandleTmp, 0, 0, HeightImage - 1, WidthImage - 1)</l>
<l>disp_obj (Image, WindowHandleTmp)</l>
<c>* </c>
<c>* For regions for which the confidence decreased, generate a color palette</c>
<c>* from red to yellow with 66% transparency</c>
<l>Colors := ['#ff3300','#ff6600','#ff9900','#ffcc00','#ffff00'] + '66'</l>
<l>for BinIndex := 1 to 5 by 1</l>
<l>    select_obj (HeatmapRegions, BinRegion, BinIndex)</l>
<l>    ActualColor := Colors[BinIndex - 1]</l>
<l>    set_color (WindowHandleTmp, ActualColor)</l>
<l>    disp_region (BinRegion, WindowHandleTmp)</l>
<l>endfor</l>
<c>* For regions for which the confidence increased, generate a color palette</c>
<c>* from blue to cyan with 66% transparency</c>
<l>Colors := ['#0033ff','#0066ff','#0099ff','#00ccff','#00ffff'] + '66'</l>
<l>for BinIndex := 1 to 5 by 1</l>
<l>    select_obj (HeatmapRegionsNegative, BinRegion, BinIndex)</l>
<l>    ActualColor := Colors[BinIndex - 1]</l>
<l>    set_color (WindowHandleTmp, ActualColor)</l>
<l>    disp_region (BinRegion, WindowHandleTmp)</l>
<l>endfor</l>
<c>* </c>
<c>* Get the actual window content.</c>
<l>dump_window_image (Heatmap, WindowHandleTmp)</l>
<l>close_window (WindowHandleTmp)</l>
<l>set_system ('clip_region', ClipRegionSettingBefore)</l>
<c>* Set the heatmap and its parameters in the result dictionary.</c>
<l>create_dict (HeatmapParameters)</l>
<l>set_dict_tuple (HeatmapParameters, 'feature_size', FeatureSize)</l>
<l>set_dict_tuple (HeatmapParameters, 'sampling_size', SamplingSize)</l>
<l>create_dict (HeatmapResult)</l>
<l>HeatmapImageName := 'heatmap_image_class_' + TargetClassID</l>
<l>set_dict_object (Heatmap, HeatmapResult, HeatmapImageName)</l>
<l>set_dict_tuple (HeatmapResult, 'classification_heatmap_maxdeviation', MaxDeviation)</l>
<l>set_dict_tuple (HeatmapResult, 'heatmap_parameters', HeatmapParameters)</l>
<l>set_dict_tuple (DLResult, 'heatmap_confidence_based', HeatmapResult)</l>
<l>return ()</l>
</body>
<docu id="gen_dl_model_classification_heatmap">
<abstract lang="en_US">This procedure generates a heatmap for the sample given in DLSample using the classification model given in DLModelHandle.
The heatmap and the parameters used for its generation are returned as a dictionary in DLResult. In case the result dictionary does not already contain inference results, an additional inference step is done to retrieve the results.

The calculation of the heatmap bases on the confidence value differences.

Note that the sample image needs to be preprocessed for the computation of the heatmap using the same preprocessing as used during training.

Additional parameters can be given via a generic parameter dict GenParam. Thereby, the following name/value pairs are supported:
- 'feature_size' (default: 30): Should be set to the expected size (diameter) in pixels of the feature/defect that you want to detect. Note the the result is very sensitive with respect to this parameter.
- 'sampling_size' (default: 7): Represents the approximate distance in pixels between two sampling points at which the heatmap is evaluated. The sampling size given by the user might be adjusted slightly in order to obtain an equidistant sampling over the whole image. The sampling_size must be smaller than the feature_size.
- 'target_class_id' (default: []): Determines the target class for which class the heatmap is generated. For an empty tuple the heatmap is calculated for the predicted class.

The heatmap is designed to indicate parts of the image, which are important for the decision of the classifier. To compute the heatmap, numerous new images are created by partially occluding (overpainting) a certain region of the original image. Each modified image is classified and the resulting confidence value is compared to the original one. If the displayed maximum value of these deviations is very small, the heatmap might not provide any significanct information. 

Regions for which the resulting confidence value is lower than the original one are visualized by colors ranging from red to yellow. Red represents a region where the deviation is high, orange represents a medium deviation, yellow a minor one. Regions for which the resulting confidence value is higher the original one are visualized by colors ranging from blue to cyan in a similar manner. If no color is displayed, the confidence values are (almost) not affected by the occlusions.

The heatmap should be used as a tool for visualizing and better understanding classification results. It is not intended as a segmentation tool.</abstract>
<chapters lang="en_US">
<item>Deep Learning</item>
<item>Classification</item>
</chapters>
<library lang="en_US">MVTec Standard Procedures</library>
<short lang="en_US">Return the confidence based heatmap of a deep learning classification in DLResult.</short>
<parameters>
<parameter id="DLModelHandle">
<default_type>integer</default_type>
<description lang="en_US">Handle of the deep-learning-based classification model.</description>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>dl_model</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="DLResult">
<default_type>integer</default_type>
<description lang="en_US">Dictonary with the inference results for the sample, into which also the heatmap will be written.</description>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>dict</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="DLSample">
<default_type>integer</default_type>
<description lang="en_US">Dictonary with the input data and the image of the sample, serving as input for the model.</description>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>dict</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="GenParam">
<description lang="en_US">Generic parameter values with the corresponding names given in GenParamName.</description>
</parameter>
</parameters>
</docu>
</procedure>
<procedure name="gen_dl_samples">
<interface>
<ic>
<par name="DLDataset" base_type="ctrl" dimension="0"/>
<par name="SampleIndices" base_type="ctrl" dimension="0"/>
<par name="RestrictKeysDLSample" base_type="ctrl" dimension="0"/>
<par name="GenParam" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="DLSampleBatch" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c>* </c>
<c>* This procedure creates DLSampleBatch, a tuple of DLSample dictionaries, with</c>
<c>* the image data for each DLDataset sample, that was selected through SampleIndices.</c>
<c>* The keys to be transferred can be restricted using RestrictKeysDLSample,</c>
<c>* which is switched off ('off') by default.</c>
<c>* The procedure returns all generated DLSample dictionaries in the tuple</c>
<c>* DLSampleBatch.</c>
<c>* Setting the GenParam 'ignore_missing_labels' controls whether an error is thrown,</c>
<c>* if no ground truth annotation information is available for a given image.</c>
<c>* </c>
<c>* Get the image directory.</c>
<l>get_dict_tuple (DLDataset, 'image_dir', ImageDir)</l>
<c>* </c>
<c>* Get the samples from the DLDataset.</c>
<l>get_dict_tuple (DLDataset, 'samples', DLSamples)</l>
<c>* </c>
<c>* Check the input values.</c>
<c>* </c>
<c>* Check that the given indices are valid.</c>
<l>tuple_min (SampleIndices, MinIndex)</l>
<l>tuple_max (SampleIndices, MaxIndex)</l>
<l>if ((MinIndex &lt; 0) or (MaxIndex &gt; (|DLSamples| - 1)))</l>
<l>    throw ('The given SampleIndices are not within the range of available samples in DLDataset.')</l>
<l>endif</l>
<c>* </c>
<c>* Check if the given method is valid.</c>
<l>if (|RestrictKeysDLSample| == 1)</l>
<l>    if (max(find(['anomaly_detection','detection','segmentation','classification','image_only','off'],RestrictKeysDLSample)) == -1)</l>
<l>        throw ('Unknown RestrictKeysDLSample : ' + RestrictKeysDLSample)</l>
<l>    endif</l>
<l>else</l>
<l>    throw ('RestrictKeysDLSample must be specified by one string.')</l>
<l>endif</l>
<c>* </c>
<c>* Generic Parameters.</c>
<c>* Set default values.</c>
<l>InstanceType := 'rectangle1'</l>
<c>* For missing labels an error is thrown.</c>
<l>if (RestrictKeysDLSample == 'off')</l>
<l>    IgnoreMissing := true</l>
<l>else</l>
<l>    IgnoreMissing := false</l>
<l>endif</l>
<c>* </c>
<c>* Transfer generic parameters.</c>
<l>if (GenParam != [])</l>
<l>    get_dict_param (GenParam, 'keys', [], GenParamName)</l>
<l>    for IndexGenParam := 0 to |GenParamName| - 1 by 1</l>
<l>        if (GenParamName[IndexGenParam] == 'ignore_missing_labels')</l>
<l>            get_dict_tuple (GenParam, 'ignore_missing_labels', IgnoreMissing)</l>
<l>            if (not (IgnoreMissing == 1 or IgnoreMissing == 0))</l>
<l>                throw ('The GenParam ignore_missing_labels must be true or false.')</l>
<l>            endif</l>
<l>        elseif (GenParamName[IndexGenParam] == 'instance_type')</l>
<l>            if (max(find(['detection','off'],RestrictKeysDLSample)) == -1)</l>
<l>                throw ('The GenParam instance_type can only be set for RestrictKeysDLSample detection or off.')</l>
<l>            endif</l>
<l>            get_dict_tuple (GenParam, 'instance_type', InstanceType)</l>
<l>            if (max(find(['rectangle1','rectangle2'],InstanceType)) == -1)</l>
<l>                throw ('The GenParam instance_type must be either \'rectangle1\' or \'rectangle2\'.')</l>
<l>            endif</l>
<l>        else</l>
<l>            throw ('Unknown GenParam key : ' + GenParamName[IndexGenParam])</l>
<l>        endif</l>
<l>    endfor</l>
<l>endif</l>
<c>* </c>
<c>* Get the samples to be processed.</c>
<l>DLSamplesProc := DLSamples[SampleIndices]</l>
<c>* </c>
<c>* Initialize the tuple for collection the DLSample dictionaries.</c>
<l>DLSampleBatch := []</l>
<c>* </c>
<c>* Set the BboxKeyList according to the InstanceType.</c>
<l>if (max(find(['detection','off'],RestrictKeysDLSample)) != -1)</l>
<l>    BboxKeyList := ['bbox_col1','bbox_row1','bbox_col2','bbox_row2']</l>
<l>    if (InstanceType == 'rectangle2')</l>
<l>        BboxKeyList := ['bbox_row','bbox_col','bbox_length1','bbox_length2','bbox_phi']</l>
<l>    endif</l>
<l>endif</l>
<c>* Loop over all selected samples and create a DLSample dictionary</c>
<c>* for each dictionary in the DLDataset samples.</c>
<l>for ImageIndex := 0 to |SampleIndices| - 1 by 1</l>
<c>    * </c>
<c>    * Create the DLSample dictionary</c>
<l>    create_dict (DLSample)</l>
<c>    * </c>
<c>    * Set the image key.</c>
<l>    get_dict_tuple (DLSamplesProc[ImageIndex], 'image_id', ImageID)</l>
<l>    set_dict_tuple (DLSample, 'image_id', ImageID)</l>
<c>    * </c>
<c>    * Read image.</c>
<c>    * The relative file path of the image is specified in image_name.</c>
<l>    get_dict_tuple (DLSamplesProc[ImageIndex], 'image_file_name', ImageName)</l>
<c>    * </c>
<l>    if (strlen(ImageDir) == 0)</l>
<l>        FileName := ImageName</l>
<l>    else</l>
<l>        FileName := ImageDir + '/' + ImageName</l>
<l>    endif</l>
<l>    try</l>
<l>        read_image (ImageRaw, FileName)</l>
<c>        * Insert image into dictionary.</c>
<l>        set_dict_object (ImageRaw, DLSample, 'image')</l>
<l>    catch (Exception)</l>
<l>        throw ('Error for reading/setting image ' + FileName + ' with ID ' + ImageID + ' : Error code ' + Exception[0])</l>
<l>    endtry</l>
<c>    * </c>
<c>    * Read specific data.</c>
<c>    * </c>
<l>    if (RestrictKeysDLSample != 'image_only')</l>
<c>        * </c>
<c>        * Transfer anomaly detection relevant data.</c>
<l>        if (max(find(['anomaly_detection','off'],RestrictKeysDLSample)) != -1)</l>
<c>            * Check the existence of the label key.</c>
<l>            get_dict_param (DLSamplesProc[ImageIndex], 'key_exists', 'anomaly_label', AnomalyLabelExists)</l>
<l>            if (AnomalyLabelExists)</l>
<c>                * Get the image label.</c>
<l>                get_dict_tuple (DLSamplesProc[ImageIndex], 'anomaly_label', AnomalyLabel)</l>
<c>                * Check the existence of the anomaly file name key. If not found it is just ignored.</c>
<l>                get_dict_param (DLSamplesProc[ImageIndex], 'key_exists', 'anomaly_file_name', AnomalyFileNameExists)</l>
<l>                if (AnomalyFileNameExists)</l>
<c>                    * Get the ground truth anomaly directory.</c>
<l>                    get_dict_tuple (DLDataset, 'anomaly_dir', AnomalyDir)</l>
<c>                    * Get the image file name.</c>
<l>                    get_dict_tuple (DLSamplesProc[ImageIndex], 'anomaly_file_name', AnomalyFileName)</l>
<c>                    * Read the ground truth anomaly image.</c>
<l>                    try</l>
<l>                        read_image (ImageAnomaly, AnomalyDir + '/' + AnomalyFileName)</l>
<l>                    catch (ExceptionImageAnomaly)</l>
<c>                        * If the file is not an image, try to read the ground truth anomaly region.</c>
<c>                        * Then, convert this region to a ground truth anomaly image.</c>
<l>                        try</l>
<l>                            read_region (RegionAnomaly, AnomalyDir + '/' + AnomalyFileName)</l>
<l>                        catch (ExceptionRegionAnomaly)</l>
<l>                            throw ('Error: Could not read the anomaly ground truth information of image_id ' + ImageID + ' : Error code ' + ExceptionImageAnomaly[0])</l>
<l>                        endtry</l>
<l>                        get_image_size (ImageRaw, Width, Height)</l>
<l>                        gen_image_const (ImageAnomaly, 'byte', Width, Height)</l>
<l>                        overpaint_region (ImageAnomaly, ImageAnomaly, 0, 'fill')</l>
<l>                        overpaint_region (ImageAnomaly, RegionAnomaly, 1, 'fill')</l>
<l>                    endtry</l>
<c>                    * Insert anomaly image into DLSample dictionary.</c>
<l>                    set_dict_object (ImageAnomaly, DLSample, 'anomaly_ground_truth')</l>
<l>                endif</l>
<c>                * </c>
<c>                * Insert anomaly label into DLSample dictionary.</c>
<l>                set_dict_tuple (DLSample, 'anomaly_label', AnomalyLabel)</l>
<c>                * Insert anomaly label id into DLSample dictionary.</c>
<l>                if (AnomalyLabel == 'nok')</l>
<l>                    set_dict_tuple (DLSample, 'anomaly_label_id', 1)</l>
<l>                else</l>
<l>                    set_dict_tuple (DLSample, 'anomaly_label_id', 0)</l>
<l>                endif</l>
<l>            elseif (not AnomalyLabelExists and not IgnoreMissing)</l>
<l>                throw ('For image_id ' + ImageID + ' the key \'anomaly_label\' is missing. Missing keys can be ignored using the GenParam ignore_missing_labels.')</l>
<l>            endif</l>
<l>        endif</l>
<c>        * </c>
<c>        * Transfer classification relevant data.</c>
<l>        if (max(find(['classification','off'],RestrictKeysDLSample)) != -1)</l>
<c>            * Check the existence of the required key.</c>
<l>            get_dict_param (DLSamplesProc[ImageIndex], 'key_exists', 'image_label_id', ImageLabelIDExists)</l>
<l>            if (ImageLabelIDExists)</l>
<c>                * Transfer the image label.</c>
<l>                get_dict_tuple (DLSamplesProc[ImageIndex], 'image_label_id', ImageLabelID)</l>
<l>                set_dict_tuple (DLSample, 'image_label_id', ImageLabelID)</l>
<l>            elseif (not ImageLabelIDExists and not IgnoreMissing)</l>
<l>                throw ('For image_id ' + ImageID + ' the key \'image_label_id\' is missing. Missing keys can be ignored using the GenParam ignore_missing_labels.')</l>
<l>            endif</l>
<l>        endif</l>
<c>        * </c>
<c>        * Transfer detection relevant data.</c>
<l>        if (max(find(['detection','off'],RestrictKeysDLSample)) != -1)</l>
<c>            * Check the existence of the required key.</c>
<l>            get_dict_param (DLSamplesProc[ImageIndex], 'key_exists', 'bbox_label_id', BboxExists)</l>
<l>            if (BboxExists)</l>
<c>                * Transfer the bounding box labels.</c>
<l>                get_dict_tuple (DLSamplesProc[ImageIndex], 'bbox_label_id', BboxLabels)</l>
<l>                set_dict_tuple (DLSample, 'bbox_label_id', BboxLabels)</l>
<c>                * Transfer the bounding box coordinates.</c>
<l>                get_dict_param (DLSamplesProc[ImageIndex], 'key_exists', BboxKeyList, KeysExist)</l>
<l>                if (sum(KeysExist) != |KeysExist| and not IgnoreMissing)</l>
<l>                    MissingKeyIndices := find(KeysExist [==] 0,1)</l>
<l>                    throw ('For image_id ' + ImageID + ', an error has occurred when transferring the key ' + BboxKeyList[MissingKeyIndices])</l>
<l>                endif</l>
<l>                for IndexParam := 0 to |BboxKeyList| - 1 by 1</l>
<l>                    get_dict_tuple (DLSamplesProc[ImageIndex], BboxKeyList[IndexParam], BboxCoord)</l>
<l>                    set_dict_tuple (DLSample, BboxKeyList[IndexParam], BboxCoord)</l>
<l>                endfor</l>
<l>            elseif (not IgnoreMissing)</l>
<l>                throw ('For image_id ' + ImageID + ' there is no key bbox_label_id. Missing keys can be ignored using the GenParam ignore_missing_labels.')</l>
<l>            endif</l>
<l>        endif</l>
<c>        * </c>
<c>        * Transfer segmentation relevant data.</c>
<l>        if (max(find(['segmentation','off'],RestrictKeysDLSample)) != -1)</l>
<c>            * Check the existence of the required keys.</c>
<l>            get_dict_param (DLSamplesProc[ImageIndex], 'key_exists', 'segmentation_file_name', SegKeyExists)</l>
<l>            if (SegKeyExists)</l>
<c>                * Get the ground truth segmentation directory.</c>
<l>                get_dict_tuple (DLDataset, 'segmentation_dir', SegmentationDir)</l>
<c>                * Get the image file name.</c>
<l>                get_dict_tuple (DLSamplesProc[ImageIndex], 'segmentation_file_name', SegmentationName)</l>
<c>                * Read the ground truth segmentation image.</c>
<l>                try</l>
<l>                    read_image (ImageSegmentation, SegmentationDir + '/' + SegmentationName)</l>
<l>                catch (ExceptionSegmentation)</l>
<l>                    throw ('Error for reading segmentation file of image_id ' + ImageID + ' : Error code ' + ExceptionSegmentation[0])</l>
<l>                endtry</l>
<c>                * Insert image into DLSample dictionary.</c>
<l>                set_dict_object (ImageSegmentation, DLSample, 'segmentation_image')</l>
<l>            elseif (not IgnoreMissing)</l>
<l>                throw ('For image_id ' + ImageID + ' there is no key segmentation_file_name. Missing keys can be ignored using the GenParam ignore_missing_labels.')</l>
<l>            endif</l>
<l>        endif</l>
<l>    endif</l>
<c>    * </c>
<c>    * Collect all data dictionaries of all processed indices.</c>
<l>    DLSampleBatch := [DLSampleBatch,DLSample]</l>
<l>endfor</l>
<l>return ()</l>
</body>
<docu id="gen_dl_samples">
<abstract lang="en_US">This procedure returns the dictionaries DLSample for samples specified over SampleIndices of the dictionary DLDataset. 
Thereby SampleIndices is an index or a tuple of indices.
RestrictKeysDLSample determines, which set of keys is to be processed.

For every selected sample, a dictionary DLSample is created, comprising the following (initial) keys depending on the model type:
- For all model types:
   -- 'image' (the image)
   -- 'image_id' (a unique image identifier given through DLDataset)
- For model type 'anomaly_detection':
   -- 'anomaly_label' (label indicating a sample containing an anomaly)
   -- 'anomaly_label_id' (ID for the given class of the sample)
   -- 'anomaly_ground_truth' (image with anomaly region)
- For model type 'classification':
   -- 'image_label_id' (ID for the given class of the image)
- For model type 'detection':
   -- 'bbox_label_id' (bounding box label IDs)
   -- Bounding box parameter for instance type 'rectangle1':
      --- 'bbox_col1' (bounding box parameter: upper left corner, column coordinate)
      --- 'bbox_row1' (bounding box parameter: upper left corner, row coordinate)
      --- 'bbox_col2' (bounding box parameter: lower right corner, column coordinate)
      --- 'bbox_row2' (bounding box parameter: lower right corner, row coordinate)
   -- Bounding box parameter for instance type 'rectangle2':
      --- 'bbox_row' (bounding box parameter: center point, row coordinate)
      --- 'bbox_col' (bounding box parameter: center point, column coordinate)
      --- 'bbox_phi' (bounding box parameter: angle phi)
      --- 'bbox_length1' (bounding box parameter: half length of edge 1)
      --- 'bbox_length2' (bounding box parameter: half length of edge 2)
- For model type 'segmentation':
   -- 'segmentation_image' (the segmentation annotation image)

For the bounding boxes, pixel centered, subpixel accurate coordinates are used.

The parameter RestrictKeysDLSample restricts the set of keys to be processed from the DLDataset sample information to generate the DLSample keys. It can contain one of the following string values:
- 'off' (default): All available keys are transferred.
- 'anomaly_detection': General and anomaly detection entries are created in DLSample.
- 'classification': General and classification entries are created in DLSample.
- 'detection': General and detection entries are created in DLSample.
- 'segmentation': General and segmentation entries are created in DLSample. 
- 'image_only': Only general entries are created. 

GenParam is a dictionary, which can have the following key:
- 'ignore_missing_labels': Controls whether missing label keys lead to errors ('false') or not ('true'). The default value is 'true' if RestrictKeysDLSample has a value 'off', otherwise it is 'false'.
- 'instance_type': Specifies for which model instance type the data is prepared. Only applicable for models of type 'detection'.
  Supported values: 'rectangle1' (default), 'rectangle2'.</abstract>
<chapters lang="de_DE">
<item>Deep Learning</item>
<item>Modell</item>
</chapters>
<chapters lang="en_US">
<item>Deep Learning</item>
<item>Model</item>
</chapters>
<library lang="en_US">MVTec Standard Procedures</library>
<short lang="en_US">The procedure returns DLSample dicts for given sample indices of a DLDataset.</short>
<parameters>
<parameter id="DLDataset">
<default_type>integer</default_type>
<description lang="en_US">Dictionary containing the used dataset and its information.</description>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>dict</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="DLSampleBatch">
<default_type>integer</default_type>
<description lang="en_US">Tuple of DLSample dictionaries.</description>
<mixed_type>false</mixed_type>
<multivalue>optional</multivalue>
<sem_type>dict</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="GenParam">
<default_type>integer</default_type>
<default_value>[]</default_value>
<description lang="en_US">Dictionary containing the generic parameter. The default is [], in this case default values are used.</description>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>any</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="RestrictKeysDLSample">
<default_type>string</default_type>
<default_value>'off'</default_value>
<description lang="en_US">A string restricting the set of keys of the sample information, which are to be processed to generate the dictionary DLSample.</description>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>string</sem_type>
<type_list>
<item>string</item>
</type_list>
<values>
<item>'off'</item>
<item>'anomaly_detection'</item>
<item>'classification'</item>
<item>'detection'</item>
<item>'segmentation'</item>
<item>'image_only'</item>
</values>
</parameter>
<parameter id="SampleIndices">
<default_type>integer</default_type>
<description lang="en_US">Tuple with indices of the samples from DLDataset, for which the dictionaries DLSample are to be returned.</description>
<multivalue>optional</multivalue>
<sem_type>integer</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
</parameters>
</docu>
</procedure>
<procedure name="gen_dl_samples_from_images">
<interface>
<io>
<par name="Images" base_type="iconic" dimension="0"/>
</io>
<oc>
<par name="DLSampleBatch" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c>* </c>
<c>* This procedure creates DLSampleBatch, a tuple</c>
<c>* containing a dictionary DLSample</c>
<c>* for every image given in Images.</c>
<c>* </c>
<c>* Initialize output tuple.</c>
<l>count_obj (Images, NumImages)</l>
<l>DLSampleBatch := gen_tuple_const(NumImages,-1)</l>
<c>* </c>
<c>* Loop through all given images.</c>
<l>for ImageIndex := 0 to NumImages - 1 by 1</l>
<l>    select_obj (Images, Image, ImageIndex + 1)</l>
<c>    * Create DLSample from image.</c>
<l>    create_dict (DLSample)</l>
<l>    set_dict_object (Image, DLSample, 'image')</l>
<c>    * </c>
<c>    * Collect the DLSamples.</c>
<l>    DLSampleBatch[ImageIndex] := DLSample</l>
<l>endfor</l>
<l>return ()</l>
</body>
<docu id="gen_dl_samples_from_images">
<abstract lang="en_US">This procedure creates DLSampleBatch, a tuple containing a dictionary DLSample for every image given in Images.</abstract>
<chapters lang="de_DE">
<item>Deep Learning</item>
<item>Modell</item>
</chapters>
<chapters lang="en_US">
<item>Deep Learning</item>
<item>Model</item>
</chapters>
<library lang="en_US">MVTec Standard Procedures</library>
<short lang="en_US">Store the given images in a tuple of dictionaries DLSamples.</short>
<parameters>
<parameter id="DLSampleBatch">
<default_type>integer</default_type>
<description lang="en_US">Tuple of DLSample dictionaries.</description>
<mixed_type>false</mixed_type>
<multivalue>optional</multivalue>
<sem_type>dict</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="Images">
<description lang="en_US">Images to be stored as DLSamples in the output dictionary DLSampleBatch.</description>
<multivalue>optional</multivalue>
<sem_type>image</sem_type>
</parameter>
</parameters>
</docu>
</procedure>
<procedure name="gen_dl_segmentation_weight_images">
<interface>
<ic>
<par name="DLDataset" base_type="ctrl" dimension="0"/>
<par name="DLPreprocessParam" base_type="ctrl" dimension="0"/>
<par name="ClassWeights" base_type="ctrl" dimension="0"/>
<par name="GenParam" base_type="ctrl" dimension="0"/>
</ic>
</interface>
<body>
<c>* </c>
<c>* This procedure generates for each training sample in DLDataset a weight image,</c>
<c>* that is used as input to the loss in a segmentation model.</c>
<c>* The dictionary DLDataset needs a key 'dlsample_dir', assigning a directory</c>
<c>* in which for every sample a dictionary DLSample has to exist.</c>
<c>* The procedure reads for each training sample the dictionary DLSample,</c>
<c>* generates a weight image according to the specified ClassWeights</c>
<c>* and overwrites the DLSample with the updated sample including the weight image.</c>
<c>* </c>
<c>* Check input data.</c>
<l>get_dict_param (DLDataset, 'key_exists', ['dlsample_dir','samples','class_ids'], KeyExists)</l>
<l>if (not KeyExists[0])</l>
<l>    throw ('DLDataset needs a key-value pair for \'dlsample_dir\'')</l>
<l>endif</l>
<l>if (not KeyExists[1])</l>
<l>    throw ('DLDataset needs a key-value pair for \'samples\'')</l>
<l>endif</l>
<l>if (not KeyExists[2])</l>
<l>    throw ('DLDataset needs a key-value pair for \'class_ids\'')</l>
<l>endif</l>
<c>* </c>
<l>get_dict_tuple (DLDataset, 'class_ids', ClassIDs)</l>
<l>if (ClassWeights == [])</l>
<l>    throw ('ClassWeights is empty')</l>
<l>elseif (|ClassWeights| != |ClassIDs| and |ClassWeights| != 1)</l>
<l>    throw ('ClassWeights must be either a single value or of the same length as the DLDataset ClassIDs.')</l>
<l>endif</l>
<c>* </c>
<l>if (find(ClassWeights [&lt;] 0,1) &gt; -1)</l>
<l>    throw ('ClassWeights must be greater or equal zero.')</l>
<l>elseif (|ClassWeights| == 1 and ClassWeights &lt;= 0)</l>
<l>    throw ('If only a single weight is given as ClassWeights, this must be greater than zero.')</l>
<l>endif</l>
<c>* </c>
<c>* Check the validity of the preprocessing parameters.</c>
<l>check_dl_preprocess_param (DLPreprocessParam)</l>
<c>* </c>
<c>* Set defaults.</c>
<l>OverwriteFiles := false</l>
<c>* </c>
<c>* Overwrite defaults specified in GenParam.</c>
<l>if (GenParam != [])</l>
<l>    get_dict_param (GenParam, 'keys', [], GenParamKeys)</l>
<l>    for GenParamIndex := 0 to |GenParamKeys| - 1 by 1</l>
<l>        if (GenParamKeys[GenParamIndex] == 'overwrite_files')</l>
<c>            * Set parameter for overwriting files.</c>
<l>            get_dict_tuple (GenParam, 'overwrite_files', OverwriteFiles)</l>
<l>            if (OverwriteFiles != false and OverwriteFiles != true)</l>
<l>                throw ('\'overwrite_files\' must be either true or false')</l>
<l>            endif</l>
<l>        else</l>
<l>            throw ('Unknown parameter: \'' + GenParamKeys[GenParamIndex] + '\'')</l>
<l>        endif</l>
<l>    endfor</l>
<l>endif</l>
<c>* </c>
<c>* Get the IDs of the classes to be ignored.</c>
<l>try</l>
<l>    get_dict_tuple (DLPreprocessParam, 'ignore_class_ids', IgnoreClassIDs)</l>
<l>catch (Exception)</l>
<l>    IgnoreClassIDs := []</l>
<l>endtry</l>
<c>* </c>
<c>* Get the samples from the dataset.</c>
<l>get_dict_tuple (DLDataset, 'samples', DLSamples)</l>
<c>* </c>
<c>* Get the indices of the samples belonging to the defined split.</c>
<l>find_dl_samples (DLSamples, 'split', 'train', 'or', SampleIndices)</l>
<c>* </c>
<c>* Get system info on init_new_image.</c>
<l>get_system ('init_new_image', InitNewImage)</l>
<c>* </c>
<c>* Loop over training samples.</c>
<l>for SampleIndex := 0 to |SampleIndices| - 1 by 1</l>
<c>    * </c>
<c>    * Read the DLSample.</c>
<l>    read_dl_samples (DLDataset, SampleIndices[SampleIndex], DLSample)</l>
<c>    * </c>
<c>    * Check if there is already a weight image in the DLSample.</c>
<l>    get_dict_param (DLSample, 'key_exists', 'weight_image', WeightImageExists)</l>
<l>    if (WeightImageExists and not OverwriteFiles)</l>
<l>        get_dict_tuple (DLSample, 'image_id', SampleImageID)</l>
<l>        throw ('The DLSample with image_id ' + SampleImageID + ' already contains a weight image. Force overwriting using the parameter \'overwrite_files\' to true.')</l>
<l>    endif</l>
<c>    * </c>
<c>    * Get the segmentation image.</c>
<l>    get_dict_object (SegmentationImage, DLSample, 'segmentation_image')</l>
<c>    * </c>
<c>    * Generate the weight image.</c>
<c>    * </c>
<c>    * Initialize the weight image with 0.</c>
<l>    get_image_size (SegmentationImage, ImageWidth, ImageHeight)</l>
<l>    gen_image_const (WeightImage, 'real', ImageWidth, ImageHeight)</l>
<c>    * Clear image.</c>
<l>    if (InitNewImage == 'false')</l>
<l>        overpaint_region (WeightImage, WeightImage, 0, 'fill')</l>
<l>    endif</l>
<c>    * </c>
<l>    if (|ClassWeights| == 1)</l>
<c>        * Constant class weight.</c>
<l>        overpaint_region (WeightImage, WeightImage, ClassWeights[0], 'fill')</l>
<c>        * </c>
<l>        if (|IgnoreClassIDs| &gt; 0)</l>
<c>            * Set ignore region to 0.</c>
<l>            gen_empty_region (IgnoreRegion)</l>
<l>            for IgnoreIndex := 0 to |IgnoreClassIDs| - 1 by 1</l>
<l>                IgnoreClassID := IgnoreClassIDs[IgnoreIndex]</l>
<l>                threshold (SegmentationImage, IgnoreRegionTmp, IgnoreClassID, IgnoreClassID)</l>
<l>                union2 (IgnoreRegion, IgnoreRegionTmp, IgnoreRegion)</l>
<l>            endfor</l>
<l>            overpaint_region (WeightImage, IgnoreRegion, 0., 'fill')</l>
<l>        endif</l>
<l>    else</l>
<c>        * Loop over model ClassIDs.</c>
<l>        for ClassIndex := 0 to |ClassIDs| - 1 by 1</l>
<l>            if (IgnoreClassIDs == [] or find(IgnoreClassIDs,ClassIDs[ClassIndex]) == -1)</l>
<c>                * Set the pixel values of the weight image according to ClassWeights.</c>
<l>                ClassID := ClassIDs[ClassIndex]</l>
<l>                Weight := ClassWeights[ClassIndex]</l>
<l>                threshold (SegmentationImage, ClassRegion, ClassID, ClassID)</l>
<l>                overpaint_region (WeightImage, ClassRegion, Weight, 'fill')</l>
<l>            else</l>
<c>                * Ignore class has weight 0 which is already set.</c>
<l>            endif</l>
<l>        endfor</l>
<l>    endif</l>
<c>    * </c>
<c>    * Add the weight image to DLSample.</c>
<l>    set_dict_object (WeightImage, DLSample, 'weight_image')</l>
<c>    * </c>
<c>    * Write the updated DLSample.</c>
<l>    write_dl_samples (DLDataset, SampleIndices[SampleIndex], DLSample, [], [])</l>
<l>endfor</l>
<c>* </c>
<c>* On success we store the class weights for later reference in the DLDataset.</c>
<l>set_dict_tuple (DLDataset, 'class_weights', ClassWeights)</l>
<c>* </c>
<l>return ()</l>
</body>
<docu id="gen_dl_segmentation_weight_images">
<abstract lang="en_US">This procedure generates for each training sample in DLDataset a weight image that is used as input to the loss in a segmentation model. 
The procedure reads for each training sample the dictionary DLSample, generates a weight image according to the specified ClassWeights and overwrites the DLSample with the updated sample including the weight image.

Input parameters:
- DLDataset: The dictionary with the dataset, including the samples for which the weight images are to be calculated. The dataset needs to be split before, as only samples of the training dataset are processed (thus, having the value 'train' for the key 'split'). These samples need to be preprocessed and their DLSample include a 'segmentation_image', an image with the ground truth annotations for every pixel.
- DLPreprocessParam: A dictionary containing the preprocessing parameters, as created by e.g., create_dl_preprocess_param.
- ClassWeights: The weights each class will get in the weight image. Either a single value, if every class gets the same weight, or a tuple containing a weight for every class ID.
- GenParam: A dictionary used to set additional parameters:
   -- overwrite_files: For a value of false, an error is thrown if a weight image already exists. Otherwise a new one is generated. The default value is false.</abstract>
<chapters lang="de_DE">
<item>Deep Learning</item>
<item>Semantische Segmentierung</item>
</chapters>
<chapters lang="en_US">
<item>Deep Learning</item>
<item>Semantic Segmentation</item>
</chapters>
<library lang="en_US">MVTec Standard Procedures</library>
<short lang="en_US">Generates weight images for the training dataset.</short>
<parameters>
<parameter id="ClassWeights">
<default_type>real</default_type>
<default_value>ClassWeights</default_value>
<description lang="en_US">The weights each class will get in the weight image. Either a single value, if every class gets the same weight, or a tuple containing a weight for every class ID.</description>
<mixed_type>optional</mixed_type>
<multivalue>optional</multivalue>
<sem_type>any</sem_type>
<type_list>
<item>real</item>
</type_list>
</parameter>
<parameter id="DLDataset">
<default_type>integer</default_type>
<default_value>DLDataset</default_value>
<description lang="en_US">Dictionary containing the dataset, including the samples for which the weight images are to be calculated.</description>
<mixed_type>false</mixed_type>
<sem_type>dict</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="DLPreprocessParam">
<default_type>integer</default_type>
<description lang="en_US">Dictionary containing the preprocessing parameters.</description>
<mixed_type>false</mixed_type>
<sem_type>dict</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="GenParam">
<default_type>integer</default_type>
<default_value>[]</default_value>
<description lang="en_US">Dictionary used to set additional parameters.</description>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>any</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
</parameters>
</docu>
</procedure>
<procedure name="gen_dummy_objects" access="local">
<interface>
<oo>
<par name="Region" base_type="iconic" dimension="0"/>
<par name="Image" base_type="iconic" dimension="0"/>
</oo>
</interface>
<body>
<c>* </c>
<c>* Create dummy objects for the feature calculation</c>
<c>* (may be used to determine the lengths of the</c>
<c>* vectors etc.).</c>
<c>* </c>
<l>gen_image_const (Image, 'byte', 3, 3)</l>
<l>compose3 (Image, Image, Image, Image)</l>
<l>get_domain (Image, Region)</l>
<l>return ()</l>
</body>
<docu id="gen_dummy_objects">
<abstract lang="en_US">Generate a dummy image and region.

This is an auxiliary procedure for get_feature_lengths, get_feature_names, query_feature_names_by_group, and query_feature_group_names.

For more information about the usage of the get_feature_set library, see documentation of calculate_features.</abstract>
<chapters lang="de_DE">
<item>Klassifikation</item>
<item>Sonstiges</item>
</chapters>
<chapters lang="en_US">
<item>Classification</item>
<item>Misc</item>
</chapters>
<library lang="en_US">MVTec Standard Procedures</library>
<short lang="en_US">Generate a dummy image and region that are, e.g., used to determine the lengths of the feature vectors in get_feature_lengths.</short>
<parameters>
<parameter id="Image">
<description lang="en_US">Dummy image.</description>
<multichannel>true</multichannel>
<multivalue>false</multivalue>
<sem_type>image</sem_type>
<type_list>
<item>byte</item>
</type_list>
</parameter>
<parameter id="Region">
<description lang="en_US">Dummy region.</description>
<multivalue>false</multivalue>
<sem_type>region</sem_type>
</parameter>
</parameters>
</docu>
</procedure>
<procedure name="gen_ground_plane_object_model_3d">
<interface>
<ic>
<par name="OM3DTool" base_type="ctrl" dimension="0"/>
<par name="OM3DCamera" base_type="ctrl" dimension="0"/>
<par name="OM3DBase" base_type="ctrl" dimension="0"/>
<par name="FactorBorder" base_type="ctrl" dimension="0"/>
<par name="PlaneInBasePose" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="OM3DPlane" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c>* This procedure generates the 3D object model of</c>
<c>* the plane on which objects are matched and grasped.</c>
<c>* </c>
<l>XBase := []</l>
<l>YBase := []</l>
<l>ZBase := []</l>
<c>* Extent of tool in base coordinates.</c>
<l>get_extent_by_axis (OM3DTool, XBase, YBase, ZBase, XBase, YBase, ZBase)</l>
<c>* Extent of camera in base coordinates.</c>
<l>get_extent_by_axis (OM3DCamera, XBase, YBase, ZBase, XBase, YBase, ZBase)</l>
<c>* Extent of base in base coordinates.</c>
<l>get_extent_by_axis (OM3DBase, XBase, YBase, ZBase, XBase, YBase, ZBase)</l>
<c>* </c>
<c>* Joint bounding box.</c>
<l>MinXt := min(XBase)</l>
<l>MinYt := min(YBase)</l>
<l>MinZt := min(ZBase)</l>
<l>MaxXt := max(XBase)</l>
<l>MaxYt := max(YBase)</l>
<l>MaxZt := max(ZBase)</l>
<l>Min := [MinXt,MinYt,MinZt]</l>
<l>Max := [MaxXt,MaxYt,MaxZt]</l>
<c>* </c>
<c>* Joint bounding box extended by a factor of FactorBorder.</c>
<l>MinT := Max * (1.0 - FactorBorder) / 2.0 + Min * (1.0 + FactorBorder) / 2.0</l>
<l>MaxT := Max * (1.0 + FactorBorder) / 2.0 + Min * (1.0 - FactorBorder) / 2.0</l>
<l>BoundingBox := [MinT,MaxT]</l>
<c>* </c>
<c>* Get the eight corner points of the bounding box from the min/max representation.</c>
<l>get_bounding_box_points_from_min_max (BoundingBox, PXBB, PYBB, PZBB)</l>
<c></c>
<c>* Transform to plane coordinates (z is direction of the normal of the plane).</c>
<l>pose_invert (PlaneInBasePose, BaseInPlanePose)</l>
<l>pose_to_hom_mat3d (BaseInPlanePose, HomMat3D)</l>
<l>affine_trans_point_3d (HomMat3D, PXBB, PYBB, PZBB, PX, PY, PZ)</l>
<c>* </c>
<c>* Get outline of projection onto the plane.</c>
<l>Qx := min(PX)</l>
<l>Qx1 := max(PX)</l>
<l>Qy := min(PY)</l>
<l>Qy1 := max(PY)</l>
<l>XPlane := [Qx,Qx,Qx1,Qx1]</l>
<l>YPlane := [Qy,Qy1,Qy1,Qy]</l>
<l>tuple_gen_const (4, 0, ZPlane)</l>
<c>* </c>
<c>* Transform back to base coordinates.</c>
<l>pose_to_hom_mat3d (PlaneInBasePose, HomMat3D1)</l>
<l>affine_trans_point_3d (HomMat3D1, XPlane, YPlane, ZPlane, Qx2, Qy2, Qz)</l>
<c>* </c>
<c>* Generate the visualization.</c>
<l>gen_object_model_3d_from_points (Qx2, Qy2, Qz, OM3DPlane)</l>
<l>Faces := []</l>
<l>Faces := [Faces,4,0,1,2,3]</l>
<l>set_object_model_3d_attrib_mod (OM3DPlane, 'polygons', [], Faces)</l>
<c>* </c>
<l>return ()</l>
</body>
<docu id="gen_ground_plane_object_model_3d">
<abstract lang="en_US">This procedure generates the 3D object model of the plane, on which we attempt to match and grip.
The input parameters OM3DTool, OM3DCamera, and OM3DBase are the respective 3D object models of the robot's tool, the camera, and the robot's base. FactorBorder controls the extent of the visualized plane. PlaneInBasePose is the adapted pose of the plane in the base coordinate system.
The output parameter OM3DPlane is the 3D object model of the plane.
</abstract>
<chapters lang="de_DE">
<item>3D-Objektmodell</item>
<item>Generierung</item>
</chapters>
<chapters lang="en_US">
<item>3D Object Model</item>
<item>Creation</item>
</chapters>
<library lang="de_DE">MVTec Standard Procedures</library>
<library lang="en_US">MVTec Standard Procedures</library>
<short lang="en_US">Generate the 3D object model of the plane.</short>
<parameters>
<parameter id="FactorBorder">
<default_type>real</default_type>
<description lang="en_US">Extent of the plane.</description>
<multivalue>false</multivalue>
<sem_type>real</sem_type>
<type_list>
<item>real</item>
</type_list>
</parameter>
<parameter id="OM3DBase">
<default_type>integer</default_type>
<description lang="en_US">3D models representing the robot's base.</description>
<mixed_type>false</mixed_type>
<multivalue>true</multivalue>
<sem_type>object_model_3d</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="OM3DCamera">
<default_type>integer</default_type>
<description lang="en_US">3D model of the camera and its cone.</description>
<mixed_type>false</mixed_type>
<multivalue>true</multivalue>
<sem_type>object_model_3d</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="OM3DPlane">
<default_type>integer</default_type>
<description lang="en_US">3D model of the plane.</description>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>object_model_3d</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="OM3DTool">
<default_type>integer</default_type>
<description lang="en_US">3D model of the robot's tool in its current position.</description>
<mixed_type>false</mixed_type>
<multivalue>true</multivalue>
<sem_type>object_model_3d</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="PlaneInBasePose">
<default_type>real</default_type>
<description lang="en_US">Pose of the plane.</description>
<multivalue>true</multivalue>
<sem_type>pose</sem_type>
<type_list>
<item>real</item>
</type_list>
</parameter>
</parameters>
</docu>
</procedure>
<procedure name="gen_interactive_confusion_matrix">
<interface>
<ic>
<par name="ImageFiles" base_type="ctrl" dimension="0"/>
<par name="GroundTruthLabels" base_type="ctrl" dimension="0"/>
<par name="PredictedClasses" base_type="ctrl" dimension="0"/>
<par name="GenParamName" base_type="ctrl" dimension="0"/>
<par name="GenParamValue" base_type="ctrl" dimension="0"/>
<par name="WindowHandle" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="ConfusionMatrix" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c>* This procedure computes a confusion matrix.</c>
<c>* Therefore, it compares the classes</c>
<c>* assigned in GroundTruthLabels and PredictedClasses.</c>
<c>* The resulting confusion matrix can be</c>
<c>* visualized, returned, or both.</c>
<c>* In each case, the output can be changed</c>
<c>* via generic parameters using GenParamName and GenParamValue.</c>
<c>* For the visualization, the graphics window</c>
<c>* must be specified with WindowHandle.</c>
<c>* </c>
<l>if (|GroundTruthLabels| != |PredictedClasses|)</l>
<l>    throw ('Number of ground truth labels and predicted classes must be equal.')</l>
<l>endif</l>
<c>* </c>
<c>* Set generic parameter defaults.</c>
<l>DisplayMatrix := 'absolute'</l>
<l>ReturnMatrix := 'absolute'</l>
<l>DisplayColor := 'true'</l>
<l>DisplayColumnWidth := 'minimal'</l>
<c>* </c>
<c>* Parse generic parameters.</c>
<l>for GenParamIndex := 0 to |GenParamName| - 1 by 1</l>
<l>    if (GenParamName[GenParamIndex] == 'display_matrix')</l>
<c>        * Set 'display_matrix'.</c>
<l>        DisplayMatrix := GenParamValue[GenParamIndex]</l>
<l>    elseif (GenParamName[GenParamIndex] == 'return_matrix')</l>
<c>        * Set 'return_matrix'.</c>
<l>        ReturnMatrix := GenParamValue[GenParamIndex]</l>
<l>    elseif (GenParamName[GenParamIndex] == 'display_color')</l>
<c>        * Set 'display_color'.</c>
<l>        DisplayColor := GenParamValue[GenParamIndex]</l>
<l>    elseif (GenParamName[GenParamIndex] == 'display_column_width')</l>
<c>        * Set 'display_column_width'.</c>
<l>        DisplayColumnWidth := GenParamValue[GenParamIndex]</l>
<l>    else</l>
<l>        throw ('Unknown generic parameter: \'' + GenParamName[GenParamIndex] + '\'')</l>
<l>    endif</l>
<l>endfor</l>
<c>* </c>
<l>if (DisplayMatrix == 'relative' or ReturnMatrix == 'relative' or DisplayColor == 'true')</l>
<l>    CalculateRelativeMatrix := 1</l>
<l>else</l>
<l>    CalculateRelativeMatrix := 0</l>
<l>endif</l>
<c>* </c>
<c>* Calculate the confusion matrix with absolute values</c>
<c>* and the confusion matrix with relative errors.</c>
<c>* We start with an empty matrix</c>
<c>* and add the number of matching labels.</c>
<l>Classes := uniq(sort(GroundTruthLabels))</l>
<l>NumClasses := |Classes|</l>
<l>create_matrix (NumClasses, NumClasses, 0, AbsoluteMatrixID)</l>
<l>if (CalculateRelativeMatrix)</l>
<l>    create_matrix (NumClasses, NumClasses, 0, RelativeMatrixID)</l>
<l>endif</l>
<l>for ColumnMatrix := 0 to NumClasses - 1 by 1</l>
<l>    Class := Classes[ColumnMatrix]</l>
<l>    ThisLabel := GroundTruthLabels [==] Class</l>
<l>    if (CalculateRelativeMatrix)</l>
<c>        * Obtain the number of ground truth labels per class.</c>
<l>        NumClassGroundTruth := sum(ThisLabel)</l>
<l>    endif</l>
<l>    for RowMatrix := 0 to NumClasses - 1 by 1</l>
<c>        * Select classes for this row/column.</c>
<l>        PredictedClass := Classes[RowMatrix]</l>
<c>        * Check whether the input data</c>
<c>        * corresponds to these classes.</c>
<l>        ThisPredictedClass := PredictedClasses [==] PredictedClass</l>
<c>        * Count the number of elements where the predicted class</c>
<c>        * matches the ground truth label.</c>
<l>        NumMatches := sum((ThisLabel + ThisPredictedClass) [==] 2)</l>
<c>        * Set value in matrix.</c>
<l>        set_value_matrix (AbsoluteMatrixID, RowMatrix, ColumnMatrix, NumMatches)</l>
<l>        if (CalculateRelativeMatrix)</l>
<l>            if (NumClassGroundTruth &gt; 0)</l>
<l>                RelativeError := real(NumMatches) / NumClassGroundTruth</l>
<l>            else</l>
<l>                RelativeError := 0</l>
<l>            endif</l>
<l>            set_value_matrix (RelativeMatrixID, RowMatrix, ColumnMatrix, RelativeError)</l>
<l>        endif</l>
<l>    endfor</l>
<l>endfor</l>
<c>* </c>
<c>* Return the result.</c>
<l>if (ReturnMatrix == 'absolute')</l>
<l>    copy_matrix (AbsoluteMatrixID, ConfusionMatrix)</l>
<l>elseif (ReturnMatrix == 'relative')</l>
<l>    copy_matrix (RelativeMatrixID, ConfusionMatrix)</l>
<l>elseif (ReturnMatrix == 'none')</l>
<c>    * No matrix is returned.</c>
<l>else</l>
<l>    throw ('Unsupported mode for \'return_matrix\'')</l>
<l>endif</l>
<c>* </c>
<c>* Display the matrix.</c>
<l>if (DisplayMatrix != 'none')</l>
<l>    DisplayMatrixAgain := 1</l>
<l>    while (DisplayMatrixAgain)</l>
<c>        * </c>
<c>        * Find maximal string width and set display position parameters.</c>
<l>        StringWidths := []</l>
<c>        * Get the string width of each class.</c>
<l>        for StringIndex := 0 to |Classes| - 1 by 1</l>
<l>            String := Classes[StringIndex]</l>
<l>            get_string_extents (WindowHandle, String, Ascent, Descent, StringWidth, StringHeight)</l>
<l>            StringWidths := [StringWidths,StringWidth]</l>
<l>        endfor</l>
<c>        * The columns should have a minimum width for 4 characters.</c>
<l>        get_string_extents (WindowHandle, 'test', Ascent, Descent, StringWidth, StringHeight)</l>
<l>        MaxStringWidth := max2(max(StringWidths),StringWidth)</l>
<c>        * Get the maximum string width</c>
<c>        * and resize the window accordingly.</c>
<l>        RowStart := 80</l>
<l>        RowDistance := StringHeight + 10</l>
<l>        RowEnd := StringHeight * 7</l>
<l>        ColumnStart := 50 + MaxStringWidth</l>
<l>        ColumnOffset := 20</l>
<l>        ColumnEnd := ColumnOffset</l>
<c>        * </c>
<c>        * Adapt the window size to fit the confusion matrix.</c>
<l>        if (DisplayColumnWidth == 'minimal')</l>
<c>            * Every column of the confusion matrix is as narrow as possible</c>
<c>            * based to the respective string widths.</c>
<l>            WindowWidth := sum(StringWidths) + ColumnOffset * NumClasses + ColumnStart + ColumnEnd</l>
<l>        elseif (DisplayColumnWidth == 'equal')</l>
<c>            * Every column of the confusion matrix should have the same width.</c>
<c>            * based on the maximum string width.</c>
<l>            WindowWidth := (MaxStringWidth + ColumnOffset) * NumClasses + ColumnStart + ColumnEnd</l>
<l>        else</l>
<l>            throw ('')</l>
<l>        endif</l>
<l>        WindowHeight := RowDistance * NumClasses + RowStart + RowEnd</l>
<l>        dev_set_window (WindowHandle)</l>
<l>        dev_clear_window ()</l>
<c>        * </c>
<c>        * Set reasonable limits for graphics window (adapt if necessary).</c>
<l>        WidthLimit := [450,1920]</l>
<l>        HeightLimit := [250,1080]</l>
<l>        if (WindowWidth &gt; WidthLimit[1] or WindowHeight &gt; HeightLimit[1])</l>
<l>            throw ('Confusion Matrix does not fit into graphics window. Please adapt font and/or size limits.')</l>
<l>        endif</l>
<l>        dev_resize_window_fit_size (0, 0, WindowWidth, WindowHeight, WidthLimit, HeightLimit)</l>
<c>        * </c>
<c>        * Get display coordinates.</c>
<c>        * Get row coordinates for display.</c>
<l>        TextRow := []</l>
<l>        for ColumnMatrix := 0 to NumClasses - 1 by 1</l>
<l>            TextRow := [TextRow,[0:RowDistance:(NumClasses - 1) * RowDistance]]</l>
<l>        endfor</l>
<c>        * Get column coordinates for display.</c>
<l>        TextColumn := []</l>
<l>        for Index := 0 to NumClasses - 1 by 1</l>
<l>            TextColumn := [TextColumn,gen_tuple_const(NumClasses,ColumnStart)]</l>
<l>            if (DisplayColumnWidth == 'minimal')</l>
<l>                ColumnStart := ColumnStart + StringWidths[Index] + ColumnOffset</l>
<l>            elseif (DisplayColumnWidth == 'equal')</l>
<l>                ColumnStart := ColumnStart + MaxStringWidth + ColumnOffset</l>
<l>            endif</l>
<l>        endfor</l>
<c>        * Display the confusion matrix with a margin from the top.</c>
<l>        TextRow := TextRow + RowStart</l>
<c>        * Display axis titles.</c>
<l>        dev_disp_text ('Ground truth labels', 'window', 'top', 'right', 'white', 'box', 'false')</l>
<l>        dev_disp_text ('Predicted classes', 'window', 'bottom', 'left', 'white', 'box', 'false')</l>
<l>        for Index := 0 to |Classes| - 1 by 1</l>
<l>            Text := Classes[Index]</l>
<c>            * Display predicted class names.</c>
<l>            Row := TextRow[Index]</l>
<l>            Column := TextColumn[0] - MaxStringWidth - ColumnOffset</l>
<l>            dev_disp_text (Text, 'window', Row, Column, 'light gray', 'box', 'false')</l>
<c>            * Display ground truth label names.</c>
<l>            Row := TextRow[0] - RowDistance * 1.1</l>
<l>            Column := TextColumn[Index * NumClasses]</l>
<l>            dev_disp_text (Text, 'window', Row, Column, 'light gray', 'box', 'false')</l>
<l>        endfor</l>
<c>        * </c>
<c>        * Get the confusion matrix values for display.</c>
<l>        if (DisplayMatrix == 'absolute')</l>
<c>            * Displayed matrix corresponds to the transposed returned matrix.</c>
<l>            transpose_matrix (AbsoluteMatrixID, AbsoluteTransposedMatrixID)</l>
<l>            get_full_matrix (AbsoluteTransposedMatrixID, MatrixText)</l>
<c>            * Align the numbers right.</c>
<l>            max_matrix (AbsoluteMatrixID, 'full', MatrixMaxID)</l>
<l>            get_full_matrix (MatrixMaxID, MaxValue)</l>
<l>            clear_matrix (MatrixMaxID)</l>
<l>            StringConversion := int(ceil(log10(MaxValue))) + '.0f'</l>
<l>            MatrixText := MatrixText$StringConversion</l>
<l>        else</l>
<c>            * Displayed matrix corresponds to the transposed returned matrix.</c>
<l>            transpose_matrix (RelativeMatrixID, RelativeTransposedMatrixID)</l>
<l>            get_full_matrix (RelativeTransposedMatrixID, MatrixText)</l>
<l>            clear_matrix (RelativeTransposedMatrixID)</l>
<l>            MatrixText := MatrixText$'.2f'</l>
<l>        endif</l>
<c>        * Set color for displayed confusion matrix.</c>
<l>        if (DisplayColor == 'true')</l>
<l>            tuple_gen_const (|MatrixText|, '#666666', TextColor)</l>
<c>            * Use the relative values to adapt the color of the text.</c>
<l>            transpose_matrix (RelativeMatrixID, RelativeTransposedMatrixID)</l>
<l>            get_full_matrix (RelativeTransposedMatrixID, RelativeValues)</l>
<l>            clear_matrix (RelativeTransposedMatrixID)</l>
<c>            * Set the colors and respective thresholds for the off-diagonal values.</c>
<l>            Thresholds := [0.0,0.05,0.1,0.2]</l>
<l>            Colors := ['#8C4D4D','#B33333','#D91A1A','#FF0000']</l>
<l>            for Index := 0 to |Thresholds| - 1 by 1</l>
<l>                tuple_greater_elem (RelativeValues, Thresholds[Index], Greater)</l>
<l>                tuple_find (Greater, 1, Indices)</l>
<l>                if (Indices != -1)</l>
<l>                    tuple_replace (TextColor, Indices, Colors[Index], TextColor)</l>
<l>                else</l>
<l>                    break</l>
<l>                endif</l>
<l>            endfor</l>
<c>            * Set the colors and respective thresholds for the diagonal values.</c>
<l>            Thresholds := [-0.01,0.60,0.80,0.90,0.95,0.98]</l>
<l>            Colors := ['#666666','#508650','#419C41','#2BBD2B','#15DE15','#00FF00']</l>
<l>            for DiagonalIndex := 0 to NumClasses - 1 by 1</l>
<l>                get_value_matrix (RelativeMatrixID, DiagonalIndex, DiagonalIndex, Value)</l>
<l>                for Index := 0 to |Thresholds| - 1 by 1</l>
<l>                    if (Value &gt; Thresholds[Index])</l>
<l>                        TextColor[DiagonalIndex * (NumClasses + 1)] := Colors[Index]</l>
<l>                    else</l>
<l>                        break</l>
<l>                    endif</l>
<l>                endfor</l>
<l>            endfor</l>
<l>        else</l>
<c>            * Default value for the text color.</c>
<l>            tuple_gen_const (|MatrixText|, 'white', TextColor)</l>
<l>        endif</l>
<c>        * </c>
<c>        * Prepare display of buttons.</c>
<l>        ButtonHeight := gen_tuple_const(|TextRow|,RowDistance * 0.8)</l>
<l>        ButtonWidth := []</l>
<l>        for I := 0 to NumClasses - 1 by 1</l>
<l>            ButtonWidth[I * NumClasses:I * NumClasses + NumClasses - 1] := StringWidths[I % NumClasses] + ColumnOffset</l>
<l>        endfor</l>
<l>        ButtonWidth := gen_tuple_const(|ButtonWidth|,min(ButtonWidth) * 0.9)</l>
<l>        BoxColor := gen_tuple_const(|ButtonWidth|,'#333333')</l>
<c>        * Do not display colored box</c>
<c>        * when no images can be shown.</c>
<l>        transpose_matrix (AbsoluteMatrixID, AbsoluteTransposedMatrixID)</l>
<l>        get_full_matrix (AbsoluteTransposedMatrixID, AbsValues)</l>
<l>        FoundIndices := find(AbsValues [==] 0.0,1)</l>
<l>        if (FoundIndices != -1)</l>
<l>            BoxColor := replace(BoxColor,FoundIndices,'black')</l>
<l>        endif</l>
<l>        HighlightColor := '#fce9d4'</l>
<c>        * Add continue button.</c>
<l>        MatrixText := [MatrixText,'Continue']</l>
<l>        get_string_extents (WindowHandle, 'Continue', Ascent, Descent, TextWidth, TextHeight)</l>
<l>        get_window_extents (WindowHandle, Row, Column, WindowWidth, WindowHeight)</l>
<l>        TextRow := [TextRow,WindowHeight - TextHeight - 20]</l>
<l>        TextColumn := [TextColumn,WindowWidth - TextWidth - 40]</l>
<l>        ButtonHeight := [ButtonHeight,TextHeight * 1.5]</l>
<l>        ButtonWidth := [ButtonWidth,TextWidth * 1.2]</l>
<l>        TextColor := [TextColor,'black']</l>
<l>        BoxColor := [BoxColor,'#f28d26']</l>
<c>        * </c>
<c>        * Display confusion matrix.</c>
<l>        dev_disp_button (MatrixText, TextRow, TextColumn, ButtonWidth, ButtonHeight, TextColor, BoxColor, HighlightColor, WindowHandle, SelectedElement)</l>
<l>        dev_clear_window ()</l>
<c>        * </c>
<l>        if (SelectedElement != (|Classes| * |Classes|))</l>
<c>            * </c>
<c>            * Display images as selected with confusion matrix.</c>
<l>            ClickedGroundTruthLabel := Classes[SelectedElement / |Classes|]</l>
<l>            ClickedPredictedClass := Classes[SelectedElement % |Classes|]</l>
<c>            * </c>
<c>            * Check if 0 images are to be displayed.</c>
<l>            get_value_matrix (AbsoluteMatrixID, SelectedElement % |Classes|, SelectedElement / |Classes|, Value)</l>
<l>            if (Value != 0.0)</l>
<l>                GenParamName := ['global_selection','label_selection','predicted_class_selection','display_buttons']</l>
<l>                GenParamValue := ['all',ClickedGroundTruthLabel,ClickedPredictedClass,'true']</l>
<l>                get_dl_classifier_image_results (Images, ImageFiles, GroundTruthLabels, PredictedClasses, GenParamName, GenParamValue, WindowHandle)</l>
<l>            else</l>
<l>                dev_disp_text ('Please select an element where images are available.', 'window', 'center', 'center', 'black', [], [])</l>
<l>                wait_seconds (3)</l>
<l>            endif</l>
<l>        else</l>
<c>            * Exit the display loop.</c>
<l>            DisplayMatrixAgain := 0</l>
<l>        endif</l>
<l>    endwhile</l>
<c>    * </c>
<c>    * Clean up.</c>
<l>    if (CalculateRelativeMatrix)</l>
<l>        clear_matrix (RelativeMatrixID)</l>
<l>    endif</l>
<l>    clear_matrix (AbsoluteMatrixID)</l>
<l>endif</l>
<l>return ()</l>
</body>
<docu id="gen_interactive_confusion_matrix">
<abstract lang="en_US">This procedure computes a confusion matrix. Therefore, it compares the classes assigned in GroundTruthLabels and PredictedClasses. The resulting confusion matrix can be visualized, returned, or both. In each case, the output can be changed via generic parameters using GenParamName and GenParamValue. For the visualization, the graphics window must be specified with WindowHandle. If the confusion matrix is visualized, clicking on the entries where the absolute value is &gt; 0 displays the respective images.

The following generic parameters are supported:

* 'display_matrix': 'absolute' (default),'relative','none'. Parameters for the confusion matrix displayed by this procedure. 'absolute' displays the total counted combinations of inferred / ground truth labels. 'relative' means for a given class the number of inferred images are given in ratio to the number of images having this ground truth label. If 'none' is chosen, no visualization is performed, and the confusion matrix is only returned as specified by 'return_matrix'.

* 'return_matrix': 'absolute' (default), 'relative', 'none'. Parameters for the confusion matrix returned from this procedure. The parameters have the same meaning and behavior as for 'display_matrix'.

* 'display_color': 'true' (default), 'false'. This parameter determines if the entries of the confusion matrix are shown in different colors or not. If it is set to 'true', the diagonal values are displayed in colors from dim gray (relative match &lt; 0.6) to green (relative match &gt; 0.98, suggesting a good result), while the off-diagonal values are displayed in colors from dim gray (relative match == 0, suggesting a good result) to red (relative match &gt; 0.2). If the parameter is set to 'false', all entries are shown in white.

* 'display_column_width': 'minimal' (default), 'equal'. This parameter determines if the columns of the confusion matrix are shown equidistantly or not. 'equal' means the width is adapted to the longest class name in order to facilitate the vision of the diagonal. 'minimal' sets the width of every column is according to the respective length of the class name.

This procedure returns a handle if 'return_matrix' is not set to 'none'. This handle should be cleared using clear_matrix when it is not needed anymore, to free the allocated memory.</abstract>
<chapters lang="en_US">
<item>Legacy</item>
<item>DL Classification</item>
</chapters>
<library lang="en_US">MVTec Standard Procedures</library>
<short lang="en_US">Visualize and return the confusion matrix for the given labels.</short>
<successor>
<item>get_full_matrix</item>
<item>get_value_matrix</item>
<item>sum_matrix</item>
</successor>
<warning lang="en_US">gen_interactive_confusion_matrix is obsolete and is only provided for reasons of backward compatibility.
New applications should use the general CNN-based procedure dev_display_dl_interactive_confusion_matrix.</warning>
<parameters>
<parameter id="ConfusionMatrix">
<default_type>integer</default_type>
<description lang="en_US">The resulting confusion matrix.</description>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>matrix</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="GenParamName">
<default_type>string</default_type>
<description lang="en_US">Name of the generic parameter.</description>
<mixed_type>false</mixed_type>
<multivalue>optional</multivalue>
<sem_type>attribute.name</sem_type>
<type_list>
<item>string</item>
</type_list>
<values>
<item>'display_matrix'</item>
<item>'return_matrix'</item>
<item>'display_color'</item>
<item>'display_column_width'</item>
</values>
</parameter>
<parameter id="GenParamValue">
<default_type>string</default_type>
<description lang="en_US">Value of the generic parameter.</description>
<mixed_type>false</mixed_type>
<multivalue>optional</multivalue>
<sem_type>attribute.value</sem_type>
<type_list>
<item>string</item>
</type_list>
<values>
<item>'absolute'</item>
<item>'relative'</item>
<item>'true'</item>
<item>'false'</item>
<item>'minimal'</item>
<item>'equal'</item>
<item>'none'</item>
</values>
</parameter>
<parameter id="GroundTruthLabels">
<default_type>string</default_type>
<description lang="en_US">The correct labels.</description>
<mixed_type>false</mixed_type>
<multivalue>optional</multivalue>
<sem_type>string</sem_type>
<type_list>
<item>string</item>
</type_list>
</parameter>
<parameter id="ImageFiles">
<default_type>string</default_type>
<description lang="en_US">Tuple of the image paths.</description>
<multivalue>optional</multivalue>
<sem_type>string</sem_type>
<type_list>
<item>string</item>
</type_list>
</parameter>
<parameter id="PredictedClasses">
<default_type>string</default_type>
<description lang="en_US">The classes as inferred by the classifier.</description>
<mixed_type>false</mixed_type>
<multivalue>optional</multivalue>
<sem_type>string</sem_type>
<type_list>
<item>string</item>
</type_list>
</parameter>
<parameter id="WindowHandle">
<default_type>integer</default_type>
<description lang="en_US">Handle of the window.</description>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>window</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
</parameters>
</docu>
</procedure>
<procedure name="gen_matching_object_model_3d">
<interface>
<ic>
<par name="ModelID" base_type="ctrl" dimension="0"/>
<par name="ObjectHeight" base_type="ctrl" dimension="0"/>
<par name="Poses" base_type="ctrl" dimension="0"/>
<par name="HandEyeCalibData" base_type="ctrl" dimension="0"/>
<par name="RectificationData" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="OM3DModel" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c>* This procedure generates a 3D model from a shape model for</c>
<c>* visualization for a known (rectified) matching plane.</c>
<c>* </c>
<c>* The 3D model consists of the model-contours transformed to</c>
<c>* their real world size. The origin of the 3D model coordinate system</c>
<c>* lies in the origin of the input shape model with the z-axis</c>
<c>* pointing towards the camera. The model contours are displayed</c>
<c>* twice, at z = 0 and z = ObjectHeight.</c>
<c>* </c>
<l>read_dict_tuple (HandEyeCalibData, 'CamParam', CamParam)</l>
<l>read_dict_tuple (Poses, 'MatchingPlaneInCamPose', MatchingPlaneInCamPose)</l>
<l>read_dict_tuple (RectificationData, 'RectifyImage', RectifyImage)</l>
<l>if (RectifyImage == 'true' or RectifyImage == 'only_rectify' or RectifyImage == 'align_and_rectify')</l>
<l>    read_dict_tuple (RectificationData, 'ScaleRectification', ScaleRectification)</l>
<l>endif</l>
<c>* </c>
<c>* Get shape model contours.</c>
<l>get_shape_model_contours (ModelContours, ModelID, 1)</l>
<l>count_obj (ModelContours, Number)</l>
<l>ModelRows := []</l>
<l>ModelCols := []</l>
<l>for Index := 1 to Number by 1</l>
<l>    select_obj (ModelContours, ObjectSelected, Index)</l>
<l>    get_contour_xld (ObjectSelected, Row1, Col1)</l>
<l>    ModelRows := [ModelRows,Row1]</l>
<l>    ModelCols := [ModelCols,Col1]</l>
<l>endfor</l>
<c>* Obtain real world size (col = x, row = y), centered around the shape model origin (0,0).</c>
<l>if (RectifyImage == 'true' or RectifyImage == 'only_rectify' or RectifyImage == 'align_and_rectify')</l>
<l>    PX := ModelCols * ScaleRectification</l>
<l>    PY := ModelRows * ScaleRectification</l>
<l>else</l>
<l>    image_points_to_world_plane (CamParam, MatchingPlaneInCamPose, ModelRows, ModelCols, 'm', PXPlane, PYPlane)</l>
<l>    image_points_to_world_plane (CamParam, MatchingPlaneInCamPose, 0, 0, 'm', PXPlaneOrig, PYPlaneOrig)</l>
<l>    PX := PXPlane - PXPlaneOrig</l>
<l>    PY := PYPlane - PYPlaneOrig</l>
<l>endif</l>
<c>* Display the contours twice, once in the plane, once above.</c>
<l>tuple_gen_const (|PY|, 0, PZ1)</l>
<l>tuple_gen_const (|PY|, ObjectHeight, PZ2)</l>
<c>* Transform from plane to model coordinate system. The plane</c>
<c>* coordinate system has previously been adapted such that its</c>
<c>* z-axis points away from the camera.</c>
<l>create_pose (0, 0, ObjectHeight, 180, 0, 0, 'Rp+T', 'gba', 'point', PlanePartRectToModelPose)</l>
<l>pose_to_hom_mat3d (PlanePartRectToModelPose, HomMat3D)</l>
<l>affine_trans_point_3d (HomMat3D, [PX,PX], [PY,PY], [PZ1,PZ2], Qx, Qy, Qz)</l>
<l>gen_object_model_3d_from_points (Qx, Qy, Qz, OM3DModel)</l>
<l>return ()</l>
</body>
<docu id="gen_matching_object_model_3d">
<abstract lang="en_US">This procedure generates a 3D object model of the matched object from the contours.

The parameter ModelID is a handle of the matching model. ScaleRect is the rectification scale used.

ObjectHeight is the height of the matched object, which is the difference between the matching and actual planes.

The input dict HandEyeCalibData must contain the camera parameters, the input dict Poses must contain the pose MatchingPlaneInCamPose, and the input dict RectificationData must contain the parameter RectifyImage, and, if the model ist to be rectified, the parameter ScaleRectification.

The output parameter OM3DModel is the 3D object representing the matched object on the plane.
</abstract>
<chapters lang="de_DE">
<item>3D-Objektmodell</item>
<item>Generierung</item>
</chapters>
<chapters lang="en_US">
<item>3D Object Model</item>
<item>Creation</item>
</chapters>
<library lang="de_DE">MVTec Standard Procedures</library>
<library lang="en_US">MVTec Standard Procedures</library>
<short lang="en_US">Generate a 3D object of the matched model, in the case of rectification.</short>
<parameters>
<parameter id="HandEyeCalibData">
<default_type>integer</default_type>
<description lang="en_US">Hand-eye calibration data.</description>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>dict</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="ModelID">
<default_type>integer</default_type>
<description lang="en_US">Handle of the shape-based matching model.</description>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>shape_model</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="OM3DModel">
<default_type>integer</default_type>
<description lang="en_US">3D object model of the matched object contour.</description>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>object_model_3d</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="ObjectHeight">
<default_type>real</default_type>
<description lang="en_US">Height of the matched object.</description>
<multivalue>false</multivalue>
<sem_type>real</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
<parameter id="Poses">
<default_type>integer</default_type>
<description lang="en_US">Pose data.</description>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>dict</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="RectificationData">
<default_type>integer</default_type>
<description lang="en_US">Rectification data.</description>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>dict</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
</parameters>
</docu>
</procedure>
<procedure name="gen_menu_regions_ext" access="local">
<interface>
<oo>
<par name="MenuRegions" base_type="iconic" dimension="0"/>
</oo>
<ic>
<par name="TopBottom" base_type="ctrl" dimension="0"/>
<par name="WindowHandleMenu" base_type="ctrl" dimension="0"/>
<par name="PercentageHeight" base_type="ctrl" dimension="0"/>
<par name="NumRows" base_type="ctrl" dimension="0"/>
<par name="NumCols" base_type="ctrl" dimension="0"/>
</ic>
</interface>
<body>
<l>if (TopBottom != 'top' and TopBottom != 'bottom')</l>
<l>    throw ('Invalid parameter: TopBottom must be "top" or "bottom"')</l>
<l>endif</l>
<c></c>
<l>get_part (WindowHandleMenu, PartRow1, PartCol1, PartRow2, PartCol2)</l>
<l>Height := PartRow2 - PartRow1 + 1</l>
<l>Width := PartCol2 - PartCol1 + 1</l>
<l>MenuHeight := Height * PercentageHeight / 100.0</l>
<l>MenuWidth := Width</l>
<l>ButtonHeight := MenuHeight / NumRows</l>
<l>ButtonWidth := MenuWidth / NumCols</l>
<l>if (TopBottom == 'top')</l>
<l>    Row0 := PartRow1</l>
<l>endif</l>
<l>if (TopBottom == 'bottom')</l>
<l>    Row0 := PartRow2 - MenuHeight</l>
<l>endif</l>
<l>Col0 := PartCol1</l>
<l>set_system ('clip_region', 'false')</l>
<l>gen_empty_obj (MenuRegions)</l>
<l>for r := 0 to NumRows - 1 by 1</l>
<l>    for c := 0 to NumCols - 1 by 1</l>
<l>        gen_rectangle1 (Rectangle, Row0 + r * ButtonHeight, Col0 + c * ButtonWidth, Row0 + r * ButtonHeight + ButtonHeight - 1, Col0 + c * ButtonWidth + ButtonWidth - 1)</l>
<l>        concat_obj (MenuRegions, Rectangle, MenuRegions)</l>
<l>    endfor</l>
<l>endfor</l>
<l>return ()</l>
</body>
<docu id="gen_menu_regions_ext">
<chapters lang="en_US">
<item>Graphics</item>
<item>Output</item>
</chapters>
<library lang="en_US">MVTec Standard Procedures</library>
<parameters>
<parameter id="MenuRegions"/>
<parameter id="NumCols"/>
<parameter id="NumRows"/>
<parameter id="PercentageHeight"/>
<parameter id="TopBottom"/>
<parameter id="WindowHandleMenu"/>
</parameters>
</docu>
</procedure>
<procedure name="gen_robot_tool_and_base_object_model_3d">
<interface>
<ic>
<par name="ArrowThickness" base_type="ctrl" dimension="0"/>
<par name="ArrowLength" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="OM3DToolOrigin" base_type="ctrl" dimension="0"/>
<par name="OM3DBase" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c>* This procedure creates 3D models that represent the tool and the base</c>
<c>* of the robot.</c>
<c>* </c>
<l>if (ArrowThickness &lt;= 0)</l>
<l>    throw ('ArrowThickness should be &gt; 0')</l>
<l>endif</l>
<l>if (ArrowLength &lt;= 0)</l>
<l>    throw ('ArrowLength should be &gt; 0')</l>
<l>endif</l>
<l>create_pose (0, 0, 0, 0, 0, 0, 'Rp+T', 'gba', 'point', IdentityPose)</l>
<c>* </c>
<c>* 3D model for the tool.</c>
<l>create_pose (ArrowLength, 0, 0, 0, 0, 0, 'Rp+T', 'gba', 'point', TransXPose)</l>
<l>gen_arrow_object_model_3d (ArrowThickness, IdentityPose, TransXPose, OM3DToolXOrigin)</l>
<l>create_pose (0, ArrowLength, 0, 0, 0, 0, 'Rp+T', 'gba', 'point', TransYPose)</l>
<l>gen_arrow_object_model_3d (ArrowThickness, IdentityPose, TransYPose, OM3DToolYOrigin)</l>
<l>create_pose (0, 0, ArrowLength, 0, 0, 0, 'Rp+T', 'gba', 'point', TransZPose)</l>
<l>gen_arrow_object_model_3d (ArrowThickness, IdentityPose, TransZPose, OM3DToolZOrigin)</l>
<l>OM3DToolOrigin := [OM3DToolXOrigin,OM3DToolYOrigin,OM3DToolZOrigin]</l>
<c>* </c>
<c>* 3D model for the base.</c>
<l>FactorVisBase := ArrowThickness * 10</l>
<l>gen_box_object_model_3d (IdentityPose, FactorVisBase * 1.5, FactorVisBase * 1.5, FactorVisBase / 12, OM3DBasePlate)</l>
<l>create_pose (ArrowLength, 0, 0, 0, 0, 0, 'Rp+T', 'gba', 'point', TransXPose)</l>
<l>gen_arrow_object_model_3d (ArrowThickness, IdentityPose, TransXPose, OM3DBaseX)</l>
<l>create_pose (0, ArrowLength, 0, 0, 0, 0, 'Rp+T', 'gba', 'point', TransYPose)</l>
<l>gen_arrow_object_model_3d (ArrowThickness, IdentityPose, TransYPose, OM3DBaseY)</l>
<l>create_pose (0, 0, ArrowLength, 0, 0, 0, 'Rp+T', 'gba', 'point', TransZPose)</l>
<l>gen_arrow_object_model_3d (ArrowThickness, IdentityPose, TransZPose, OM3DBaseZ)</l>
<l>OM3DBase := [OM3DBaseX,OM3DBaseY,OM3DBaseZ,OM3DBasePlate]</l>
<l>return ()</l>
</body>
<docu id="gen_robot_tool_and_base_object_model_3d">
<abstract lang="en_US">This procedures generates the 3D models of the base and the tool coordinate systems of the robot.

The input parameters ArrowThickness and ArrowLength determine the size of the objects in 3D. 

The output parameters OM3DToolOrigin and OM3DBase carry the handles for the tool and base 3D models respectively.</abstract>
<chapters lang="de_DE">
<item>3D-Objektmodell</item>
<item>Generierung</item>
</chapters>
<chapters lang="en_US">
<item>3D Object Model</item>
<item>Creation</item>
</chapters>
<library lang="en_US">MVTec Standard Procedures</library>
<short lang="en_US">Generate base and tool 3D models of the robot.</short>
<parameters>
<parameter id="ArrowLength">
<default_type>real</default_type>
<description lang="en_US">Length of the arrows.</description>
<multivalue>false</multivalue>
<sem_type>real</sem_type>
<type_list>
<item>real</item>
</type_list>
</parameter>
<parameter id="ArrowThickness">
<default_type>real</default_type>
<description lang="en_US">Thickness of the arrows.</description>
<multivalue>false</multivalue>
<sem_type>real</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
<parameter id="OM3DBase">
<default_type>integer</default_type>
<description lang="en_US">3D model of the robot's base.</description>
<mixed_type>false</mixed_type>
<sem_type>object_model_3d</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="OM3DToolOrigin">
<default_type>integer</default_type>
<description lang="en_US">3D model of the robot's tool.</description>
<mixed_type>false</mixed_type>
<sem_type>object_model_3d</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
</parameters>
</docu>
</procedure>
<procedure name="gen_sheet_of_light_object_model_3d">
<interface>
<ic>
<par name="SheetOfLightModelID" base_type="ctrl" dimension="0"/>
<par name="PlaneAndMovementSize" base_type="ctrl" dimension="0"/>
<par name="CameraSize" base_type="ctrl" dimension="0"/>
<par name="ConeLength" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="OM3DLightPlane" base_type="ctrl" dimension="0"/>
<par name="OM3DMovement" base_type="ctrl" dimension="0"/>
<par name="OM3DCamera" base_type="ctrl" dimension="0"/>
<par name="OM3DCone" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c>* </c>
<l>get_sheet_of_light_param (SheetOfLightModelID, 'calibration', CalibrationType)</l>
<l>if (CalibrationType != 'xyz')</l>
<l>    throw ('The \'calibration\' of the sheet of light model has to be \'xyz\'.')</l>
<l>endif</l>
<c>* </c>
<l>if (PlaneAndMovementSize &lt;= 0.0)</l>
<l>    throw ('Invalid value for PlaneAndMovementSize. PlaneAndMovementSize must be positive.')</l>
<l>endif</l>
<c>* </c>
<l>get_sheet_of_light_param (SheetOfLightModelID, 'camera_parameter', CamParam)</l>
<l>get_sheet_of_light_param (SheetOfLightModelID, 'camera_pose', CameraPose)</l>
<l>get_sheet_of_light_param (SheetOfLightModelID, 'lightplane_pose', LPPose)</l>
<l>get_sheet_of_light_param (SheetOfLightModelID, 'movement_pose', MovementPose)</l>
<l>if (CamParam == [] or CameraPose == [] or LPPose == [] or MovementPose == [])</l>
<l>    throw ('The sheet of light model has to contain all calibration results.')</l>
<l>endif</l>
<c>* </c>
<c>* Create object model 3D of light plane.</c>
<l>pose_invert (LPPose, LightPlanePoseVis)</l>
<l>XVis := [-1.0,1.0,1.0,-1.0] * PlaneAndMovementSize</l>
<l>YVis := [-1.0,-1.0,1.0,1.0] * PlaneAndMovementSize</l>
<l>gen_plane_object_model_3d (LightPlanePoseVis, XVis, YVis, OM3DLightPlane)</l>
<c>* </c>
<c>* Create object model 3D of movement.</c>
<l>Norm := sqrt(sum(MovementPose[0:2] * MovementPose[0:2]))</l>
<l>ArrowStart := [0.0,0.0,0.0]</l>
<l>ArrowEnd := MovementPose[0:2] * PlaneAndMovementSize / Norm</l>
<l>gen_arrow_object_model_3d (PlaneAndMovementSize / 40.0, ArrowStart, ArrowEnd, OM3DMovement)</l>
<c>* </c>
<c>* Create object model 3D of camera.</c>
<l>create_camera_setup_model (1, CameraSetupModelID)</l>
<l>pose_invert (CameraPose, CameraPoseVis)</l>
<l>set_camera_setup_cam_param (CameraSetupModelID, 0, [], CamParam, CameraPoseVis)</l>
<l>gen_camera_setup_object_model_3d (CameraSetupModelID, CameraSize, ConeLength, OM3DCamera, OM3DCone)</l>
<l>clear_camera_setup_model (CameraSetupModelID)</l>
<l>return ()</l>
</body>
<docu id="gen_sheet_of_light_object_model_3d">
<abstract lang="en_US">The procedure gen_sheet_of_light_object_model_3d generates 3D object models which can be used to visualize the calibrated sheet of light setup SheetOfLightModelID. As a result, you get 3d object models of the light plane, of the movement direction, and of the camera and its its fields of view. You can adapt the size of the created 3D object models using the parameters PlaneAndMovementSize, CameraSize and ConeLength.

The procedure can be used, e.g., to visualize the results of the calibration obtained by calibrate_sheet_of_light.

Note that if the created 3D object models are no longer needed or should be overwritten, the memory has to be freed first by calling the operator clear_object_model_3d.</abstract>
<chapters lang="en_US">
<item>3D Object Model</item>
<item>Creation</item>
</chapters>
<library lang="en_US">MVTec Standard Procedures</library>
<predecessor>
<item>set_sheet_of_light_param</item>
<item>calibrate_sheet_of_light</item>
<item>set_profile_sheet_of_light</item>
<item>get_sheet_of_light_result_object_model_3d</item>
</predecessor>
<short lang="en_US">Generate 3D object models which visualize a sheet of light setup.</short>
<successor>
<item>visualize_object_model_3d</item>
<item>dev_inspect_ctrl</item>
</successor>
<parameters>
<parameter id="CameraSize">
<default_type>integer</default_type>
<description lang="en_US">Size of represented cameras.</description>
<sem_type>number</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
<parameter id="ConeLength">
<default_type>integer</default_type>
<description lang="en_US">Depth of represented fields of view. </description>
<sem_type>number</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
<parameter id="OM3DCamera">
<default_type>integer</default_type>
<description lang="en_US">Handles of the 3D object models representing the camera.</description>
<mixed_type>false</mixed_type>
<sem_type>object_model_3d</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="OM3DCone">
<default_type>integer</default_type>
<description lang="en_US">Depth of represented fields of view. </description>
<mixed_type>false</mixed_type>
<sem_type>object_model_3d</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="OM3DLightPlane">
<default_type>integer</default_type>
<description lang="en_US">Handle of the 3D object model representing the light plane.</description>
<mixed_type>false</mixed_type>
<sem_type>object_model_3d</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="OM3DMovement">
<default_type>integer</default_type>
<description lang="en_US">Handles of the 3D object models representing the movement.</description>
<mixed_type>false</mixed_type>
<sem_type>object_model_3d</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="PlaneAndMovementSize">
<default_type>integer</default_type>
<description lang="en_US">Size of represented light plane and movement.</description>
<sem_type>number</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
<parameter id="SheetOfLightModelID">
<default_type>integer</default_type>
<description lang="en_US">Handle of the sheet of light model.</description>
<mixed_type>false</mixed_type>
<sem_type>sheet_of_light_model</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
</parameters>
</docu>
</procedure>
<procedure name="gen_tiled_classification_image_result" access="local">
<interface>
<oo>
<par name="TiledImageRow" base_type="iconic" dimension="0"/>
</oo>
<ic>
<par name="DLSamples" base_type="ctrl" dimension="0"/>
<par name="SpacingCol" base_type="ctrl" dimension="0"/>
<par name="PredictionsCorrect" base_type="ctrl" dimension="0"/>
<par name="ResClasses" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="TextImageRows" base_type="ctrl" dimension="0"/>
<par name="TextImageColumns" base_type="ctrl" dimension="0"/>
<par name="TextImageWidth" base_type="ctrl" dimension="0"/>
<par name="TextImageHeight" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c>* </c>
<c>* This procedure generates a tiled image for the classified DLSamples.</c>
<c>* In the process it adds indications if the prediction was</c>
<c>* correct (green frame and checkmark) or wrong (red frame and cross).</c>
<c>* </c>
<l>NumSamples := |DLSamples|</l>
<c>* </c>
<c>* Get number of rows/columns of tiled image.</c>
<l>if (NumSamples &gt; 9)</l>
<l>    throw ('More than 9 images cannot be shown in the training progress.')</l>
<l>endif</l>
<l>if (NumSamples == 1 or NumSamples == 4 or NumSamples == 9)</l>
<l>    NumRows := int(sqrt(NumSamples))</l>
<l>    NumColumns := NumRows</l>
<l>else</l>
<l>    NumRows := min2(NumSamples,3)</l>
<l>    NumColumns := (NumSamples - 1) / NumRows + 1</l>
<l>endif</l>
<c>* </c>
<c>* Get images and minimal/maximal gray values.</c>
<l>gen_empty_obj (GTImagesRaw)</l>
<l>for Index := 0 to NumSamples - 1 by 1</l>
<l>    get_dict_object (GTImage, DLSamples[Index], 'image')</l>
<l>    concat_obj (GTImagesRaw, GTImage, GTImagesRaw)</l>
<l>    count_channels (GTImage, NumChannels)</l>
<l>    GrayMin := []</l>
<l>    GrayMax := []</l>
<l>    for IndexChannel := 0 to NumChannels - 1 by 1</l>
<l>        access_channel (GTImage, Channel, IndexChannel + 1)</l>
<l>        min_max_gray (Channel, Channel, 0, GrayMinTmp, GrayMaxTmp, _)</l>
<l>        GrayMin := [GrayMin,GrayMinTmp]</l>
<l>        GrayMax := [GrayMax,GrayMaxTmp]</l>
<l>    endfor</l>
<l>    GrayMins.at(Index) := GrayMin</l>
<l>    GrayMaxs.at(Index) := GrayMax</l>
<l>endfor</l>
<c>* </c>
<c>* Create a checkmark, a cross, and a frame.</c>
<c>* Note: It is assumed that all images have the same size.</c>
<c>* Set parameters for displaying crosses/hooks at the bottom-right corner.</c>
<l>get_image_size (GTImage, ImageWidth, ImageHeight)</l>
<l>Length1 := min2(ImageWidth,ImageHeight) / 5</l>
<l>Length2 := min2(ImageWidth,ImageHeight) / 25</l>
<l>hom_mat2d_identity (HomMat2DIdentity)</l>
<l>hom_mat2d_rotate (HomMat2DIdentity, rad(45), 0, 0, HomMat2DRotate)</l>
<l>hom_mat2d_translate (HomMat2DRotate, ImageHeight - 0.75 * Length1, ImageWidth - 0.75 * Length1, HomMat2DCompose)</l>
<c>* Generate checkmark.</c>
<l>gen_contour_polygon_xld (RegionContourCheck, [-Length2,Length2,Length2,0,0,-Length2,-Length2], [0,0,Length1,Length1,Length2,Length2,0] - Length1 / 2)</l>
<l>affine_trans_contour_xld (RegionContourCheck, RegionContourCheck, HomMat2DCompose)</l>
<c>* Generate cross.</c>
<l>gen_rectangle2_contour_xld (Rectangle1, 0, 0, 0, Length1 / 2, Length2 / 2)</l>
<l>gen_rectangle2_contour_xld (Rectangle2, 0, 0, 0, Length2 / 2, Length1 / 2)</l>
<l>concat_obj (Rectangle1, Rectangle2, RegionContourCross)</l>
<l>affine_trans_contour_xld (RegionContourCross, RegionContourCross, HomMat2DCompose)</l>
<c>* Generate the color frame.</c>
<l>FrameSize := 7</l>
<l>gen_contour_polygon_xld (TopContour, [0,0,FrameSize,FrameSize,0] - 0.5, [0,ImageWidth,ImageWidth,0,0] - 0.5)</l>
<l>gen_contour_polygon_xld (LeftContour, [0,0,ImageHeight,ImageHeight,0] - 0.5, [0,FrameSize,FrameSize,0,0] - 0.5)</l>
<l>gen_contour_polygon_xld (RightContour, [0,ImageHeight,ImageHeight,0,0] - 0.5, [ImageWidth,ImageWidth,ImageWidth - FrameSize,ImageWidth - FrameSize,ImageWidth] - 0.5)</l>
<l>gen_contour_polygon_xld (BottomContour, [ImageHeight,ImageHeight - FrameSize,ImageHeight - FrameSize,ImageHeight,ImageHeight] - 0.5, [0,0,ImageWidth,ImageWidth,0] - 0.5)</l>
<l>concat_obj (TopContour, RightContour, Frame)</l>
<l>concat_obj (Frame, BottomContour, Frame)</l>
<l>concat_obj (Frame, LeftContour, Frame)</l>
<c>* </c>
<c>* Greate black image to print in text later.</c>
<l>TextImageHeight := 40</l>
<l>TextImageWidth := ImageWidth</l>
<l>gen_image_const (TextImageOneChannel, 'real', TextImageWidth, TextImageHeight)</l>
<l>concat_obj (TextImageOneChannel, TextImageOneChannel, TextImageOneChannels)</l>
<l>concat_obj (TextImageOneChannels, TextImageOneChannel, TextImageOneChannels)</l>
<l>channels_to_image (TextImageOneChannels, TextImage)</l>
<c>* </c>
<c>* Greate black image to separate columns.</c>
<l>SeparateImageHeight := NumRows * (ImageHeight + TextImageHeight)</l>
<l>SeparateImageWidth := 4</l>
<l>gen_image_const (SeparateImageOneChannel, 'real', SeparateImageWidth, SeparateImageHeight)</l>
<l>concat_obj (SeparateImageOneChannel, SeparateImageOneChannel, SeparateImageOneChannels)</l>
<l>concat_obj (SeparateImageOneChannels, SeparateImageOneChannel, SeparateImageOneChannels)</l>
<l>channels_to_image (SeparateImageOneChannels, SeparateImage)</l>
<c>* </c>
<c>* Adapt images with frame and checkmark/cross.</c>
<l>gen_empty_obj (GTImages)</l>
<l>for Index := 0 to NumSamples - 1 by 1</l>
<c>    * Scale iamges to [0,1] to have identical color ranges.</c>
<l>    select_obj (GTImagesRaw, GTImage, Index + 1)</l>
<l>    count_channels (GTImage, NumChannels)</l>
<l>    gen_empty_obj (GTImageChannelsScaled)</l>
<l>    for IndexChannel := 0 to NumChannels - 1 by 1</l>
<l>        access_channel (GTImage, GTImageChannel, IndexChannel + 1)</l>
<l>        ScaleMax := GrayMaxs.at(Index)[IndexChannel]</l>
<l>        ScaleMin := GrayMins.at(Index)[IndexChannel]</l>
<l>        if (ScaleMax - ScaleMin &gt; 1e-5)</l>
<l>            scale_image (GTImageChannel, GTImageChannelScaled, 1.0 / (ScaleMax - ScaleMin), -ScaleMin / (ScaleMax - ScaleMin))</l>
<l>        else</l>
<l>            scale_image (GTImageChannel, GTImageChannelScaled, 0, 0)</l>
<l>        endif</l>
<l>        concat_obj (GTImageChannelsScaled, GTImageChannelScaled, GTImageChannelsScaled)</l>
<l>    endfor</l>
<l>    channels_to_image (GTImageChannelsScaled, GTImage)</l>
<c>    * The frame has 3 channels, hence ensure that GTImage</c>
<c>    * has equal number of channels for display.</c>
<l>    if (NumChannels != 3)</l>
<c>        * Just take the first channel and use this to generate</c>
<c>        * an image with 3 channels for visualization.</c>
<l>        access_channel (GTImage, GTImageR, 1)</l>
<l>        copy_image (GTImageR, GTImageG)</l>
<l>        copy_image (GTImageR, GTImageB)</l>
<l>        compose3 (GTImageR, GTImageG, GTImageB, GTImage)</l>
<l>    endif</l>
<c>    * </c>
<l>    if (PredictionsCorrect[Index] == true)</l>
<c>        * If the actual image is predicted correctly, plot a green frame and</c>
<c>        * a green checkmark.</c>
<l>        RegionContour := RegionContourCheck</l>
<l>        Color := [0,1,0]</l>
<l>    else</l>
<c>        * Same as for the correct predictions, plot red frame and</c>
<c>        * a red cross for uncorrect predictions.</c>
<l>        RegionContour := RegionContourCross</l>
<l>        Color := [1,0,0]</l>
<l>    endif</l>
<l>    dev_set_draw ('margin')</l>
<l>    paint_xld (Frame, GTImage, GTImage, Color)</l>
<l>    paint_xld (RegionContour, GTImage, GTImage, Color)</l>
<l>    concat_obj (GTImages, GTImage, GTImages)</l>
<c>    * Add TextImage.</c>
<l>    concat_obj (GTImages, TextImage, GTImages)</l>
<l>endfor</l>
<c>* </c>
<c>* Tile the images. The maximum is 3x3=9 samples.</c>
<c>* Set row/column positions of upper-left corners of images and text images.</c>
<l>count_obj (GTImages, Number)</l>
<l>tuple_gen_const (Number, 0, TiledRows)</l>
<l>tuple_gen_const (Number, 0, TiledColumns)</l>
<l>tuple_gen_const (Number / 2, 0, TextImageRows)</l>
<l>tuple_gen_const (Number / 2, 0, TextImageColumns)</l>
<l>for Index := 0 to Number / 2 - 1 by 1</l>
<l>    TiledRows[2 * Index] := (TextImageHeight + ImageHeight) * (Index % NumRows)</l>
<l>    TextImageRows[Index] := (TextImageHeight + ImageHeight) * (Index % NumRows) + ImageHeight</l>
<l>    TiledRows[2 * Index + 1] := TextImageRows[Index]</l>
<l>    TiledColumns[2 * Index] := (ImageWidth + SeparateImageWidth) * (Index / NumRows)</l>
<l>    TextImageColumns[Index] := TiledColumns[2 * Index]</l>
<l>    TiledColumns[2 * Index + 1] := TextImageColumns[Index]</l>
<l>endfor</l>
<c>* Add images and row/column positions of upper-left corners of SeparateImages.</c>
<l>for Index := 0 to NumColumns - 2 by 1</l>
<l>    concat_obj (GTImages, SeparateImage, GTImages)</l>
<l>    TiledRows[|TiledRows|] := 0</l>
<l>    TiledColumns[|TiledColumns|] := (Index + 1) * ImageWidth</l>
<l>endfor</l>
<c>* </c>
<l>TiledHeights := NumRows * (TextImageHeight + ImageHeight)</l>
<l>TiledWidths := NumColumns * ImageWidth + (NumColumns - 1) * SeparateImageWidth</l>
<l>tuple_gen_const (|TiledRows|, -1, MinusOnes)</l>
<l>tile_images_offset (GTImages, TiledImageRow, TiledRows, TiledColumns, MinusOnes, MinusOnes, MinusOnes, MinusOnes, TiledWidths, TiledHeights)</l>
<c>* </c>
<l>return ()</l>
</body>
<docu id="gen_tiled_classification_image_result">
<chapters lang="en_US">
<item>Deep Learning</item>
<item>Classification</item>
</chapters>
<library lang="en_US">MVTec Standard Procedures</library>
<short lang="en_US">Generate a tiled image for the classified DLSamples and add indications whether the predictions are true or not.</short>
<parameters>
<parameter id="DLSamples"/>
<parameter id="PredictionsCorrect"/>
<parameter id="ResClasses"/>
<parameter id="SpacingCol"/>
<parameter id="TextImageColumns"/>
<parameter id="TextImageHeight"/>
<parameter id="TextImageRows"/>
<parameter id="TextImageWidth"/>
<parameter id="TiledImageRow"/>
</parameters>
</docu>
</procedure>
<procedure name="gen_tiled_segmentation_image" access="local">
<interface>
<oo>
<par name="TiledImageRow" base_type="iconic" dimension="0"/>
</oo>
<ic>
<par name="DLSamples" base_type="ctrl" dimension="0"/>
<par name="SpacingCol" base_type="ctrl" dimension="0"/>
<par name="Width" base_type="ctrl" dimension="0"/>
<par name="Height" base_type="ctrl" dimension="0"/>
</ic>
</interface>
<body>
<c>* </c>
<c>* This procedure tiles the segmentation images of given samples in a row.</c>
<c>* </c>
<l>tuple_gen_const (|Width|, -1, Crop)</l>
<l>tuple_gen_const (|Width|, 0, OffsetRow)</l>
<l>NumSamples := |DLSamples|</l>
<l>gen_empty_obj (GTImages)</l>
<l>for Index := 0 to NumSamples - 1 by 1</l>
<l>    get_dict_object (GTImage, DLSamples[Index], 'segmentation_image')</l>
<l>    concat_obj (GTImages, GTImage, GTImages)</l>
<l>endfor</l>
<c>* </c>
<l>tile_images_offset (GTImages, TiledImageRow, OffsetRow, [0,cumul(Width + SpacingCol)][0:|Width| - 1], Crop, Crop, Crop, Crop, cumul(Width + SpacingCol)[|Width| - 1] - SpacingCol, max(Height))</l>
<l>return ()</l>
</body>
<docu id="gen_tiled_segmentation_image">
<chapters lang="de_DE">
<item>Deep Learning</item>
<item>Semantische Segmentierung</item>
</chapters>
<chapters lang="en_US">
<item>Deep Learning</item>
<item>Semantic Segmentation</item>
</chapters>
<library lang="en_US">MVTec Standard Procedures</library>
<short lang="en_US">Generate a tiled image for segmentation DLSamples.
</short>
<parameters>
<parameter id="DLSamples"/>
<parameter id="Height"/>
<parameter id="SpacingCol"/>
<parameter id="TiledImageRow"/>
<parameter id="Width"/>
</parameters>
</docu>
</procedure>
<procedure name="gen_tool_to_touching_point_object_model_3d">
<interface>
<ic>
<par name="ToolInBasePosesTouchingPoint" base_type="ctrl" dimension="1"/>
<par name="RobotTouchingPointInToolCoordinates" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="OM3DToolTouchingPoint" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c>* </c>
<l>gen_robot_tool_and_base_object_model_3d (0.0025, 0.05, OM3DToolOrigin, OM3DBase)</l>
<l>gen_object_model_3d_from_points ([0,RobotTouchingPointInToolCoordinates[0]], [0,RobotTouchingPointInToolCoordinates[1]], [0,RobotTouchingPointInToolCoordinates[2]], OM3DToolTouchingPoint)</l>
<l>set_object_model_3d_attrib_mod (OM3DToolTouchingPoint, 'lines', [], [2,0,1])</l>
<l>OM3DToolTouchingPointTmp := [OM3DToolOrigin,OM3DToolTouchingPoint]</l>
<c>* </c>
<l>OM3DToolTouchingPoint := []</l>
<l>for Index := 0 to ToolInBasePosesTouchingPoint.length() - 1 by 1</l>
<l>    rigid_trans_object_model_3d (OM3DToolTouchingPointTmp, ToolInBasePosesTouchingPoint.at(Index), OM3DRigidTrans)</l>
<l>    OM3DToolTouchingPoint := [OM3DToolTouchingPoint,OM3DRigidTrans]</l>
<l>endfor</l>
<l>return ()</l>
</body>
<docu id="gen_tool_to_touching_point_object_model_3d">
<chapters lang="de_DE">
<item>3D-Objektmodell</item>
<item>Generierung</item>
</chapters>
<chapters lang="en_US">
<item>3D Object Model</item>
<item>Creation</item>
</chapters>
<library lang="en_US">MVTec Standard Procedures</library>
<parameters>
<parameter id="OM3DToolTouchingPoint">
<default_type>integer</default_type>
<description lang="en_US">3D model of the robot's tool in its current position.</description>
<mixed_type>false</mixed_type>
<multivalue>true</multivalue>
<sem_type>object_model_3d</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="RobotTouchingPointInToolCoordinates">
<description lang="en_US">A point on the gripper that has been used to approach points in the measurement plane of the robot.</description>
<sem_type>coordinates</sem_type>
</parameter>
<parameter id="ToolInBasePosesTouchingPoint">
<default_type>real</default_type>
<description lang="en_US">Robot positions.</description>
<multivalue>false</multivalue>
<sem_type>pose</sem_type>
<type_list>
<item>real</item>
</type_list>
</parameter>
</parameters>
</docu>
</procedure>
<procedure name="get_aggregated_models_diameter" access="local">
<interface>
<ic>
<par name="ObjectModel3DBox" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="ModelDiameterAggregated" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<l>get_object_model_3d_params (ObjectModel3DBox, 'diameter', ModelDiameter)</l>
<l>tuple_mean (ModelDiameter, ModelDiameterAggregated)</l>
<l>return ()</l>
</body>
<docu id="get_aggregated_models_diameter">
<parameters>
<parameter id="ModelDiameterAggregated"/>
<parameter id="ObjectModel3DBox">
<default_type>handle</default_type>
<description lang="en_US">3D object models of the found boxes.</description>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>object_model_3d</sem_type>
<type_list>
<item>handle</item>
</type_list>
</parameter>
</parameters>
</docu>
</procedure>
<procedure name="get_anomaly_ground_truth_label" access="local">
<interface>
<ic>
<par name="SampleKeys" base_type="ctrl" dimension="0"/>
<par name="DLSample" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="AnomalyLabelGroundTruth" base_type="ctrl" dimension="0"/>
<par name="AnomalyLabelIDGroundTruth" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c>* </c>
<c>* This procedure returns the anomaly ground truth label.</c>
<c>* </c>
<l>if (find(SampleKeys,'anomaly_label') != -1)</l>
<l>    get_dict_tuple (DLSample, 'anomaly_label', AnomalyLabelGroundTruth)</l>
<l>else</l>
<l>    throw ('Ground truth class label cannot be found in DLSample.')</l>
<l>endif</l>
<l>if (find(SampleKeys,'anomaly_label_id') != -1)</l>
<l>    get_dict_tuple (DLSample, 'anomaly_label_id', AnomalyLabelIDGroundTruth)</l>
<l>else</l>
<l>    throw ('Ground truth class label id cannot be found in DLSample.')</l>
<l>endif</l>
<c>* </c>
<l>return ()</l>
</body>
<docu id="get_anomaly_ground_truth_label">
<chapters lang="en_US">
<item>Deep Learning</item>
<item>Anomaly Detection</item>
</chapters>
<library lang="en_US">MVTec Standard Procedures</library>
<short lang="en_US">Get the ground truth anomaly label and label ID.</short>
<parameters>
<parameter id="AnomalyLabelGroundTruth"/>
<parameter id="AnomalyLabelIDGroundTruth"/>
<parameter id="DLSample"/>
<parameter id="SampleKeys"/>
</parameters>
</docu>
</procedure>
<procedure name="get_anomaly_result" access="local">
<interface>
<oo>
<par name="AnomalyImage" base_type="iconic" dimension="0"/>
</oo>
<ic>
<par name="ResultKeys" base_type="ctrl" dimension="0"/>
<par name="DLResult" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="AnomalyScore" base_type="ctrl" dimension="0"/>
<par name="AnomalyClassID" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c>* </c>
<c>* This procedure returns the anomaly image of DLResult.</c>
<c>* </c>
<l>if (find(ResultKeys,'anomaly_image') != -1)</l>
<l>    get_dict_param (DLResult, 'key_exists', 'anomaly_image', AnomalyImageExists)</l>
<l>    if (AnomalyImageExists)</l>
<l>        get_dict_object (AnomalyImage, DLResult, 'anomaly_image')</l>
<l>    else</l>
<l>        throw ('Result anomaly image could not be found in DLResult.')</l>
<l>    endif</l>
<l>else</l>
<l>    throw ('Result anomaly image could not be found in DLResult.')</l>
<l>endif</l>
<c>* </c>
<c>* This procedure returns the anomaly score of DLResult.</c>
<c>* </c>
<l>if (find(ResultKeys,'anomaly_score') != -1)</l>
<l>    get_dict_tuple (DLResult, 'anomaly_score', AnomalyScore)</l>
<l>else</l>
<l>    throw ('Result anomaly score could not be found in DLResult.')</l>
<l>endif</l>
<c>* </c>
<c>* This procedure returns the anomaly class id of DLResult.</c>
<c>* </c>
<l>if (find(ResultKeys,'anomaly_class_id') != -1)</l>
<l>    get_dict_tuple (DLResult, 'anomaly_class_id', AnomalyClassID)</l>
<l>else</l>
<l>    throw ('Result anomaly class ID could not be found in DLResult.')</l>
<l>endif</l>
<l>return ()</l>
</body>
<docu id="get_anomaly_result">
<chapters lang="en_US">
<item>Deep Learning</item>
<item>Anomaly Detection</item>
</chapters>
<library lang="en_US">MVTec Standard Procedures</library>
<short lang="en_US">Get the anomaly image out of DLResult.</short>
<parameters>
<parameter id="AnomalyClassID">
<sem_type>integer</sem_type>
</parameter>
<parameter id="AnomalyImage">
<multivalue>false</multivalue>
<sem_type>object</sem_type>
</parameter>
<parameter id="AnomalyScore">
<sem_type>integer</sem_type>
</parameter>
<parameter id="DLResult">
<default_type>integer</default_type>
<mixed_type>false</mixed_type>
<sem_type>dict</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="ResultKeys">
<sem_type>string</sem_type>
</parameter>
</parameters>
</docu>
</procedure>
<procedure name="get_bounding_box_points_from_min_max" access="local">
<interface>
<ic>
<par name="BoundingBox" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="PX" base_type="ctrl" dimension="0"/>
<par name="PY" base_type="ctrl" dimension="0"/>
<par name="PZ" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<l>Points := {[]}</l>
<l>Points.at(0) := [BoundingBox[0],BoundingBox[1],BoundingBox[2]]</l>
<l>Points.at(1) := [BoundingBox[3],BoundingBox[1],BoundingBox[2]]</l>
<l>Points.at(2) := [BoundingBox[3],BoundingBox[4],BoundingBox[2]]</l>
<l>Points.at(3) := [BoundingBox[0],BoundingBox[4],BoundingBox[2]]</l>
<l>Points.at(4) := [BoundingBox[0],BoundingBox[1],BoundingBox[5]]</l>
<l>Points.at(5) := [BoundingBox[3],BoundingBox[1],BoundingBox[5]]</l>
<l>Points.at(6) := [BoundingBox[3],BoundingBox[4],BoundingBox[5]]</l>
<l>Points.at(7) := [BoundingBox[0],BoundingBox[4],BoundingBox[5]]</l>
<l>PX := []</l>
<l>PY := []</l>
<l>PZ := []</l>
<l>for Index := 0 to 7 by 1</l>
<l>    PX := [PX,Points.at(Index)[0]]</l>
<l>    PY := [PY,Points.at(Index)[1]]</l>
<l>    PZ := [PZ,Points.at(Index)[2]]</l>
<l>endfor</l>
<l>return ()</l>
</body>
<docu id="get_bounding_box_points_from_min_max">
<chapters lang="de_DE">
<item>3D-Objektmodell</item>
<item>Merkmale</item>
</chapters>
<chapters lang="en_US">
<item>3D Object Model</item>
<item>Features</item>
</chapters>
<library lang="en_US">MVTec Standard Procedures</library>
<parameters>
<parameter id="BoundingBox">
<default_type>real</default_type>
<multivalue>true</multivalue>
<sem_type>real</sem_type>
<type_list>
<item>real</item>
</type_list>
</parameter>
<parameter id="PX">
<default_type>real</default_type>
<multivalue>true</multivalue>
<sem_type>real</sem_type>
<type_list>
<item>real</item>
</type_list>
</parameter>
<parameter id="PY">
<default_type>real</default_type>
<multivalue>true</multivalue>
<sem_type>real</sem_type>
<type_list>
<item>real</item>
</type_list>
</parameter>
<parameter id="PZ">
<default_type>real</default_type>
<multivalue>true</multivalue>
<sem_type>real</sem_type>
<type_list>
<item>real</item>
</type_list>
</parameter>
</parameters>
</docu>
</procedure>
<procedure name="get_cam_par_data">
<interface>
<ic>
<par name="CameraParam" base_type="ctrl" dimension="0"/>
<par name="ParamName" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="ParamValue" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c>* get_cam_par_data returns in ParamValue the value of the</c>
<c>* parameter that is given in ParamName from the tuple of</c>
<c>* camera parameters that is given in CameraParam.</c>
<c>* </c>
<c>* Get the parameter names that correspond to the</c>
<c>* elements in the input camera parameter tuple.</c>
<l>get_cam_par_names (CameraParam, CameraType, CameraParamNames)</l>
<c>* </c>
<c>* Find the index of the requested camera data and return</c>
<c>* the corresponding value.</c>
<l>ParamValue := []</l>
<l>for Index := 0 to |ParamName| - 1 by 1</l>
<l>    ParamNameInd := ParamName[Index]</l>
<l>    if (ParamNameInd == 'camera_type')</l>
<l>        ParamValue := [ParamValue,CameraType]</l>
<l>        continue</l>
<l>    endif</l>
<l>    I := find(CameraParamNames,ParamNameInd)</l>
<l>    if (I != -1)</l>
<l>        ParamValue := [ParamValue,CameraParam[I]]</l>
<l>    else</l>
<l>        throw ('Unknown camera parameter ' + ParamNameInd)</l>
<l>    endif</l>
<l>endfor</l>
<l>return ()</l>
</body>
<docu id="get_cam_par_data">
<abstract lang="en_US">get_cam_par_data returns the value ParamValue of the camera parameter ParamName from the camera parameter tuple CameraParam. The following parameter names can be queried: 'camera_type', 'focus', 'magnification', 'kappa', 'k1', 'k2', 'k3', 'p1', 'p2', 'image_plane_dist', 'tilt', 'rot', 'sx' ,'sy', 'cx', 'cy', 'image_width', 'image_height', 'vx', 'vy', 'vz'. If the camera type does not support the requested value, an exception is raised.</abstract>
<chapters lang="de_DE">
<item>Kalibrierung</item>
<item>Kameraparameter</item>
</chapters>
<chapters lang="en_US">
<item>Calibration</item>
<item>Camera Parameters</item>
</chapters>
<example lang="en_US">read_cam_par ('campar.dat', CameraParam) 
get_cam_par_data (CameraParam, 'image_width', ImageWidth)
get_cam_par_data (CameraParam, 'image_height', ImageHeight)
gen_image_const (Image, 'byte', ImageWidth, ImageHeight)</example>
<keywords lang="de_DE">
<item>Kameraparameter kalibrieren</item>
<item>Kamera-Kalibrierparameter erhalten</item>
<item>Kameramodell</item>
<item>interne Kameraparameter</item>
<item>interne Kameraparameter kalibrieren</item>
<item>kalibrierte interne Kameraparameter erhalten</item>
</keywords>
<keywords lang="en_US">
<item>camera calibration parameters</item>
<item>camera calibration result</item>
<item>calibrate camera parameters</item>
<item>calibrate internal camera parameters</item>
<item>calibrated internal camera parameters</item>
</keywords>
<library lang="en_US">MVTec Standard Procedures</library>
<predecessor>
<item>read_cam_par</item>
<item>deserialize_cam_par</item>
<item>get_calib_data</item>
<item>get_deformable_model_params</item>
<item>get_sheet_of_light_param</item>
<item>get_shape_model_3d_param</item>
</predecessor>
<see_also>
<item>calibrate_cameras</item>
<item>set_cam_par_data</item>
<item>get_cam_par_names</item>
<item>gen_cam_par_area_scan_division</item>
<item>gen_cam_par_area_scan_polynomial</item>
<item>gen_cam_par_area_scan_tilt_division</item>
<item>gen_cam_par_area_scan_tilt_polynomial</item>
<item>gen_cam_par_area_scan_telecentric_division</item>
<item>gen_cam_par_area_scan_telecentric_polynomial</item>
<item>gen_cam_par_area_scan_tilt_bilateral_telecentric_division</item>
<item>gen_cam_par_area_scan_tilt_bilateral_telecentric_polynomial</item>
<item>gen_cam_par_area_scan_tilt_object_side_telecentric_division</item>
<item>gen_cam_par_area_scan_tilt_object_side_telecentric_polynomial</item>
<item>gen_cam_par_area_scan_hypercentric_division</item>
<item>gen_cam_par_area_scan_hypercentric_polynomial</item>
<item>gen_cam_par_line_scan_division</item>
<item>gen_cam_par_line_scan_polynomial</item>
<item>gen_cam_par_line_scan_telecentric_division</item>
<item>gen_cam_par_line_scan_telecentric_polynomial</item>
</see_also>
<short lang="en_US">Get the value of a specified camera parameter from the camera parameter tuple.</short>
<parameters>
<parameter id="CameraParam">
<default_type>real</default_type>
<description lang="en_US">Input camera parameter tuple.</description>
<mixed_type>optional</mixed_type>
<sem_type>campar</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
<item>string</item>
</type_list>
</parameter>
<parameter id="ParamName">
<default_type>string</default_type>
<default_value>'image_width'</default_value>
<description lang="en_US">Name of the camera parameter for that the value should be returned.</description>
<mixed_type>false</mixed_type>
<multivalue>optional</multivalue>
<sem_type>string</sem_type>
<type_list>
<item>string</item>
</type_list>
<value_list>
<item>'camera_type'</item>
<item>'focus'</item>
<item>'magnification'</item>
<item>'kappa'</item>
<item>'k1'</item>
<item>'k2'</item>
<item>'k3'</item>
<item>'p1'</item>
<item>'p2'</item>
<item>'image_plane_dist'</item>
<item>'tilt'</item>
<item>'rot'</item>
<item>'sx'</item>
<item>'sy'</item>
<item>'cx'</item>
<item>'cy'</item>
<item>'image_width'</item>
<item>'image_height'</item>
<item>'vx'</item>
<item>'vy'</item>
<item>'vz'</item>
</value_list>
</parameter>
<parameter id="ParamValue">
<default_type>real</default_type>
<description lang="en_US">Value of the requested camera parameter.</description>
<mixed_type>optional</mixed_type>
<multivalue>optional</multivalue>
<sem_type>real</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
<item>string</item>
</type_list>
</parameter>
</parameters>
</docu>
</procedure>
<procedure name="get_cam_par_names">
<interface>
<ic>
<par name="CameraParam" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="CameraType" base_type="ctrl" dimension="0"/>
<par name="ParamNames" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c>* get_cam_par_names returns for each element in the camera</c>
<c>* parameter tuple that is passed in CameraParam the name</c>
<c>* of the respective camera parameter. The parameter names</c>
<c>* are returned in ParamNames. Additionally, the camera</c>
<c>* type is returned in CameraType. Alternatively, instead of</c>
<c>* the camera parameters, the camera type can be passed in</c>
<c>* CameraParam in form of one of the following strings:</c>
<c>*   - 'area_scan_division'</c>
<c>*   - 'area_scan_polynomial'</c>
<c>*   - 'area_scan_tilt_division'</c>
<c>*   - 'area_scan_tilt_polynomial'</c>
<c>*   - 'area_scan_telecentric_division'</c>
<c>*   - 'area_scan_telecentric_polynomial'</c>
<c>*   - 'area_scan_tilt_bilateral_telecentric_division'</c>
<c>*   - 'area_scan_tilt_bilateral_telecentric_polynomial'</c>
<c>*   - 'area_scan_tilt_object_side_telecentric_division'</c>
<c>*   - 'area_scan_tilt_object_side_telecentric_polynomial'</c>
<c>*   - 'area_scan_hypercentric_division'</c>
<c>*   - 'area_scan_hypercentric_polynomial'</c>
<c>*   - 'line_scan_division'</c>
<c>*   - 'line_scan_polynomial'</c>
<c>*   - 'line_scan_telecentric_division'</c>
<c>*   - 'line_scan_telecentric_polynomial'</c>
<c>* </c>
<l>CameraParamAreaScanDivision := ['focus','kappa','sx','sy','cx','cy','image_width','image_height']</l>
<l>CameraParamAreaScanPolynomial := ['focus','k1','k2','k3','p1','p2','sx','sy','cx','cy','image_width','image_height']</l>
<l>CameraParamAreaScanTelecentricDivision := ['magnification','kappa','sx','sy','cx','cy','image_width','image_height']</l>
<l>CameraParamAreaScanTelecentricPolynomial := ['magnification','k1','k2','k3','p1','p2','sx','sy','cx','cy','image_width','image_height']</l>
<l>CameraParamAreaScanTiltDivision := ['focus','kappa','image_plane_dist','tilt','rot','sx','sy','cx','cy','image_width','image_height']</l>
<l>CameraParamAreaScanTiltPolynomial := ['focus','k1','k2','k3','p1','p2','image_plane_dist','tilt','rot','sx','sy','cx','cy','image_width','image_height']</l>
<l>CameraParamAreaScanImageSideTelecentricTiltDivision := ['focus','kappa','tilt','rot','sx','sy','cx','cy','image_width','image_height']</l>
<l>CameraParamAreaScanImageSideTelecentricTiltPolynomial := ['focus','k1','k2','k3','p1','p2','tilt','rot','sx','sy','cx','cy','image_width','image_height']</l>
<l>CameraParamAreaScanBilateralTelecentricTiltDivision := ['magnification','kappa','tilt','rot','sx','sy','cx','cy','image_width','image_height']</l>
<l>CameraParamAreaScanBilateralTelecentricTiltPolynomial := ['magnification','k1','k2','k3','p1','p2','tilt','rot','sx','sy','cx','cy','image_width','image_height']</l>
<l>CameraParamAreaScanObjectSideTelecentricTiltDivision := ['magnification','kappa','image_plane_dist','tilt','rot','sx','sy','cx','cy','image_width','image_height']</l>
<l>CameraParamAreaScanObjectSideTelecentricTiltPolynomial := ['magnification','k1','k2','k3','p1','p2','image_plane_dist','tilt','rot','sx','sy','cx','cy','image_width','image_height']</l>
<l>CameraParamAreaScanHypercentricDivision := ['focus','kappa','sx','sy','cx','cy','image_width','image_height']</l>
<l>CameraParamAreaScanHypercentricPolynomial := ['focus','k1','k2','k3','p1','p2','sx','sy','cx','cy','image_width','image_height']</l>
<l>CameraParamLinesScanDivision := ['focus','kappa','sx','sy','cx','cy','image_width','image_height','vx','vy','vz']</l>
<l>CameraParamLinesScanPolynomial := ['focus','k1','k2','k3','p1','p2','sx','sy','cx','cy','image_width','image_height','vx','vy','vz']</l>
<l>CameraParamLinesScanTelecentricDivision := ['magnification','kappa','sx','sy','cx','cy','image_width','image_height','vx','vy','vz']</l>
<l>CameraParamLinesScanTelecentricPolynomial := ['magnification','k1','k2','k3','p1','p2','sx','sy','cx','cy','image_width','image_height','vx','vy','vz']</l>
<c>* Legacy parameter names</c>
<l>CameraParamAreaScanTiltDivisionLegacy := ['focus','kappa','tilt','rot','sx','sy','cx','cy','image_width','image_height']</l>
<l>CameraParamAreaScanTiltPolynomialLegacy := ['focus','k1','k2','k3','p1','p2','tilt','rot','sx','sy','cx','cy','image_width','image_height']</l>
<l>CameraParamAreaScanTelecentricDivisionLegacy := ['focus','kappa','sx','sy','cx','cy','image_width','image_height']</l>
<l>CameraParamAreaScanTelecentricPolynomialLegacy := ['focus','k1','k2','k3','p1','p2','sx','sy','cx','cy','image_width','image_height']</l>
<l>CameraParamAreaScanBilateralTelecentricTiltDivisionLegacy := ['focus','kappa','tilt','rot','sx','sy','cx','cy','image_width','image_height']</l>
<l>CameraParamAreaScanBilateralTelecentricTiltPolynomialLegacy := ['focus','k1','k2','k3','p1','p2','tilt','rot','sx','sy','cx','cy','image_width','image_height']</l>
<c>* </c>
<c>* If the camera type is passed in CameraParam</c>
<l>if (|CameraParam| == 1 and is_string(CameraParam[0]))</l>
<l>    CameraType := CameraParam[0]</l>
<l>    if (CameraType == 'area_scan_division')</l>
<l>        ParamNames := ['camera_type',CameraParamAreaScanDivision]</l>
<l>    elseif (CameraType == 'area_scan_polynomial')</l>
<l>        ParamNames := ['camera_type',CameraParamAreaScanPolynomial]</l>
<l>    elseif (CameraType == 'area_scan_telecentric_division')</l>
<l>        ParamNames := ['camera_type',CameraParamAreaScanTelecentricDivision]</l>
<l>    elseif (CameraType == 'area_scan_telecentric_polynomial')</l>
<l>        ParamNames := ['camera_type',CameraParamAreaScanTelecentricPolynomial]</l>
<l>    elseif (CameraType == 'area_scan_tilt_division')</l>
<l>        ParamNames := ['camera_type',CameraParamAreaScanTiltDivision]</l>
<l>    elseif (CameraType == 'area_scan_tilt_polynomial')</l>
<l>        ParamNames := ['camera_type',CameraParamAreaScanTiltPolynomial]</l>
<l>    elseif (CameraType == 'area_scan_tilt_image_side_telecentric_division')</l>
<l>        ParamNames := ['camera_type',CameraParamAreaScanImageSideTelecentricTiltDivision]</l>
<l>    elseif (CameraType == 'area_scan_tilt_image_side_telecentric_polynomial')</l>
<l>        ParamNames := ['camera_type',CameraParamAreaScanImageSideTelecentricTiltPolynomial]</l>
<l>    elseif (CameraType == 'area_scan_tilt_bilateral_telecentric_division')</l>
<l>        ParamNames := ['camera_type',CameraParamAreaScanBilateralTelecentricTiltDivision]</l>
<l>    elseif (CameraType == 'area_scan_tilt_bilateral_telecentric_polynomial')</l>
<l>        ParamNames := ['camera_type',CameraParamAreaScanBilateralTelecentricTiltPolynomial]</l>
<l>    elseif (CameraType == 'area_scan_tilt_object_side_telecentric_division')</l>
<l>        ParamNames := ['camera_type',CameraParamAreaScanObjectSideTelecentricTiltDivision]</l>
<l>    elseif (CameraType == 'area_scan_tilt_object_side_telecentric_polynomial')</l>
<l>        ParamNames := ['camera_type',CameraParamAreaScanObjectSideTelecentricTiltPolynomial]</l>
<l>    elseif (CameraType == 'area_scan_hypercentric_division')</l>
<l>        ParamNames := ['camera_type',CameraParamAreaScanHypercentricDivision]</l>
<l>    elseif (CameraType == 'area_scan_hypercentric_polynomial')</l>
<l>        ParamNames := ['camera_type',CameraParamAreaScanHypercentricPolynomial]</l>
<l>    elseif (CameraType == 'line_scan_division' or CameraType == 'line_scan')</l>
<l>        ParamNames := ['camera_type',CameraParamLinesScanDivision]</l>
<l>    elseif (CameraType == 'line_scan_polynomial')</l>
<l>        ParamNames := ['camera_type',CameraParamLinesScanPolynomial]</l>
<l>    elseif (CameraType == 'line_scan_telecentric_division')</l>
<l>        ParamNames := ['camera_type',CameraParamLinesScanTelecentricDivision]</l>
<l>    elseif (CameraType == 'line_scan_telecentric_polynomial')</l>
<l>        ParamNames := ['camera_type',CameraParamLinesScanTelecentricPolynomial]</l>
<l>    else</l>
<l>        throw ('Unknown camera type \'' + CameraType + '\' passed in CameraParam.')</l>
<l>    endif</l>
<l>    return ()</l>
<l>endif</l>
<c>* </c>
<c>* If the camera parameters are passed in CameraParam</c>
<l>if (not is_string(CameraParam[0]))</l>
<c>    * Format of camera parameters for HALCON 12 and earlier</c>
<l>    switch (|CameraParam|)</l>
<c>        * </c>
<c>        * Area Scan</c>
<l>    case 8:</l>
<c>        * CameraType: 'area_scan_division' or 'area_scan_telecentric_division'</c>
<l>        if (CameraParam[0] != 0.0)</l>
<l>            ParamNames := CameraParamAreaScanDivision</l>
<l>            CameraType := 'area_scan_division'</l>
<l>        else</l>
<l>            ParamNames := CameraParamAreaScanTelecentricDivisionLegacy</l>
<l>            CameraType := 'area_scan_telecentric_division'</l>
<l>        endif</l>
<l>        break</l>
<l>    case 10:</l>
<c>        * CameraType: 'area_scan_tilt_division' or 'area_scan_telecentric_tilt_division'</c>
<l>        if (CameraParam[0] != 0.0)</l>
<l>            ParamNames := CameraParamAreaScanTiltDivisionLegacy</l>
<l>            CameraType := 'area_scan_tilt_division'</l>
<l>        else</l>
<l>            ParamNames := CameraParamAreaScanBilateralTelecentricTiltDivisionLegacy</l>
<l>            CameraType := 'area_scan_tilt_bilateral_telecentric_division'</l>
<l>        endif</l>
<l>        break</l>
<l>    case 12:</l>
<c>        * CameraType: 'area_scan_polynomial' or 'area_scan_telecentric_polynomial'</c>
<l>        if (CameraParam[0] != 0.0)</l>
<l>            ParamNames := CameraParamAreaScanPolynomial</l>
<l>            CameraType := 'area_scan_polynomial'</l>
<l>        else</l>
<l>            ParamNames := CameraParamAreaScanTelecentricPolynomialLegacy</l>
<l>            CameraType := 'area_scan_telecentric_polynomial'</l>
<l>        endif</l>
<l>        break</l>
<l>    case 14:</l>
<c>        * CameraType: 'area_scan_tilt_polynomial' or 'area_scan_telecentric_tilt_polynomial'</c>
<l>        if (CameraParam[0] != 0.0)</l>
<l>            ParamNames := CameraParamAreaScanTiltPolynomialLegacy</l>
<l>            CameraType := 'area_scan_tilt_polynomial'</l>
<l>        else</l>
<l>            ParamNames := CameraParamAreaScanBilateralTelecentricTiltPolynomialLegacy</l>
<l>            CameraType := 'area_scan_tilt_bilateral_telecentric_polynomial'</l>
<l>        endif</l>
<l>        break</l>
<c>        * </c>
<c>        * Line Scan</c>
<l>    case 11:</l>
<c>        * CameraType: 'line_scan' or 'line_scan_telecentric'</c>
<l>        if (CameraParam[0] != 0.0)</l>
<l>            ParamNames := CameraParamLinesScanDivision</l>
<l>            CameraType := 'line_scan_division'</l>
<l>        else</l>
<l>            ParamNames := CameraParamLinesScanTelecentricDivision</l>
<l>            CameraType := 'line_scan_telecentric_division'</l>
<l>        endif</l>
<l>        break</l>
<l>    default:</l>
<l>        throw ('Wrong number of values in CameraParam.')</l>
<l>    endswitch</l>
<l>else</l>
<c>    * Format of camera parameters since HALCON 13</c>
<l>    CameraType := CameraParam[0]</l>
<l>    if (CameraType == 'area_scan_division')</l>
<l>        if (|CameraParam| != 9)</l>
<l>            throw ('Wrong number of values in CameraParam.')</l>
<l>        endif</l>
<l>        ParamNames := ['camera_type',CameraParamAreaScanDivision]</l>
<l>    elseif (CameraType == 'area_scan_polynomial')</l>
<l>        if (|CameraParam| != 13)</l>
<l>            throw ('Wrong number of values in CameraParam.')</l>
<l>        endif</l>
<l>        ParamNames := ['camera_type',CameraParamAreaScanPolynomial]</l>
<l>    elseif (CameraType == 'area_scan_telecentric_division')</l>
<l>        if (|CameraParam| != 9)</l>
<l>            throw ('Wrong number of values in CameraParam.')</l>
<l>        endif</l>
<l>        ParamNames := ['camera_type',CameraParamAreaScanTelecentricDivision]</l>
<l>    elseif (CameraType == 'area_scan_telecentric_polynomial')</l>
<l>        if (|CameraParam| != 13)</l>
<l>            throw ('Wrong number of values in CameraParam.')</l>
<l>        endif</l>
<l>        ParamNames := ['camera_type',CameraParamAreaScanTelecentricPolynomial]</l>
<l>    elseif (CameraType == 'area_scan_tilt_division')</l>
<l>        if (|CameraParam| != 12)</l>
<l>            throw ('Wrong number of values in CameraParam.')</l>
<l>        endif</l>
<l>        ParamNames := ['camera_type',CameraParamAreaScanTiltDivision]</l>
<l>    elseif (CameraType == 'area_scan_tilt_polynomial')</l>
<l>        if (|CameraParam| != 16)</l>
<l>            throw ('Wrong number of values in CameraParam.')</l>
<l>        endif</l>
<l>        ParamNames := ['camera_type',CameraParamAreaScanTiltPolynomial]</l>
<l>    elseif (CameraType == 'area_scan_tilt_image_side_telecentric_division')</l>
<l>        if (|CameraParam| != 11)</l>
<l>            throw ('Wrong number of values in CameraParam.')</l>
<l>        endif</l>
<l>        ParamNames := ['camera_type',CameraParamAreaScanImageSideTelecentricTiltDivision]</l>
<l>    elseif (CameraType == 'area_scan_tilt_image_side_telecentric_polynomial')</l>
<l>        if (|CameraParam| != 15)</l>
<l>            throw ('Wrong number of values in CameraParam.')</l>
<l>        endif</l>
<l>        ParamNames := ['camera_type',CameraParamAreaScanImageSideTelecentricTiltPolynomial]</l>
<l>    elseif (CameraType == 'area_scan_tilt_bilateral_telecentric_division')</l>
<l>        if (|CameraParam| != 11)</l>
<l>            throw ('Wrong number of values in CameraParam.')</l>
<l>        endif</l>
<l>        ParamNames := ['camera_type',CameraParamAreaScanBilateralTelecentricTiltDivision]</l>
<l>    elseif (CameraType == 'area_scan_tilt_bilateral_telecentric_polynomial')</l>
<l>        if (|CameraParam| != 15)</l>
<l>            throw ('Wrong number of values in CameraParam.')</l>
<l>        endif</l>
<l>        ParamNames := ['camera_type',CameraParamAreaScanBilateralTelecentricTiltPolynomial]</l>
<l>    elseif (CameraType == 'area_scan_tilt_object_side_telecentric_division')</l>
<l>        if (|CameraParam| != 12)</l>
<l>            throw ('Wrong number of values in CameraParam.')</l>
<l>        endif</l>
<l>        ParamNames := ['camera_type',CameraParamAreaScanObjectSideTelecentricTiltDivision]</l>
<l>    elseif (CameraType == 'area_scan_tilt_object_side_telecentric_polynomial')</l>
<l>        if (|CameraParam| != 16)</l>
<l>            throw ('Wrong number of values in CameraParam.')</l>
<l>        endif</l>
<l>        ParamNames := ['camera_type',CameraParamAreaScanObjectSideTelecentricTiltPolynomial]</l>
<l>    elseif (CameraType == 'area_scan_hypercentric_division')</l>
<l>        if (|CameraParam| != 9)</l>
<l>            throw ('Wrong number of values in CameraParam.')</l>
<l>        endif</l>
<l>        ParamNames := ['camera_type',CameraParamAreaScanHypercentricDivision]</l>
<l>    elseif (CameraType == 'area_scan_hypercentric_polynomial')</l>
<l>        if (|CameraParam| != 13)</l>
<l>            throw ('Wrong number of values in CameraParam.')</l>
<l>        endif</l>
<l>        ParamNames := ['camera_type',CameraParamAreaScanHypercentricPolynomial]</l>
<l>    elseif (CameraType == 'line_scan_division' or CameraType == 'line_scan')</l>
<l>        if (|CameraParam| != 12)</l>
<l>            throw ('Wrong number of values in CameraParam.')</l>
<l>        endif</l>
<l>        ParamNames := ['camera_type',CameraParamLinesScanDivision]</l>
<l>    elseif (CameraType == 'line_scan_polynomial')</l>
<l>        if (|CameraParam| != 16)</l>
<l>            throw ('Wrong number of values in CameraParam.')</l>
<l>        endif</l>
<l>        ParamNames := ['camera_type',CameraParamLinesScanPolynomial]</l>
<l>    elseif (CameraType == 'line_scan_telecentric_division')</l>
<l>        if (|CameraParam| != 12)</l>
<l>            throw ('Wrong number of values in CameraParam.')</l>
<l>        endif</l>
<l>        ParamNames := ['camera_type',CameraParamLinesScanTelecentricDivision]</l>
<l>    elseif (CameraType == 'line_scan_telecentric_polynomial')</l>
<l>        if (|CameraParam| != 16)</l>
<l>            throw ('Wrong number of values in CameraParam.')</l>
<l>        endif</l>
<l>        ParamNames := ['camera_type',CameraParamLinesScanTelecentricPolynomial]</l>
<l>    else</l>
<l>        throw ('Unknown camera type in CameraParam.')</l>
<l>    endif</l>
<l>endif</l>
<l>return ()</l>
</body>
<docu id="get_cam_par_names">
<abstract lang="en_US">get_cam_par_names returns the names ParamNames of the camera parameters for each element of CameraParam. The parameter names are returned in ParamNames. Additionally, the camera type is returned in CameraType.

Alternatively, instead of the camera parameters, the camera type can be passed in CameraParam in form of one of the following strings:
   - 'area_scan_division'
   - 'area_scan_polynomial'
   - 'area_scan_tilt_division'
   - 'area_scan_tilt_polynomial'
   - 'area_scan_telecentric_division'
   - 'area_scan_telecentric_polynomial'
   - 'area_scan_tilt_bilateral_telecentric_division'
   - 'area_scan_tilt_bilateral_telecentric_polynomial'
   - 'area_scan_tilt_object_side_telecentric_division'
   - 'area_scan_tilt_object_side_telecentric_polynomial'
   - 'area_scan_hypercentric_division'
   - 'area_scan_hypercentric_polynomial'
   - 'line_scan_division'
   - 'line_scan_polynomial'
   - 'line_scan_telecentric_division'
   - 'line_scan_telecentric_polynomial'</abstract>
<chapters lang="de_DE">
<item>Kalibrierung</item>
<item>Kameraparameter</item>
</chapters>
<chapters lang="en_US">
<item>Calibration</item>
<item>Camera Parameters</item>
</chapters>
<example lang="en_US">read_cam_par ('campar.dat', CameraParam)
get_cam_par_names (CameraParam, CameraType, ParamNames)</example>
<keywords lang="de_DE">
<item>Kameraparameter kalibrieren</item>
<item>Kamera-Kalibrierparameter erhalten</item>
<item>Kameramodell</item>
<item>interne Kameraparameter</item>
<item>interne Kameraparameter kalibrieren</item>
<item>kalibrierte interne Kameraparameter erhalten</item>
</keywords>
<keywords lang="en_US">
<item>camera calibration parameters</item>
<item>camera calibration result</item>
<item>calibrate camera parameters</item>
<item>calibrate internal camera parameters</item>
<item>calibrated internal camera parameters</item>
</keywords>
<library lang="en_US">MVTec Standard Procedures</library>
<predecessor>
<item>read_cam_par</item>
<item>deserialize_cam_par</item>
<item>get_calib_data</item>
<item>get_deformable_model_params</item>
<item>get_sheet_of_light_param</item>
<item>get_shape_model_3d_param</item>
</predecessor>
<see_also>
<item>calibrate_cameras</item>
<item>get_cam_par_data</item>
<item>set_cam_par_data</item>
<item>gen_cam_par_area_scan_division</item>
<item>gen_cam_par_area_scan_polynomial</item>
<item>gen_cam_par_area_scan_tilt_division</item>
<item>gen_cam_par_area_scan_tilt_polynomial</item>
<item>gen_cam_par_area_scan_telecentric_division</item>
<item>gen_cam_par_area_scan_telecentric_polynomial</item>
<item>gen_cam_par_area_scan_tilt_bilateral_telecentric_division</item>
<item>gen_cam_par_area_scan_tilt_bilateral_telecentric_polynomial</item>
<item>gen_cam_par_area_scan_tilt_object_side_telecentric_division</item>
<item>gen_cam_par_area_scan_tilt_object_side_telecentric_polynomial</item>
<item>gen_cam_par_area_scan_hypercentric_division</item>
<item>gen_cam_par_area_scan_hypercentric_polynomial</item>
<item>gen_cam_par_line_scan_division</item>
<item>gen_cam_par_line_scan_polynomial</item>
<item>gen_cam_par_line_scan_telecentric_division</item>
<item>gen_cam_par_line_scan_telecentric_polynomial</item>
</see_also>
<short lang="en_US">Get the names of the parameters in a camera parameter tuple.</short>
<parameters>
<parameter id="CameraParam">
<default_type>real</default_type>
<description lang="en_US">Input camera parameter tuple or camera type.</description>
<mixed_type>optional</mixed_type>
<multivalue>optional</multivalue>
<sem_type>campar</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
<item>string</item>
</type_list>
<values>
<item>'area_scan_division'</item>
<item>'area_scan_polynomial'</item>
<item>'area_scan_tilt_division'</item>
<item>'area_scan_tilt_polynomial'</item>
<item>'area_scan_telecentric_division'</item>
<item>'area_scan_telecentric_polynomial'</item>
<item>'area_scan_tilt_bilateral_telecentric_division'</item>
<item>'area_scan_tilt_bilateral_telecentric_polynomial'</item>
<item>'area_scan_tilt_object_side_telecentric_division'</item>
<item>'area_scan_tilt_object_side_telecentric_polynomial'</item>
<item>'area_scan_tilt_image_side_telecentric_division'</item>
<item>'area_scan_tilt_image_side_telecentric_polynomial'</item>
<item>'area_scan_hypercentric_division'</item>
<item>'area_scan_hypercentric_polynomial'</item>
<item>'line_scan_division'</item>
<item>'line_scan_polynomial'</item>
<item>'line_scan_telecentric_division'</item>
<item>'line_scan_telecentric_polynomial'</item>
</values>
</parameter>
<parameter id="CameraType">
<default_type>string</default_type>
<description lang="en_US">The camera type that is described by CameraParam.</description>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>string</sem_type>
<type_list>
<item>string</item>
</type_list>
<value_list>
<item>'area_scan_division'</item>
<item>'area_scan_polynomial'</item>
<item>'area_scan_tilt_division'</item>
<item>'area_scan_tilt_polynomial'</item>
<item>'area_scan_telecentric_division'</item>
<item>'area_scan_telecentric_polynomial'</item>
<item>'area_scan_tilt_bilateral_telecentric_division'</item>
<item>'area_scan_tilt_bilateral_telecentric_polynomial'</item>
<item>'area_scan_tilt_object_side_telecentric_division'</item>
<item>'area_scan_tilt_object_side_telecentric_polynomial'</item>
<item>'line_scan_division'</item>
<item>'line_scan_polynomial'</item>
<item>'line_scan_telecentric_division'</item>
<item>'line_scan_telecentric_polynomial'</item>
</value_list>
</parameter>
<parameter id="ParamNames">
<default_type>string</default_type>
<description lang="en_US">Parameter names of the camera parameter tuple or camera type passed in CameraParam.</description>
<mixed_type>false</mixed_type>
<multivalue>true</multivalue>
<sem_type>string</sem_type>
<type_list>
<item>string</item>
</type_list>
<values>
<item>'focus'</item>
<item>'magnification'</item>
<item>'kappa'</item>
<item>'k1'</item>
<item>'k2'</item>
<item>'k3'</item>
<item>'p1'</item>
<item>'p2'</item>
<item>'image_plane_dist'</item>
<item>'tilt'</item>
<item>'rot'</item>
<item>'sx'</item>
<item>'sy'</item>
<item>'cx'</item>
<item>'cy'</item>
<item>'image_width'</item>
<item>'image_height'</item>
<item>'vx'</item>
<item>'vy'</item>
<item>'vz'</item>
</values>
</parameter>
</parameters>
</docu>
</procedure>
<procedure name="get_child_window" access="local">
<interface>
<ic>
<par name="HeightImage" base_type="ctrl" dimension="0"/>
<par name="Font" base_type="ctrl" dimension="0"/>
<par name="FontSize" base_type="ctrl" dimension="0"/>
<par name="Text" base_type="ctrl" dimension="0"/>
<par name="PrevWindowCoordinates" base_type="ctrl" dimension="0"/>
<par name="WindowHandleDict" base_type="ctrl" dimension="0"/>
<par name="WindowHandleKey" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="WindowImageRatio" base_type="ctrl" dimension="0"/>
<par name="PrevWindowCoordinatesOut" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c>* </c>
<c>* This procedure returns the next child window that</c>
<c>* is used for visualization. If ReuseWindows is true</c>
<c>* and WindowHandleList is suitable, the window handles</c>
<c>* that are passed over are used. Else, this procedure</c>
<c>* opens a new window, either next to the last ones, or</c>
<c>* in a new row.</c>
<c>* </c>
<c>* First, check if the requested window is already available.</c>
<l>OpenNewWindow := false</l>
<l>try</l>
<l>    get_dict_tuple (WindowHandleDict, WindowHandleKey, WindowHandles)</l>
<l>    ParentWindowHandle := WindowHandles[0]</l>
<l>    ChildWindowHandle := WindowHandles[1]</l>
<c>    * Check if window handle is valid.</c>
<l>    try</l>
<l>        flush_buffer (ChildWindowHandle)</l>
<l>    catch (Exception)</l>
<c>        * Since there is something wrong with the current window, create a new one.</c>
<l>        OpenNewWindow := true</l>
<l>    endtry</l>
<l>catch (Exception)</l>
<l>    OpenNewWindow := true</l>
<l>endtry</l>
<c>* </c>
<c>* Get next child window.</c>
<l>if (not OpenNewWindow)</l>
<c>    * </c>
<c>    * If possible, reuse existing window handles.</c>
<l>    dev_set_window (ChildWindowHandle)</l>
<l>    dev_clear_window ()</l>
<l>    set_display_font (ChildWindowHandle, FontSize, Font, 'true', 'false')</l>
<c>    * </c>
<l>    get_dict_tuple (WindowHandleDict, 'meta_information', MetaInfo)</l>
<c>    * </c>
<c>    * Get previous window coordinates.</c>
<l>    get_window_extents (ParentWindowHandle, WindowRow, WindowColumn, WindowWidth, WindowHeight)</l>
<l>    WindowImageRatio := WindowHeight / (HeightImage * 1.0)</l>
<c>    * </c>
<l>    try</l>
<c>        * </c>
<c>        * Get WindowImageRatio from parent window.</c>
<l>        get_dict_tuple (MetaInfo, WindowHandleKey + '_window_image_ratio_height', WindowImageRatio)</l>
<c>        * </c>
<c>        * Get previous window coordinates.</c>
<l>        get_dict_tuple (MetaInfo, WindowHandleKey + '_child_window_coordinates', PrevWindowCoordinatesOut)</l>
<l>    catch (Exception)</l>
<c>        * </c>
<c>        * Set WindowImageRatio from parent window.</c>
<l>        get_window_extents (ParentWindowHandle, WindowRow, WindowColumn, WindowWidth, WindowHeight)</l>
<l>        WindowImageRatio := WindowHeight / (HeightImage * 1.0)</l>
<c>        * </c>
<c>        * Set previous window coordinates.</c>
<l>        PrevWindowCoordinatesOut[0] := WindowRow</l>
<l>        PrevWindowCoordinatesOut[1] := WindowColumn</l>
<l>        PrevWindowCoordinatesOut[2] := WindowWidth</l>
<l>        PrevWindowCoordinatesOut[3] := WindowHeight</l>
<l>    endtry</l>
<l>else</l>
<c>    * </c>
<c>    * Open a new child window.</c>
<l>    open_child_window (ParentWindowHandle, Font, FontSize, Text, PrevWindowCoordinates, WindowHandleDict, WindowHandleKey, ChildWindowHandle, PrevWindowCoordinatesOut)</l>
<l>    set_window_param (ChildWindowHandle, 'flush', 'false')</l>
<l>    set_dict_tuple (WindowHandleDict, WindowHandleKey, [ParentWindowHandle,ChildWindowHandle])</l>
<l>endif</l>
<c>* </c>
<l>return ()</l>
</body>
<docu id="get_child_window">
<chapters lang="de_DE">
<item>Graphik</item>
<item>Fenster</item>
</chapters>
<chapters lang="en_US">
<item>Graphics</item>
<item>Window</item>
</chapters>
<library lang="en_US">MVTec Standard Procedures</library>
<short lang="en_US">Get the next child window that can be used for visualization.</short>
<parameters>
<parameter id="Font">
<default_type>string</default_type>
<sem_type>string</sem_type>
<type_list>
<item>string</item>
</type_list>
</parameter>
<parameter id="FontSize">
<default_type>integer</default_type>
<default_value>0</default_value>
<multivalue>false</multivalue>
<sem_type>integer</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="HeightImage">
<default_type>integer</default_type>
<default_value>0</default_value>
<multivalue>false</multivalue>
<sem_type>extent.y</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="PrevWindowCoordinates">
<default_type>integer</default_type>
<default_value>0</default_value>
<multivalue>true</multivalue>
<sem_type>integer</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="PrevWindowCoordinatesOut">
<default_type>integer</default_type>
<multivalue>true</multivalue>
<sem_type>integer</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="Text">
<default_type>string</default_type>
<multivalue>false</multivalue>
<sem_type>string</sem_type>
<type_list>
<item>string</item>
</type_list>
</parameter>
<parameter id="WindowHandleDict">
<default_type>integer</default_type>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>dict</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="WindowHandleKey">
<default_type>string</default_type>
<multivalue>false</multivalue>
<sem_type>string</sem_type>
<type_list>
<item>string</item>
</type_list>
</parameter>
<parameter id="WindowImageRatio">
<default_type>real</default_type>
<multivalue>false</multivalue>
<sem_type>real</sem_type>
<type_list>
<item>real</item>
</type_list>
</parameter>
</parameters>
</docu>
</procedure>
<procedure name="get_classification_ground_truth" access="local">
<interface>
<ic>
<par name="SampleKeys" base_type="ctrl" dimension="0"/>
<par name="DLSample" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="ClassificationLabelIDGroundTruth" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c>* </c>
<c>* This procedure returns the classification ground truth label ID.</c>
<c>* </c>
<l>if (find(SampleKeys,'image_label_id') != -1)</l>
<l>    get_dict_tuple (DLSample, 'image_label_id', ClassificationLabelIDGroundTruth)</l>
<l>else</l>
<l>    throw ('Ground truth class label cannot be found in DLSample.')</l>
<l>endif</l>
<c>* </c>
<l>return ()</l>
</body>
<docu id="get_classification_ground_truth">
<chapters lang="en_US">
<item>Deep Learning</item>
<item>Classification</item>
</chapters>
<library lang="en_US">MVTec Standard Procedures</library>
<short lang="en_US">Get the ground truth classification label id.</short>
<parameters>
<parameter id="ClassificationLabelIDGroundTruth">
<sem_type>integer</sem_type>
</parameter>
<parameter id="DLSample">
<default_type>integer</default_type>
<mixed_type>false</mixed_type>
<sem_type>dict</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="SampleKeys">
<sem_type>string</sem_type>
</parameter>
</parameters>
</docu>
</procedure>
<procedure name="get_classification_result" access="local">
<interface>
<ic>
<par name="ResultKeys" base_type="ctrl" dimension="0"/>
<par name="DLResult" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="ClassificationClassID" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c>* </c>
<c>* This procedure returns the predicted classification class ID.</c>
<c>* </c>
<l>if (find(ResultKeys,'classification_class_ids') != -1)</l>
<l>    get_dict_tuple (DLResult, 'classification_class_ids', ClassificationClassID)</l>
<l>    if (|ClassificationClassID| &gt; 0)</l>
<l>        ClassificationClassID := ClassificationClassID[0]</l>
<l>    endif</l>
<l>else</l>
<l>    throw ('Key entry \'classification_class_ids\' could not be found in DLResult.')</l>
<l>endif</l>
<c>* </c>
<l>return ()</l>
</body>
<docu id="get_classification_result">
<chapters lang="en_US">
<item>Deep Learning</item>
<item>Classification</item>
</chapters>
<library lang="en_US">MVTec Standard Procedures</library>
<short lang="en_US">Get the predicted classification class ID.</short>
<parameters>
<parameter id="ClassificationClassID">
<sem_type>integer</sem_type>
</parameter>
<parameter id="DLResult">
<default_type>integer</default_type>
<mixed_type>false</mixed_type>
<sem_type>dict</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="ResultKeys">
<sem_type>string</sem_type>
</parameter>
</parameters>
</docu>
</procedure>
<procedure name="get_confidence_image" access="local">
<interface>
<oo>
<par name="ImageConfidence" base_type="iconic" dimension="0"/>
</oo>
<ic>
<par name="ResultKeys" base_type="ctrl" dimension="0"/>
<par name="DLResult" base_type="ctrl" dimension="0"/>
</ic>
</interface>
<body>
<c>* </c>
<c>* This procedure returns confidences of the segmentation result.</c>
<c>* </c>
<l>if (find(ResultKeys,'segmentation_confidence') != -1)</l>
<l>    get_dict_object (ImageConfidence, DLResult, 'segmentation_confidence')</l>
<l>elseif (find(ResultKeys,'segmentation_confidences') != -1)</l>
<l>    get_dict_object (ImageConfidence, DLResult, 'segmentation_confidences')</l>
<l>else</l>
<l>    throw ('Confidence image could not be found in DLSample.')</l>
<l>endif</l>
<l>return ()</l>
</body>
<docu id="get_confidence_image">
<chapters lang="de_DE">
<item>Deep Learning</item>
<item>Semantische Segmentierung</item>
</chapters>
<chapters lang="en_US">
<item>Deep Learning</item>
<item>Semantic Segmentation</item>
</chapters>
<library lang="en_US">MVTec Standard Procedures</library>
<short lang="en_US">Get the confidences of the segmentation result.</short>
<parameters>
<parameter id="DLResult">
<default_type>integer</default_type>
<mixed_type>false</mixed_type>
<sem_type>dict</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="ImageConfidence">
<sem_type>image</sem_type>
</parameter>
<parameter id="ResultKeys">
<sem_type>string</sem_type>
</parameter>
</parameters>
</docu>
</procedure>
<procedure name="get_custom_features">
<interface>
<io>
<par name="Region" base_type="iconic" dimension="0"/>
<par name="Image" base_type="iconic" dimension="0"/>
</io>
<ic>
<par name="CurrentName" base_type="ctrl" dimension="0"/>
<par name="Mode" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="Output" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c>* </c>
<c>* This procedure can be used to extend the functionality</c>
<c>* of the calculate_feature_set procedure library by</c>
<c>* user-defined features.</c>
<c>* </c>
<c>* Instructions:</c>
<c>* </c>
<c>* 1. Find the template block at the beginning the procedure</c>
<c>* (marked by comments) and duplicate it.</c>
<c>* </c>
<c>* 2. In the copy edit the two marked areas as follows:</c>
<c>* </c>
<c>* 2.1. Feature name and groups:</c>
<c>* Assign a unique identifier for your feature to the variable "Name".</c>
<c>* Then, assign the groups that you want your feature to belong to</c>
<c>* to the variable "Groups".</c>
<c>* </c>
<c>* 2.2. Feature calculation:</c>
<c>* Enter the code that calculates your feature and</c>
<c>* assign the result to the variable "Feature".</c>
<c>* </c>
<c>* 3. Test</c>
<c>* Use the "test_feature" procedure to check,</c>
<c>* if the feature is calculated correctly.</c>
<c>* If the procedure throws an exception,</c>
<c>* maybe the order of the feature vector is wrong</c>
<c>* (See note below).</c>
<c>* </c>
<c>* 4. Integration</c>
<c>* - Save your modified procedure get_custom_features.hdvp</c>
<c>*   to a location of your choice.</c>
<c>*   (We recommend not to overwrite the template.)</c>
<c>* - Make sure, that your version of get_custom_procedures</c>
<c>*   is included in the procedure directories of HDevelop.</c>
<c>*   (Choose Procedures -&gt; Manage Procedures -&gt; Directories -&gt; Add from the HDevelop menu bar.)</c>
<c>* </c>
<c>* Note:</c>
<c>* The current implementation supports region arrays as input.</c>
<c>* In that case, multi-dimensional feature vectors are simply concatenated.</c>
<c>* Example: The feature 'center' has two dimensions [Row,Column].</c>
<c>* If an array of three regions is passed, the correct order of the "Feature" variable is</c>
<c>* [Row1, Column1, Row2, Column2, Row3, Column3].</c>
<c>* </c>
<l>TmpResults := []</l>
<c>* ************************************************</c>
<c>* ************************************************</c>
<c>* **** Copy the following template block     *****</c>
<c>* **** and edit the two marked code sections *****</c>
<c>* **** to add user-defined features          *****</c>
<c>* ************************************************</c>
<c>* ************************************************</c>
<c>* </c>
<c>* ***************************************</c>
<c>* *********** TEMPLATE BLOCK ************</c>
<c>* ***************************************</c>
<c>* </c>
<c>* ********************************************************************</c>
<c>* ** Section 1:</c>
<c>* ** Enter unique feature name and groups to which it belongs here ***</c>
<l>Name := 'custom_feature_numlines'</l>
<l>Groups := 'custom'</l>
<c>* ** Enter unique feature name and groups above this line ************</c>
<c>* ********************************************************************</c>
<l>if (Name == CurrentName)</l>
<c>    * ******************************************************</c>
<c>    * ** Section 2:</c>
<c>    * ** Enter code to calculate feature here **************</c>
<l>    Feature := []</l>
<l>    count_obj (Region, NumRegions)</l>
<l>    for I := 1 to NumRegions by 1</l>
<l>        select_obj (Region, RegionSelected, I)</l>
<l>        gen_contour_region_xld (RegionSelected, Contours, 'border')</l>
<l>        count_obj (Contours, NumContours)</l>
<l>        NumLines := 0</l>
<l>        for J := 1 to NumContours by 1</l>
<l>            select_obj (Contours, ContoursSelected, J)</l>
<l>            segment_contours_xld (ContoursSelected, ContoursSplit, 'lines', 5, 2, 1)</l>
<l>            count_obj (ContoursSplit, NumSplit)</l>
<l>            NumLines := NumLines + NumSplit</l>
<l>        endfor</l>
<l>        Feature := [Feature,NumLines]</l>
<l>    endfor</l>
<c>    * ** Enter code to calculate feature above this line ***</c>
<c>    * ******************************************************</c>
<l>    append_length_or_values (Mode, Feature, TmpResults, TmpResults)</l>
<l>endif</l>
<l>append_names_or_groups (Mode, Name, Groups, CurrentName, TmpResults, TmpResults)</l>
<c>* </c>
<c>* ************************************</c>
<c>* ****** END OF TEMPLATE BLOCK *******</c>
<c>* ************************************</c>
<c>* </c>
<l>Output := TmpResults</l>
<l>return ()</l>
</body>
<docu id="get_custom_features">
<abstract lang="en_US">This procedure can be used to extend the functionality of the calculate_feature_set procedure library by user-defined features.

Instructions:

1. Find the 'template block' at the beginning of the procedure (enclosed by comments) and duplicate it.

2. In the duplicate edit the two marked code sections as follows:

2.1. 'Section 1': Feature name and groups

 Assign a unique identifier for your feature to the variable 'Name'. Then, assign the groups your feature belongs to to the variable 'Groups'.

2.2. 'Section 2': Feature calculation

Enter the code that calculates your feature and assign the result to the variable 'Feature'.

3. Test

Use the "test_feature" procedure to check, if the feature is integrated correctly.
If the procedure throws an exception, first check if the order of the feature vector is correct (see note below).

4. Integration

Save your modified procedure get_custom_features.hdvp to a location of your choice. We recommend not to overwrite the template.

Make sure that your version of get_custom_features is included in the procedure directories of HDevelop (Choose the following  from the HDevelop menu bar: Procedures -&gt; Manage Procedures -&gt; Directories -&gt; Add).

Note that the current implementation supports region arrays as input. In that case, multi-dimensional feature vectors are simply concatenated.

Example: The feature 'center' has two dimensions [Row,Column]. If an array of three regions is passed, the correct order of thevalues in the  variable Feature is [Row1, Column1, Row2, Column2, Row3, Column3].

The Output depends on the processing mode Mode:
If  Mode == 'get_names', the names of all features that belong to the input group in CurrentName are returned.
If  Mode == 'get_lengths', the length of the feature vector of the feature in CurrentName is returned.
If  Mode == 'get_groups', the names of all groups to which the feature in CurrentNamebelongs to are returned.
If  Mode == 'calculate', the feature vector of the feature in CurrentName is returned.

For more information about the usage of the get_feature_set library, see documentation of calculate_features.
</abstract>
<chapters lang="de_DE">
<item>Klassifikation</item>
<item>Sonstiges</item>
</chapters>
<chapters lang="en_US">
<item>Classification</item>
<item>Misc</item>
</chapters>
<library lang="en_US">MVTec Procedure Templates</library>
<short lang="en_US">Describe and calculate user-defined features to be used in conjunction with the calculate_feature_set procedure library.</short>
<parameters>
<parameter id="CurrentName">
<default_type>string</default_type>
<description lang="en_US">Current feature or group name as received from the caller procedure get_features.</description>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>string</sem_type>
<type_list>
<item>string</item>
</type_list>
</parameter>
<parameter id="Image">
<description lang="en_US">Gray-value image.</description>
<multivalue>false</multivalue>
<sem_type>image</sem_type>
</parameter>
<parameter id="Mode">
<default_type>string</default_type>
<description lang="en_US">Processing mode as received from the caller procedure get_features.</description>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>string</sem_type>
<type_list>
<item>string</item>
</type_list>
<value_list>
<item>'get_names'</item>
<item>'get_lengths'</item>
<item>'get_groups'</item>
<item>'calculate'</item>
</value_list>
</parameter>
<parameter id="Output">
<default_type>string</default_type>
<description lang="en_US">Feature names, feature vector, feature vector lengths, or group names.</description>
<multivalue>optional</multivalue>
</parameter>
<parameter id="Region">
<description lang="en_US">Regions to be examined.</description>
<multivalue>optional</multivalue>
<sem_type>region</sem_type>
</parameter>
</parameters>
</docu>
</procedure>
<procedure name="get_distinct_colors" access="local">
<interface>
<ic>
<par name="NumColors" base_type="ctrl" dimension="0"/>
<par name="Random" base_type="ctrl" dimension="0"/>
<par name="StartColor" base_type="ctrl" dimension="0"/>
<par name="EndColor" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="Colors" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c>* </c>
<c>* We get distinct color-values first in HLS color-space.</c>
<c>* Assumes hue [0, EndColor), lightness [0, 1), saturation [0, 1).</c>
<c>* </c>
<c>* Parameter checks.</c>
<c>* NumColors.</c>
<l>if (NumColors &lt; 1)</l>
<l>    throw ('NumColors should be at least 1')</l>
<l>endif</l>
<l>if (not is_int(NumColors))</l>
<l>    throw ('NumColors should be of type int')</l>
<l>endif</l>
<l>if (|NumColors| != 1)</l>
<l>    throw ('NumColors should have length 1')</l>
<l>endif</l>
<c>* Random.</c>
<l>if (Random != 0 and Random != 1)</l>
<l>    tuple_is_string (Random, IsString)</l>
<l>    if (IsString)</l>
<l>        Random := Random == 'true' or 'false'</l>
<l>    else</l>
<l>        throw ('Random should be either true or false')</l>
<l>    endif</l>
<l>endif</l>
<c>* StartColor.</c>
<l>if (|StartColor| != 1)</l>
<l>    throw ('StartColor should have length 1')</l>
<l>endif</l>
<l>if (StartColor &lt; 0 or StartColor &gt; 255)</l>
<l>    throw ('StartColor should be in the range [0, 255]')</l>
<l>endif</l>
<l>if (not is_int(StartColor))</l>
<l>    throw ('StartColor should be of type int')</l>
<l>endif</l>
<c>* EndColor.</c>
<l>if (|EndColor| != 1)</l>
<l>    throw ('EndColor should have length 1')</l>
<l>endif</l>
<l>if (EndColor &lt; 0 or EndColor &gt; 255)</l>
<l>    throw ('EndColor should be in the range [0, 255]')</l>
<l>endif</l>
<l>if (not is_int(EndColor))</l>
<l>    throw ('EndColor should be of type int')</l>
<l>endif</l>
<c>* </c>
<c>* Color generation.</c>
<l>if (StartColor &gt; EndColor)</l>
<l>    EndColor := EndColor + 255</l>
<l>endif</l>
<l>if (NumColors != 1)</l>
<l>    Hue := (StartColor + int((EndColor - StartColor) * real([0:NumColors - 1]) / real(NumColors - 1))) % 255</l>
<l>else</l>
<l>    Hue := mean([StartColor,EndColor])</l>
<l>endif</l>
<l>if (Random)</l>
<l>    Hue := Hue[sort_index(rand(NumColors))]</l>
<l>    Lightness := int((5.0 + rand(NumColors)) * 255.0 / 10.0)</l>
<l>    Saturation := int((9.0 + rand(NumColors)) * 255.0 / 10.0)</l>
<l>else</l>
<l>    Lightness := int(gen_tuple_const(NumColors,0.55) * 255.0)</l>
<l>    Saturation := int(gen_tuple_const(NumColors,0.95) * 255.0)</l>
<l>endif</l>
<c>* </c>
<c>* Write colors to a 3-channel image in order to transform easier.</c>
<l>gen_image_const (HLSImageH, 'byte', 1, NumColors)</l>
<l>gen_image_const (HLSImageL, 'byte', 1, NumColors)</l>
<l>gen_image_const (HLSImageS, 'byte', 1, NumColors)</l>
<l>get_region_points (HLSImageH, Rows, Columns)</l>
<l>set_grayval (HLSImageH, Rows, Columns, Hue)</l>
<l>set_grayval (HLSImageL, Rows, Columns, Lightness)</l>
<l>set_grayval (HLSImageS, Rows, Columns, Saturation)</l>
<c>* </c>
<c>* Convert from HLS to RGB.</c>
<l>trans_to_rgb (HLSImageH, HLSImageL, HLSImageS, ImageR, ImageG, ImageB, 'hls')</l>
<c>* </c>
<c>* Get RGB-values and transform to Hex.</c>
<l>get_grayval (ImageR, Rows, Columns, Red)</l>
<l>get_grayval (ImageG, Rows, Columns, Green)</l>
<l>get_grayval (ImageB, Rows, Columns, Blue)</l>
<l>Colors := '#' + Red$'02x' + Green$'02x' + Blue$'02x'</l>
<l>return ()</l>
<c>* </c>
</body>
<docu id="get_distinct_colors">
<abstract lang="en_US">This procedure generates NumColors distinct colors returned as vector Colors.
Random is a boolean, determining if the returned colors are generated randomly (1 or 'true') or not (0 or 'false').
StartColor and EndColor determine the start- and end-angle of the circle sector in HLS color space, within which the the hue values for the colors are sampled.

The resulting Colors is a vector of NumColors [R,G,B] tuples, where the single color values are given as strings of hexadecimal numbers.

StartColor and EndColor have to be integers within the range [0, 255], where 0 corresponds to zero degrees and 255 corresponds to 360 degrees.
Note, that for a StartColor of zero and EndColor close to 255, the first and the last of the generated colors look very similar.
As 0 and 255 both correspond to the same point on the hue-color-circle, it is also possible to set a StartColor that is larger than EndColor.</abstract>
<chapters lang="de_DE">
<item>Deep Learning</item>
<item>Modell</item>
</chapters>
<chapters lang="en_US">
<item>Deep Learning</item>
<item>Model</item>
</chapters>
<library lang="en_US">MVTec Standard Procedures</library>
<short lang="en_US">Generate NumColors distinct colors</short>
<parameters>
<parameter id="Colors">
<default_type>string</default_type>
<description lang="en_US">Tuple of NumColors RGB color values given as hex-strings.</description>
<mixed_type>false</mixed_type>
<multivalue>optional</multivalue>
<sem_type>color</sem_type>
<type_list>
<item>string</item>
</type_list>
</parameter>
<parameter id="EndColor">
<default_type>integer</default_type>
<default_value>255</default_value>
<description lang="en_US">Corresponds to the end-angle of the circle sector where the hue-values of the colors are sampled in HLS-color-space. Range [0, 255] corresponds to degrees of [0, 360].</description>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>integer</sem_type>
<type_list>
<item>integer</item>
</type_list>
<value_max>255</value_max>
<value_min>1</value_min>
</parameter>
<parameter id="NumColors">
<default_value>NumColors</default_value>
<description lang="en_US">Number of colors to be generated.</description>
<multivalue>false</multivalue>
<sem_type>integer</sem_type>
</parameter>
<parameter id="Random">
<default_type>string</default_type>
<default_value>false</default_value>
<description lang="en_US">If true, the colors are generated randomly and they differ for each call of get_distinct_colors, except if a random seed is set.
If false, the colors are generated deterministically.</description>
<multivalue>false</multivalue>
<sem_type>integer</sem_type>
<type_list>
<item>string</item>
</type_list>
<values>
<item>true</item>
<item>false</item>
</values>
</parameter>
<parameter id="StartColor">
<default_type>integer</default_type>
<default_value>0</default_value>
<description lang="en_US">Corresponds to he start-angle of the circle sector where the hue-values of the colors are sampled in HLS-color-space. Range [0, 255] corresponds to degrees of [0, 360].</description>
<multivalue>false</multivalue>
<sem_type>integer</sem_type>
<type_list>
<item>integer</item>
</type_list>
<value_max>254</value_max>
<value_min>0</value_min>
</parameter>
</parameters>
</docu>
</procedure>
<procedure name="get_dl_class_colors" access="local">
<interface>
<ic>
<par name="ClassNames" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="Colors" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c>* </c>
<c>* This procedure returns for each class a certain color.</c>
<c>* </c>
<c>* Define distinct colors for the classes.</c>
<l>NumColors := |ClassNames|</l>
<c>* Get distinct colors without randomness makes neighboring colors look very similar.</c>
<c>* We use a workaround to get deterministic colors where subsequent colors are distinguishable.</c>
<l>get_distinct_colors (NumColors, false, 0, 200, ColorsRainbow)</l>
<l>tuple_inverse (ColorsRainbow, ColorsRainbow)</l>
<l>make_neighboring_colors_distinguishable (ColorsRainbow, Colors)</l>
<c>* If a class 'OK','ok', 'good' or 'GOOD' is present set this class to green.</c>
<c>* Only the first occurrence found is set to a green shade.</c>
<l>ClassNamesGood := ['good','GOOD','ok','OK']</l>
<l>for IndexFind := 0 to |ClassNamesGood| - 1 by 1</l>
<l>    GoodIdx := find_first(ClassNames,ClassNamesGood[IndexFind])</l>
<l>    if (GoodIdx != -1 and |ClassNames| &lt;= 8)</l>
<c>        * If number of classes is &lt;= 8, swap color with a green color.</c>
<l>        CurrentColor := Colors[GoodIdx]</l>
<l>        GreenIdx := floor(|ClassNames| / 2.0)</l>
<c>        * Set to pure green.</c>
<l>        Colors[GoodIdx] := '#00ff00'</l>
<c>        * Write original color to a green entry.</c>
<l>        Colors[GreenIdx] := CurrentColor</l>
<l>        break</l>
<l>    elseif (GoodIdx != -1 and |ClassNames| &gt; 8)</l>
<c>        * If number of classes is larger than 8, set the respective color to green.</c>
<l>        Colors[GoodIdx] := '#00ff00'</l>
<l>        break</l>
<l>    endif</l>
<l>endfor</l>
<l>return ()</l>
</body>
<docu id="get_dl_class_colors">
<abstract lang="en_US">Compute a color for each class in ClassNames that is distinguishable from neighboring entries in ClassNames.
If the ClassNames include 'good', GOOD', 'ok' or 'OK', the color is set to green.
</abstract>
<chapters lang="de_DE">
<item>Deep Learning</item>
<item>Modell</item>
</chapters>
<chapters lang="en_US">
<item>Deep Learning</item>
<item>Model</item>
</chapters>
<library lang="en_US">MVTec Standard Procedures</library>
<short lang="en_US">Generates certain colors for different ClassNames</short>
<parameters>
<parameter id="ClassNames"/>
<parameter id="Colors"/>
</parameters>
</docu>
</procedure>
<procedure name="get_dl_classifier_image_results">
<interface>
<oo>
<par name="Images" base_type="iconic" dimension="0"/>
</oo>
<ic>
<par name="ImageFiles" base_type="ctrl" dimension="0"/>
<par name="GroundTruthLabels" base_type="ctrl" dimension="0"/>
<par name="PredictedClasses" base_type="ctrl" dimension="0"/>
<par name="GenParamName" base_type="ctrl" dimension="0"/>
<par name="GenParamValue" base_type="ctrl" dimension="0"/>
<par name="WindowHandle" base_type="ctrl" dimension="0"/>
</ic>
</interface>
<body>
<c>* This procedure can be used to visualize classified</c>
<c>* ImageFiles selected according to the specifications</c>
<c>* given with GenParamName and GenParamValue.</c>
<c>* </c>
<c>* Set parameter defaults.</c>
<l>LabelSelection := 'all'</l>
<l>PredictedClassSelection := 'all'</l>
<l>GlobalSelection := 'erroneously_classified'</l>
<l>DisplayImages := 'true'</l>
<l>DisplayButtons := 'false'</l>
<c>* </c>
<c>* Check if number of elements in</c>
<c>* GenParamName and GenParamValue is equal.</c>
<l>if (|GenParamName| != |GenParamValue|)</l>
<l>    throw ('Number of generic parameter names does not match number of generic parameter values.')</l>
<l>endif</l>
<c>* </c>
<c>* Parse generic parameters.</c>
<l>for GenParamIndex := 0 to |GenParamName| - 1 by 1</l>
<l>    if (GenParamName[GenParamIndex] == 'label_selection')</l>
<c>        * Set 'label_selection'.</c>
<l>        LabelSelection := GenParamValue[GenParamIndex]</l>
<l>    elseif (GenParamName[GenParamIndex] == 'predicted_class_selection')</l>
<c>        * Set 'predicted_class_selection'.</c>
<l>        PredictedClassSelection := GenParamValue[GenParamIndex]</l>
<l>    elseif (GenParamName[GenParamIndex] == 'global_selection')</l>
<c>        * Set 'global_selection'.</c>
<l>        GlobalSelection := GenParamValue[GenParamIndex]</l>
<l>    elseif (GenParamName[GenParamIndex] == 'display_images')</l>
<c>        * Set 'display_images'.</c>
<l>        DisplayImages := GenParamValue[GenParamIndex]</l>
<l>    elseif (GenParamName[GenParamIndex] == 'display_buttons')</l>
<c>        * Set 'display_buttons'.</c>
<l>        DisplayButtons := GenParamValue[GenParamIndex]</l>
<l>    else</l>
<l>        throw ('Unknown generic parameter: \'' + GenParamName[GenParamIndex] + '\'')</l>
<l>    endif</l>
<l>endfor</l>
<c>* </c>
<c>* Filter data according to LabelSelection.</c>
<l>if (LabelSelection != 'all')</l>
<l>    Mask := GroundTruthLabels [==] LabelSelection</l>
<l>    if (sum(Mask) == 0)</l>
<l>        throw ('LabelSelection \'' + LabelSelection + '\' not found in GroundTruthLabels.')</l>
<l>    endif</l>
<l>    ImageFiles := select_mask(ImageFiles,Mask)</l>
<l>    GroundTruthLabels := select_mask(GroundTruthLabels,Mask)</l>
<l>    PredictedClasses := select_mask(PredictedClasses,Mask)</l>
<l>endif</l>
<c>* </c>
<c>* Filter data according to PredictedClassSelection.</c>
<l>if (PredictedClassSelection != 'all')</l>
<l>    Mask := PredictedClasses [==] PredictedClassSelection</l>
<l>    if (sum(Mask) == 0)</l>
<l>        throw ('PredictedClassSelection \'' + PredictedClassSelection + '\' not found in PredictedClasses.')</l>
<l>    endif</l>
<l>    ImageFiles := select_mask(ImageFiles,Mask)</l>
<l>    GroundTruthLabels := select_mask(GroundTruthLabels,Mask)</l>
<l>    PredictedClasses := select_mask(PredictedClasses,Mask)</l>
<l>endif</l>
<c>* </c>
<c>* Filter data according to GlobalSelection.</c>
<l>if (GlobalSelection != 'all')</l>
<l>    Mask := GroundTruthLabels [==] PredictedClasses</l>
<l>    if (GlobalSelection == 'erroneously_classified')</l>
<c>        * Flip the mask.</c>
<l>        Mask := abs(Mask - 1)</l>
<l>    endif</l>
<l>    ImageFiles := select_mask(ImageFiles,Mask)</l>
<l>    GroundTruthLabels := select_mask(GroundTruthLabels,Mask)</l>
<l>    PredictedClasses := select_mask(PredictedClasses,Mask)</l>
<l>endif</l>
<c>* </c>
<l>if (DisplayImages == 'true')</l>
<c>    * Loop over the images.</c>
<l>    gen_empty_obj (Images)</l>
<l>    for ImageIndex := 0 to |ImageFiles| - 1 by 1</l>
<c>        * </c>
<c>        * Concatenate selected images.</c>
<l>        read_image (Image, ImageFiles[ImageIndex])</l>
<l>        concat_obj (Images, Image, Images)</l>
<c>        * </c>
<l>        Label := GroundTruthLabels[ImageIndex]</l>
<l>        PredictedClass := PredictedClasses[ImageIndex]</l>
<c>        * </c>
<l>        Text := 'Image ' + (ImageIndex + 1) + '/' + |ImageFiles|</l>
<l>        Text[1] := 'Label: ' + Label</l>
<l>        Text[2] := 'Predicted Class: ' + PredictedClass</l>
<l>        if (Label == PredictedClass)</l>
<l>            Color := 'forest green'</l>
<l>        else</l>
<l>            Color := 'red'</l>
<l>        endif</l>
<c>        * </c>
<c>        * Display the image.</c>
<l>        dev_resize_window_fit_image (Image, 0, 0, -1, -1)</l>
<l>        dev_display (Image)</l>
<l>        dev_disp_text (Text, 'window', 'top', 'left', ['black','black',Color], 'box_color', '#ffffffaa')</l>
<l>        if (DisplayButtons == 'false')</l>
<l>            dev_disp_text ('Press Run (F5) to continue', 'window', 'bottom', 'right', 'black', 'box_color', '#ffffffaa')</l>
<l>            stop ()</l>
<l>        else</l>
<l>            get_window_extents (WindowHandle, Row, Column, WindowWidth, WindowHeight)</l>
<l>            ButtonLabel := ['Next image','Continue']</l>
<l>            get_string_extents (WindowHandle, ButtonLabel[0], Ascent, Descent, TextWidth, TextHeight)</l>
<l>            ButtonRow := [WindowHeight - TextHeight - 20,WindowHeight - TextHeight - 20]</l>
<l>            ButtonColumn := [20,WindowWidth - TextWidth - 40]</l>
<l>            ColorLabels := 'black'</l>
<l>            Color := ['#fce9d4','#fce9d4']</l>
<l>            HighlightColor := '#f28d26'</l>
<l>            dev_disp_button (ButtonLabel, ButtonRow, ButtonColumn, TextWidth * 1.2, TextHeight * 1.2, ColorLabels, Color, HighlightColor, WindowHandle, SelectedButton)</l>
<l>            if (SelectedButton == 0)</l>
<l>                wait_seconds (0.1)</l>
<l>            else</l>
<l>                return ()</l>
<l>            endif</l>
<l>        endif</l>
<l>    endfor</l>
<l>else</l>
<l>    read_image (Images, ImageFiles)</l>
<l>endif</l>
<l>return ()</l>
</body>
<docu id="get_dl_classifier_image_results">
<abstract lang="en_US">This procedure can be used to visualize classified ImageFiles according to the specifications given with GenParamName and GenParamValue. The classification success is determined with the given ground truth Labels and PredictedClasses. If the images are to be displayed, a WindowHandle must be given. The selected Images are returned. 

The following parameter values for the generic parameters are available:

* 'label_selection': Only the images with the ground truth labels are displayed and returned, or 'all' images are used. The default is 'all'.
* 'predicted_class_selection': Only the images with the predicted classes (the inferred classes) are displayed and returned, or 'all' images are used. The default is 'all'.
* 'global_selection': Either 'all' images or only the 'erroneously_classified' images can be displayed and returned. The default is 'erroneously_classified'.
* 'display_images': If set to 'false', the images are only returned in Images, not displayed. The default is 'true'.
* 'display_buttons': If set to 'false', you can display the next image with 'Run' (F5). If set to 'true', buttons are displayed to either display the next image or continue with the program. The default is 'false'.</abstract>
<chapters lang="en_US">
<item>Legacy</item>
<item>DL Classification</item>
</chapters>
<library lang="en_US">MVTec Standard Procedures</library>
<short lang="en_US">Display and return the classified images.</short>
<warning lang="en_US">get_dl_classifier_image_results is obsolete and is only provided for reasons of backward compatibility.</warning>
<parameters>
<parameter id="GenParamName">
<description lang="en_US">Name of the generic parameter.</description>
<multivalue>optional</multivalue>
<sem_type>attribute.name</sem_type>
<values>
<item>'label_selection'</item>
<item>'predicted_class_selection'</item>
<item>'global_selection'</item>
<item>'display_images'</item>
<item>'display_buttons'</item>
</values>
</parameter>
<parameter id="GenParamValue">
<description lang="en_US">Value of the generic parameter.</description>
<multivalue>optional</multivalue>
<sem_type>attribute.value</sem_type>
<values>
<item>'all'</item>
<item>'true'</item>
<item>'false'</item>
</values>
</parameter>
<parameter id="GroundTruthLabels">
<default_type>string</default_type>
<description lang="en_US">Ground truth labels of the images.</description>
<multivalue>optional</multivalue>
<sem_type>string</sem_type>
<type_list>
<item>integer</item>
<item>string</item>
</type_list>
</parameter>
<parameter id="ImageFiles">
<default_type>string</default_type>
<description lang="en_US">Tuple of the image paths.</description>
<multivalue>optional</multivalue>
<sem_type>string</sem_type>
<type_list>
<item>string</item>
</type_list>
</parameter>
<parameter id="Images">
<description lang="en_US">The selected images.</description>
<multichannel>optional</multichannel>
<multivalue>optional</multivalue>
<sem_type>image</sem_type>
<type_list>
<item>byte</item>
<item>real</item>
</type_list>
</parameter>
<parameter id="PredictedClasses">
<default_type>string</default_type>
<description lang="en_US">The classes predicted from the classifier.</description>
<multivalue>optional</multivalue>
<sem_type>string</sem_type>
<type_list>
<item>string</item>
</type_list>
</parameter>
<parameter id="WindowHandle">
<default_type>integer</default_type>
<description lang="en_US">Handle of the graphics window.</description>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>window</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
</parameters>
</docu>
</procedure>
<procedure name="get_extent_by_axis" access="local">
<interface>
<ic>
<par name="OM3D" base_type="ctrl" dimension="0"/>
<par name="XExtent" base_type="ctrl" dimension="0"/>
<par name="YExtent" base_type="ctrl" dimension="0"/>
<par name="ZExtent" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="XExtentOut" base_type="ctrl" dimension="0"/>
<par name="YExtentOut" base_type="ctrl" dimension="0"/>
<par name="ZExtentOut" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<l>XExtentOut := XExtent</l>
<l>YExtentOut := YExtent</l>
<l>ZExtentOut := ZExtent</l>
<l>get_object_model_3d_params (OM3D, 'bounding_box1', BB)</l>
<l>for Index := 0 to |BB| / 6 - 1 by 1</l>
<l>    XExtentOut := [XExtentOut,BB[Index * 6],BB[Index * 6 + 3]]</l>
<l>    YExtentOut := [YExtentOut,BB[Index * 6 + 1],BB[Index * 6 + 4]]</l>
<l>    ZExtentOut := [ZExtentOut,BB[Index * 6 + 2],BB[Index * 6 + 5]]</l>
<l>endfor</l>
<l>return ()</l>
</body>
<docu id="get_extent_by_axis">
<chapters lang="de_DE">
<item>3D-Objektmodell</item>
<item>Transformationen</item>
</chapters>
<chapters lang="en_US">
<item>3D Object Model</item>
<item>Transformations</item>
</chapters>
<library lang="en_US">MVTec Standard Procedures</library>
<parameters>
<parameter id="OM3D">
<default_type>integer</default_type>
<mixed_type>false</mixed_type>
<multivalue>true</multivalue>
<sem_type>object_model_3d</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="XExtent">
<default_type>real</default_type>
<multivalue>true</multivalue>
<sem_type>real</sem_type>
<type_list>
<item>real</item>
</type_list>
</parameter>
<parameter id="XExtentOut">
<default_type>real</default_type>
<multivalue>true</multivalue>
<sem_type>real</sem_type>
<type_list>
<item>real</item>
</type_list>
</parameter>
<parameter id="YExtent">
<default_type>real</default_type>
<multivalue>true</multivalue>
<sem_type>real</sem_type>
<type_list>
<item>real</item>
</type_list>
</parameter>
<parameter id="YExtentOut">
<default_type>real</default_type>
<multivalue>true</multivalue>
<sem_type>real</sem_type>
<type_list>
<item>real</item>
</type_list>
</parameter>
<parameter id="ZExtent">
<default_type>real</default_type>
<multivalue>false</multivalue>
<sem_type>real</sem_type>
<type_list>
<item>real</item>
</type_list>
</parameter>
<parameter id="ZExtentOut">
<default_type>real</default_type>
<multivalue>true</multivalue>
<sem_type>real</sem_type>
<type_list>
<item>real</item>
</type_list>
</parameter>
</parameters>
</docu>
</procedure>
<procedure name="get_feature_lengths">
<interface>
<ic>
<par name="FeatureNames" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="Lengths" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c>* </c>
<c>* Calculate the lengths of the feature vectors of</c>
<c>* the features in FeatureNames.</c>
<c>* </c>
<l>gen_dummy_objects (Region, Image)</l>
<l>get_features (Region, Image, FeatureNames, 'get_lengths', Lengths)</l>
<l>return ()</l>
</body>
<docu id="get_feature_lengths">
<abstract lang="en_US">Returns the length of the feature vector for each feature name in FeatureNames.

For more information about the usage of the get_feature_set library, see documentation of calculate_features.</abstract>
<chapters lang="de_DE">
<item>Klassifikation</item>
<item>Sonstiges</item>
</chapters>
<chapters lang="en_US">
<item>Classification</item>
<item>Misc</item>
</chapters>
<keywords lang="en_US">
<item>classification</item>
<item>features</item>
</keywords>
<library lang="en_US">MVTec Standard Procedures</library>
<predecessor>
<item>get_feature_names</item>
</predecessor>
<see_also>
<item>get_feature_names</item>
<item>set_feature_lengths_class_train_data</item>
<item>select_feature_set_knn</item>
<item>select_feature_set_svm</item>
<item>select_feature_set_mlp</item>
</see_also>
<short lang="en_US">Returns the length of the feature vector for each feature name.</short>
<successor>
<item>set_feature_lengths_class_train_data</item>
</successor>
<parameters>
<parameter id="FeatureNames">
<default_type>string</default_type>
<default_value>'area'</default_value>
<description lang="en_US">A list of feature names.</description>
<mixed_type>false</mixed_type>
<multivalue>optional</multivalue>
<sem_type>string</sem_type>
<type_list>
<item>string</item>
</type_list>
<values>
<item>'area'</item>
<item>'width'</item>
<item>'height'</item>
<item>'ra'</item>
<item>'rb'</item>
<item>'phi'</item>
<item>'roundness'</item>
<item>'num_sides'</item>
<item>'num_connected'</item>
<item>'num_holes'</item>
<item>'area_holes'</item>
<item>'max_diameter'</item>
<item>'orientation'</item>
<item>'outer_radius'</item>
<item>'inner_radius'</item>
<item>'inner_width'</item>
<item>'inner_height'</item>
<item>'circularity'</item>
<item>'compactness'</item>
<item>'convexity'</item>
<item>'rectangularity'</item>
<item>'anisometry'</item>
<item>'bulkiness'</item>
<item>'struct_factor'</item>
<item>'dist_mean'</item>
<item>'dist_deviation'</item>
<item>'euler_number'</item>
<item>'rect2_phi'</item>
<item>'rect2_len1'</item>
<item>'rect2_len2'</item>
<item>'contlength'</item>
<item>'porosity'</item>
<item>'gray_area'</item>
<item>'gray_ra'</item>
<item>'gray_rb'</item>
<item>'gray_phi'</item>
<item>'gray_min'</item>
<item>'gray_max'</item>
<item>'gray_range'</item>
<item>'gray_mean'</item>
<item>'gray_deviation'</item>
<item>'gray_plane_deviation'</item>
<item>'gray_anisotropy'</item>
<item>'gray_entropy'</item>
<item>'gray_hor_proj'</item>
<item>'gray_vert_proj'</item>
<item>'gray_hor_proj_histo'</item>
<item>'gray_vert_proj_histo'</item>
<item>'grad_dir_histo'</item>
<item>'edge_density'</item>
<item>'edge_density_histogram'</item>
<item>'edge_density_pyramid_2'</item>
<item>'edge_density_pyramid_3'</item>
<item>'edge_density_pyramid_4'</item>
<item>'edge_density_histogram_pyramid_2'</item>
<item>'edge_density_histogram_pyramid_3'</item>
<item>'edge_density_histogram_pyramid_4'</item>
<item>'cooc'</item>
<item>'cooc_pyramid_2'</item>
<item>'cooc_pyramid_3'</item>
<item>'cooc_pyramid_4'</item>
<item>'polar_gray_proj'</item>
<item>'polar_grad_proj'</item>
<item>'polar_grad_x_proj'</item>
<item>'polar_grad_y_proj'</item>
<item>'polar_gray_proj_histo'</item>
<item>'cielab_mean'</item>
<item>'cielab_dev'</item>
<item>'hls_mean'</item>
<item>'hls_dev'</item>
<item>'rgb_mean'</item>
<item>'rgb_dev'</item>
</values>
</parameter>
<parameter id="Lengths">
<default_type>integer</default_type>
<description lang="en_US">The lengths of the feature vectors.</description>
<mixed_type>false</mixed_type>
<multivalue>optional</multivalue>
<sem_type>integer</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
</parameters>
</docu>
</procedure>
<procedure name="get_feature_names">
<interface>
<ic>
<par name="GroupNames" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="Names" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c>* </c>
<c>* Return all features that belong to</c>
<c>* at least one of the groups in GroupNames</c>
<c>* </c>
<l>gen_dummy_objects (Region, Image)</l>
<l>get_features (Region, Image, GroupNames, 'get_names', Names)</l>
<l>return ()</l>
</body>
<docu id="get_feature_names">
<abstract lang="en_US">Returns a list of feature names that belong to the feature groups given in GroupNames.

For more information about the usage of the get_feature_set library, see documentation of calculate_features.</abstract>
<chapters lang="de_DE">
<item>Klassifikation</item>
<item>Sonstiges</item>
</chapters>
<chapters lang="en_US">
<item>Classification</item>
<item>Misc</item>
</chapters>
<keywords lang="en_US">
<item>classification</item>
<item>features</item>
</keywords>
<library lang="en_US">MVTec Standard Procedures</library>
<predecessor>
<item>query_feature_group_names</item>
<item>query_feature_names_by_group</item>
</predecessor>
<see_also>
<item>get_feature_lengths</item>
<item>query_feature_group_names</item>
<item>query_feature_names_by_group</item>
</see_also>
<short lang="en_US">Returns a list of feature names that belong to the feature groups given in GroupNames.</short>
<successor>
<item>get_feature_lengths</item>
<item>calculate_features</item>
<item>tuple_intersection</item>
<item>tuple_union</item>
</successor>
<parameters>
<parameter id="GroupNames">
<default_type>string</default_type>
<default_value>'region'</default_value>
<description lang="en_US">Name(s) of the feature group(s)</description>
<mixed_type>false</mixed_type>
<multivalue>optional</multivalue>
<sem_type>string</sem_type>
<type_list>
<item>string</item>
</type_list>
<values>
<item>'color'</item>
<item>'gray'</item>
<item>'region'</item>
<item>'rot_invar'</item>
<item>'scale_invar'</item>
<item>'texture'</item>
<item>'all'</item>
</values>
</parameter>
<parameter id="Names">
<default_type>string</default_type>
<description lang="en_US">Names of the features belonging to at least one of the input feature groups</description>
<mixed_type>false</mixed_type>
<multivalue>optional</multivalue>
<sem_type>string</sem_type>
<type_list>
<item>string</item>
</type_list>
</parameter>
</parameters>
</docu>
</procedure>
<procedure name="get_features" access="local">
<interface>
<io>
<par name="Region" base_type="iconic" dimension="0"/>
<par name="Image" base_type="iconic" dimension="0"/>
</io>
<ic>
<par name="Namelist" base_type="ctrl" dimension="0"/>
<par name="Mode" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="Output" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c>* *********************************************************</c>
<c>* Feature procedure</c>
<c>* Contains the names, properties and calculation of</c>
<c>* all supproted features.</c>
<c>* It consists of similar blocks for each feature.</c>
<c>* </c>
<c>* If you like to add your own features, please use</c>
<c>* the external procedure get_custom_features.hdvp</c>
<c>* in the HALCON procedures/templates directory.</c>
<c>* *********************************************************</c>
<c>* </c>
<c>* Insert location of your custom procedure here</c>
<c>* </c>
<l>get_system ('empty_region_result', EmptyRegionResult)</l>
<l>set_system ('empty_region_result', 'true')</l>
<l>AccumulatedResults := []</l>
<l>CustomResults := []</l>
<l>count_obj (Region, NumRegions)</l>
<l>get_image_size (Image, ImageWidth, ImageHeight)</l>
<c>* </c>
<l>for I := 0 to |Namelist| - 1 by 1</l>
<l>    CurrentName := Namelist[I]</l>
<c>    * </c>
<l>    get_custom_features (Region, Image, CurrentName, Mode, CustomResults)</l>
<l>    AccumulatedResults := [AccumulatedResults,CustomResults]</l>
<c>    * </c>
<c>    * </c>
<c>    * ************************************</c>
<c>    * HALCON REGION FEATURES</c>
<c>    * ************************************</c>
<c>    * </c>
<c>    * ************************************</c>
<c>    * BASIC</c>
<c>    * ************************************</c>
<c>    * ** area ***</c>
<l>    Name := 'area'</l>
<l>    Groups := ['region','rot_invar']</l>
<c>    * ****************</c>
<l>    if (Name == CurrentName)</l>
<c>        * ** Calculate feature ***</c>
<l>        area_center (Region, Feature, _, _)</l>
<c>        * *************************</c>
<l>        append_length_or_values (Mode, Feature, AccumulatedResults, ExtendedResults)</l>
<l>        AccumulatedResults := ExtendedResults</l>
<l>    endif</l>
<l>    append_names_or_groups (Mode, Name, Groups, CurrentName, AccumulatedResults, ExtendedResults)</l>
<l>    AccumulatedResults := ExtendedResults</l>
<c>    * ************************************</c>
<c>    * </c>
<c>    * ************************************</c>
<c>    * ** width ***</c>
<l>    Name := 'width'</l>
<l>    Groups := 'region'</l>
<c>    * *************</c>
<l>    if (Name == CurrentName)</l>
<c>        * ** Calculate feature ***</c>
<l>        smallest_rectangle1 (Region, Row1, Column1, Row2, Column2)</l>
<l>        Feature := Column2 - Column1 + 1</l>
<c>        * *************************</c>
<l>        append_length_or_values (Mode, Feature, AccumulatedResults, ExtendedResults)</l>
<l>        AccumulatedResults := ExtendedResults</l>
<l>    endif</l>
<l>    append_names_or_groups (Mode, Name, Groups, CurrentName, AccumulatedResults, ExtendedResults)</l>
<l>    AccumulatedResults := ExtendedResults</l>
<c>    * ************************************</c>
<c>    * </c>
<c>    * ************************************</c>
<c>    * ** height ***</c>
<l>    Name := 'height'</l>
<l>    Groups := 'region'</l>
<c>    * *************</c>
<l>    if (Name == CurrentName)</l>
<c>        * ** Calculate feature ***</c>
<l>        smallest_rectangle1 (Region, Row1, Column1, Row2, Column2)</l>
<l>        Feature := Row2 - Row1 + 1</l>
<c>        * *************************</c>
<l>        append_length_or_values (Mode, Feature, AccumulatedResults, ExtendedResults)</l>
<l>        AccumulatedResults := ExtendedResults</l>
<l>    endif</l>
<l>    append_names_or_groups (Mode, Name, Groups, CurrentName, AccumulatedResults, ExtendedResults)</l>
<l>    AccumulatedResults := ExtendedResults</l>
<c>    * ************************************</c>
<c>    * </c>
<c>    * ************************************</c>
<c>    * ** ra ***</c>
<l>    Name := 'ra'</l>
<l>    Groups := ['region','rot_invar']</l>
<c>    * *************</c>
<l>    if (Name == CurrentName)</l>
<c>        * ** Calculate feature ***</c>
<l>        elliptic_axis (Region, Ra, Rb, Phi)</l>
<l>        Feature := Ra</l>
<c>        * *************************</c>
<l>        append_length_or_values (Mode, Feature, AccumulatedResults, ExtendedResults)</l>
<l>        AccumulatedResults := ExtendedResults</l>
<l>    endif</l>
<l>    append_names_or_groups (Mode, Name, Groups, CurrentName, AccumulatedResults, ExtendedResults)</l>
<l>    AccumulatedResults := ExtendedResults</l>
<c>    * ************************************</c>
<c>    * </c>
<c>    * ************************************</c>
<c>    * ** rb ***</c>
<l>    Name := 'rb'</l>
<l>    Groups := ['region','rot_invar']</l>
<c>    * *************</c>
<l>    if (Name == CurrentName)</l>
<c>        * ** Calculate feature ***</c>
<l>        elliptic_axis (Region, Ra, Rb, Phi)</l>
<l>        Feature := Rb</l>
<c>        * *************************</c>
<l>        append_length_or_values (Mode, Feature, AccumulatedResults, ExtendedResults)</l>
<l>        AccumulatedResults := ExtendedResults</l>
<l>    endif</l>
<l>    append_names_or_groups (Mode, Name, Groups, CurrentName, AccumulatedResults, ExtendedResults)</l>
<l>    AccumulatedResults := ExtendedResults</l>
<c>    * ************************************</c>
<c>    * </c>
<c>    * ************************************</c>
<c>    * ** phi ***</c>
<l>    Name := 'phi'</l>
<l>    Groups := ['region','scale_invar']</l>
<c>    * *************</c>
<l>    if (Name == CurrentName)</l>
<c>        * ** Calculate feature ***</c>
<l>        elliptic_axis (Region, Ra, Rb, Phi)</l>
<l>        Feature := Phi</l>
<c>        * *************************</c>
<l>        append_length_or_values (Mode, Feature, AccumulatedResults, ExtendedResults)</l>
<l>        AccumulatedResults := ExtendedResults</l>
<l>    endif</l>
<l>    append_names_or_groups (Mode, Name, Groups, CurrentName, AccumulatedResults, ExtendedResults)</l>
<l>    AccumulatedResults := ExtendedResults</l>
<c>    * ************************************</c>
<c>    * </c>
<c>    * ************************************</c>
<c>    * ** roundness ***</c>
<l>    Name := 'roundness'</l>
<l>    Groups := ['region','rot_invar','scale_invar']</l>
<c>    * *************</c>
<l>    if (Name == CurrentName)</l>
<c>        * ** Calculate feature ***</c>
<l>        roundness (Region, Distance, Sigma, Roundness, Sides)</l>
<l>        Feature := Roundness</l>
<c>        * *************************</c>
<l>        append_length_or_values (Mode, Feature, AccumulatedResults, ExtendedResults)</l>
<l>        AccumulatedResults := ExtendedResults</l>
<l>    endif</l>
<l>    append_names_or_groups (Mode, Name, Groups, CurrentName, AccumulatedResults, ExtendedResults)</l>
<l>    AccumulatedResults := ExtendedResults</l>
<c>    * ************************************</c>
<c>    * </c>
<c>    * ************************************</c>
<c>    * ** num_sides ***</c>
<l>    Name := 'num_sides'</l>
<l>    Groups := ['region','rot_invar','scale_invar']</l>
<c>    * *************</c>
<l>    if (Name == CurrentName)</l>
<c>        * ** Calculate feature ***</c>
<l>        roundness (Region, Distance, Sigma, Roundness, Sides)</l>
<l>        Feature := Sides</l>
<c>        * *************************</c>
<l>        append_length_or_values (Mode, Feature, AccumulatedResults, ExtendedResults)</l>
<l>        AccumulatedResults := ExtendedResults</l>
<l>    endif</l>
<l>    append_names_or_groups (Mode, Name, Groups, CurrentName, AccumulatedResults, ExtendedResults)</l>
<l>    AccumulatedResults := ExtendedResults</l>
<c>    * ************************************</c>
<c>    * </c>
<c>    * ************************************</c>
<c>    * ** num_connected ***</c>
<l>    Name := 'num_connected'</l>
<l>    Groups := ['region','rot_invar','scale_invar']</l>
<c>    * *************</c>
<l>    if (Name == CurrentName)</l>
<c>        * ** Calculate feature ***</c>
<l>        connect_and_holes (Region, NumConnected, NumHoles)</l>
<l>        Feature := NumConnected</l>
<c>        * *************************</c>
<l>        append_length_or_values (Mode, Feature, AccumulatedResults, ExtendedResults)</l>
<l>        AccumulatedResults := ExtendedResults</l>
<l>    endif</l>
<l>    append_names_or_groups (Mode, Name, Groups, CurrentName, AccumulatedResults, ExtendedResults)</l>
<l>    AccumulatedResults := ExtendedResults</l>
<c>    * ************************************</c>
<c>    * </c>
<c>    * ************************************</c>
<c>    * ** num_holes ***</c>
<l>    Name := 'num_holes'</l>
<l>    Groups := ['region','rot_invar','scale_invar']</l>
<c>    * *************</c>
<l>    if (Name == CurrentName)</l>
<c>        * ** Calculate feature ***</c>
<l>        connect_and_holes (Region, NumConnected, NumHoles)</l>
<l>        Feature := NumHoles</l>
<c>        * *************************</c>
<l>        append_length_or_values (Mode, Feature, AccumulatedResults, ExtendedResults)</l>
<l>        AccumulatedResults := ExtendedResults</l>
<l>    endif</l>
<l>    append_names_or_groups (Mode, Name, Groups, CurrentName, AccumulatedResults, ExtendedResults)</l>
<l>    AccumulatedResults := ExtendedResults</l>
<c>    * ************************************</c>
<c>    * </c>
<c>    * ************************************</c>
<c>    * ** area_holes ***</c>
<l>    Name := 'area_holes'</l>
<l>    Groups := ['region','rot_invar']</l>
<c>    * *************</c>
<l>    if (Name == CurrentName)</l>
<c>        * ** Calculate feature ***</c>
<l>        area_holes (Region, Feature)</l>
<c>        * *************************</c>
<l>        append_length_or_values (Mode, Feature, AccumulatedResults, ExtendedResults)</l>
<l>        AccumulatedResults := ExtendedResults</l>
<l>    endif</l>
<l>    append_names_or_groups (Mode, Name, Groups, CurrentName, AccumulatedResults, ExtendedResults)</l>
<l>    AccumulatedResults := ExtendedResults</l>
<c>    * ************************************</c>
<c>    * </c>
<c>    * ************************************</c>
<c>    * ** max_diameter ***</c>
<l>    Name := 'max_diameter'</l>
<l>    Groups := ['region','rot_invar']</l>
<c>    * *************</c>
<l>    if (Name == CurrentName)</l>
<c>        * ** Calculate feature ***</c>
<l>        diameter_region (Region, Row1, Column1, Row2, Column2, Diameter)</l>
<l>        Feature := Diameter</l>
<c>        * *************************</c>
<l>        append_length_or_values (Mode, Feature, AccumulatedResults, ExtendedResults)</l>
<l>        AccumulatedResults := ExtendedResults</l>
<l>    endif</l>
<l>    append_names_or_groups (Mode, Name, Groups, CurrentName, AccumulatedResults, ExtendedResults)</l>
<l>    AccumulatedResults := ExtendedResults</l>
<c>    * ************************************</c>
<c>    * </c>
<c>    * ************************************</c>
<c>    * ** orientation ***</c>
<l>    Name := 'orientation'</l>
<l>    Groups := ['region','scale_invar']</l>
<c>    * *************</c>
<l>    if (Name == CurrentName)</l>
<c>        * ** Calculate feature ***</c>
<l>        orientation_region (Region, Feature)</l>
<c>        * *************************</c>
<l>        append_length_or_values (Mode, Feature, AccumulatedResults, ExtendedResults)</l>
<l>        AccumulatedResults := ExtendedResults</l>
<l>    endif</l>
<l>    append_names_or_groups (Mode, Name, Groups, CurrentName, AccumulatedResults, ExtendedResults)</l>
<l>    AccumulatedResults := ExtendedResults</l>
<c>    * ************************************</c>
<c>    * </c>
<c>    * ************************************</c>
<c>    * SHAPE</c>
<c>    * ************************************</c>
<c>    * </c>
<c>    * ************************************</c>
<c>    * ** outer_radius ***</c>
<l>    Name := 'outer_radius'</l>
<l>    Groups := ['region','rot_invar']</l>
<c>    * *************</c>
<l>    if (Name == CurrentName)</l>
<c>        * ** Calculate feature ***</c>
<l>        smallest_circle (Region, Row, Column, Feature)</l>
<c>        * *************************</c>
<l>        append_length_or_values (Mode, Feature, AccumulatedResults, ExtendedResults)</l>
<l>        AccumulatedResults := ExtendedResults</l>
<l>    endif</l>
<l>    append_names_or_groups (Mode, Name, Groups, CurrentName, AccumulatedResults, ExtendedResults)</l>
<l>    AccumulatedResults := ExtendedResults</l>
<c>    * ************************************</c>
<c>    * </c>
<c>    * ************************************</c>
<c>    * ** inner_radius ***</c>
<l>    Name := 'inner_radius'</l>
<l>    Groups := ['region','rot_invar']</l>
<c>    * *************</c>
<l>    if (Name == CurrentName)</l>
<c>        * ** Calculate feature ***</c>
<l>        inner_circle (Region, Row, Column, Feature)</l>
<c>        * *************************</c>
<l>        append_length_or_values (Mode, Feature, AccumulatedResults, ExtendedResults)</l>
<l>        AccumulatedResults := ExtendedResults</l>
<l>    endif</l>
<l>    append_names_or_groups (Mode, Name, Groups, CurrentName, AccumulatedResults, ExtendedResults)</l>
<l>    AccumulatedResults := ExtendedResults</l>
<c>    * ************************************</c>
<c>    * </c>
<c>    * ************************************</c>
<c>    * ** inner_width ***</c>
<l>    Name := 'inner_width'</l>
<l>    Groups := 'region'</l>
<c>    * *************</c>
<l>    if (Name == CurrentName)</l>
<c>        * ** Calculate feature ***</c>
<l>        inner_rectangle1 (Region, Row1, Column1, Row2, Column2)</l>
<l>        Feature := Column2 - Column1 + 1</l>
<c>        * *************************</c>
<l>        append_length_or_values (Mode, Feature, AccumulatedResults, ExtendedResults)</l>
<l>        AccumulatedResults := ExtendedResults</l>
<l>    endif</l>
<l>    append_names_or_groups (Mode, Name, Groups, CurrentName, AccumulatedResults, ExtendedResults)</l>
<l>    AccumulatedResults := ExtendedResults</l>
<c>    * ************************************</c>
<c>    * </c>
<c>    * ************************************</c>
<c>    * ** inner_height ***</c>
<l>    Name := 'inner_height'</l>
<l>    Groups := 'region'</l>
<c>    * *************</c>
<l>    if (Name == CurrentName)</l>
<c>        * ** Calculate feature ***</c>
<l>        inner_rectangle1 (Region, Row1, Column1, Row2, Column2)</l>
<l>        Feature := Row2 - Row1 + 1</l>
<c>        * *************************</c>
<l>        append_length_or_values (Mode, Feature, AccumulatedResults, ExtendedResults)</l>
<l>        AccumulatedResults := ExtendedResults</l>
<l>    endif</l>
<l>    append_names_or_groups (Mode, Name, Groups, CurrentName, AccumulatedResults, ExtendedResults)</l>
<l>    AccumulatedResults := ExtendedResults</l>
<c>    * </c>
<c>    * ************************************</c>
<c>    * </c>
<c>    * ************************************</c>
<c>    * ** circularity ***</c>
<l>    Name := 'circularity'</l>
<l>    Groups := ['region','rot_invar','scale_invar']</l>
<c>    * *************</c>
<l>    if (Name == CurrentName)</l>
<c>        * ** Calculate feature ***</c>
<l>        circularity (Region, Feature)</l>
<c>        * *************************</c>
<l>        append_length_or_values (Mode, Feature, AccumulatedResults, ExtendedResults)</l>
<l>        AccumulatedResults := ExtendedResults</l>
<l>    endif</l>
<l>    append_names_or_groups (Mode, Name, Groups, CurrentName, AccumulatedResults, ExtendedResults)</l>
<l>    AccumulatedResults := ExtendedResults</l>
<c>    * </c>
<c>    * ************************************</c>
<c>    * </c>
<c>    * ************************************</c>
<c>    * ** compactness ***</c>
<l>    Name := 'compactness'</l>
<l>    Groups := ['region','rot_invar','scale_invar']</l>
<c>    * *************</c>
<l>    if (Name == CurrentName)</l>
<c>        * ** Calculate feature ***</c>
<l>        compactness (Region, Feature)</l>
<c>        * *************************</c>
<l>        append_length_or_values (Mode, Feature, AccumulatedResults, ExtendedResults)</l>
<l>        AccumulatedResults := ExtendedResults</l>
<l>    endif</l>
<l>    append_names_or_groups (Mode, Name, Groups, CurrentName, AccumulatedResults, ExtendedResults)</l>
<l>    AccumulatedResults := ExtendedResults</l>
<c>    * </c>
<c>    * ************************************</c>
<c>    * </c>
<c>    * ************************************</c>
<c>    * ** convexity ***</c>
<l>    Name := 'convexity'</l>
<l>    Groups := ['region','rot_invar','scale_invar']</l>
<c>    * *************</c>
<l>    if (Name == CurrentName)</l>
<c>        * ** Calculate feature ***</c>
<l>        convexity (Region, Feature)</l>
<c>        * *************************</c>
<l>        append_length_or_values (Mode, Feature, AccumulatedResults, ExtendedResults)</l>
<l>        AccumulatedResults := ExtendedResults</l>
<l>    endif</l>
<l>    append_names_or_groups (Mode, Name, Groups, CurrentName, AccumulatedResults, ExtendedResults)</l>
<l>    AccumulatedResults := ExtendedResults</l>
<c>    * </c>
<c>    * ************************************</c>
<c>    * </c>
<c>    * ************************************</c>
<c>    * ** rectangularity ***</c>
<l>    Name := 'rectangularity'</l>
<l>    Groups := ['region','rot_invar','scale_invar']</l>
<c>    * *************</c>
<l>    if (Name == CurrentName)</l>
<c>        * ** Calculate feature ***</c>
<l>        rectangularity (Region, Feature)</l>
<c>        * *************************</c>
<l>        append_length_or_values (Mode, Feature, AccumulatedResults, ExtendedResults)</l>
<l>        AccumulatedResults := ExtendedResults</l>
<l>    endif</l>
<l>    append_names_or_groups (Mode, Name, Groups, CurrentName, AccumulatedResults, ExtendedResults)</l>
<l>    AccumulatedResults := ExtendedResults</l>
<c>    * </c>
<c>    * ************************************</c>
<c>    * </c>
<c>    * ************************************</c>
<c>    * ** anisometry ***</c>
<l>    Name := 'anisometry'</l>
<l>    Groups := ['region','rot_invar','scale_invar']</l>
<c>    * *************</c>
<l>    if (Name == CurrentName)</l>
<c>        * ** Calculate feature ***</c>
<l>        eccentricity (Region, Anisometry, Bulkiness, StructureFactor)</l>
<l>        Feature := Anisometry</l>
<c>        * *************************</c>
<l>        append_length_or_values (Mode, Feature, AccumulatedResults, ExtendedResults)</l>
<l>        AccumulatedResults := ExtendedResults</l>
<l>    endif</l>
<l>    append_names_or_groups (Mode, Name, Groups, CurrentName, AccumulatedResults, ExtendedResults)</l>
<l>    AccumulatedResults := ExtendedResults</l>
<c>    * </c>
<c>    * ************************************</c>
<c>    * </c>
<c>    * ************************************</c>
<c>    * ** bulkiness ***</c>
<l>    Name := 'bulkiness'</l>
<l>    Groups := ['region','rot_invar','scale_invar']</l>
<c>    * *************</c>
<l>    if (Name == CurrentName)</l>
<c>        * ** Calculate feature ***</c>
<l>        eccentricity (Region, Anisometry, Bulkiness, StructureFactor)</l>
<l>        Feature := Bulkiness</l>
<c>        * *************************</c>
<l>        append_length_or_values (Mode, Feature, AccumulatedResults, ExtendedResults)</l>
<l>        AccumulatedResults := ExtendedResults</l>
<l>    endif</l>
<l>    append_names_or_groups (Mode, Name, Groups, CurrentName, AccumulatedResults, ExtendedResults)</l>
<l>    AccumulatedResults := ExtendedResults</l>
<c>    * </c>
<c>    * ************************************</c>
<c>    * </c>
<c>    * ************************************</c>
<c>    * ** struct_factor ***</c>
<l>    Name := 'struct_factor'</l>
<l>    Groups := ['region','rot_invar','scale_invar']</l>
<c>    * *************</c>
<l>    if (Name == CurrentName)</l>
<c>        * ** Calculate feature ***</c>
<l>        eccentricity (Region, Anisometry, Bulkiness, StructureFactor)</l>
<l>        Feature := StructureFactor</l>
<c>        * *************************</c>
<l>        append_length_or_values (Mode, Feature, AccumulatedResults, ExtendedResults)</l>
<l>        AccumulatedResults := ExtendedResults</l>
<l>    endif</l>
<l>    append_names_or_groups (Mode, Name, Groups, CurrentName, AccumulatedResults, ExtendedResults)</l>
<l>    AccumulatedResults := ExtendedResults</l>
<c>    * </c>
<c>    * ************************************</c>
<c>    * </c>
<c>    * ************************************</c>
<c>    * ** dist_mean ***</c>
<l>    Name := 'dist_mean'</l>
<l>    Groups := ['region','rot_invar']</l>
<c>    * *************</c>
<l>    if (Name == CurrentName)</l>
<c>        * ** Calculate feature ***</c>
<l>        roundness (Region, Distance, Sigma, Roundness, Sides)</l>
<l>        Feature := Distance</l>
<c>        * *************************</c>
<l>        append_length_or_values (Mode, Feature, AccumulatedResults, ExtendedResults)</l>
<l>        AccumulatedResults := ExtendedResults</l>
<l>    endif</l>
<l>    append_names_or_groups (Mode, Name, Groups, CurrentName, AccumulatedResults, ExtendedResults)</l>
<l>    AccumulatedResults := ExtendedResults</l>
<c>    * </c>
<c>    * ************************************</c>
<c>    * </c>
<c>    * ************************************</c>
<c>    * ** dist_deviation ***</c>
<l>    Name := 'dist_deviation'</l>
<l>    Groups := ['region','rot_invar']</l>
<c>    * *************</c>
<l>    if (Name == CurrentName)</l>
<c>        * ** Calculate feature ***</c>
<l>        roundness (Region, Distance, Sigma, Roundness, Sides)</l>
<l>        Feature := Sigma</l>
<c>        * *************************</c>
<l>        append_length_or_values (Mode, Feature, AccumulatedResults, ExtendedResults)</l>
<l>        AccumulatedResults := ExtendedResults</l>
<l>    endif</l>
<l>    append_names_or_groups (Mode, Name, Groups, CurrentName, AccumulatedResults, ExtendedResults)</l>
<l>    AccumulatedResults := ExtendedResults</l>
<c>    * </c>
<c>    * ************************************</c>
<c>    * </c>
<c>    * ************************************</c>
<c>    * ** euler_number ***</c>
<l>    Name := 'euler_number'</l>
<l>    Groups := ['region','rot_invar','scale_invar']</l>
<c>    * *************</c>
<l>    if (Name == CurrentName)</l>
<c>        * ** Calculate feature ***</c>
<l>        euler_number (Region, Feature)</l>
<c>        * *************************</c>
<l>        append_length_or_values (Mode, Feature, AccumulatedResults, ExtendedResults)</l>
<l>        AccumulatedResults := ExtendedResults</l>
<l>    endif</l>
<l>    append_names_or_groups (Mode, Name, Groups, CurrentName, AccumulatedResults, ExtendedResults)</l>
<l>    AccumulatedResults := ExtendedResults</l>
<c>    * </c>
<c>    * ************************************</c>
<c>    * </c>
<c>    * ************************************</c>
<c>    * ** rect2_phi ***</c>
<l>    Name := 'rect2_phi'</l>
<l>    Groups := ['region','scale_invar']</l>
<c>    * *************</c>
<l>    if (Name == CurrentName)</l>
<c>        * ** Calculate feature ***</c>
<l>        smallest_rectangle2 (Region, Row, Column, Phi, Length1, Length2)</l>
<l>        Feature := Phi</l>
<c>        * *************************</c>
<l>        append_length_or_values (Mode, Feature, AccumulatedResults, ExtendedResults)</l>
<l>        AccumulatedResults := ExtendedResults</l>
<l>    endif</l>
<l>    append_names_or_groups (Mode, Name, Groups, CurrentName, AccumulatedResults, ExtendedResults)</l>
<l>    AccumulatedResults := ExtendedResults</l>
<c>    * </c>
<c>    * ************************************</c>
<c>    * </c>
<c>    * ************************************</c>
<c>    * ** rect2_len1 ***</c>
<l>    Name := 'rect2_len1'</l>
<l>    Groups := ['region','rot_invar']</l>
<c>    * *************</c>
<l>    if (Name == CurrentName)</l>
<c>        * ** Calculate feature ***</c>
<l>        smallest_rectangle2 (Region, Row, Column, Phi, Length1, Length2)</l>
<l>        Feature := Length1</l>
<c>        * *************************</c>
<l>        append_length_or_values (Mode, Feature, AccumulatedResults, ExtendedResults)</l>
<l>        AccumulatedResults := ExtendedResults</l>
<l>    endif</l>
<l>    append_names_or_groups (Mode, Name, Groups, CurrentName, AccumulatedResults, ExtendedResults)</l>
<l>    AccumulatedResults := ExtendedResults</l>
<c>    * </c>
<c>    * ************************************</c>
<c>    * </c>
<c>    * ************************************</c>
<c>    * ** rect2_len2 ***</c>
<l>    Name := 'rect2_len2'</l>
<l>    Groups := ['region','rot_invar']</l>
<c>    * *************</c>
<l>    if (Name == CurrentName)</l>
<c>        * ** Calculate feature ***</c>
<l>        smallest_rectangle2 (Region, Row, Column, Phi, Length1, Length2)</l>
<l>        Feature := Length2</l>
<c>        * *************************</c>
<l>        append_length_or_values (Mode, Feature, AccumulatedResults, ExtendedResults)</l>
<l>        AccumulatedResults := ExtendedResults</l>
<l>    endif</l>
<l>    append_names_or_groups (Mode, Name, Groups, CurrentName, AccumulatedResults, ExtendedResults)</l>
<l>    AccumulatedResults := ExtendedResults</l>
<c>    * </c>
<c>    * ************************************</c>
<c>    * </c>
<c>    * ************************************</c>
<c>    * ** contlength ***</c>
<l>    Name := 'contlength'</l>
<l>    Groups := ['region','rot_invar']</l>
<c>    * *************</c>
<l>    if (Name == CurrentName)</l>
<c>        * ** Calculate feature ***</c>
<l>        contlength (Region, ContLength)</l>
<l>        Feature := ContLength</l>
<c>        * *************************</c>
<l>        append_length_or_values (Mode, Feature, AccumulatedResults, ExtendedResults)</l>
<l>        AccumulatedResults := ExtendedResults</l>
<l>    endif</l>
<l>    append_names_or_groups (Mode, Name, Groups, CurrentName, AccumulatedResults, ExtendedResults)</l>
<l>    AccumulatedResults := ExtendedResults</l>
<c>    * </c>
<c>    * ************************************</c>
<c>    * REGION FEATURES</c>
<c>    * ************************************</c>
<c>    * MISC</c>
<c>    * ************************************</c>
<c>    * ** porosity ***</c>
<l>    Name := 'porosity'</l>
<l>    Groups := ['region','rot_invar','scale_invar']</l>
<c>    * *************</c>
<l>    if (Name == CurrentName)</l>
<c>        * ** Calculate feature ***</c>
<l>        area_holes (Region, AreaHoles)</l>
<l>        area_center (Region, Area, Row, Column)</l>
<l>        if (Area == 0)</l>
<l>            Feature := 0.0</l>
<l>        else</l>
<l>            Feature := real(AreaHoles) / (Area + AreaHoles)</l>
<l>        endif</l>
<c>        * *************************</c>
<l>        append_length_or_values (Mode, Feature, AccumulatedResults, ExtendedResults)</l>
<l>        AccumulatedResults := ExtendedResults</l>
<l>    endif</l>
<l>    append_names_or_groups (Mode, Name, Groups, CurrentName, AccumulatedResults, ExtendedResults)</l>
<l>    AccumulatedResults := ExtendedResults</l>
<c>    * </c>
<c>    * ************************************</c>
<c>    * HALCON GRAY VALUE FEATURES</c>
<c>    * ************************************</c>
<c>    * BASIC</c>
<c>    * ************************************</c>
<c>    * </c>
<c>    * ** gray_area ***</c>
<l>    Name := 'gray_area'</l>
<l>    Groups := ['gray','rot_invar']</l>
<c>    * ****************</c>
<l>    if (Name == CurrentName)</l>
<c>        * ** Calculate feature ***</c>
<l>        area_center_gray (Region, Image, Area, Row, Column)</l>
<l>        Feature := Area</l>
<c>        * *************************</c>
<l>        append_length_or_values (Mode, Feature, AccumulatedResults, ExtendedResults)</l>
<l>        AccumulatedResults := ExtendedResults</l>
<l>    endif</l>
<l>    append_names_or_groups (Mode, Name, Groups, CurrentName, AccumulatedResults, ExtendedResults)</l>
<l>    AccumulatedResults := ExtendedResults</l>
<c>    * ************************************</c>
<c>    * </c>
<c>    * ************************************</c>
<c>    * ** gray_ra ***</c>
<l>    Name := 'gray_ra'</l>
<l>    Groups := ['gray','rot_invar']</l>
<c>    * ****************</c>
<l>    if (Name == CurrentName)</l>
<c>        * ** Calculate feature ***</c>
<l>        elliptic_axis_gray (Region, Image, Ra, Rb, Phi)</l>
<l>        Feature := Ra</l>
<c>        * *************************</c>
<l>        append_length_or_values (Mode, Feature, AccumulatedResults, ExtendedResults)</l>
<l>        AccumulatedResults := ExtendedResults</l>
<l>    endif</l>
<l>    append_names_or_groups (Mode, Name, Groups, CurrentName, AccumulatedResults, ExtendedResults)</l>
<l>    AccumulatedResults := ExtendedResults</l>
<c>    * ************************************</c>
<c>    * </c>
<c>    * ************************************</c>
<c>    * ** gray_rb ***</c>
<l>    Name := 'gray_rb'</l>
<l>    Groups := ['gray','rot_invar']</l>
<c>    * ****************</c>
<l>    if (Name == CurrentName)</l>
<c>        * ** Calculate feature ***</c>
<l>        elliptic_axis_gray (Region, Image, Ra, Rb, Phi)</l>
<l>        Feature := Rb</l>
<c>        * *************************</c>
<l>        append_length_or_values (Mode, Feature, AccumulatedResults, ExtendedResults)</l>
<l>        AccumulatedResults := ExtendedResults</l>
<l>    endif</l>
<l>    append_names_or_groups (Mode, Name, Groups, CurrentName, AccumulatedResults, ExtendedResults)</l>
<l>    AccumulatedResults := ExtendedResults</l>
<c>    * ************************************</c>
<c>    * </c>
<c>    * ************************************</c>
<c>    * ** gray_phi ***</c>
<l>    Name := 'gray_phi'</l>
<l>    Groups := ['gray','scale_invar']</l>
<c>    * ****************</c>
<l>    if (Name == CurrentName)</l>
<c>        * ** Calculate feature ***</c>
<l>        elliptic_axis_gray (Region, Image, Ra, Rb, Phi)</l>
<l>        Feature := Phi</l>
<c>        * *************************</c>
<l>        append_length_or_values (Mode, Feature, AccumulatedResults, ExtendedResults)</l>
<l>        AccumulatedResults := ExtendedResults</l>
<l>    endif</l>
<l>    append_names_or_groups (Mode, Name, Groups, CurrentName, AccumulatedResults, ExtendedResults)</l>
<l>    AccumulatedResults := ExtendedResults</l>
<c>    * ************************************</c>
<c>    * </c>
<c>    * ************************************</c>
<c>    * ** gray_min ***</c>
<l>    Name := 'gray_min'</l>
<l>    Groups := ['gray','rot_invar','scale_invar']</l>
<c>    * ****************</c>
<l>    if (Name == CurrentName)</l>
<c>        * ** Calculate feature ***</c>
<l>        min_max_gray (Region, Image, 0, Min, Max, Range)</l>
<l>        Feature := Min</l>
<c>        * *************************</c>
<l>        append_length_or_values (Mode, Feature, AccumulatedResults, ExtendedResults)</l>
<l>        AccumulatedResults := ExtendedResults</l>
<l>    endif</l>
<l>    append_names_or_groups (Mode, Name, Groups, CurrentName, AccumulatedResults, ExtendedResults)</l>
<l>    AccumulatedResults := ExtendedResults</l>
<c>    * ************************************</c>
<c>    * </c>
<c>    * ************************************</c>
<c>    * ** gray_max ***</c>
<l>    Name := 'gray_max'</l>
<l>    Groups := ['gray','rot_invar','scale_invar']</l>
<c>    * ****************</c>
<l>    if (Name == CurrentName)</l>
<c>        * ** Calculate feature ***</c>
<l>        min_max_gray (Region, Image, 0, Min, Max, Range)</l>
<l>        Feature := Max</l>
<c>        * *************************</c>
<l>        append_length_or_values (Mode, Feature, AccumulatedResults, ExtendedResults)</l>
<l>        AccumulatedResults := ExtendedResults</l>
<l>    endif</l>
<l>    append_names_or_groups (Mode, Name, Groups, CurrentName, AccumulatedResults, ExtendedResults)</l>
<l>    AccumulatedResults := ExtendedResults</l>
<c>    * ************************************</c>
<c>    * </c>
<c>    * ************************************</c>
<c>    * ** gray_range ***</c>
<l>    Name := 'gray_range'</l>
<l>    Groups := ['gray','rot_invar','scale_invar']</l>
<c>    * ****************</c>
<l>    if (Name == CurrentName)</l>
<c>        * ** Calculate feature ***</c>
<l>        min_max_gray (Region, Image, 0, Min, Max, Range)</l>
<l>        Feature := Range</l>
<c>        * *************************</c>
<l>        append_length_or_values (Mode, Feature, AccumulatedResults, ExtendedResults)</l>
<l>        AccumulatedResults := ExtendedResults</l>
<l>    endif</l>
<l>    append_names_or_groups (Mode, Name, Groups, CurrentName, AccumulatedResults, ExtendedResults)</l>
<l>    AccumulatedResults := ExtendedResults</l>
<c>    * ************************************</c>
<c>    * </c>
<c>    * ************************************</c>
<c>    * TEXTURE</c>
<c>    * ************************************</c>
<c>    * </c>
<c>    * ************************************</c>
<c>    * ** gray_mean ***</c>
<l>    Name := 'gray_mean'</l>
<l>    Groups := ['gray','texture','rot_invar','scale_invar']</l>
<c>    * ****************</c>
<l>    if (Name == CurrentName)</l>
<c>        * ** Calculate feature ***</c>
<l>        intensity (Region, Image, Mean, Deviation)</l>
<l>        Feature := Mean</l>
<c>        * *************************</c>
<l>        append_length_or_values (Mode, Feature, AccumulatedResults, ExtendedResults)</l>
<l>        AccumulatedResults := ExtendedResults</l>
<l>    endif</l>
<l>    append_names_or_groups (Mode, Name, Groups, CurrentName, AccumulatedResults, ExtendedResults)</l>
<l>    AccumulatedResults := ExtendedResults</l>
<c>    * ************************************</c>
<c>    * </c>
<c>    * ************************************</c>
<c>    * ** gray_deviation ***</c>
<l>    Name := 'gray_deviation'</l>
<l>    Groups := ['gray','texture','rot_invar','scale_invar']</l>
<c>    * ****************</c>
<l>    if (Name == CurrentName)</l>
<c>        * ** Calculate feature ***</c>
<l>        intensity (Region, Image, Mean, Deviation)</l>
<l>        Feature := Deviation</l>
<c>        * *************************</c>
<l>        append_length_or_values (Mode, Feature, AccumulatedResults, ExtendedResults)</l>
<l>        AccumulatedResults := ExtendedResults</l>
<l>    endif</l>
<l>    append_names_or_groups (Mode, Name, Groups, CurrentName, AccumulatedResults, ExtendedResults)</l>
<l>    AccumulatedResults := ExtendedResults</l>
<c>    * ************************************</c>
<c>    * </c>
<c>    * ************************************</c>
<c>    * ** gray_plane_deviation ***</c>
<l>    Name := 'gray_plane_deviation'</l>
<l>    Groups := ['gray','texture','rot_invar','scale_invar']</l>
<c>    * ****************</c>
<l>    if (Name == CurrentName)</l>
<c>        * ** Calculate feature ***</c>
<l>        plane_deviation (Region, Image, Feature)</l>
<c>        * *************************</c>
<l>        append_length_or_values (Mode, Feature, AccumulatedResults, ExtendedResults)</l>
<l>        AccumulatedResults := ExtendedResults</l>
<l>    endif</l>
<l>    append_names_or_groups (Mode, Name, Groups, CurrentName, AccumulatedResults, ExtendedResults)</l>
<l>    AccumulatedResults := ExtendedResults</l>
<c>    * ************************************</c>
<c>    * </c>
<c>    * ************************************</c>
<c>    * ** gray_anisotropy ***</c>
<l>    Name := 'gray_anisotropy'</l>
<l>    Groups := ['gray','texture','rot_invar','scale_invar']</l>
<c>    * ****************</c>
<l>    if (Name == CurrentName)</l>
<c>        * ** Calculate feature ***</c>
<l>        entropy_gray (Region, Image, Entropy, Anisotropy)</l>
<l>        Feature := Anisotropy</l>
<c>        * *************************</c>
<l>        append_length_or_values (Mode, Feature, AccumulatedResults, ExtendedResults)</l>
<l>        AccumulatedResults := ExtendedResults</l>
<l>    endif</l>
<l>    append_names_or_groups (Mode, Name, Groups, CurrentName, AccumulatedResults, ExtendedResults)</l>
<l>    AccumulatedResults := ExtendedResults</l>
<c>    * ************************************</c>
<c>    * </c>
<c>    * ************************************</c>
<c>    * ** gray_entropy ***</c>
<l>    Name := 'gray_entropy'</l>
<l>    Groups := ['gray','texture','rot_invar','scale_invar']</l>
<c>    * ****************</c>
<l>    if (Name == CurrentName)</l>
<c>        * ** Calculate feature ***</c>
<l>        entropy_gray (Region, Image, Entropy, Anisotropy)</l>
<l>        Feature := Entropy</l>
<c>        * *************************</c>
<l>        append_length_or_values (Mode, Feature, AccumulatedResults, ExtendedResults)</l>
<l>        AccumulatedResults := ExtendedResults</l>
<l>    endif</l>
<l>    append_names_or_groups (Mode, Name, Groups, CurrentName, AccumulatedResults, ExtendedResults)</l>
<l>    AccumulatedResults := ExtendedResults</l>
<c>    * ************************************</c>
<c>    * </c>
<c>    * ************************************</c>
<c>    * ** gray_hor_proj ***</c>
<l>    Name := 'gray_hor_proj'</l>
<l>    Groups := ['gray','texture','scale_invar']</l>
<c>    * ****************</c>
<l>    if (Name == CurrentName)</l>
<c>        * ** Calculate feature ***</c>
<l>        Size := 20</l>
<l>        calc_feature_gray_proj (Region, Image, 'hor', Size, Feature)</l>
<c>        * *************************</c>
<l>        append_length_or_values (Mode, Feature, AccumulatedResults, ExtendedResults)</l>
<l>        AccumulatedResults := ExtendedResults</l>
<l>    endif</l>
<l>    append_names_or_groups (Mode, Name, Groups, CurrentName, AccumulatedResults, ExtendedResults)</l>
<l>    AccumulatedResults := ExtendedResults</l>
<c>    * ************************************</c>
<c>    * </c>
<c>    * ************************************</c>
<c>    * ** gray_vert_proj ***</c>
<l>    Name := 'gray_vert_proj'</l>
<l>    Groups := ['gray','texture','scale_invar']</l>
<c>    * ****************</c>
<l>    if (Name == CurrentName)</l>
<c>        * ** Calculate feature ***</c>
<l>        Size := 20</l>
<l>        calc_feature_gray_proj (Region, Image, 'vert', Size, Feature)</l>
<c>        * *************************</c>
<l>        append_length_or_values (Mode, Feature, AccumulatedResults, ExtendedResults)</l>
<l>        AccumulatedResults := ExtendedResults</l>
<l>    endif</l>
<l>    append_names_or_groups (Mode, Name, Groups, CurrentName, AccumulatedResults, ExtendedResults)</l>
<l>    AccumulatedResults := ExtendedResults</l>
<c>    * ************************************</c>
<c>    * </c>
<c>    * ************************************</c>
<c>    * ** gray_hor_proj_histo ***</c>
<l>    Name := 'gray_hor_proj_histo'</l>
<l>    Groups := ['gray','texture','scale_invar']</l>
<c>    * ****************</c>
<l>    if (Name == CurrentName)</l>
<c>        * ** Calculate feature ***</c>
<l>        Size := 20</l>
<l>        calc_feature_gray_proj (Region, Image, 'hor_histo', Size, Feature)</l>
<c>        * *************************</c>
<l>        append_length_or_values (Mode, Feature, AccumulatedResults, ExtendedResults)</l>
<l>        AccumulatedResults := ExtendedResults</l>
<l>    endif</l>
<l>    append_names_or_groups (Mode, Name, Groups, CurrentName, AccumulatedResults, ExtendedResults)</l>
<l>    AccumulatedResults := ExtendedResults</l>
<c>    * ************************************</c>
<c>    * </c>
<c>    * ************************************</c>
<c>    * ** gray_vert_proj_histo ***</c>
<l>    Name := 'gray_vert_proj_histo'</l>
<l>    Groups := ['gray','texture','scale_invar']</l>
<c>    * ****************</c>
<l>    if (Name == CurrentName)</l>
<c>        * ** Calculate feature ***</c>
<l>        Size := 20</l>
<l>        calc_feature_gray_proj (Region, Image, 'vert_histo', Size, Feature)</l>
<c>        * *************************</c>
<l>        append_length_or_values (Mode, Feature, AccumulatedResults, ExtendedResults)</l>
<l>        AccumulatedResults := ExtendedResults</l>
<l>    endif</l>
<l>    append_names_or_groups (Mode, Name, Groups, CurrentName, AccumulatedResults, ExtendedResults)</l>
<l>    AccumulatedResults := ExtendedResults</l>
<c>    * ************************************</c>
<c>    * </c>
<c>    * ************************************</c>
<c>    * ** grad_dir_histo ***</c>
<l>    Name := 'grad_dir_histo'</l>
<l>    Groups := ['gray','texture']</l>
<c>    * ****************</c>
<l>    if (Name == CurrentName)</l>
<c>        * ** Calculate feature ***</c>
<l>        NumBins := 20</l>
<l>        calc_feature_grad_dir_histo (Region, Image, NumBins, Feature)</l>
<c>        * *************************</c>
<l>        append_length_or_values (Mode, Feature, AccumulatedResults, ExtendedResults)</l>
<l>        AccumulatedResults := ExtendedResults</l>
<l>    endif</l>
<l>    append_names_or_groups (Mode, Name, Groups, CurrentName, AccumulatedResults, ExtendedResults)</l>
<l>    AccumulatedResults := ExtendedResults</l>
<c>    * ************************************</c>
<c>    * </c>
<c>    * ************************************</c>
<c>    * ** edge_density ***</c>
<l>    Name := 'edge_density'</l>
<l>    Groups := ['gray','texture','rot_invar','scale_invar']</l>
<c>    * ****************</c>
<l>    if (Name == CurrentName)</l>
<c>        * ** Calculate feature ***</c>
<l>        calc_feature_edge_density (Region, Image, Feature)</l>
<c>        * *************************</c>
<l>        append_length_or_values (Mode, Feature, AccumulatedResults, ExtendedResults)</l>
<l>        AccumulatedResults := ExtendedResults</l>
<l>    endif</l>
<l>    append_names_or_groups (Mode, Name, Groups, CurrentName, AccumulatedResults, ExtendedResults)</l>
<l>    AccumulatedResults := ExtendedResults</l>
<c>    * </c>
<c>    * ************************************</c>
<c>    * </c>
<c>    * ************************************</c>
<c>    * ** edge_density_histogram ***</c>
<l>    Name := 'edge_density_histogram'</l>
<l>    Groups := ['gray','texture','rot_invar','scale_invar']</l>
<c>    * ****************</c>
<l>    if (Name == CurrentName)</l>
<c>        * ** Calculate feature ***</c>
<l>        NumBins := 4</l>
<l>        calc_feature_edge_density_histogram (Region, Image, NumBins, Feature)</l>
<c>        * *************************</c>
<l>        append_length_or_values (Mode, Feature, AccumulatedResults, ExtendedResults)</l>
<l>        AccumulatedResults := ExtendedResults</l>
<l>    endif</l>
<l>    append_names_or_groups (Mode, Name, Groups, CurrentName, AccumulatedResults, ExtendedResults)</l>
<l>    AccumulatedResults := ExtendedResults</l>
<c>    * </c>
<c>    * ************************************</c>
<c>    * </c>
<c>    * ************************************</c>
<c>    * ** edge_density_pyramid ***</c>
<l>    NameRegExp := 'edge_density_pyramid_([234])'</l>
<l>    Names := 'edge_density_pyramid_' + [2:4]</l>
<l>    Groups := ['gray','texture','rot_invar','scale_invar']</l>
<c>    * ****************</c>
<l>    if (CurrentName =~ NameRegExp)</l>
<c>        * ** Calculate feature ***</c>
<l>        NumPyramids := number(regexp_match(CurrentName,NameRegExp))</l>
<l>        calc_feature_pyramid (Region, Image, 'edge_density', NumPyramids, Feature)</l>
<c>        * *************************</c>
<l>        append_length_or_values (Mode, Feature, AccumulatedResults, ExtendedResults)</l>
<l>        AccumulatedResults := ExtendedResults</l>
<l>    endif</l>
<l>    append_names_or_groups_pyramid (Mode, Groups, CurrentName, Names, NameRegExp, AccumulatedResults, ExtendedResults)</l>
<l>    AccumulatedResults := ExtendedResults</l>
<c>    * </c>
<c>    * ************************************</c>
<c>    * </c>
<c>    * ************************************</c>
<c>    * ** edge_density_histogram_pyramid ***</c>
<l>    NameRegExp := 'edge_density_histogram_pyramid_([234])'</l>
<l>    Names := 'edge_density_histogram_pyramid_' + [2:4]</l>
<l>    Groups := ['gray','texture','rot_invar','scale_invar']</l>
<c>    * ****************</c>
<l>    if (CurrentName =~ NameRegExp)</l>
<c>        * ** Calculate feature ***</c>
<l>        NumPyramids := number(regexp_match(CurrentName,NameRegExp))</l>
<l>        calc_feature_pyramid (Region, Image, 'edge_density_histogram', NumPyramids, Feature)</l>
<c>        * *************************</c>
<l>        append_length_or_values (Mode, Feature, AccumulatedResults, ExtendedResults)</l>
<l>        AccumulatedResults := ExtendedResults</l>
<l>    endif</l>
<l>    append_names_or_groups_pyramid (Mode, Groups, CurrentName, Names, NameRegExp, AccumulatedResults, ExtendedResults)</l>
<l>    AccumulatedResults := ExtendedResults</l>
<c>    * </c>
<c>    * ************************************</c>
<c>    * </c>
<c>    * ************************************</c>
<c>    * ** cooc ***</c>
<l>    Name := 'cooc'</l>
<l>    Groups := ['gray','texture']</l>
<c>    * ****************</c>
<l>    if (Name == CurrentName)</l>
<c>        * ** Calculate feature ***</c>
<l>        Feature := []</l>
<l>        cooc_feature_image (Region, Image, 6, 0, Energy, Correlation, Homogeneity, Contrast)</l>
<l>        if (NumRegions &gt; 0)</l>
<l>            Index := [0:4:4 * NumRegions - 1]</l>
<l>            Feature[Index] := Energy</l>
<l>            Feature[1 + Index] := Correlation</l>
<l>            Feature[2 + Index] := Homogeneity</l>
<l>            Feature[3 + Index] := Contrast</l>
<l>        endif</l>
<c>        * *************************</c>
<l>        append_length_or_values (Mode, Feature, AccumulatedResults, ExtendedResults)</l>
<l>        AccumulatedResults := ExtendedResults</l>
<l>    endif</l>
<l>    append_names_or_groups (Mode, Name, Groups, CurrentName, AccumulatedResults, ExtendedResults)</l>
<l>    AccumulatedResults := ExtendedResults</l>
<c>    * ************************************</c>
<c>    * </c>
<c>    * ************************************</c>
<c>    * ** cooc_pyramid ***</c>
<l>    NameRegExp := 'cooc_pyramid_([234])'</l>
<l>    Names := 'cooc_pyramid_' + [2:4]</l>
<l>    Groups := ['gray','texture']</l>
<c>    * ****************</c>
<l>    if (CurrentName =~ NameRegExp)</l>
<c>        * ** Calculate feature ***</c>
<l>        NumPyramids := number(regexp_match(CurrentName,NameRegExp))</l>
<l>        calc_feature_pyramid (Region, Image, 'cooc', NumPyramids, Feature)</l>
<c>        * *************************</c>
<l>        append_length_or_values (Mode, Feature, AccumulatedResults, ExtendedResults)</l>
<l>        AccumulatedResults := ExtendedResults</l>
<l>    endif</l>
<l>    append_names_or_groups_pyramid (Mode, Groups, CurrentName, Names, NameRegExp, AccumulatedResults, ExtendedResults)</l>
<l>    AccumulatedResults := ExtendedResults</l>
<c>    * </c>
<c>    * ************************************</c>
<c>    * </c>
<c>    * ************************************</c>
<c>    * POLAR TRANSFORM FEATURES</c>
<c>    * ************************************</c>
<c>    * </c>
<c>    * ************************************</c>
<c>    * ** polar_gray_proj ***</c>
<l>    Name := 'polar_gray_proj'</l>
<l>    Groups := ['gray','rot_invar','scale_invar']</l>
<c>    * *************</c>
<l>    if (Name == CurrentName)</l>
<c>        * ** Calculate feature ***</c>
<l>        Width := 100</l>
<l>        Height := 40</l>
<l>        calc_feature_polar_gray_proj (Region, Image, 'hor_gray', Width, Height, Feature)</l>
<c>        * *************************</c>
<l>        append_length_or_values (Mode, Feature, AccumulatedResults, ExtendedResults)</l>
<l>        AccumulatedResults := ExtendedResults</l>
<l>    endif</l>
<l>    append_names_or_groups (Mode, Name, Groups, CurrentName, AccumulatedResults, ExtendedResults)</l>
<l>    AccumulatedResults := ExtendedResults</l>
<c>    * ************************************</c>
<c>    * </c>
<c>    * ************************************</c>
<c>    * ** polar_grad_proj ***</c>
<l>    Name := 'polar_grad_proj'</l>
<l>    Groups := ['gray','rot_invar','scale_invar']</l>
<c>    * *************</c>
<l>    if (Name == CurrentName)</l>
<c>        * ** Calculate feature ***</c>
<l>        Width := 100</l>
<l>        Height := 40</l>
<l>        calc_feature_polar_gray_proj (Region, Image, 'hor_sobel_amp', Width, Height, Feature)</l>
<c>        * *************************</c>
<l>        append_length_or_values (Mode, Feature, AccumulatedResults, ExtendedResults)</l>
<l>        AccumulatedResults := ExtendedResults</l>
<l>    endif</l>
<l>    append_names_or_groups (Mode, Name, Groups, CurrentName, AccumulatedResults, ExtendedResults)</l>
<l>    AccumulatedResults := ExtendedResults</l>
<c>    * ************************************</c>
<c>    * </c>
<c>    * ************************************</c>
<c>    * ** polar_grad_x_proj ***</c>
<l>    Name := 'polar_grad_x_proj'</l>
<l>    Groups := ['gray','rot_invar','scale_invar']</l>
<c>    * *************</c>
<l>    if (Name == CurrentName)</l>
<c>        * ** Calculate feature ***</c>
<l>        Width := 100</l>
<l>        Height := 40</l>
<l>        calc_feature_polar_gray_proj (Region, Image, 'hor_sobel_x', Width, Height, Feature)</l>
<c>        * *************************</c>
<l>        append_length_or_values (Mode, Feature, AccumulatedResults, ExtendedResults)</l>
<l>        AccumulatedResults := ExtendedResults</l>
<l>    endif</l>
<l>    append_names_or_groups (Mode, Name, Groups, CurrentName, AccumulatedResults, ExtendedResults)</l>
<l>    AccumulatedResults := ExtendedResults</l>
<c>    * ************************************</c>
<c>    * </c>
<c>    * ************************************</c>
<c>    * ** polar_grad_y_proj ***</c>
<l>    Name := 'polar_grad_y_proj'</l>
<l>    Groups := ['gray','rot_invar','scale_invar']</l>
<c>    * *************</c>
<l>    if (Name == CurrentName)</l>
<c>        * ** Calculate feature ***</c>
<l>        Width := 100</l>
<l>        Height := 40</l>
<l>        calc_feature_polar_gray_proj (Region, Image, 'hor_sobel_y', Width, Height, Feature)</l>
<c>        * *************************</c>
<l>        append_length_or_values (Mode, Feature, AccumulatedResults, ExtendedResults)</l>
<l>        AccumulatedResults := ExtendedResults</l>
<l>    endif</l>
<l>    append_names_or_groups (Mode, Name, Groups, CurrentName, AccumulatedResults, ExtendedResults)</l>
<l>    AccumulatedResults := ExtendedResults</l>
<c>    * ************************************</c>
<c>    * </c>
<c>    * ************************************</c>
<c>    * ** polar_gray_proj_histo ***</c>
<l>    Name := 'polar_gray_proj_histo'</l>
<l>    Groups := ['gray','rot_invar','scale_invar']</l>
<c>    * *************</c>
<l>    if (Name == CurrentName)</l>
<c>        * ** Calculate feature ***</c>
<l>        Width := 100</l>
<l>        Height := 40</l>
<l>        calc_feature_polar_gray_proj (Region, Image, 'vert_gray', Width, Height, Projection)</l>
<l>        NumBins := 20</l>
<l>        Feature := []</l>
<l>        for Index := 1 to NumRegions by 1</l>
<l>            Start := (Index - 1) * Width</l>
<l>            tuple_histo_range (Projection[Start:Start + Width - 1], 0, 255, NumBins, Histo, BinSize)</l>
<l>            Feature := [Feature,Histo]</l>
<l>        endfor</l>
<c>        * *************************</c>
<l>        append_length_or_values (Mode, Feature, AccumulatedResults, ExtendedResults)</l>
<l>        AccumulatedResults := ExtendedResults</l>
<l>    endif</l>
<l>    append_names_or_groups (Mode, Name, Groups, CurrentName, AccumulatedResults, ExtendedResults)</l>
<l>    AccumulatedResults := ExtendedResults</l>
<c>    * ************************************</c>
<c>    * </c>
<c>    * ************************************</c>
<c>    * COLOR FEATURES</c>
<c>    * ************************************</c>
<c>    * </c>
<c>    * ************************************</c>
<c>    * ** cielab_mean ***</c>
<l>    Name := 'cielab_mean'</l>
<l>    Groups := 'color'</l>
<c>    * *************</c>
<l>    if (Name == CurrentName)</l>
<c>        * ** Calculate feature ***</c>
<l>        calc_feature_color_intensity (Region, Image, 'cielab', 'mean', Feature)</l>
<c>        * *************************</c>
<l>        append_length_or_values (Mode, Feature, AccumulatedResults, ExtendedResults)</l>
<l>        AccumulatedResults := ExtendedResults</l>
<l>    endif</l>
<l>    append_names_or_groups (Mode, Name, Groups, CurrentName, AccumulatedResults, ExtendedResults)</l>
<l>    AccumulatedResults := ExtendedResults</l>
<c>    * ************************************</c>
<c>    * </c>
<c>    * ************************************</c>
<c>    * ** cielab_dev ***</c>
<l>    Name := 'cielab_dev'</l>
<l>    Groups := 'color'</l>
<c>    * *************</c>
<l>    if (Name == CurrentName)</l>
<c>        * ** Calculate feature ***</c>
<l>        calc_feature_color_intensity (Region, Image, 'cielab', 'deviation', Feature)</l>
<c>        * *************************</c>
<l>        append_length_or_values (Mode, Feature, AccumulatedResults, ExtendedResults)</l>
<l>        AccumulatedResults := ExtendedResults</l>
<l>    endif</l>
<l>    append_names_or_groups (Mode, Name, Groups, CurrentName, AccumulatedResults, ExtendedResults)</l>
<l>    AccumulatedResults := ExtendedResults</l>
<c>    * ************************************</c>
<c>    * </c>
<c>    * ************************************</c>
<c>    * ** hls_mean ***</c>
<l>    Name := 'hls_mean'</l>
<l>    Groups := 'color'</l>
<c>    * *************</c>
<l>    if (Name == CurrentName)</l>
<c>        * ** Calculate feature ***</c>
<l>        calc_feature_color_intensity (Region, Image, 'hls', 'mean', Feature)</l>
<c>        * *************************</c>
<l>        append_length_or_values (Mode, Feature, AccumulatedResults, ExtendedResults)</l>
<l>        AccumulatedResults := ExtendedResults</l>
<l>    endif</l>
<l>    append_names_or_groups (Mode, Name, Groups, CurrentName, AccumulatedResults, ExtendedResults)</l>
<l>    AccumulatedResults := ExtendedResults</l>
<c>    * ************************************</c>
<c>    * </c>
<c>    * ************************************</c>
<c>    * ** hls_dev ***</c>
<l>    Name := 'hls_dev'</l>
<l>    Groups := 'color'</l>
<c>    * *************</c>
<l>    if (Name == CurrentName)</l>
<c>        * ** Calculate feature ***</c>
<l>        calc_feature_color_intensity (Region, Image, 'hls', 'deviation', Feature)</l>
<c>        * *************************</c>
<l>        append_length_or_values (Mode, Feature, AccumulatedResults, ExtendedResults)</l>
<l>        AccumulatedResults := ExtendedResults</l>
<l>    endif</l>
<l>    append_names_or_groups (Mode, Name, Groups, CurrentName, AccumulatedResults, ExtendedResults)</l>
<l>    AccumulatedResults := ExtendedResults</l>
<c>    * ************************************</c>
<c>    * </c>
<c>    * ************************************</c>
<c>    * ** rgb_mean ***</c>
<l>    Name := 'rgb_mean'</l>
<l>    Groups := 'color'</l>
<c>    * *************</c>
<l>    if (Name == CurrentName)</l>
<c>        * ** Calculate feature ***</c>
<l>        calc_feature_color_intensity (Region, Image, 'rgb', 'mean', Feature)</l>
<c>        * *************************</c>
<l>        append_length_or_values (Mode, Feature, AccumulatedResults, ExtendedResults)</l>
<l>        AccumulatedResults := ExtendedResults</l>
<l>    endif</l>
<l>    append_names_or_groups (Mode, Name, Groups, CurrentName, AccumulatedResults, ExtendedResults)</l>
<l>    AccumulatedResults := ExtendedResults</l>
<c>    * ************************************</c>
<c>    * </c>
<c>    * ************************************</c>
<c>    * ** rgb_dev ***</c>
<l>    Name := 'rgb_dev'</l>
<l>    Groups := 'color'</l>
<c>    * *************</c>
<l>    if (Name == CurrentName)</l>
<c>        * ** Calculate feature ***</c>
<l>        calc_feature_color_intensity (Region, Image, 'rgb', 'deviation', Feature)</l>
<c>        * *************************</c>
<l>        append_length_or_values (Mode, Feature, AccumulatedResults, ExtendedResults)</l>
<l>        AccumulatedResults := ExtendedResults</l>
<l>    endif</l>
<l>    append_names_or_groups (Mode, Name, Groups, CurrentName, AccumulatedResults, ExtendedResults)</l>
<l>    AccumulatedResults := ExtendedResults</l>
<l>endfor</l>
<l>Output := AccumulatedResults</l>
<l>set_system ('empty_region_result', EmptyRegionResult)</l>
<l>return ()</l>
</body>
<docu id="get_features">
<abstract lang="en_US">This procedure contains all feature names, the groups they belong to and the code how to calculate them.

It is designed in a way, that it can be easily used to handle user-defined features. 
The user-defined features have to be defined in an external procedure get_custom_features.hdvp (See there for detailed instructions).

For more information about the usage of the get_feature_set library, see documentation of calculate_features.

Currently, get_features supports the following features (associated groups in parenthesis):

'area' ('REGION','ROT_INVAR'): Area of the region (see area_center).

'width' ('REGION'): Width of the region (see smallest_rectangle1).

'height' ('height'): Height of the region (see smallest_rectangle1).

'ra' ('REGION','ROT_INVAR'): Main radius of the equivalent ellipse (see elliptic_axis).

'rb' ('REGION','ROT_INVAR'): Secondary radius of the equivalent ellipse (see elliptic_axis).

'phi' ('REGION','SCALE_INVAR'): Orientation of the equivalent ellipse (see elliptic_axis).

'roundness' ('REGION','ROT_INVAR','SCALE_INVAR'): Roundness (see roundness).

'num_sides' ('REGION','ROT_INVAR','SCALE_INVAR'): Number of polygon sides (see roundness).

'num_connected' ('REGION','ROT_INVAR','SCALE_INVAR'): Number of connection components (see connect_and_holes).

'num_holes' ('REGION','ROT_INVAR','SCALE_INVAR'): Number of holes (see connect_and_holes).

'area_holes' ('REGION','ROT_INVAR'): Area of the holes of the object (see area_holes).

'max_diameter' ('REGION','ROT_INVAR'): Maximum diameter of the region (see diameter_region).

'orientation' ('REGION','SCALE_INVAR'): Orientation of the region (see orientation_region).

'outer_radius' ('REGION','ROT_INVAR'): Radius of smallest surrounding circle (see smallest_circle).

'inner_radius' ('REGION','ROT_INVAR'): Radius of largest inner circle (see inner_circle).

'inner_width' ('REGION'): Width of the largest axis-parallel rectangle that fits into the region (see inner_rectangle1).

'inner_height' ('REGION'): Height of the largest axis-parallel rectangle that fits into the region (see (see inner_rectangle1).

'circularity' ('REGION','ROT_INVAR','SCALE_INVAR'): Circularity (see circularity).

'compactness' ('REGION','ROT_INVAR','SCALE_INVAR'): Compactness (see compactness).

'convexity' ('REGION','ROT_INVAR','SCALE_INVAR'): Convexity (see convexity).

'rectangularity' ('REGION','ROT_INVAR','SCALE_INVAR'): Rectangularity (see rectangularity).

'anisometry: ('REGION','ROT_INVAR','SCALE_INVAR')' Anisometry (see eccentricity).

'bulkiness: ('REGION','ROT_INVAR','SCALE_INVAR')' Bulkiness (see eccentricity).

'struct_factor: ('REGION','ROT_INVAR','SCALE_INVAR')' Structur Factor (see eccentricity).

'dist_mean' ('REGION','ROT_INVAR'): Mean distance from the region border to the center (see roundness).

'dist_deviation': ('REGION','ROT_INVAR') Deviation of the distance from the region border from the center (see roundness).

'euler_number' ('REGION','ROT_INVAR','SCALE_INVAR'): Euler number (see euler_number).

'rect2_phi' ('REGION','SCALE_INVAR'): Orientation of the smallest surrounding rectangle (see smallest_rectangle2).

'rect2_len1' ('REGION','ROT_INVAR'): Half the length of the smallest surrounding rectangle (see smallest_rectangle2).

'rect2_len2' ('REGION','ROT_INVAR'): Half the width of the smallest surrounding rectangle (see smallest_rectangle2).

'contlength' ('REGION','ROT_INVAR'): Total length of the region's contour (see contlength).

'poriosity' ('REGION','ROT_INVAR','SCALE_INVAR'): Ratio of the area of the holes to the region area.

'gray_area' ('GRAY','ROT_INVAR'): Gray-value volume of region (see area_center_gray).

'gray_ra' ('GRAY','ROT_INVAR'): Major axis of equivallent ellipse (see elliptic_axis_gray).

'gray_rb' ('GRAY','ROT_INVAR'): Minor axis of equivallent ellipse (see elliptic_axis_gray).

'gray_phi' ('GRAY','SCALE_INVAR'): Orientation of equivallent ellipse (see elliptic_axis_gray).

'gray_min' ('GRAY','ROT_INVAR','SCALE_INVAR'): Minimum gray value (see min_max_gray).

'gray_max' ('GRAY','ROT_INVAR','SCALE_INVAR'): Maximum gray value (see min_max_gray).

'gray_range' ('GRAY','ROT_INVAR','SCALE_INVAR'): Gray-value range.

'gray_mean' ('GRAY','TEXTURE','ROT_INVAR','SCALE_INVAR'): Mean gray value (see intensity).

'gray_deviation' ('GRAY','TEXTURE','ROT_INVAR','SCALE_INVAR'): Deviation of gray values (see intensity).

'gray_plane_deviation' ('GRAY','TEXTURE','ROT_INVAR','SCALE_INVAR'): Deviation from the approximating plane (see plane_deviation).

'gray_anisotropy' ('GRAY','TEXTURE','ROT_INVAR','SCALE_INVAR'): Anisotropy (see entropy_gray).

'gray_entropy' ('GRAY','TEXTURE','ROT_INVAR','SCALE_INVAR'): Entropy (see entropy_gray).

'gray_hor_proj' ('GRAY','TEXTURE','SCALE_INVAR'): Horizontal gray-value projection.

'gray_vert_proj' ('GRAY','TEXTURE','SCALE_INVAR'): Vertical gray-value projection.

'gray_hor_proj_histo' ('GRAY','TEXTURE','SCALE_INVAR'): Histogram of horizontal gray-value projection.

'gray_vert_proj_histo' ('GRAY','TEXTURE','SCALE_INVAR'): Histogram of horizontal gray-value projection.

'grad_dir_histo' ('GRAY','TEXTURE'): Gradient direction histogram.

'edge_density' ('GRAY','TEXTURE','ROT_INVAR','SCALE_INVAR'): Ratio of the gray-value volume of the edge image to the region area.

'edge_density_pyramid_[234]' ('GRAY','TEXTURE','ROT_INVAR','SCALE_INVAR'): Edge density for 2, 3, or 4 pyramid levels.

'edge_density_histogram' ('GRAY','TEXTURE','ROT_INVAR','SCALE_INVAR'): Ratio of the gray-value histogram of the edge image to the region area.

'edge_density_histogram_pyramid_[234]' ('GRAY','TEXTURE','ROT_INVAR','SCALE_INVAR'): Edge density histogram for 2, 3, or 4 pyramid levels.

'cooc' ('GRAY','TEXTURE'): Energy, correlation, local homogeneity, and contrast of co-occurrance matrix (see cooc_feature_matrix).

'cooc_pyramid_[234]' ('GRAY','TEXTURE'): 'cooc' feature for 2, 3, or 4 pyramid levels.

'polar_gray_proj' ('GRAY','ROT_INVAR','SCALE_INVAR'): Gray-value projection along the tangential axis of the polar-transformed image.

'polar_grad_proj' ('GRAY','ROT_INVAR','SCALE_INVAR'): Gray-value projection along the tangential axis of the polar-transformed edge image.

'polar_grad_x_proj' ('GRAY','ROT_INVAR','SCALE_INVAR'): Gray-value projection along the tangential axis of the polar-transformed derivative in x direction.

'polar_grad_y_proj' ('GRAY','ROT_INVAR','SCALE_INVAR'): Gray-value projection along the tangential axis of the polar-transformed derivative in y direction.

'polar_gray_proj_histo' ('GRAY','ROT_INVAR','SCALE_INVAR'): Histogram of the gray-value projection along the radial axis of the polar-transformed image.

'cielab_mean' ('COLOR'): Mean gray values of the L, A, and B channel.

'cielab_dev' ('COLOR'): Gray value deviation of the L, A, and B channel.

'hls_mean' ('COLOR'): Mean gray values of the H, L, and S channel.

'hls_dev' ('COLOR'): Gray value deviation of the H, L, and S channel.

'rgb_mean' ('COLOR'): Mean gray values of the R, G, and B channel.

'rgb_dev' ('COLOR'): Gray value deviation of the R, G, and B channel.</abstract>
<alternatives>
<item>get_custom_features</item>
</alternatives>
<chapters lang="de_DE">
<item>Klassifikation</item>
<item>Sonstiges</item>
</chapters>
<chapters lang="en_US">
<item>Classification</item>
<item>Misc</item>
</chapters>
<keywords lang="en_US">
<item>classification</item>
<item>features</item>
</keywords>
<library lang="en_US">MVTec Standard Procedures</library>
<see_also>
<item>calculate_features</item>
<item>get_feature_names</item>
<item>get_feature_lengths</item>
<item>query_feature_names_by_group</item>
<item>query_feature_group_names</item>
</see_also>
<short lang="en_US">This procedure contains all relevant information about the supported features.</short>
<parameters>
<parameter id="Image">
<description lang="en_US">Input image.</description>
<multichannel>optional</multichannel>
<multivalue>false</multivalue>
<sem_type>image</sem_type>
</parameter>
<parameter id="Mode">
<default_type>string</default_type>
<description lang="en_US">Calculation mode.</description>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>string</sem_type>
<type_list>
<item>string</item>
</type_list>
<value_list>
<item>'get_names'</item>
<item>'get_groups'</item>
<item>'get_length'</item>
<item>'calculate'</item>
</value_list>
</parameter>
<parameter id="Namelist">
<default_type>string</default_type>
<description lang="en_US">Feature names or feature group names</description>
<mixed_type>false</mixed_type>
<multivalue>optional</multivalue>
<sem_type>string</sem_type>
<type_list>
<item>string</item>
</type_list>
</parameter>
<parameter id="Output">
<default_type>real</default_type>
<description lang="en_US">Feature names, feature vector, feature vector lengths, or group names.</description>
<mixed_type>false</mixed_type>
<multivalue>optional</multivalue>
<type_list>
<item>integer</item>
<item>real</item>
<item>string</item>
</type_list>
</parameter>
<parameter id="Region">
<description lang="en_US">Region to be examined.</description>
<multivalue>optional</multivalue>
<sem_type>region</sem_type>
</parameter>
</parameters>
</docu>
</procedure>
<procedure name="get_find_parameter" access="local">
<interface>
<ic>
<par name="GenParamNames" base_type="ctrl" dimension="0"/>
<par name="GenParamValues" base_type="ctrl" dimension="0"/>
<par name="ParamName" base_type="ctrl" dimension="0"/>
<par name="DefaultValue" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="ParamValue" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<l>ParamValue := DefaultValue</l>
<l>tuple_find (GenParamNames, ParamName, Idx)</l>
<l>if (Idx != -1 and Idx != [])</l>
<l>    ParamValue := GenParamValues[Idx]</l>
<l>endif</l>
<l>return ()</l>
</body>
<docu id="get_find_parameter">
<chapters lang="en_US">
<item>Tuple</item>
<item>Selection</item>
</chapters>
<library lang="en_US">MVTec Standard Procedures</library>
<parameters>
<parameter id="DefaultValue"/>
<parameter id="GenParamNames">
<sem_type>attribute.name</sem_type>
</parameter>
<parameter id="GenParamValues">
<sem_type>attribute.value</sem_type>
</parameter>
<parameter id="ParamName">
<sem_type>attribute.name</sem_type>
</parameter>
<parameter id="ParamValue">
<sem_type>attribute.value</sem_type>
</parameter>
</parameters>
</docu>
</procedure>
<procedure name="get_find_surface_model_param" access="local">
<interface>
<ic>
<par name="ParamName" base_type="ctrl" dimension="0"/>
<par name="DefaultValue" base_type="ctrl" dimension="0"/>
<par name="GenParamNames" base_type="ctrl" dimension="0"/>
<par name="GenParamValues" base_type="ctrl" dimension="0"/>
<par name="ConvertBoolToInt" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="ParamValue" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<l>if (1)</l>
<c>    * Debug Check: Is the parameter valid?</c>
<l>    get_param_info ('find_surface_model_image', 'GenParamName', 'value_list', ValidParamNames)</l>
<l>    tuple_find (ValidParamNames, ParamName, Pos)</l>
<l>    if (Pos == -1 or Pos == [])</l>
<l>        throw ('Invalid parameter name: ' + ParamName)</l>
<l>    endif</l>
<l>endif</l>
<c></c>
<l>Pos := find(GenParamNames,ParamName)</l>
<l>if (Pos != [] and Pos != -1)</l>
<c>    * If the parameter is set multiple times, use the last.</c>
<l>    ParamValue := GenParamValues[Pos[|Pos| - 1]]</l>
<l>else</l>
<l>    ParamValue := DefaultValue</l>
<l>endif</l>
<c></c>
<l>if (ConvertBoolToInt)</l>
<l>    if (ParamValue == 'true')</l>
<l>        ParamValue := 1</l>
<l>    endif</l>
<l>    if (ParamValue == 'false')</l>
<l>        ParamValue := 0</l>
<l>    endif</l>
<l>endif</l>
<c></c>
<l>return ()</l>
</body>
<docu id="get_find_surface_model_param">
<chapters lang="en_US">
<item>3D Matching</item>
<item>Surface-Based</item>
</chapters>
<library lang="en_US">MVTec Standard Procedures</library>
<parameters>
<parameter id="ConvertBoolToInt">
<default_value>0</default_value>
<sem_type>integer</sem_type>
<values>
<item>0</item>
<item>1</item>
</values>
</parameter>
<parameter id="DefaultValue">
<default_value>[]</default_value>
</parameter>
<parameter id="GenParamNames">
<sem_type>attribute.name</sem_type>
</parameter>
<parameter id="GenParamValues">
<sem_type>attribute.value</sem_type>
</parameter>
<parameter id="ParamName"/>
<parameter id="ParamValue"/>
</parameters>
</docu>
</procedure>
<procedure name="get_genparam_single_value" access="local">
<interface>
<ic>
<par name="GenParamName" base_type="ctrl" dimension="0"/>
<par name="GenParamValue" base_type="ctrl" dimension="0"/>
<par name="RequestedGenParamName" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="FoundGenParamValue" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c>* </c>
<c>* Get a parameter value from GenParamValue with the name RequestedGenParamName,</c>
<c>* which is allowed to appear only once in GenParamName.</c>
<c>* </c>
<c>* Set a default in case no value is provided.</c>
<l>FoundGenParamValue := []</l>
<c>* Set user provided values, if provided.</c>
<l>Indices := find(GenParamName,RequestedGenParamName)</l>
<l>if (|Indices| == 1 and Indices != -1)</l>
<l>    FoundGenParamValue := GenParamValue[Indices]</l>
<l>elseif (|Indices| &gt; 1)</l>
<c>    * Throw an error if more than one value was provided for RequestedGenParamName.</c>
<l>    throw ('Only a single parameter dictionary or none is allowed for \'' + RequestedGenParamName + '\'.')</l>
<l>endif</l>
<l>return ()</l>
</body>
<docu id="get_genparam_single_value">
<abstract lang="en_US">This procedure returns a parameter value from GenParamValue with the name RequestedGenParamName.
Thereby, the name is allowed to appear only once in GenParamName.</abstract>
<chapters lang="de_DE">
<item>Deep Learning</item>
<item>Modell</item>
</chapters>
<chapters lang="en_US">
<item>Deep Learning</item>
<item>Model</item>
</chapters>
<library lang="en_US">MVTec Standard Procedures</library>
<short lang="en_US">Get a parameter value from GenParamValue with the name RequestedGenParamName.</short>
<parameters>
<parameter id="FoundGenParamValue">
<description lang="en_US">Parameter value to be found.</description>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>any</sem_type>
</parameter>
<parameter id="GenParamName">
<default_type>string</default_type>
<description lang="en_US">All parameter names of the values in GenParamValue.</description>
<mixed_type>false</mixed_type>
<multivalue>optional</multivalue>
<sem_type>string</sem_type>
<type_list>
<item>string</item>
</type_list>
</parameter>
<parameter id="GenParamValue">
<description lang="en_US">All values of the parameters with a name given in GenParamName.</description>
<multivalue>optional</multivalue>
<sem_type>any</sem_type>
</parameter>
<parameter id="RequestedGenParamName">
<default_type>string</default_type>
<description lang="en_US">Name of the parameter whose value is to be returned.</description>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>string</sem_type>
<type_list>
<item>string</item>
</type_list>
</parameter>
</parameters>
</docu>
</procedure>
<procedure name="get_hom_mat2d_from_matching_result">
<interface>
<ic>
<par name="Row" base_type="ctrl" dimension="0"/>
<par name="Column" base_type="ctrl" dimension="0"/>
<par name="Angle" base_type="ctrl" dimension="0"/>
<par name="ScaleR" base_type="ctrl" dimension="0"/>
<par name="ScaleC" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="HomMat2D" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c>* This procedure calculates the transformation matrix for the model contours</c>
<c>* from the results of Shape-Based Matching.</c>
<c>* </c>
<l>hom_mat2d_identity (HomMat2DIdentity)</l>
<l>hom_mat2d_scale (HomMat2DIdentity, ScaleR, ScaleC, 0, 0, HomMat2DScale)</l>
<l>hom_mat2d_rotate (HomMat2DScale, Angle, 0, 0, HomMat2DRotate)</l>
<l>hom_mat2d_translate (HomMat2DRotate, Row, Column, HomMat2D)</l>
<l>return ()</l>
<c></c>
<c></c>
</body>
<docu id="get_hom_mat2d_from_matching_result">
<abstract lang="en_US">The procedure get_hom_mat2d_from_matching_result calculates the transformation matrix HomMat2D from results of Shape-Based Matching. This transformation matrix can be used to transform model contours obtained by get_shape_model_contours to the position of the found match.

Row, Column, and Angle contain the position and rotation information of the found instances of the shape models.

ScaleR and ScaleC contain the scale of the found instances of the shape model. If find_shape_model(s) was used to find the instances of the shape model, ScaleR and ScaleC should be set to 1.0. If find_scaled_shape_model(s) was used to find the instances of the shape model, ScaleR and ScaleC contain the scale of the found instances. If find_aniso_shape_model(s) was used to find the instances of the shape model, ScaleR and ScaleC contain the respective anisotropic scales of the found instances.</abstract>
<chapters lang="de_DE">
<item>Matching</item>
<item>Formbasiert</item>
</chapters>
<chapters lang="en_US">
<item>Matching</item>
<item>Shape-Based</item>
</chapters>
<keywords lang="en_US">
<item>display results of shape-based matching</item>
</keywords>
<library lang="en_US">MVTec Standard Procedures</library>
<predecessor>
<item>find_shape_model</item>
<item>find_shape_models</item>
<item>find_scaled_shape_model</item>
<item>find_scaled_shape_models</item>
<item>find_aniso_shape_model</item>
<item>find_aniso_shape_models</item>
</predecessor>
<short lang="de_DE">Berechnen der Transformationsmatrix für Ergebnisse des formbasierten Matchings.</short>
<short lang="en_US">Calculate the transformation matrix for results of Shape-Based Matching.</short>
<successor>
<item>set_shape_model_metric</item>
<item>set_shape_model_clutter</item>
</successor>
<parameters>
<parameter id="Angle">
<default_type>real</default_type>
<description lang="en_US">Rotation angle of the found instance of the models.</description>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>angle.rad</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
<parameter id="Column">
<default_type>real</default_type>
<description lang="en_US">Column coordinate of the found instances of the models.</description>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>point.x</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
<parameter id="HomMat2D">
<default_type>real</default_type>
<description lang="en_US">Transformation matrix.</description>
<mixed_type>optional</mixed_type>
<multivalue>true</multivalue>
<sem_type>hom_mat2d</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
<parameter id="Row">
<default_type>real</default_type>
<description lang="en_US">Row coordinate of the found instance of the models.</description>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>point.y</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
<parameter id="ScaleC">
<default_type>real</default_type>
<default_value>1.0</default_value>
<description lang="en_US">Scale of the found instance of the models in the column direction.</description>
<mixed_type>optional</mixed_type>
<multivalue>false</multivalue>
<sem_type>number</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
<parameter id="ScaleR">
<default_type>real</default_type>
<default_value>1.0</default_value>
<description lang="en_US">Scale of the found instance of the models in the row direction.</description>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>number</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
</parameters>
</docu>
</procedure>
<procedure name="get_image" access="local">
<interface>
<oo>
<par name="Image" base_type="iconic" dimension="0"/>
</oo>
<ic>
<par name="SampleKeys" base_type="ctrl" dimension="0"/>
<par name="DLSample" base_type="ctrl" dimension="0"/>
</ic>
</interface>
<body>
<c>* </c>
<c>* This procedure returns the image of a sample.</c>
<c>* </c>
<l>if (find(SampleKeys,'image') != -1)</l>
<l>    get_dict_object (Image, DLSample, 'image')</l>
<l>else</l>
<l>    throw ('Image could not be found in DLSample.')</l>
<l>endif</l>
<l>return ()</l>
</body>
<docu id="get_image">
<chapters lang="de_DE">
<item>Deep Learning</item>
<item>Modell</item>
</chapters>
<chapters lang="en_US">
<item>Deep Learning</item>
<item>Model</item>
</chapters>
<library lang="en_US">MVTec Standard Procedures</library>
<short lang="en_US">Get the image of a sample.</short>
<parameters>
<parameter id="DLSample">
<default_type>integer</default_type>
<mixed_type>false</mixed_type>
<sem_type>dict</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="Image">
<sem_type>image</sem_type>
</parameter>
<parameter id="SampleKeys">
<sem_type>string</sem_type>
</parameter>
</parameters>
</docu>
</procedure>
<procedure name="get_image_direction" access="local">
<interface>
<io>
<par name="Image" base_type="iconic" dimension="0"/>
</io>
<oc>
<par name="MedianDirection" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<l>Direction := [1,0]</l>
<l>get_domain (Image, Domain)</l>
<l>affine_trans_region (Domain, RegionTrans, [1,0,Direction[1],0,1,Direction[0]], 'false')</l>
<l>intersection (Image, RegionTrans, XWithNeighbor)</l>
<l>get_region_points (XWithNeighbor, Rows, Columns)</l>
<l>if (|Columns| &gt; 0)</l>
<l>    get_grayval (Image, Rows - Direction[1], Columns - Direction[0], Grayval1)</l>
<l>    get_grayval (Image, Rows, Columns, Grayval2)</l>
<l>    Diff := Grayval2 - Grayval1</l>
<l>    MedianDiff1 := median(Diff)</l>
<l>else</l>
<l>    MedianDirection := [0,0]</l>
<l>    return ()</l>
<l>endif</l>
<c></c>
<l>Direction := [0,1]</l>
<l>affine_trans_region (Image, RegionTrans, [1,0,Direction[1],0,1,Direction[0]], 'nearest_neighbor')</l>
<l>intersection (Image, RegionTrans, XWithNeighbor)</l>
<l>get_region_points (XWithNeighbor, Rows, Columns)</l>
<l>if (|Columns| &gt; 0)</l>
<l>    get_grayval (Image, Rows - Direction[1], Columns - Direction[0], Grayval1)</l>
<l>    get_grayval (Image, Rows, Columns, Grayval2)</l>
<l>    Diff := Grayval2 - Grayval1</l>
<l>    MedianDiff2 := median(Diff)</l>
<l>else</l>
<l>    MedianDirection := [0,0]</l>
<l>    return ()</l>
<l>endif</l>
<c></c>
<l>MedianDirection := [MedianDiff1,MedianDiff2]</l>
<c></c>
<l>return ()</l>
</body>
<docu id="get_image_direction">
<chapters lang="en_US">
<item>Image</item>
<item>Features</item>
</chapters>
<library lang="en_US">MVTec Standard Procedures</library>
<parameters>
<parameter id="Image"/>
<parameter id="MedianDirection"/>
</parameters>
</docu>
</procedure>
<procedure name="get_max_min_amplitude" access="local">
<interface>
<ic>
<par name="BoxInformation" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="MaxMinAmplitude" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c>* Get input lengths.</c>
<l>get_dict_tuple (BoxInformation, 'gen_param', GenParamDict)</l>
<l>get_dict_tuple (GenParamDict, 'lengths', InputLengths)</l>
<c>* Squaring avoids negative inputs to sqrt.</c>
<l>SideLengths := [sqrt(pow(InputLengths[0],2) + pow(InputLengths[3],2)),sqrt(pow(InputLengths[3],2) + pow(InputLengths[5],2)),sqrt(pow(InputLengths[0],2) + pow(InputLengths[5],2))]</l>
<c>* </c>
<l>FactorConst := 3</l>
<l>if (InputLengths[5] &gt; 0)</l>
<l>    MaxMinAmplitude := FactorConst * min(SideLengths)</l>
<l>else</l>
<l>    MaxMinAmplitude := FactorConst * SideLengths[0]</l>
<l>endif</l>
<l>return ()</l>
</body>
<docu id="get_max_min_amplitude">
<parameters>
<parameter id="BoxInformation"/>
<parameter id="MaxMinAmplitude"/>
</parameters>
</docu>
</procedure>
<procedure name="get_min_amplitude" access="local">
<interface>
<ic>
<par name="BoxInformation" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="MinAmplitude" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c>* Get input lengths.</c>
<l>get_dict_tuple (BoxInformation, 'gen_param', GenParamDict)</l>
<l>get_dict_tuple (GenParamDict, 'lengths', InputLengths)</l>
<c>* Ignore -1 lengths</c>
<l>PositiveIndices := find(InputLengths [&gt;] 0,1)</l>
<l>PositiveLengths := InputLengths[PositiveIndices]</l>
<c>* </c>
<l>MinAmplitude := min(PositiveLengths)</l>
<l>return ()</l>
</body>
<docu id="get_min_amplitude">
<parameters>
<parameter id="BoxInformation"/>
<parameter id="MinAmplitude"/>
</parameters>
</docu>
</procedure>
<procedure name="get_mouse_info" access="local">
<interface>
<ic>
<par name="WindowHandle" base_type="ctrl" dimension="0"/>
<par name="MessageQueue" base_type="ctrl" dimension="0"/>
<par name="Timeout" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="Row" base_type="ctrl" dimension="0"/>
<par name="Column" base_type="ctrl" dimension="0"/>
<par name="Button" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c>* Initialize as "no event"</c>
<l>Row := -1</l>
<l>Column := -1</l>
<l>Button := -1</l>
<c>* </c>
<l>if (MessageQueue == [])</l>
<l>    get_mposition_sub_pix (WindowHandle, Row, Column, Button)</l>
<l>else</l>
<c>    * Queue-based visualization</c>
<l>    if (Timeout == [])</l>
<l>        dequeue_message (MessageQueue[0], [], [], MessageHandle)</l>
<l>    else</l>
<l>        try</l>
<l>            dequeue_message (MessageQueue[0], 'timeout', Timeout, MessageHandle)</l>
<l>        catch (Exception)</l>
<l>            H_ERR_TIMEOUT := 9400</l>
<l>            if (Exception[0] == H_ERR_TIMEOUT)</l>
<l>                return ()</l>
<l>            else</l>
<l>                throw (Exception)</l>
<l>            endif</l>
<l>        endtry</l>
<l>    endif</l>
<l>    get_message_tuple (MessageHandle, 'type', MessageType)</l>
<l>    if (MessageType == 'mouse_event')</l>
<l>        get_message_tuple (MessageHandle, 'mouse_row', Row)</l>
<l>        get_message_tuple (MessageHandle, 'mouse_col', Column)</l>
<l>        get_message_tuple (MessageHandle, 'mouse_button', Button)</l>
<l>        clear_message (MessageHandle)</l>
<l>    else</l>
<l>        clear_message (MessageHandle)</l>
<l>        throw ('Unknown or unexpected message type: ' + MessageType)</l>
<l>    endif</l>
<l>endif</l>
<c></c>
<c>* Normalize the button</c>
<l>if (Button == [])</l>
<l>    Button := 0</l>
<l>endif</l>
<l>return ()</l>
</body>
<docu id="get_mouse_info">
<chapters lang="en_US">
<item>Graphics</item>
<item>Mouse</item>
</chapters>
<library lang="en_US">MVTec Standard Procedures</library>
<parameters>
<parameter id="Button">
<default_type>integer</default_type>
<sem_type>integer</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="Column">
<sem_type>coordinates.x</sem_type>
</parameter>
<parameter id="MessageQueue">
<default_type>integer</default_type>
<mixed_type>false</mixed_type>
<sem_type>message_queue</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="Row">
<sem_type>coordinates.y</sem_type>
</parameter>
<parameter id="Timeout"/>
<parameter id="WindowHandle">
<default_type>integer</default_type>
<mixed_type>false</mixed_type>
<sem_type>window</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
</parameters>
</docu>
</procedure>
<procedure name="get_nearest_finder_pattern_coordinates">
<interface>
<io>
<par name="CalibPlateImage" base_type="iconic" dimension="0"/>
</io>
<ic>
<par name="RowNearFinderPattern" base_type="ctrl" dimension="0"/>
<par name="ColumNearFinderPattern" base_type="ctrl" dimension="0"/>
<par name="CalibObjectData" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="RowFinderPattern" base_type="ctrl" dimension="0"/>
<par name="ColumnFinderPattern" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c>* </c>
<l>read_dict_tuple (CalibObjectData, 'CamParam', CamParam)</l>
<l>read_dict_tuple (CalibObjectData, 'CalPlateDescr', CalPlateDescr)</l>
<l>read_dict_tuple (CalibObjectData, 'MarksPerRow', MarksPerRow)</l>
<l>read_dict_tuple (CalibObjectData, 'FinderRow', FinderRow)</l>
<l>read_dict_tuple (CalibObjectData, 'FinderColumn', FinderColumn)</l>
<c>* </c>
<c>* Check input.</c>
<c>* </c>
<c>* Check image coordinates.</c>
<l>if (|RowNearFinderPattern| &gt; 1 or |ColumNearFinderPattern| &gt; 1)</l>
<l>    throw ('Please specify only one image coordinate.')</l>
<l>endif</l>
<c>* Check number of marks per row.</c>
<l>if (MarksPerRow &lt; 3)</l>
<l>    throw ('At least three marks per row are necessary for a valid finder pattern.')</l>
<l>endif</l>
<c>* Find calibration plate.</c>
<l>create_calib_data ('calibration_object', 1, 1, CalibDataID)</l>
<l>set_calib_data_cam_param (CalibDataID, 0, [], CamParam)</l>
<l>set_calib_data_calib_object (CalibDataID, 0, CalPlateDescr)</l>
<l>try</l>
<l>    find_calib_object (CalibPlateImage, CalibDataID, 0, 0, 0, [], [])</l>
<l>catch (Exception)</l>
<l>    throw ('Calibration plate could not be find, please make sure that at least one finder pattern is visible.')</l>
<l>endtry</l>
<l>get_calib_data_observ_points (CalibDataID, 0, 0, 0, Row, Column, Index1, Pose)</l>
<l>get_calib_data_observ_contours (Contours, CalibDataID, 'caltab', 0, 0, 0)</l>
<c>* Get the finder pattern used to find the calibration plate.</c>
<l>gen_region_contour_xld (Contours, Region, 'filled')</l>
<l>union1 (Region, RegionUnion)</l>
<l>area_center (RegionUnion, Area1, Row2, Column2)</l>
<l>RowTmp := abs(Row - Row2)</l>
<l>ColTmp := abs(Column - Column2)</l>
<l>Diff := sqrt(RowTmp * RowTmp + ColTmp * ColTmp)</l>
<l>tuple_find (Diff, min(Diff), IndexFinal)</l>
<l>RowToApproach1 := Row[IndexFinal]</l>
<l>ColToApproach1 := Column[IndexFinal]</l>
<l>clear_calib_data (CalibDataID)</l>
<c>* Get remaining finder pattern.</c>
<c>* </c>
<c>* Get finder pattern in world coordinates.</c>
<l>caltab_points (CalPlateDescr, XCal, YCal, ZCal)</l>
<l>XFP := XCal[FinderRow * MarksPerRow + FinderColumn]</l>
<l>YFP := YCal[FinderRow * MarksPerRow + FinderColumn]</l>
<c>* Get finder pattern in camera coordinates.</c>
<l>pose_to_hom_mat3d (Pose, HomMat3D)</l>
<l>tuple_gen_const (|XFP|, 0.0, ZFP)</l>
<l>affine_trans_point_3d (HomMat3D, XFP, YFP, ZFP, X1, Y1, Z1)</l>
<c>* Project into the image.</c>
<l>project_3d_point (X1, Y1, Z1, CamParam, Row, Column)</l>
<c>* </c>
<c>* Get the image coordinates that are the closest ones to the passed ones.</c>
<l>RowTmp := abs(Row - RowNearFinderPattern)</l>
<l>ColTmp := abs(Column - ColumNearFinderPattern)</l>
<l>Diff := sqrt(RowTmp * RowTmp + ColTmp * ColTmp)</l>
<l>tuple_find (Diff, min(Diff), IndexFinal)</l>
<c>* Return the image coordinates.</c>
<l>RowFinderPattern := Row[IndexFinal]</l>
<l>ColumnFinderPattern := Column[IndexFinal]</l>
<l>return ()</l>
</body>
<docu id="get_nearest_finder_pattern_coordinates">
<abstract lang="en_US">This procedure returns the image coordinates of the central mark of the finder pattern (RowFinderPattern, ColumnFinderPattern) in the CalibPlateImage that is the closest one to the passed image coordinates in the parameters RowNearFinderPattern and ColumnNearFinderPattern.

The dict CalibObjectData must contain the parameters CamParam, CalPlateDescr, MarksPerRow, FinderRow and FinderColumn.</abstract>
<chapters lang="de_DE">
<item>Kalibrierung</item>
<item>Hand-Auge</item>
</chapters>
<chapters lang="en_US">
<item>Calibration</item>
<item>Hand-Eye</item>
</chapters>
<library lang="en_US">MVTec Standard Procedures</library>
<predecessor>
<item>calibrate_camera_and_plane_single_image</item>
<item>get_mbutton_sub_pix</item>
</predecessor>
<short lang="en_US">Get the coordinates of the central mark of the closest finder pattern.</short>
<successor>
<item>calibrate_hand_eye_stationary_cam</item>
</successor>
<parameters>
<parameter id="CalibObjectData">
<default_type>integer</default_type>
<description lang="en_US">Calibration data.</description>
<mixed_type>false</mixed_type>
<sem_type>dict</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="CalibPlateImage">
<description lang="en_US">Image of the calibration plate describing the measurement plane.</description>
<multichannel>false</multichannel>
<multivalue>false</multivalue>
<sem_type>image</sem_type>
<type_list>
<item>byte</item>
<item>uint2</item>
</type_list>
</parameter>
<parameter id="ColumNearFinderPattern">
<default_type>real</default_type>
<default_value>[]</default_value>
<description lang="en_US">Column coordinate near the touching point / central mark of the approached finder pattern.</description>
<multivalue>false</multivalue>
<sem_type>point.x</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
<parameter id="ColumnFinderPattern">
<default_type>real</default_type>
<description lang="en_US">Column coordinate of the central mark of the closest finder pattern.</description>
<multivalue>false</multivalue>
<sem_type>point.x</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
<parameter id="RowFinderPattern">
<default_type>real</default_type>
<description lang="en_US">Row coordinate of the central mark of the closest finder pattern.</description>
<multivalue>false</multivalue>
<sem_type>point.y</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
<parameter id="RowNearFinderPattern">
<default_type>real</default_type>
<default_value>[]</default_value>
<description lang="en_US">Row coordinate near the touching point / central mark of the approached finder pattern.</description>
<multivalue>false</multivalue>
<sem_type>point.y</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
</parameters>
</docu>
</procedure>
<procedure name="get_next_window" access="local">
<interface>
<ic>
<par name="Font" base_type="ctrl" dimension="0"/>
<par name="FontSize" base_type="ctrl" dimension="0"/>
<par name="ShowBottomDesc" base_type="ctrl" dimension="0"/>
<par name="WidthImage" base_type="ctrl" dimension="0"/>
<par name="HeightImage" base_type="ctrl" dimension="0"/>
<par name="MapColorBarWidth" base_type="ctrl" dimension="0"/>
<par name="ScaleWindows" base_type="ctrl" dimension="0"/>
<par name="ThresholdWidth" base_type="ctrl" dimension="0"/>
<par name="PrevWindowCoordinates" base_type="ctrl" dimension="0"/>
<par name="WindowHandleDict" base_type="ctrl" dimension="0"/>
<par name="WindowHandleKey" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="CurrentWindowHandle" base_type="ctrl" dimension="0"/>
<par name="WindowImageRatioHeight" base_type="ctrl" dimension="0"/>
<par name="PrevWindowCoordinatesOut" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c>* </c>
<c>* This procedure returns the next window that</c>
<c>* is used for visualization. If ReuseWindows is true</c>
<c>* and WindowHandleList is suitable, the window handles</c>
<c>* that are passed over are used. Else, this procedure</c>
<c>* opens a new window, either next to the last ones, or</c>
<c>* in a new row.</c>
<c>* </c>
<c>* First, check if the requested window is already available.</c>
<l>OpenNewWindow := false</l>
<l>try</l>
<l>    get_dict_tuple (WindowHandleDict, WindowHandleKey, WindowHandles)</l>
<l>    CurrentWindowHandle := WindowHandles[0]</l>
<c>    * Check if window handle is valid.</c>
<l>    try</l>
<l>        get_window_param (CurrentWindowHandle, 'flush', Value)</l>
<l>    catch (Exception)</l>
<c>        * If there is something wrong with the current window, create a new one.</c>
<l>        OpenNewWindow := true</l>
<l>        remove_dict_key (WindowHandleDict, WindowHandleKey)</l>
<l>    endtry</l>
<l>catch (Exception)</l>
<l>    OpenNewWindow := true</l>
<l>endtry</l>
<c>* </c>
<c>* Get next window.</c>
<l>if (not OpenNewWindow)</l>
<c>    * </c>
<c>    * If possible, reuse existing window handles.</c>
<l>    dev_set_window (CurrentWindowHandle)</l>
<l>    dev_clear_window ()</l>
<l>    set_display_font (CurrentWindowHandle, FontSize, Font, 'true', 'false')</l>
<c>    * </c>
<c>    * Calculate MarginBottom.</c>
<l>    if (ShowBottomDesc)</l>
<l>        get_string_extents (CurrentWindowHandle, 'test_string', Ascent, Descent, _, _)</l>
<l>        MarginBottom := 2 * 12 + Ascent + Descent</l>
<l>    else</l>
<l>        MarginBottom := 0</l>
<l>    endif</l>
<c>    * </c>
<c>    * Get and set meta information for current window.</c>
<l>    update_window_meta_information (CurrentWindowHandle, WidthImage, HeightImage, 0, 0, MapColorBarWidth, MarginBottom, WindowImageRatioHeight, WindowImageRatioWidth, SetPartRow2, SetPartColumn2, PrevWindowCoordinatesOut)</l>
<c>    * </c>
<c>    * Update meta information.</c>
<l>    get_dict_tuple (WindowHandleDict, 'meta_information', MetaInfo)</l>
<l>    set_dict_tuple (MetaInfo, WindowHandleKey + '_window_image_ratio_height', WindowImageRatioHeight)</l>
<l>    set_dict_tuple (MetaInfo, WindowHandleKey + '_window_image_ratio_width', WindowImageRatioWidth)</l>
<l>    set_dict_tuple (MetaInfo, WindowHandleKey + '_set_part_row2', SetPartRow2)</l>
<l>    set_dict_tuple (MetaInfo, WindowHandleKey + '_set_part_column2', SetPartColumn2)</l>
<l>    set_dict_tuple (MetaInfo, WindowHandleKey + '_margin_bottom', MarginBottom)</l>
<l>    set_dict_tuple (MetaInfo, WindowHandleKey + '_map_color_bar_with', MapColorBarWidth)</l>
<l>    set_dict_tuple (MetaInfo, WindowHandleKey + '_window_coordinates', PrevWindowCoordinatesOut)</l>
<l>else</l>
<c>    * </c>
<c>    * Open a new window.</c>
<l>    open_next_window (Font, FontSize, ShowBottomDesc, WidthImage, HeightImage, MapColorBarWidth, ScaleWindows, ThresholdWidth, PrevWindowCoordinates, WindowHandleDict, WindowHandleKey, CurrentWindowHandle, WindowImageRatioHeight, PrevWindowCoordinatesOut)</l>
<l>    set_window_param (CurrentWindowHandle, 'flush', 'false')</l>
<l>endif</l>
<c>* </c>
<l>return ()</l>
</body>
<docu id="get_next_window">
<chapters lang="de_DE">
<item>Graphik</item>
<item>Fenster</item>
</chapters>
<chapters lang="en_US">
<item>Graphics</item>
<item>Window</item>
</chapters>
<library lang="en_US">MVTec Standard Procedures</library>
<short lang="en_US">Get the next window that can be used for visualization.</short>
<parameters>
<parameter id="CurrentWindowHandle">
<default_type>integer</default_type>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>window</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="Font">
<default_type>string</default_type>
<multivalue>false</multivalue>
<sem_type>string</sem_type>
<type_list>
<item>string</item>
</type_list>
</parameter>
<parameter id="FontSize">
<default_type>integer</default_type>
<default_value>0</default_value>
<multivalue>false</multivalue>
<sem_type>integer</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="HeightImage">
<default_type>integer</default_type>
<default_value>0</default_value>
<multivalue>false</multivalue>
<sem_type>extent.y</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="MapColorBarWidth">
<default_type>integer</default_type>
<default_value>0</default_value>
<multivalue>false</multivalue>
<sem_type>integer</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="PrevWindowCoordinates">
<default_type>integer</default_type>
<default_value>0</default_value>
<multivalue>true</multivalue>
<sem_type>integer</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="PrevWindowCoordinatesOut">
<default_type>integer</default_type>
<multivalue>true</multivalue>
<sem_type>integer</sem_type>
<type_list>
<item>integer</item>
</type_list>
<values>
<item>0</item>
</values>
</parameter>
<parameter id="ScaleWindows">
<default_type>real</default_type>
<default_value>0</default_value>
<multivalue>false</multivalue>
<sem_type>real</sem_type>
<type_list>
<item>real</item>
</type_list>
</parameter>
<parameter id="ShowBottomDesc"/>
<parameter id="ThresholdWidth">
<default_type>real</default_type>
<multivalue>false</multivalue>
<sem_type>real</sem_type>
<type_list>
<item>real</item>
</type_list>
</parameter>
<parameter id="WidthImage">
<default_type>integer</default_type>
<sem_type>extent.x</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="WindowHandleDict">
<default_type>integer</default_type>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>dict</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="WindowHandleKey">
<default_type>string</default_type>
<multivalue>false</multivalue>
<sem_type>string</sem_type>
<type_list>
<item>string</item>
</type_list>
</parameter>
<parameter id="WindowImageRatioHeight">
<default_type>real</default_type>
<multivalue>false</multivalue>
<sem_type>real</sem_type>
<type_list>
<item>real</item>
</type_list>
</parameter>
</parameters>
</docu>
</procedure>
<procedure name="get_object_models_center">
<interface>
<ic>
<par name="ObjectModel3DID" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="Center" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c>* Compute the mean of all model centers (weighted by the diameter of the object models)</c>
<l>Diameters := gen_tuple_const(|ObjectModel3DID|,0.0)</l>
<l>for Index := 0 to |ObjectModel3DID| - 1 by 1</l>
<l>    try</l>
<l>        get_object_model_3d_params (ObjectModel3DID[Index], 'diameter_axis_aligned_bounding_box', Diameter)</l>
<l>        get_object_model_3d_params (ObjectModel3DID[Index], 'center', C)</l>
<l>        Diameters[Index] := Diameter</l>
<l>    catch (Exception)</l>
<c>        * Object model is empty, has no center etc. -&gt; ignore it by leaving its diameter at zero</c>
<l>    endtry</l>
<l>endfor</l>
<c></c>
<l>if (sum(Diameters) &gt; 0)</l>
<c>    * Normalize Diameter to use it as weights for a weighted mean of the individual centers</c>
<l>    MD := mean(select_mask(Diameters,Diameters [&gt;] 0))</l>
<l>    if (MD &gt; 1e-10)</l>
<l>        Weight := Diameters / MD</l>
<l>    else</l>
<l>        Weight := Diameters</l>
<l>    endif</l>
<l>    SumW := sum(Weight)</l>
<l>    if (SumW &lt; 1e-10)</l>
<l>        Weight := gen_tuple_const(|Weight|,1.0)</l>
<l>        SumW := sum(Weight)</l>
<l>    endif</l>
<l>    Center := [0,0,0]</l>
<l>    for Index := 0 to |ObjectModel3DID| - 1 by 1</l>
<l>        if (Diameters[Index] &gt; 0)</l>
<l>            ObjectModel3DIDSelected := ObjectModel3DID[Index]</l>
<l>            get_object_model_3d_params (ObjectModel3DIDSelected, 'center', C)</l>
<l>            Center[0] := Center[0] + C[0] * Weight[Index]</l>
<l>            Center[1] := Center[1] + C[1] * Weight[Index]</l>
<l>            Center[2] := Center[2] + C[2] * Weight[Index]</l>
<l>        endif</l>
<l>    endfor</l>
<l>    InvSum := 1.0 / SumW</l>
<l>    Center[0] := Center[0] * InvSum</l>
<l>    Center[1] := Center[1] * InvSum</l>
<l>    Center[2] := Center[2] * InvSum</l>
<l>else</l>
<l>    Center := []</l>
<l>endif</l>
<l>return ()</l>
</body>
<docu id="get_object_models_center">
<abstract lang="en_US">get_object_models_center computes the center of all given 3D object models.

The center is computed as the weighted mean of all centers of the individual 3D object models. The weighting ensures that larger 3D object models have an higher impact on the calculated center.</abstract>
<chapters lang="de_DE">
<item>Graphik</item>
<item>Ausgabe</item>
</chapters>
<chapters lang="en_US">
<item>Graphics</item>
<item>Output</item>
</chapters>
<example lang="en_US">read_object_model_3d ('pipe_joint', 'm', [], [], ObjectModel3D, Status)
CamParam := [0.1,0,6e-6,6e-6,256,256,512,512]
dev_resize_window_fit_size (0, 0, CamParam[6]-1, CamParam[7]-1, -1, -1)
get_object_models_center (ObjectModel3D, Center)
create_pose (-Center[0], -Center[1], -Center[2], 135, 0, 0, \
             'Rp+T', 'gba', 'point', PoseIn)
determine_optimum_pose_distance (ObjectModel3D, CamParam, 0.9, PoseIn, \
                                 PoseEstimated)
dev_get_window (WindowHandle)
disp_object_model_3d (WindowHandle, ObjectModel3D, \
                      CamParam, PoseEstimated, [], [])</example>
<library lang="en_US">MVTec Standard Procedures</library>
<predecessor>
<item>read_object_model_3d</item>
</predecessor>
<see_also>
<item>determine_optimum_pose_distance</item>
<item>disp_object_model_3d</item>
</see_also>
<short lang="en_US">Compute the center of all given 3D object models.</short>
<successor>
<item>create_pose</item>
<item>determine_optimum_pose_distance</item>
</successor>
<parameters>
<parameter id="Center">
<default_type>real</default_type>
<description lang="en_US">Center of the 3D object models.</description>
<multivalue>true</multivalue>
<sem_type>number</sem_type>
<type_list>
<item>real</item>
</type_list>
</parameter>
<parameter id="ObjectModel3DID">
<default_type>integer</default_type>
<description lang="en_US">Handles of the 3D object models.</description>
<mixed_type>false</mixed_type>
<multivalue>optional</multivalue>
<sem_type>object_model_3d</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
</parameters>
</docu>
</procedure>
<procedure name="get_robot_touching_point_in_tool_coordinates">
<interface>
<ic>
<par name="ToolInBasePosesTouchingPoint" base_type="ctrl" dimension="1"/>
</ic>
<oc>
<par name="RobotTouchingPointInToolCoordinates" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c>* To estimate the touching point with respect to the tool coordinate system, we have to</c>
<c>* arrange three equations in the following form:</c>
<c>* Rp + T = q,</c>
<c>* where R is a is the rotation matrix that rotates a point from the tool to the base coordinate</c>
<c>* system and T is a translation that translates a point from the tool to the base coordinate.</c>
<c>* q is the touching point with respect to the base coordinate system</c>
<c>* and p the unknown touching point with respect to the tool coordinate system.</c>
<c>* </c>
<c>* Approaching the same point three times while rotating the tool leads to three rotation matrices</c>
<c>* R0, R1 and R2 and three translations T0, T1 and T2.</c>
<c>* Solving this equation for the unknown touching point yields therefore:</c>
<c>* R0*p + T0 = q, R1*p + T1 = q and R2*p + T2 = q.</c>
<c>* After building two equations in the form (R1-R0)*p = T0-T1 and (R2-R0)*p = T0-T2,</c>
<c>* the DLT (direct linear transformation) can be used to efficiently solve for the unknown</c>
<c>* touching point p.</c>
<c></c>
<c></c>
<c>* Check input.</c>
<l>if (ToolInBasePosesTouchingPoint.length() &lt; 3)</l>
<l>    throw ('Please specify at least three robot poses.')</l>
<l>endif</l>
<c></c>
<c>* Initialize equation.</c>
<l>create_matrix ((ToolInBasePosesTouchingPoint.length() - 1) * 3, 3, 0, LHS)</l>
<l>create_matrix ((ToolInBasePosesTouchingPoint.length() - 1) * 3, 1, 0, RHS)</l>
<l>RotationAxisRelativ := {[]}</l>
<l>DiffToIdentity := {[]}</l>
<c>* Decompose first pose.</c>
<l>pose_to_hom_mat3d (ToolInBasePosesTouchingPoint.at(0), HomMat3D0)</l>
<l>create_matrix (3, 4, HomMat3D0, Mat0)</l>
<l>get_sub_matrix (Mat0, 0, 0, 3, 3, MatRot0)</l>
<l>get_sub_matrix (Mat0, 0, 3, 3, 1, MatTrans0)</l>
<c>* </c>
<l>for Index := 1 to ToolInBasePosesTouchingPoint.length() - 1 by 1</l>
<c>    * Decompose current pose.</c>
<l>    pose_to_hom_mat3d (ToolInBasePosesTouchingPoint.at(Index), HomMat3D)</l>
<l>    create_matrix (3, 4, HomMat3D, Mat)</l>
<l>    get_sub_matrix (Mat, 0, 0, 3, 3, MatRot)</l>
<l>    get_sub_matrix (Mat, 0, 3, 3, 1, MatTrans)</l>
<c>    * Get rotation axis relativ to first pose.</c>
<l>    get_rotation_axis (MatRot, MatRot0, RotationAxisRelativ.at(Index), DiffToIdentity.at(Index))</l>
<c>    * Fill equation.</c>
<l>    sub_matrix_mod (MatRot, MatRot0)</l>
<l>    set_sub_matrix (LHS, MatRot, (Index - 1) * 3, 0)</l>
<l>    sub_matrix_mod (MatTrans, MatTrans0)</l>
<l>    scale_matrix_mod (MatTrans, -1.0)</l>
<l>    set_sub_matrix (RHS, MatTrans, (Index - 1) * 3, 0)</l>
<c>    * Clear.</c>
<l>    clear_matrix (Mat)</l>
<l>    clear_matrix (MatRot)</l>
<l>    clear_matrix (MatTrans)</l>
<l>endfor</l>
<c>* Solve.</c>
<l>solve_matrix (LHS, 'general', 0, RHS, MatrixResultID)</l>
<l>get_full_matrix (MatrixResultID, RobotTouchingPointInToolCoordinates)</l>
<c>* Detailed errors.</c>
<l>DetailedErrors := 0</l>
<l>if (DetailedErrors)</l>
<c>    * Check that the tool was tilted enough compared to the first pose.</c>
<l>    MinDiffToIdentity := 1e8</l>
<l>    for Index := 1 to ToolInBasePosesTouchingPoint.length() - 1 by 1</l>
<l>        if (DiffToIdentity.at(Index) &lt; MinDiffToIdentity)</l>
<l>            MinDiffToIdentity := DiffToIdentity.at(Index)</l>
<l>        endif</l>
<l>    endfor</l>
<c>    * Check that different rotation axis were used when tilted away from first pose.</c>
<l>    MinCosAngle := 1.5</l>
<l>    for Index := 1 to ToolInBasePosesTouchingPoint.length() - 2 by 1</l>
<l>        for Index1 := Index + 1 to ToolInBasePosesTouchingPoint.length() - 1 by 1</l>
<l>            CosAngle := abs(sum(RotationAxisRelativ.at(Index) * RotationAxisRelativ.at(Index1)))</l>
<l>            if (CosAngle &lt; MinCosAngle)</l>
<l>                MinCosAngle := CosAngle</l>
<l>            endif</l>
<l>        endfor</l>
<l>    endfor</l>
<l>    MaxAngleBetweenRotationAxes := deg(acos(MinCosAngle))</l>
<l>endif</l>
<l>svd_matrix (LHS, 'full', 'both', MatrixUID, MatrixSID, MatrixVID)</l>
<l>get_value_matrix (MatrixSID, [0,1,2], [0,1,2], SingularValues)</l>
<l>MinSingularValue := min(abs(SingularValues))</l>
<l>if (MinSingularValue &lt; 0.15)</l>
<c>    * Consider the rotations of the tool from its first position to each following position.</c>
<c>    * Please rotate the tool enough away from the first position.</c>
<c>    * Furthermore, please use at least two significantly different rotation axis when rotating the tool</c>
<c>    * from its first position (preferably orthogonal directions?).</c>
<c>    * The maximum angle between the corresponding rotation axis is MaxAngleBetweenRotationAxes.</c>
<c>    * </c>
<l>    throw ('The estimated touching point might not be reliable. Try to use at least two different rotation axis and/or increase the rotations around these axis.')</l>
<l>endif</l>
<c>* </c>
<c>* Clear.</c>
<l>clear_matrix (MatrixUID)</l>
<l>clear_matrix (MatrixSID)</l>
<l>clear_matrix (MatrixVID)</l>
<l>clear_matrix (Mat0)</l>
<l>clear_matrix (MatRot0)</l>
<l>clear_matrix (MatTrans0)</l>
<l>clear_matrix (LHS)</l>
<l>clear_matrix (RHS)</l>
<l>return ()</l>
</body>
<docu id="get_robot_touching_point_in_tool_coordinates">
<abstract lang="en_US">This procedure calculates the touching point with respect to the tool coordinate system.

The touching point is a point that has to be fixed with respect to to the tool coordinate system but does not have to be located on the surface of the gripper. It can e.g. lie halfway between two fingers of a gripper.

To determine the touching point, choose a fixed point in the real setup that can be approached easily and accurately. Approach this point with the touching point and register the corresponding tool pose with respect to the base coordinate system. Repeat this at least two times, rotating the tool around at least two axis and register the tool poses.

With the three robot poses approaching the same point, it is possible to arrange the following three equations:
 R0*p + T0 = q
 R1*p + T1 = q 
 R2*p + T2 = q,

where R0, R1 and R2 are the rotation matrices that rotate a point from the tool to the base coordinate system and T0, T1 and T2 are the translations that translate a point from the tool to the base coordinate.
q is the touching point with respect to the base coordinate system and p the unknown touching point with respect to the tool coordinate system.

Solving the above equations for the unknown touching point p yields
(R1-R0)*p = T0-T1 and (R2-R0)*p = T0-T2 that can be solved efficiently using the DLT (direct linear transformation).

The calculated touching point is returned in the parameter RobotTouchingPointInToolCoordinates and describes the point with respect to the robot's tool coordinate system.
    </abstract>
<alternatives>
<item>calibrate_robot_touching_point</item>
</alternatives>
<chapters lang="de_DE">
<item>Transformationen</item>
<item>Sonstiges</item>
</chapters>
<chapters lang="en_US">
<item>Transformations</item>
<item>Misc</item>
</chapters>
<library lang="en_US">MVTec Standard Procedures</library>
<predecessor>
<item>read_pose</item>
</predecessor>
<short lang="en_US">Calculate the touching point in tool coordinates.</short>
<successor>
<item>visualize_calibrated_touching_point</item>
</successor>
<parameters>
<parameter id="RobotTouchingPointInToolCoordinates">
<default_type>real</default_type>
<description lang="en_US">Touching point with respect to the tool coordinate system.</description>
<multivalue>true</multivalue>
<sem_type>real</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
<values>
<item>[]</item>
</values>
</parameter>
<parameter id="ToolInBasePosesTouchingPoint">
<default_type>real</default_type>
<default_value>[]</default_value>
<description lang="en_US">Poses of the robot's tool with respect to robot's base.</description>
<multivalue>true</multivalue>
<sem_type>pose</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
</parameters>
</docu>
</procedure>
<procedure name="get_rotation_axis" access="local">
<interface>
<ic>
<par name="MatRot" base_type="ctrl" dimension="0"/>
<par name="MatRot0" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="RotationAxis" base_type="ctrl" dimension="0"/>
<par name="DiffToIdentity" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c>* </c>
<c>* Get (R_i)^(-1)R_0</c>
<l>mult_matrix (MatRot, MatRot0, 'ATB', MatrixMultID)</l>
<c>* Get some measure for how far the matrix is from the identity.</c>
<l>create_matrix (3, 3, 'identity', Identity)</l>
<l>sub_matrix (MatrixMultID, Identity, MatrixSubID)</l>
<l>get_full_matrix (MatrixSubID, Values)</l>
<l>DiffToIdentity := sum(Values * Values)</l>
<c>* Get its rotation axis.</c>
<l>svd_matrix (MatrixSubID, 'full', 'both', MatrixUID, MatrixSID, MatrixVID)</l>
<l>get_value_matrix (MatrixSID, [0,1,2], [0,1,2], SingularValues)</l>
<l>AbsSingularValues := abs(SingularValues)</l>
<l>tuple_sort_index (AbsSingularValues, Indices)</l>
<l>get_value_matrix (MatrixVID, [0,1,2], [Indices[0],Indices[0],Indices[0]], RotationAxis)</l>
<c>* Clear matrices.</c>
<l>clear_matrix (MatrixMultID)</l>
<l>clear_matrix (MatrixUID)</l>
<l>clear_matrix (MatrixSID)</l>
<l>clear_matrix (MatrixVID)</l>
<l>clear_matrix (MatrixSubID)</l>
<l>clear_matrix (Identity)</l>
<l>return ()</l>
</body>
<docu id="get_rotation_axis">
<chapters lang="en_US">
<item>Matrix</item>
<item>Arithmetic</item>
</chapters>
<library lang="en_US">MVTec Standard Procedures</library>
<parameters>
<parameter id="DiffToIdentity"/>
<parameter id="MatRot"/>
<parameter id="MatRot0"/>
<parameter id="RotationAxis"/>
</parameters>
</docu>
</procedure>
<procedure name="get_segmentation_image_ground_truth" access="local">
<interface>
<oo>
<par name="SegmentationImagGroundTruth" base_type="iconic" dimension="0"/>
</oo>
<ic>
<par name="SampleKeys" base_type="ctrl" dimension="0"/>
<par name="DLSample" base_type="ctrl" dimension="0"/>
</ic>
</interface>
<body>
<c>* </c>
<c>* This procedure returns the ground truth segmentation image.</c>
<c>* </c>
<l>if (find(SampleKeys,'segmentation_image') != -1)</l>
<l>    get_dict_object (SegmentationImagGroundTruth, DLSample, 'segmentation_image')</l>
<l>else</l>
<l>    throw ('Ground truth segmentation image could not be found in DLSample.')</l>
<l>endif</l>
<l>return ()</l>
</body>
<docu id="get_segmentation_image_ground_truth">
<chapters lang="de_DE">
<item>Deep Learning</item>
<item>Semantische Segmentierung</item>
</chapters>
<chapters lang="en_US">
<item>Deep Learning</item>
<item>Semantic Segmentation</item>
</chapters>
<library lang="en_US">MVTec Standard Procedures</library>
<short lang="en_US">Get the ground truth segmentation image.</short>
<parameters>
<parameter id="DLSample">
<default_type>integer</default_type>
<mixed_type>false</mixed_type>
<sem_type>dict</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="SampleKeys">
<sem_type>string</sem_type>
</parameter>
<parameter id="SegmentationImagGroundTruth">
<sem_type>image</sem_type>
</parameter>
</parameters>
</docu>
</procedure>
<procedure name="get_segmentation_image_result" access="local">
<interface>
<oo>
<par name="SegmentationImageResult" base_type="iconic" dimension="0"/>
</oo>
<ic>
<par name="ResultKeys" base_type="ctrl" dimension="0"/>
<par name="DLResult" base_type="ctrl" dimension="0"/>
</ic>
</interface>
<body>
<c>* </c>
<c>* This procedure returns the predicted segmentation result image.</c>
<c>* </c>
<l>if (find(ResultKeys,'segmentation_image') != -1)</l>
<l>    get_dict_object (SegmentationImageResult, DLResult, 'segmentation_image')</l>
<l>else</l>
<l>    throw ('Result segmentation data could not be found in DLSample.')</l>
<l>endif</l>
<l>return ()</l>
</body>
<docu id="get_segmentation_image_result">
<chapters lang="de_DE">
<item>Deep Learning</item>
<item>Semantische Segmentierung</item>
</chapters>
<chapters lang="en_US">
<item>Deep Learning</item>
<item>Semantic Segmentation</item>
</chapters>
<library lang="en_US">MVTec Standard Procedures</library>
<short lang="en_US">Get the predicted segmentation result image.</short>
<parameters>
<parameter id="DLResult">
<default_type>integer</default_type>
<mixed_type>false</mixed_type>
<sem_type>dict</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="ResultKeys">
<sem_type>string</sem_type>
</parameter>
<parameter id="SegmentationImageResult">
<sem_type>image</sem_type>
</parameter>
</parameters>
</docu>
</procedure>
<procedure name="get_sheet_of_light_calib_object_dimensions">
<interface>
<ic>
<par name="Width" base_type="ctrl" dimension="0"/>
<par name="Length" base_type="ctrl" dimension="0"/>
<par name="HeightMin" base_type="ctrl" dimension="0"/>
<par name="HeightMax" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="DiameterCircle" base_type="ctrl" dimension="0"/>
<par name="PyramidHeight" base_type="ctrl" dimension="0"/>
<par name="PyramidDistanceFromFront" base_type="ctrl" dimension="0"/>
<par name="PyramidBottomDiagonal" base_type="ctrl" dimension="0"/>
<par name="PyramidTopDiagonal" base_type="ctrl" dimension="0"/>
<par name="Angle" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c>* </c>
<c>* Constants:</c>
<l>CircleFactor := 0.075</l>
<l>PyramidBottomFactor := 0.9</l>
<l>PyramidTopFactor := 0.5</l>
<l>OffsetFactor := 0.1</l>
<l>MaxAngle := rad(45)</l>
<l>Pi := rad(180)</l>
<c>* </c>
<c>* Circle:</c>
<l>DiameterCircle := CircleFactor * Width</l>
<c>* </c>
<l>PyramidBottomDiagonal := Width * PyramidBottomFactor</l>
<l>PyramidTopDiagonal := PyramidBottomDiagonal * PyramidTopFactor</l>
<l>PyramidDistanceFromFront := 0.1 * Length</l>
<c>* </c>
<c>* Find the height of the truncated pyramid such that</c>
<c>* its highest point's Z coordinate is equal to HeightMax.</c>
<l>Height := HeightMax - HeightMin</l>
<l>Hypotenuse := sqrt(Length * Length + Height * Height)</l>
<l>CosAlpha := Length / Hypotenuse</l>
<l>SinAlpha := Height / Hypotenuse</l>
<l>Angle := acos(CosAlpha)</l>
<l>Dist := OffsetFactor * Length + 0.5 * PyramidBottomDiagonal + 0.5 * PyramidTopDiagonal</l>
<l>PyramidHeight1 := (Height - Dist * SinAlpha) / CosAlpha</l>
<c>* </c>
<c>* Limit the height of the pyramid such that the angle of</c>
<c>* its side planes to the ground plane is at most MaxAngle.</c>
<l>PyramidHeight2 := tan(MaxAngle) * 0.5 * (PyramidBottomDiagonal - PyramidTopDiagonal)</l>
<l>PyramidHeight := min2(PyramidHeight1,PyramidHeight2)</l>
<l>return ()</l>
</body>
<docu id="get_sheet_of_light_calib_object_dimensions">
<abstract lang="de_DE">Im Operatorreferenzeintrag von create_sheet_of_light_calib_object kann eine technische Zeichnung gefunden werden, die die hier berechneten Werte visualisiert.</abstract>
<abstract lang="en_US">See the reference entry of create_sheet_of_light_calib_object for a technical drawing which visualizes the calculated dimensions.</abstract>
<chapters lang="de_DE">
<item>3D-Rekonstruktion</item>
<item>Sheet-of-light</item>
</chapters>
<chapters lang="en_US">
<item>3D Reconstruction</item>
<item>Sheet of Light</item>
</chapters>
<example lang="de_DE">Width := 0.1
Length := 0.15
HeightMin := 0.005
HeightMax := 0.04
create_sheet_of_light_calib_object (Width, Length, HeightMin, HeightMax, 'calib_object.dxf')
get_sheet_of_light_calib_object_dimensions (Width, Length, HeightMin, HeightMax, DiameterCircle, \
                                            PyramidHeight, PyramidDistanceFromFront, PyramidBottomDiagonal, \
                                            PyramidTopDiagonal, Angle)</example>
<library lang="en_US">MVTec Standard Procedures</library>
<predecessor>
<item>create_sheet_of_light_calib_object</item>
</predecessor>
<short lang="de_DE">Berechnen der Abmessungen eines Kalibrierobjekts für die Lichtschnittkalibrierung.</short>
<short lang="en_US">Calculate the dimensions of a sheet-of-light calibration object.</short>
<parameters>
<parameter id="Angle">
<default_type>real</default_type>
<description lang="de_DE">Winkel der schiefen Ebene.</description>
<description lang="en_US">Angle of the ramp.</description>
<sem_type>angle.rad</sem_type>
<type_list>
<item>real</item>
</type_list>
</parameter>
<parameter id="DiameterCircle">
<default_type>real</default_type>
<description lang="de_DE">Durchmesser der kreisförmigen Orientierungsmarkierung.</description>
<description lang="en_US">Diameter of the circular orientation mark.</description>
<sem_type>number</sem_type>
<type_list>
<item>real</item>
</type_list>
</parameter>
<parameter id="HeightMax">
<default_type>real</default_type>
<description lang="de_DE">Maximale Höhe der Grundebene.</description>
<description lang="en_US">Maximum height of the ramp.</description>
<sem_type>number</sem_type>
<type_list>
<item>real</item>
</type_list>
</parameter>
<parameter id="HeightMin">
<default_type>real</default_type>
<description lang="de_DE">Minimale Höhe der Grundebene.</description>
<description lang="en_US">Minimum height of the ramp.</description>
<sem_type>number</sem_type>
<type_list>
<item>real</item>
</type_list>
</parameter>
<parameter id="Length">
<default_type>real</default_type>
<description lang="de_DE">Länge des Kalibrierkörpers.</description>
<description lang="en_US">Length of the calibration object.</description>
<sem_type>number</sem_type>
<type_list>
<item>real</item>
</type_list>
</parameter>
<parameter id="PyramidBottomDiagonal">
<default_type>real</default_type>
<description lang="de_DE">Länge der Diagonalen an der Unterseite des Pyramidenstumpfes.</description>
<description lang="en_US">Length of the bottom diagonal of the truncated pyramid.</description>
<sem_type>number</sem_type>
<type_list>
<item>real</item>
</type_list>
</parameter>
<parameter id="PyramidDistanceFromFront">
<default_type>real</default_type>
<description lang="de_DE">Abstand des Pyramidenstumpfes von der Vorderseite des Kalibrierkörpers.</description>
<description lang="en_US">Distance of the truncated pyramid from the front of the calibration object.</description>
<sem_type>number</sem_type>
<type_list>
<item>real</item>
</type_list>
</parameter>
<parameter id="PyramidHeight">
<default_type>real</default_type>
<description lang="de_DE">Höhe des Pyramidenstumpfes.</description>
<description lang="en_US">Height of the truncated pyramid.</description>
<sem_type>number</sem_type>
<type_list>
<item>real</item>
</type_list>
</parameter>
<parameter id="PyramidTopDiagonal">
<default_type>real</default_type>
<description lang="de_DE">Länge der Diagonalen an der Oberseite des Pyramidenstumpfes.</description>
<description lang="en_US">Length of the top diagonal of the truncated pyramid.</description>
<sem_type>number</sem_type>
<type_list>
<item>real</item>
</type_list>
</parameter>
<parameter id="Width">
<default_type>real</default_type>
<description lang="de_DE">Breite des Kalibrierkörpers.</description>
<description lang="en_US">Width of the calibration object.</description>
<sem_type>number</sem_type>
<type_list>
<item>real</item>
</type_list>
</parameter>
</parameters>
</docu>
</procedure>
<procedure name="get_trackball_center" access="local">
<interface>
<ic>
<par name="SelectedObject" base_type="ctrl" dimension="0"/>
<par name="TrackballRadiusPixel" base_type="ctrl" dimension="0"/>
<par name="ObjectModel3D" base_type="ctrl" dimension="0"/>
<par name="Poses" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="TBCenter" base_type="ctrl" dimension="0"/>
<par name="TBSize" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c>* </c>
<l>NumModels := |ObjectModel3D|</l>
<l>TBCenter[0] := 0</l>
<l>TBCenter[1] := 0</l>
<l>TBCenter[2] := 0</l>
<l>Diameter := gen_tuple_const(|ObjectModel3D|,0.0)</l>
<l>for Index := 0 to |ObjectModel3D| - 1 by 1</l>
<l>    try</l>
<l>        get_object_model_3d_params (ObjectModel3D[Index], 'center', Center)</l>
<l>        get_object_model_3d_params (ObjectModel3D[Index], 'diameter_axis_aligned_bounding_box', CurrDiameter)</l>
<l>        Diameter[Index] := CurrDiameter</l>
<l>    catch (Exception)</l>
<c>        * 3D object model is empty or otherwise malformed -&gt; ignore</c>
<l>    endtry</l>
<l>endfor</l>
<c>* Normalize Diameter to use it as weights for a weighted mean of the individual centers</c>
<l>MD := mean(Diameter)</l>
<l>if (MD &gt; 1e-10)</l>
<l>    Weight := Diameter / MD</l>
<l>else</l>
<l>    Weight := Diameter</l>
<l>endif</l>
<l>SumW := sum(select_mask(Weight,abs(sgn(SelectedObject))))</l>
<l>if (SumW &lt; 1e-10)</l>
<l>    Weight := gen_tuple_const(|Weight|,1.0)</l>
<l>    SumW := sum(select_mask(Weight,abs(sgn(SelectedObject))))</l>
<l>endif</l>
<l>if (SumW &lt; 1e-10)</l>
<l>    SumW := 1.0</l>
<l>endif</l>
<l>for Index := 0 to NumModels - 1 by 1</l>
<l>    if (SelectedObject[Index] and Diameter[Index] &gt; 0)</l>
<l>        PoseSelected := Poses[Index * 7:Index * 7 + 6]</l>
<l>        pose_to_hom_mat3d (PoseSelected, HomMat3D)</l>
<l>        get_object_model_3d_params (ObjectModel3D[Index], 'center', Center)</l>
<l>        affine_trans_point_3d (HomMat3D, Center[0], Center[1], Center[2], TBCenterCamX, TBCenterCamY, TBCenterCamZ)</l>
<l>        TBCenter[0] := TBCenter[0] + TBCenterCamX * Weight[Index]</l>
<l>        TBCenter[1] := TBCenter[1] + TBCenterCamY * Weight[Index]</l>
<l>        TBCenter[2] := TBCenter[2] + TBCenterCamZ * Weight[Index]</l>
<l>    endif</l>
<l>endfor</l>
<l>if (max(SelectedObject) != 0)</l>
<l>    InvSum := 1.0 / SumW</l>
<l>    TBCenter[0] := TBCenter[0] * InvSum</l>
<l>    TBCenter[1] := TBCenter[1] * InvSum</l>
<l>    TBCenter[2] := TBCenter[2] * InvSum</l>
<l>    TBSize := (0.5 + 0.5 * sum(SelectedObject) / NumModels) * TrackballRadiusPixel</l>
<l>else</l>
<l>    TBCenter := []</l>
<l>    TBSize := 0</l>
<l>endif</l>
<l>return ()</l>
</body>
<docu id="get_trackball_center">
<chapters lang="de_DE">
<item>Graphik</item>
<item>Ausgabe</item>
</chapters>
<chapters lang="en_US">
<item>Graphics</item>
<item>Output</item>
</chapters>
<library lang="en_US">MVTec Standard Procedures</library>
<short lang="en_US">Get the center of the virtual trackback that is used to move the camera.</short>
<parameters>
<parameter id="ObjectModel3D"/>
<parameter id="Poses"/>
<parameter id="SelectedObject"/>
<parameter id="TBCenter"/>
<parameter id="TBSize"/>
<parameter id="TrackballRadiusPixel"/>
</parameters>
</docu>
</procedure>
<procedure name="get_trackball_center_fixed" access="local">
<interface>
<ic>
<par name="SelectedObject" base_type="ctrl" dimension="0"/>
<par name="TrackballCenterRow" base_type="ctrl" dimension="0"/>
<par name="TrackballCenterCol" base_type="ctrl" dimension="0"/>
<par name="TrackballRadiusPixel" base_type="ctrl" dimension="0"/>
<par name="Scene3D" base_type="ctrl" dimension="0"/>
<par name="ObjectModel3DID" base_type="ctrl" dimension="0"/>
<par name="Poses" base_type="ctrl" dimension="0"/>
<par name="WindowHandleBuffer" base_type="ctrl" dimension="0"/>
<par name="CamParam" base_type="ctrl" dimension="0"/>
<par name="GenParamName" base_type="ctrl" dimension="0"/>
<par name="GenParamValue" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="TBCenter" base_type="ctrl" dimension="0"/>
<par name="TBSize" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c>* </c>
<c>* Determine the trackball center for the fixed trackball</c>
<l>NumModels := |ObjectModel3DID|</l>
<l>get_cam_par_data (CamParam, 'image_width', Width)</l>
<l>get_cam_par_data (CamParam, 'image_height', Height)</l>
<c>* </c>
<c>* Project the selected objects</c>
<l>SelectPose := []</l>
<l>for Index1 := 0 to |SelectedObject| - 1 by 1</l>
<l>    SelectPose := [SelectPose,gen_tuple_const(7,SelectedObject[Index1])]</l>
<l>    if (SelectedObject[Index1] == 0)</l>
<l>        set_scene_3d_instance_param (Scene3D, Index1, 'visible', 'false')</l>
<l>    endif</l>
<l>endfor</l>
<l>set_scene_3d_param (Scene3D, 'depth_persistence', 'true')</l>
<l>display_scene_3d (WindowHandleBuffer, Scene3D, 0)</l>
<l>set_scene_3d_param (Scene3D, 'visible', 'true')</l>
<c>* </c>
<c>* determine the depth of the object point that appears closest to the trackball</c>
<c>* center</c>
<l>gen_region_points (RegionCenter, TrackballCenterRow, TrackballCenterCol)</l>
<l>distance_transform (RegionCenter, DistanceImage, 'chamfer-3-4-unnormalized', 'false', Width, Height)</l>
<l>get_domain (DistanceImage, Domain)</l>
<l>get_region_points (Domain, Rows, Columns)</l>
<l>get_grayval (DistanceImage, Rows, Columns, Grayval)</l>
<l>tuple_sort_index (Grayval, IndicesG)</l>
<l>get_display_scene_3d_info (WindowHandleBuffer, Scene3D, subset(Rows,IndicesG), subset(Columns,IndicesG), 'depth', Value)</l>
<l>tuple_find (sgn(Value), 1, Pos)</l>
<c>* </c>
<l>set_scene_3d_param (Scene3D, 'depth_persistence', 'false')</l>
<c>* </c>
<c>* </c>
<c>* set TBCenter</c>
<l>if (Pos != -1)</l>
<c>    * if the object is visible in the image</c>
<l>    TBCenter := [0,0,Value[Pos[0]]]</l>
<l>else</l>
<c>    * if the object is not visible in the image, set the z coordinate to -1</c>
<c>    * to indicate, the the previous z value should be used instead</c>
<l>    TBCenter := [0,0,-1]</l>
<l>endif</l>
<c>* </c>
<l>if (max(SelectedObject) != 0)</l>
<l>    TBSize := (0.5 + 0.5 * sum(SelectedObject) / NumModels) * TrackballRadiusPixel</l>
<l>else</l>
<l>    TBCenter := []</l>
<l>    TBSize := 0</l>
<l>endif</l>
<l>return ()</l>
</body>
<docu id="get_trackball_center_fixed">
<chapters lang="de_DE">
<item>Graphik</item>
<item>Ausgabe</item>
</chapters>
<chapters lang="en_US">
<item>Graphics</item>
<item>Output</item>
</chapters>
<library lang="de_DE">MVTec Standard Procedures</library>
<library lang="en_US">MVTec Standard Procedures</library>
<short lang="en_US">Get the center of the virtual trackback that is used to move the camera (version for inspection_mode = 'surface').</short>
<parameters>
<parameter id="CamParam"/>
<parameter id="GenParamName"/>
<parameter id="GenParamValue"/>
<parameter id="ObjectModel3DID"/>
<parameter id="Poses"/>
<parameter id="Scene3D"/>
<parameter id="SelectedObject"/>
<parameter id="TBCenter"/>
<parameter id="TBSize"/>
<parameter id="TrackballCenterCol"/>
<parameter id="TrackballCenterRow"/>
<parameter id="TrackballRadiusPixel"/>
<parameter id="WindowHandleBuffer"/>
</parameters>
</docu>
</procedure>
<procedure name="get_weight_image" access="local">
<interface>
<oo>
<par name="ImageWeight" base_type="iconic" dimension="0"/>
</oo>
<ic>
<par name="SampleKeys" base_type="ctrl" dimension="0"/>
<par name="DLSample" base_type="ctrl" dimension="0"/>
</ic>
</interface>
<body>
<c>* </c>
<c>* This procedure returns the segmentation weight image of a sample.</c>
<c>* </c>
<l>if (find(SampleKeys,'weight_image') != -1)</l>
<l>    get_dict_object (ImageWeight, DLSample, 'weight_image')</l>
<l>else</l>
<l>    throw ('Weight image could not be found in DLSample.')</l>
<l>endif</l>
<l>return ()</l>
</body>
<docu id="get_weight_image">
<chapters lang="de_DE">
<item>Deep Learning</item>
<item>Semantische Segmentierung</item>
</chapters>
<chapters lang="en_US">
<item>Deep Learning</item>
<item>Semantic Segmentation</item>
</chapters>
<library lang="en_US">MVTec Standard Procedures</library>
<short lang="en_US">Get the weight image of a sample.</short>
<parameters>
<parameter id="DLSample">
<default_type>integer</default_type>
<mixed_type>false</mixed_type>
<sem_type>dict</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="ImageWeight">
<sem_type>image</sem_type>
</parameter>
<parameter id="SampleKeys">
<sem_type>string</sem_type>
</parameter>
</parameters>
</docu>
</procedure>
<procedure name="images_exist" access="local">
<interface>
<ic>
<par name="ImageList" base_type="ctrl" dimension="0"/>
</ic>
</interface>
<body>
<c>* </c>
<c>* Get HalconImages directories.</c>
<l>get_system ('operating_system', OS)</l>
<l>if (OS{0:2} == 'Win')</l>
<l>    Separator := ';'</l>
<l>else</l>
<l>    Separator := ':'</l>
<l>endif</l>
<l>get_system ('image_dir', HalconImages)</l>
<l>tuple_split (HalconImages, Separator, HalconImages)</l>
<c>* </c>
<c>* Loop over images and segmentations.</c>
<l>for Index := 0 to |ImageList| - 1 by 1</l>
<l>    file_exists (ImageList[Index], ImageExists)</l>
<l>    if (not ImageExists)</l>
<c>        * Check in HalconImages directories.</c>
<l>        for DirIndex := 0 to |HalconImages| - 1 by 1</l>
<l>            file_exists (HalconImages[DirIndex] + '/' + ImageList[Index], ImageExists)</l>
<l>            if (ImageExists)</l>
<l>                break</l>
<l>            endif</l>
<l>        endfor</l>
<l>        if (not ImageExists)</l>
<l>            throw ('Image ' + ImageList[Index] + ' does not exist')</l>
<l>        endif</l>
<l>    endif</l>
<l>endfor</l>
<l>return ()</l>
</body>
<docu id="images_exist">
<abstract lang="en_US">Check for every image in ImageList if it exists.</abstract>
<chapters lang="de_DE">
<item>File</item>
<item>Misc</item>
</chapters>
<chapters lang="en_US">
<item>File</item>
<item>Misc</item>
</chapters>
<library lang="en_US">MVTec Standard Procedures</library>
<parameters>
<parameter id="ImageList">
<default_type>string</default_type>
<description lang="en_US">List of image paths.</description>
<mixed_type>false</mixed_type>
<multivalue>optional</multivalue>
<sem_type>filename</sem_type>
<type_list>
<item>string</item>
</type_list>
</parameter>
</parameters>
</docu>
</procedure>
<procedure name="init_running_evaluation_measures">
<interface>
<ic>
<par name="EvalParams" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="RunningMeasures" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c>* </c>
<c>* This procedure initializes the dictionary RunningMeasures for evaluation.</c>
<c>* It uses the evaluation parameters to initialize the running measures accordingly.</c>
<c>* </c>
<c>* The structure of RunningMeasures depends on the entry 'evaluate_instances' in the dictionary EvalParams.</c>
<c>* </c>
<c>* The dictionary RunningMeasures can be updated based on the per-batch/per-image evaluation results.</c>
<c>* </c>
<l>create_dict (RunningMeasures)</l>
<c>* Check that the necessary evaluation parameters exist.</c>
<l>validate_evaluation_param (EvalParams, Valid, Exception)</l>
<l>if (not Valid)</l>
<l>    throw ('Invalid EvalParams, ' + Exception)</l>
<l>endif</l>
<c>* </c>
<c>* Get general evaluation parameters.</c>
<l>get_dict_tuple (EvalParams, 'num_classes', NumClasses)</l>
<l>get_dict_tuple (EvalParams, 'evaluation_type', EvaluationType)</l>
<l>get_dict_tuple (EvalParams, 'measures', Measures)</l>
<l>get_dict_tuple (EvalParams, 'class_ids', ClassIDs)</l>
<c>* </c>
<l>if (EvaluationType == 'anomaly_detection')</l>
<c>    * RunningMeasures contains:</c>
<c>    * - image_ids:          IDs of the images.</c>
<c>    * - anomaly_label_ids:  Class IDs of ground truth labels.</c>
<c>    * - anomaly_scores:     Predicted image level anomaly scores.</c>
<l>    set_dict_tuple (RunningMeasures, 'image_ids', [])</l>
<l>    set_dict_tuple (RunningMeasures, 'anomaly_label_ids', [])</l>
<l>    set_dict_tuple (RunningMeasures, 'anomaly_scores', [])</l>
<l>elseif (EvaluationType == 'classification')</l>
<c>    * RunningMeasures contains:</c>
<c>    * - image_ids:          IDs of the images.</c>
<c>    * - image_label_ids:    Class IDs of ground truth labels.</c>
<c>    * - top1_predictions:   Class IDs of the top predicted class.</c>
<c>    * - topk_predictions:   Class IDs of top-K predicted classes.</c>
<l>    set_dict_tuple (RunningMeasures, 'image_ids', [])</l>
<l>    set_dict_tuple (RunningMeasures, 'image_label_ids', [])</l>
<l>    set_dict_tuple (RunningMeasures, 'top1_predictions', [])</l>
<l>    set_dict_tuple (RunningMeasures, 'topk_predictions', [])</l>
<l>elseif (EvaluationType == 'detection')</l>
<c>    * RunningMeasures contains:</c>
<c>    * For each maximal number of regions (MaxNumDetections):</c>
<c>    *  - For each area range (AreaRanges):</c>
<c>    *    -- confidence:     Confidence (score) of each result.</c>
<c>    *    -- num_gt:         Total number of ground truth instances per class.</c>
<c>    *    -- num_pred:       Total number of predictions per class.</c>
<c>    *    -- num_gt_ignore:  Number of ignored ground truth instances per class.</c>
<c>    *    -- for each IoU-threshold:</c>
<c>    *       --- For each class:</c>
<c>    *           ---- is_tp:                  TP/FP assignment of result.</c>
<c>    *           ---- ignore:                 Ignore/Not-Ignore assignment of result.</c>
<c>    *           ---- abs_orientation_diff (for instance_type 'rectangle2' with measure SoAP):</c>
<c>    *                                        Absolute orientation difference of the result.</c>
<c>    * </c>
<c>    * Check if the orientation difference is to be evaluated.</c>
<l>    get_dict_tuple (EvalParams, 'instance_type', InstanceType)</l>
<l>    EvalOrientation := false</l>
<l>    if (InstanceType == 'rectangle2' and (find(Measures,'soap') != -1 or find(Measures,'all') != -1))</l>
<l>        EvalOrientation := true</l>
<l>    endif</l>
<c>    * </c>
<c>    * Calculating the measures confidence, is_tp, ignore, and abs_orientation_diff,</c>
<c>    * arrays are allocated with -1 in blocks of AllocationBlockLength</c>
<c>    * (thus, if a block is filled, the next block is allocated).</c>
<c>    * Otherwise the arrays have to be concatenated which is rather slow.</c>
<c>    * The actual length of the array is garnered in num_pred.</c>
<l>    get_dict_tuple (EvalParams, 'allocation_block_length', AllocationBlockLength)</l>
<l>    get_dict_tuple (EvalParams, 'iou_threshold', IoUThreshs)</l>
<l>    get_dict_tuple (EvalParams, 'max_num_detections', MaxNumDetections)</l>
<l>    get_dict_tuple (EvalParams, 'area_ranges', AreaRanges)</l>
<c>    * AreaRanges is a dictionary containing 'name', 'min_area', 'max_area'.</c>
<l>    get_dict_tuple (AreaRanges, 'name', AreaNames)</l>
<l>    get_dict_tuple (AreaRanges, 'min', MinAreas)</l>
<l>    get_dict_tuple (AreaRanges, 'max', MaxAreas)</l>
<c>    * Check if a detailed evaluation will be performed.</c>
<l>    get_dict_tuple (EvalParams, 'detailed_evaluation', DetailedEvaluation)</l>
<c>    * Set a result dictionary for each maximal number of detections and IoU-threshold.</c>
<l>    for MaxNumIdx := 0 to |MaxNumDetections| - 1 by 1</l>
<l>        MaxNum := MaxNumDetections[MaxNumIdx]</l>
<l>        create_dict (CurrentRunningMeasure)</l>
<l>        for AreaIdx := 0 to |AreaNames| - 1 by 1</l>
<l>            create_dict (AreaRunningMeasure)</l>
<l>            for I := 0 to |IoUThreshs| - 1 by 1</l>
<l>                create_dict (IoURunningMeasure)</l>
<l>                for ClsIdx := 0 to NumClasses - 1 by 1</l>
<l>                    create_dict (ClassRunningMeasures)</l>
<l>                    set_dict_tuple (ClassRunningMeasures, 'is_tp', gen_tuple_const(AllocationBlockLength,-1))</l>
<l>                    set_dict_tuple (ClassRunningMeasures, 'ignore', gen_tuple_const(AllocationBlockLength,-1))</l>
<l>                    if (EvalOrientation)</l>
<l>                        set_dict_tuple (ClassRunningMeasures, 'abs_orientation_diff', gen_tuple_const(AllocationBlockLength,-1))</l>
<l>                    endif</l>
<l>                    if (DetailedEvaluation)</l>
<l>                        set_dict_tuple (ClassRunningMeasures, 'is_fp_class', gen_tuple_const(AllocationBlockLength,-1))</l>
<l>                        set_dict_tuple (ClassRunningMeasures, 'is_fp_background', gen_tuple_const(AllocationBlockLength,-1))</l>
<l>                        set_dict_tuple (ClassRunningMeasures, 'is_fp_localization', gen_tuple_const(AllocationBlockLength,-1))</l>
<l>                        set_dict_tuple (ClassRunningMeasures, 'is_fp_duplicate', gen_tuple_const(AllocationBlockLength,-1))</l>
<l>                        set_dict_tuple (ClassRunningMeasures, 'is_fp_multiple', gen_tuple_const(AllocationBlockLength,-1))</l>
<l>                        if (EvalOrientation)</l>
<l>                            set_dict_tuple (ClassRunningMeasures, 'abs_orientation_diff_class', gen_tuple_const(AllocationBlockLength,-1))</l>
<l>                            set_dict_tuple (ClassRunningMeasures, 'abs_orientation_diff_localization', gen_tuple_const(AllocationBlockLength,-1))</l>
<l>                            set_dict_tuple (ClassRunningMeasures, 'abs_orientation_diff_duplicate', gen_tuple_const(AllocationBlockLength,-1))</l>
<l>                            set_dict_tuple (ClassRunningMeasures, 'abs_orientation_diff_multiple', gen_tuple_const(AllocationBlockLength,-1))</l>
<l>                        endif</l>
<l>                        set_dict_tuple (IoURunningMeasure, 'image_ids_with_false_negatives', gen_tuple_const(AllocationBlockLength,-1))</l>
<l>                        set_dict_tuple (IoURunningMeasure, 'image_ids_with_false_positives', gen_tuple_const(AllocationBlockLength,-1))</l>
<l>                        set_dict_tuple (IoURunningMeasure, 'num_image_ids_with_false_negatives', 0)</l>
<l>                        set_dict_tuple (IoURunningMeasure, 'num_image_ids_with_false_positives', 0)</l>
<l>                    endif</l>
<l>                    set_dict_tuple (IoURunningMeasure, 'class_' + ClassIDs[ClsIdx], ClassRunningMeasures)</l>
<l>                endfor</l>
<l>                set_dict_tuple (AreaRunningMeasure, 'iou_' + regexp_replace('' + IoUThreshs[I],'\\.',''), IoURunningMeasure)</l>
<l>            endfor</l>
<l>            create_dict (Confidence)</l>
<l>            for ClsIdx := 0 to NumClasses - 1 by 1</l>
<l>                set_dict_tuple (Confidence, 'class_' + ClassIDs[ClsIdx], gen_tuple_const(AllocationBlockLength,-1.0))</l>
<l>            endfor</l>
<l>            set_dict_tuple (AreaRunningMeasure, 'confidence', Confidence)</l>
<l>            set_dict_tuple (AreaRunningMeasure, 'num_gt', gen_tuple_const(NumClasses,0))</l>
<l>            set_dict_tuple (AreaRunningMeasure, 'num_pred', gen_tuple_const(NumClasses,0))</l>
<l>            set_dict_tuple (AreaRunningMeasure, 'num_gt_ignore', gen_tuple_const(NumClasses,0))</l>
<l>            set_dict_tuple (CurrentRunningMeasure, 'area_' + AreaNames[AreaIdx], AreaRunningMeasure)</l>
<l>        endfor</l>
<l>        if (MaxNum == -1)</l>
<l>            MaxNum := 'all'</l>
<l>        endif</l>
<l>        set_dict_tuple (RunningMeasures, 'max_num_detections_' + MaxNum, CurrentRunningMeasure)</l>
<l>    endfor</l>
<l>elseif (EvaluationType == 'segmentation')</l>
<c>    * RunningMeasures contains:</c>
<c>    * if confusion matrix in Measures (slower but more information).</c>
<c>    *  - confusion matrix per pixel.</c>
<c>    * else:</c>
<c>    *  - TP/FP/FN (pixel numbers per class).</c>
<c>    * </c>
<c>    * Incorporate ignore class IDs.</c>
<l>    get_dict_tuple (EvalParams, 'ignore_class_ids', IgnoreClassIDs)</l>
<c>    * </c>
<c>    * Check if we need to compute/update the confusion matrix.</c>
<l>    CalcConfMatrix := (find(Measures,'pixel_confusion_matrix') &gt; -1) or (find(Measures,'all') &gt; -1)</l>
<l>    if (CalcConfMatrix)</l>
<c>        * Define the size of the confusion matrix.</c>
<l>        MatrixSize := NumClasses + (|IgnoreClassIDs| &gt; 0)</l>
<l>        create_matrix (MatrixSize, MatrixSize, 0, PixelConfusionMatrix)</l>
<l>        set_dict_tuple (RunningMeasures, 'pixel_confusion_matrix', PixelConfusionMatrix)</l>
<c>        * </c>
<c>        * If the class IDs are not running indices from 0 to NumClasses we</c>
<c>        * define a mapping from class IDs to class indices.</c>
<l>        if (ClassIDs != [0:|ClassIDs| - 1] or |IgnoreClassIDs| &gt; 0)</l>
<c>            * Get the max ID that can occur.</c>
<l>            MaxId := max(ClassIDs) + (|IgnoreClassIDs| &gt; 0)</l>
<c>            * Define the basic mapping.</c>
<l>            tuple_gen_const (MaxId + 1, -1, ClsIDToClsIdx)</l>
<l>            ClsIDToClsIdx[ClassIDs] := [0:|ClassIDs| - 1]</l>
<c>            * Map ignore IDs to the next higher one.</c>
<l>            ClsIDToClsIdx[IgnoreClassIDs] := max(ClsIDToClsIdx) + 1</l>
<c>            * Set the mapping to the evaluation parameters.</c>
<l>            set_dict_tuple (EvalParams, 'class_id_mapping', ClsIDToClsIdx)</l>
<l>        endif</l>
<l>    else</l>
<l>        TP := gen_tuple_const(NumClasses,0)</l>
<l>        FP := gen_tuple_const(NumClasses,0)</l>
<l>        FN := gen_tuple_const(NumClasses,0)</l>
<l>        set_dict_tuple (RunningMeasures, 'tp', TP)</l>
<l>        set_dict_tuple (RunningMeasures, 'fp', FP)</l>
<l>        set_dict_tuple (RunningMeasures, 'fn', FN)</l>
<l>    endif</l>
<l>endif</l>
<c>* </c>
<l>return ()</l>
</body>
<docu id="init_running_evaluation_measures">
<abstract lang="en_US">This procedure initializes the dictionary RunningMeasures for evaluation.

The structure of RunningMeasures depends on the entry 'evaluate_type' in the dictionary EvalParams:

- for evaluation of type 'anomaly_detection', RunningMeasures contains the following keys:
  -- 'image_ids': IDs of the images.
  -- 'anomaly_label_ids': Class IDs of ground truth labels.
  -- 'anomaly_scores': Predicted image level anomaly scores.

- for evaluation of type 'classification', RunningMeasures contains the following keys:
  -- 'image_ids': IDs of the images.
  -- 'image_label_ids': Class IDs of ground truth labels.
  -- 'top1_predictions': Class IDs of the top predicted class.
  -- 'topk_predictions': Class IDs of top-K predicted classes.

- for evaluation of type 'detection', RunningMeasures is a nested dictionary. It contains
   -- for each maximal number of regions, thus each value of the entry 'max_num_detections' in EvalParams, an entry 'max_num_detections_' followed by the given number or 'all':
      --- for each area range, thus each value of the entry 'area_ranges' in EvalParams, an entry 'area_' followed by its name: 
         ---- 'confidence': A dictionary with:
              ----- a tuple for each class with:
                    ------ result confidences.
         ---- 'num_gt': The tuple storing for each class the number of ground truth instances.
         ---- 'num_pred': The number of predictions.
         ---- 'num_gt_ignore': The number of ground truth instances that shall be ignored.
         ----  for each IoU-threshold, thus each value val of the entry 'iou_threshold' in EvalParams a dictionary (D1), an entry 'iou_val':
              -----  for each class a dictionary (D2) with:
                    ------ 'is_tp': Tuple to keep track for each detection if it is a true positive (for that particular IoU-threshold)
                    ------ 'ignore': Tuple to keep track for each detection if it is ignored (e.g. due to the current area range).
                    ------ 'abs_orientation_diff' (only if 'soap' is set in EvalParams 'measures'): Tuple to keep track for each detection about the absolute orientation difference in radian of each result instance with the according ground truth instance. If the result instance is a false positive, the value is set to -1 and ignored for further processing.

      If EvalParams 'detailed_evaluation' is true, additionally the dictionaries marked above with (D1) or (D2) will contain:
         (D1)  for each entry of EvalParams 'iou_threshold':
              ----- 'image_ids_with_false_negatives': Tuple containing the image IDs where false negatives occur.
              ----- 'image_ids_with_false_positives': Tuple containing the image IDs where false positives occur.
              ----- 'num_image_ids_with_false_negatives': The number of image IDs where false negatives occur. 
              ----- 'num_image_ids_with_false_positives': The number of image IDs where false positives occur.
               (D2)  for each class-dictionary the additional entries:
                    ------ 'is_fp_class': Tuple with the following entries depending on 'is_tp':
                            for detections where 'is_tp' is true: -1
                            for detections where 'is_tp' is false: Class index of the ground truth annotation with which the detection
                                overlaps most (thus, has the highest IoU), if this IoU is greater than the IoU-threshold, else -1.
                    ------ 'is_fp_background': Tuple with the following entries depending on 'is_tp':
                            for detections where 'is_tp' is true: 0
                            for detections where 'is_tp' is false: 1 if the IoU is zero with the ground truth annotations of all classes,
                                i.e., a detection within the background, else to 0.
                    ------- 'is_fp_localization': Tuple with the following entries depending on 'is_tp':
                            for detections where 'is_tp' is true: 0
                            for detections where 'is_tp' is false: 1 if the iou was between 0 and iou_threshold with a ground truth annotation
                                of the same class, i.e. a detection with bad localization for detection where 'is_tp' is false, else 0.
                    ------- 'is_fp_duplicate': Tuple with the following entries depending on 'is_tp':
                            for detections where 'is_tp' is true: 0
                            for detections where 'is_tp' is false: 1 if the class is correct and the IoU with an annotation of the same class
                                is above iou_threshold, else 0.
                                This detection would be a true positive, but apparently there is another detection with higher score.
                    ------- 'is_fp_multiple': Tuple with the following entries depending on 'is_tp':
                            for detections where 'is_tp' is true: 0
                            for detections where 'is_tp' is false: 1 if there are multiple reasons for the detection to be a false positive,
                                e.g. false class and low IoU with a ground truth annotation, else to 0.
                    For instance_type 'rectangle2', if 'soap' is set in 'measures', the additional entries (always relating to the ground truth instance with the highest IoU):
                    ------- 'abs_orientation_diff_class': Tuple with the following entries depending on 'is_fp_class':
                            for detections where 'is_fp_class' is true: The absolute orientation difference of the result.
                            for detections where 'is_fp_class' is false: -1.
                    ------- 'abs_orientation_diff_localization': Tuple with the following entries depending on 'is_fp_localization':
                            for detections where 'is_fp_localization' is true: The absolute orientation difference of the result.
                            for detections where 'is_fp_localization' is false: -1.
                    ------- 'abs_orientation_diff_duplicate': Tuple with the following entries depending on 'is_fp_duplicate':
                            for detections where 'is_fp_duplicate' is true: The absolute orientation difference of the result.
                            for detections where 'is_fp_duplicate' is false: -1.
                    ------- 'abs_orientation_diff_multiple': Tuple with the following entries depending on 'is_fp_multiple':
                            for detections where 'is_fp_multiple' is true: The absolute orientation difference of the result.
                            for detections where 'is_fp_multiple' is false: -1.
                    Note that for detections where 'is_tp' is false, exactly one of 'is_fp_background', 'is_fp_class', 'is_fp_localization',
                    'is_fp_duplicate' or 'is_fp_multiple' has to be true or not -1 in case of false_class.

- for evaluation of type 'segmentation', the structure of RunningMeasures depends if EvalParams 'measures' contains 'pixel_confusion_matrix':
   -- If so, RunningMeasures is a dictionary that contains the pixel confusion matrix of size
      (EvalParams 'num_classes', EvalParams 'num_classes').
     The matrix stores in entry (i,j) how many pixels of class_ids[j] have been predicted as class_ids[i].
     The pixel confusion matrix contains an additional row and column for the ignore class if ignore_class_ids are given.
   -- If not, there are three tuples of length EvalParams 'num_classes':
      --- 'TP' - number of true positive pixels per class
      --- 'FP' - number of false positive pixels per class
      --- 'FN' - number of false negative pixels per class

Please also see update_running_evaluation_measures.</abstract>
<chapters lang="de_DE">
<item>Deep Learning</item>
<item>Evaluierung</item>
</chapters>
<chapters lang="en_US">
<item>Deep Learning</item>
<item>Evaluation</item>
</chapters>
<library lang="en_US">MVTec Standard Procedures</library>
<short lang="en_US">Initialize the dictionary RunningMeasures for the evaluation.</short>
<parameters>
<parameter id="EvalParams">
<default_type>integer</default_type>
<default_value>EvalParams</default_value>
<description lang="en_US">Dictionary with the evaluation parameters.</description>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>dict</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="RunningMeasures">
<default_type>integer</default_type>
<description lang="en_US">Initialized dictionary for the running measures.</description>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>dict</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
</parameters>
</docu>
</procedure>
<procedure name="init_train_dl_model_change_strategies" access="local">
<interface>
<ic>
<par name="TrainParam" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="ChangeStrategyData" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c>* </c>
<c>* Initialize a dictionary with the change strategies data.</c>
<l>create_dict (ChangeStrategyData)</l>
<l>get_dict_tuple (TrainParam, 'change_strategies', ChangeStrategies)</l>
<l>Enabled := |ChangeStrategies| &gt; 0</l>
<l>set_dict_tuple (ChangeStrategyData, 'enabled', Enabled)</l>
<l>if (not Enabled)</l>
<l>    return ()</l>
<l>endif</l>
<c>* </c>
<c>* Sort all epochs in all change strategies.</c>
<l>for Index := 0 to |ChangeStrategies| - 1 by 1</l>
<l>    ChangeStrategy := ChangeStrategies[Index]</l>
<l>    get_dict_tuple (ChangeStrategy, 'model_param', ModelParam)</l>
<l>    get_dict_tuple (ChangeStrategy, 'epochs', Epochs)</l>
<l>    get_dict_tuple (ChangeStrategy, 'values', Values)</l>
<l>    get_dict_tuple (ChangeStrategy, 'initial_value', Initial)</l>
<c>    * Check that the length are equal.</c>
<l>    if (|Epochs| != |Values|)</l>
<l>        throw ('ChangeStrategy parameter error: \'epochs\' and \'values\' need to have same length.')</l>
<l>    endif</l>
<c>    * We need sorted arrays for faster access.</c>
<l>    tuple_sort_index (Epochs, Indices)</l>
<l>    set_dict_tuple (ChangeStrategy, 'epochs', Epochs[Indices])</l>
<l>    set_dict_tuple (ChangeStrategy, 'values', Values[Indices])</l>
<c>    * </c>
<c>    * For the learning rate, there can be an additional parameter</c>
<c>    * indicating if the momentum should be scaled as well.</c>
<l>    if (ModelParam == 'learning_rate')</l>
<l>        get_dict_param (ChangeStrategy, 'key_exists', 'scale_momentum_threshold', ScaleThresholdExists)</l>
<l>        if (not ScaleThresholdExists)</l>
<c>            * If not given, the threshold is set to an empty tuple such that no scaling is performed.</c>
<l>            set_dict_tuple (ChangeStrategy, 'scale_momentum_threshold', [])</l>
<l>        endif</l>
<l>    endif</l>
<l>endfor</l>
<l>set_dict_tuple (ChangeStrategyData, 'strategies', ChangeStrategies)</l>
<l>return ()</l>
</body>
<docu id="init_train_dl_model_change_strategies">
<abstract lang="en_US">This procedure initializes the change strategies data defined in the dictionary TrainParam and returns them sorted in the dictionary ChangeStrategyData.</abstract>
<chapters lang="de_DE">
<item>Deep Learning</item>
<item>Modell</item>
</chapters>
<chapters lang="en_US">
<item>Deep Learning</item>
<item>Model</item>
</chapters>
<library lang="en_US">MVTec Standard Procedures</library>
<short lang="en_US">Initialize change strategies data.</short>
<parameters>
<parameter id="ChangeStrategyData">
<default_type>integer</default_type>
<description lang="en_US">Dictionary with the change strategy data.</description>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>dict</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="TrainParam">
<default_type>integer</default_type>
<description lang="en_US">Dictionary with the training parameters.</description>
<mixed_type>false</mixed_type>
<multivalue>optional</multivalue>
<sem_type>dict</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
</parameters>
</docu>
</procedure>
<procedure name="init_train_dl_model_serialization_strategies" access="local">
<interface>
<ic>
<par name="TrainParam" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="SerializationData" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c>* </c>
<c>* This procedure initializes the dictionary setting the serialization strategies.</c>
<c>* </c>
<c>* Initialize each serialization strategy.</c>
<l>get_dict_tuple (TrainParam, 'serialization_strategies', SerializationStrategies)</l>
<l>create_dict (SerializationData)</l>
<l>set_dict_tuple (SerializationData, 'strategies', SerializationStrategies)</l>
<l>RawData := []</l>
<l>Types := []</l>
<l>SerializeFinal := false</l>
<l>for Index := 0 to |SerializationStrategies| - 1 by 1</l>
<l>    Strategy := SerializationStrategies[Index]</l>
<l>    get_dict_tuple (Strategy, 'type', Type)</l>
<l>    create_dict (Data)</l>
<l>    if (Type == 'best')</l>
<l>        set_dict_tuple (Data, 'best_value', -1)</l>
<l>    elseif (Type == 'epochs')</l>
<l>        get_dict_tuple (Strategy, 'epochs', Epochs)</l>
<c>        * Store sorted values in order to search faster during updates.</c>
<l>        tuple_sort (Epochs, Epochs)</l>
<l>        set_dict_tuple (Data, 'epochs', Epochs)</l>
<l>        set_dict_tuple (Data, 'last_epoch_index', -1)</l>
<l>    elseif (Type == 'final')</l>
<l>        set_dict_tuple (Data, 'serialize_final', true)</l>
<l>    else</l>
<l>        throw ('Unknown serialization strategy type: \'' + Type + '\'')</l>
<l>    endif</l>
<l>    Types := [Types,Type]</l>
<l>    RawData := [RawData,Data]</l>
<l>endfor</l>
<l>set_dict_tuple (SerializationData, 'raw_data', RawData)</l>
<l>set_dict_tuple (SerializationData, 'types', Types)</l>
<l>return ()</l>
</body>
<docu id="init_train_dl_model_serialization_strategies">
<abstract lang="en_US">This procedure initializes the dictionary SerializationData with the serialization strategies.</abstract>
<chapters lang="de_DE">
<item>Deep Learning</item>
<item>Modell</item>
</chapters>
<chapters lang="en_US">
<item>Deep Learning</item>
<item>Model</item>
</chapters>
<library lang="en_US">MVTec Standard Procedures</library>
<short lang="en_US">Initializes the dictionary setting the serialization strategies.</short>
<parameters>
<parameter id="SerializationData">
<default_type>integer</default_type>
<description lang="en_US">Initialized serialization data used during training.</description>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>dict</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="TrainParam">
<default_type>integer</default_type>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>dict</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
</parameters>
</docu>
</procedure>
<procedure name="inspect_normal_direction" access="local">
<interface>
<io>
<par name="MenuRegions" base_type="iconic" dimension="0"/>
</io>
<ic>
<par name="WindowHandle1" base_type="ctrl" dimension="0"/>
<par name="WindowHandle2" base_type="ctrl" dimension="0"/>
<par name="WindowHandleMenu" base_type="ctrl" dimension="0"/>
<par name="SurfaceModelID" base_type="ctrl" dimension="0"/>
<par name="ObjectModel3DScene" base_type="ctrl" dimension="0"/>
<par name="RelSamplingDistance" base_type="ctrl" dimension="0"/>
<par name="KeyPointFraction" base_type="ctrl" dimension="0"/>
<par name="MinScore" base_type="ctrl" dimension="0"/>
<par name="GenParamNames" base_type="ctrl" dimension="0"/>
<par name="GenParamValues" base_type="ctrl" dimension="0"/>
<par name="SurfaceMatchingResultID" base_type="ctrl" dimension="0"/>
<par name="MenuText" base_type="ctrl" dimension="0"/>
<par name="CurrentCase" base_type="ctrl" dimension="0"/>
<par name="CasesDone" base_type="ctrl" dimension="0"/>
<par name="FontSize" base_type="ctrl" dimension="0"/>
<par name="WindowScaling" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="CreateNames" base_type="ctrl" dimension="0"/>
<par name="CreateValues" base_type="ctrl" dimension="0"/>
<par name="FindNames" base_type="ctrl" dimension="0"/>
<par name="FindValues" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<l>Instructions[0] := 'Rotate: Left button'</l>
<l>Instructions[1] := 'Zoom:   Shift + left button'</l>
<l>Instructions[2] := 'Move:   Ctrl  + left button'</l>
<c>* </c>
<l>get_surface_matching_result (SurfaceMatchingResultID, 'sampled_scene', [], SampledScene)</l>
<l>get_surface_model_param (SurfaceModelID, 'sampled_model', SampledModel)</l>
<c>* </c>
<c>* Visualization of the model's normals</c>
<l>estimate_visualization_pose (SampledModel, WindowHandle1, VC_P_Model)</l>
<c>* </c>
<c>* Visualization of the scene's normals</c>
<l>estimate_visualization_pose (SampledScene, WindowHandle2, VC_P_Scene)</l>
<c>* </c>
<l>get_object_model_3d_params (SampledModel, 'point_normal_' + ['x','y','z'], NXYZOrig)</l>
<c>* </c>
<l>create_visualization_message_queues (MessageQueues1)</l>
<l>Buttons := ['Continue','right','bottom',-1,-1,'Invert Normals','left','bottom',-1,-1,'Hide Normals','center','bottom',-1,-1]</l>
<l>ShowNormals1 := true</l>
<l>par_start&lt;TI.at(0)&gt; : visualize_object_model_3d_ext (WindowHandle1, SampledModel, [], VC_P_Model, ['color_0','normal_color_0','disp_normals','disp_pose'], ['cyan','gray','true','true'], 'Model', [], Instructions, MessageQueues1, Buttons, [], [], 'false', [])</l>
<c></c>
<l>create_visualization_message_queues (MessageQueues2)</l>
<l>Buttons := ['Hide Normals','center','bottom',-1,-1,'Normals: fast','right','bottom',-1,-1,'Normals: mls ','right','above_bottom',-1,-1,'Invert Normals','left','bottom',-1,-1]</l>
<l>ShowNormals2 := true</l>
<l>par_start&lt;TI.at(1)&gt; : visualize_object_model_3d_ext (WindowHandle2, SampledScene, [], VC_P_Scene, ['color_0','normal_color_0','disp_normals','disp_pose'], ['cyan','gray','true','true'], 'Scene', [], Instructions, MessageQueues2, Buttons, [], [], 'false', [])</l>
<l>PreviousState1 := []</l>
<l>PreviousState2 := []</l>
<l>DidFinish1 := false</l>
<l>DidFinish2 := false</l>
<c>* </c>
<c>* Open a second (invisible) buffer window to avoid flickering</c>
<l>get_window_extents (WindowHandleMenu, Row, Column, Width, Height)</l>
<l>open_window (0, 0, Width, Height, 0, 'buffer', '', WindowHandleBufferMenu)</l>
<l>set_part (WindowHandleBufferMenu, 0, 0, Height - 1, Width - 1)</l>
<l>set_display_font (WindowHandleBufferMenu, FontSize, 'mono', 'true', 'false')</l>
<c>* </c>
<c>* Cached scene normals</c>
<l>SceneFast := []</l>
<l>SceneMLS := []</l>
<l>get_surface_matching_result (SurfaceMatchingResultID, 'scene_invert_normals', [], SceneNormalsInverted)</l>
<l>if (SceneNormalsInverted == 'true')</l>
<l>    SceneNormalsToggled := true</l>
<l>else</l>
<l>    SceneNormalsToggled := false</l>
<l>endif</l>
<l>get_find_parameter (GenParamNames, GenParamValues, 'scene_normal_computation', 'fast', NormalCompMode)</l>
<l>get_object_model_3d_params (ObjectModel3DScene, 'has_point_normals', SceneHasNormals)</l>
<l>if (SceneHasNormals == 'true')</l>
<l>    FastMethod := '(default, using existing scene normals)'</l>
<l>else</l>
<l>    FastMethod := '(default, using XYZ-mapping)'</l>
<l>endif</l>
<c>* Model normals</c>
<l>get_surface_matching_result (SurfaceMatchingResultID, 'model_invert_normals', [], ModelNormalsInverted)</l>
<l>if (ModelNormalsInverted == 'true')</l>
<l>    ModelNormalsToggled := true</l>
<l>else</l>
<l>    ModelNormalsToggled := false</l>
<l>endif</l>
<l>CreateNames := []</l>
<l>CreateValues := []</l>
<l>FindNames := []</l>
<l>FindValues := []</l>
<c>* </c>
<l>Message[0] := 'Check visually, if the normals of the model point approximately in the same direction as the normals of the scene by moving the model and the scene accordingly'</l>
<l>if (not ModelNormalsToggled)</l>
<l>    Message[1] := 'Model normals are not inverted (default)'</l>
<l>else</l>
<l>    Message[1] := 'Model normals are inverted'</l>
<l>endif</l>
<l>if (not SceneNormalsToggled)</l>
<l>    Message[2] := 'Scene normals are not inverted (default)'</l>
<l>else</l>
<l>    Message[2] := 'Scene normals are inverted'</l>
<l>endif</l>
<l>if (NormalCompMode == 'fast')</l>
<l>    Message[3] := 'Scene normals are computed based on the fast method ' + FastMethod</l>
<l>elseif (NormalCompMode == 'mls')</l>
<l>    Message[3] := 'Scene normals are computed based on the mls method'</l>
<l>else</l>
<l>    Message[3] := 'Scene normals are computed based on an unknown method'</l>
<l>endif</l>
<l>MessageChanged := 1</l>
<c>* </c>
<l>repeat</l>
<c>    * Process first visualization window</c>
<l>    process_visualize_events_generic (WindowHandle1, MessageQueues1, PreviousState1, DidFinish1, PreviousState1, ButtonPressed, Poses)</l>
<c></c>
<l>    if (ButtonPressed == 0 or DidFinish1)</l>
<c>        * Exit-button</c>
<l>        break</l>
<l>    elseif (ButtonPressed == 1)</l>
<c>        * Invert Model Normals</c>
<l>        get_object_model_3d_params (SampledModel, 'point_normal_' + ['x','y','z'], NXYZ)</l>
<l>        set_object_model_3d_attrib_mod (SampledModel, 'point_normal_' + ['x','y','z'], [], -NXYZ)</l>
<c>        * Redraw to show the flipped normals</c>
<l>        create_message (MessageHandle)</l>
<l>        set_message_tuple (MessageHandle, 'type', 'force_redraw')</l>
<l>        enqueue_message (MessageQueues1[1], MessageHandle, [], [])</l>
<l>        ModelNormalsToggled := not ModelNormalsToggled</l>
<c>        * Update parameter display</c>
<l>        if (not ModelNormalsToggled)</l>
<l>            Message[1] := 'Model normals are not inverted (default)'</l>
<l>            CreateNames := []</l>
<l>            CreateValues := []</l>
<l>        else</l>
<l>            Message[1] := 'Model normals are inverted'</l>
<l>            CreateNames := 'model_invert_normals'</l>
<l>            CreateValues := 'true'</l>
<l>        endif</l>
<l>        MessageChanged := 1</l>
<l>    elseif (ButtonPressed == 2)</l>
<c>        * Toggle normals</c>
<l>        ShowNormals1 := not ShowNormals1</l>
<l>        create_message (MessageHandle)</l>
<l>        set_message_tuple (MessageHandle, 'type', 'toggle_param')</l>
<l>        set_message_tuple (MessageHandle, 'param', 'disp_normals')</l>
<l>        enqueue_message (MessageQueues1[1], MessageHandle, [], [])</l>
<l>        create_message (MessageHandle)</l>
<l>        set_message_tuple (MessageHandle, 'type', 'change_button_text')</l>
<l>        set_message_tuple (MessageHandle, 'index', 2)</l>
<l>        if (ShowNormals1)</l>
<l>            set_message_tuple (MessageHandle, 'text', 'Hide Normals')</l>
<l>        else</l>
<l>            set_message_tuple (MessageHandle, 'text', 'Show Normals')</l>
<l>        endif</l>
<l>        enqueue_message (MessageQueues1[1], MessageHandle, [], [])</l>
<l>    endif</l>
<c></c>
<c>    * Process second visualization window</c>
<l>    process_visualize_events_generic (WindowHandle2, MessageQueues2, PreviousState2, DidFinish2, PreviousState2, ButtonPressed, Pose)</l>
<c></c>
<l>    if (ButtonPressed == 0)</l>
<l>        ShowNormals2 := not ShowNormals2</l>
<c>        * Toggle normals</c>
<l>        create_message (MessageHandle)</l>
<l>        set_message_tuple (MessageHandle, 'type', 'toggle_param')</l>
<l>        set_message_tuple (MessageHandle, 'param', 'disp_normals')</l>
<l>        enqueue_message (MessageQueues2[1], MessageHandle, [], [])</l>
<l>        create_message (MessageHandle)</l>
<l>        set_message_tuple (MessageHandle, 'type', 'change_button_text')</l>
<l>        set_message_tuple (MessageHandle, 'index', 0)</l>
<l>        if (ShowNormals2)</l>
<l>            set_message_tuple (MessageHandle, 'text', 'Hide Normals')</l>
<l>        else</l>
<l>            set_message_tuple (MessageHandle, 'text', 'Show Normals')</l>
<l>        endif</l>
<l>        enqueue_message (MessageQueues2[1], MessageHandle, [], [])</l>
<l>    elseif (ButtonPressed == 1)</l>
<c>        * FAST</c>
<c>        * Use very fast find parameters, since we are only interested in the sampled scene</c>
<l>        if (SceneFast == [])</l>
<l>            find_surface_model (SurfaceModelID, ObjectModel3DScene, RelSamplingDistance, 0.00001, 0, 'true', ['dense_pose_refinement','sparse_pose_refinement','scene_normal_computation'], ['false','false','fast'], Pose, Score, SurfaceMatchingResultID)</l>
<l>            get_surface_matching_result (SurfaceMatchingResultID, 'sampled_scene', 0, SceneFast)</l>
<l>        endif</l>
<c>        * Send the new 3D object model to the visualization thread</c>
<l>        create_message (MessageHandle)</l>
<l>        set_message_tuple (MessageHandle, 'type', 'replace_object_model')</l>
<l>        set_message_tuple (MessageHandle, 'index', 0)</l>
<l>        set_message_tuple (MessageHandle, 'model', SceneFast)</l>
<l>        enqueue_message (MessageQueues2[1], MessageHandle, [], [])</l>
<l>        SampledScene := SceneFast</l>
<l>        Message[3] := 'Scene normals are computed based on the fast method ' + FastMethod</l>
<l>        MessageChanged := 1</l>
<l>        tuple_find (FindNames, 'scene_normal_computation', Indices)</l>
<l>        if (Indices != -1)</l>
<l>            tuple_remove (FindNames, Indices, FindNames)</l>
<l>            tuple_remove (FindValues, Indices, FindValues)</l>
<l>        endif</l>
<l>    elseif (ButtonPressed == 2)</l>
<c>        * MLS</c>
<l>        if (SceneMLS == [])</l>
<c>            * Use very fast find parameters, since we are only interested in the sampled scene</c>
<l>            find_surface_model (SurfaceModelID, ObjectModel3DScene, RelSamplingDistance, 0.00001, 0, 'true', ['dense_pose_refinement','sparse_pose_refinement','scene_normal_computation'], ['false','false','mls'], Pose, Score, SurfaceMatchingResultID)</l>
<l>            get_surface_matching_result (SurfaceMatchingResultID, 'sampled_scene', 0, SceneMLS)</l>
<l>        endif</l>
<c>        * Send the new 3D object model to the visualization thread</c>
<l>        create_message (MessageHandle)</l>
<l>        set_message_tuple (MessageHandle, 'type', 'replace_object_model')</l>
<l>        set_message_tuple (MessageHandle, 'index', 0)</l>
<l>        set_message_tuple (MessageHandle, 'model', SceneMLS)</l>
<l>        enqueue_message (MessageQueues2[1], MessageHandle, [], [])</l>
<l>        SampledScene := SceneMLS</l>
<l>        Message[3] := 'Scene normals are computed based on the mls method'</l>
<l>        MessageChanged := 1</l>
<l>        FindNames := [FindNames,'scene_normal_computation']</l>
<l>        FindValues := [FindValues,'mls']</l>
<l>    elseif (ButtonPressed == 3)</l>
<c>        * Invert Scene Normals</c>
<l>        get_object_model_3d_params (SampledScene, 'point_normal_' + ['x','y','z'], NXYZ)</l>
<l>        set_object_model_3d_attrib_mod (SampledScene, 'point_normal_' + ['x','y','z'], [], -NXYZ)</l>
<c>        * Redraw to show the flipped normals</c>
<l>        create_message (MessageHandle)</l>
<l>        set_message_tuple (MessageHandle, 'type', 'force_redraw')</l>
<l>        enqueue_message (MessageQueues2[1], MessageHandle, [], [])</l>
<l>        SceneNormalsToggled := not SceneNormalsToggled</l>
<c>        * Update parameter display</c>
<l>        if (not SceneNormalsToggled)</l>
<l>            Message[2] := 'Scene normals are not inverted (default)'</l>
<l>            tuple_find (FindNames, 'scene_invert_normals', Indices)</l>
<l>            if (Indices != -1)</l>
<l>                tuple_remove (FindNames, Indices, FindNames)</l>
<l>                tuple_remove (FindValues, Indices, FindValues)</l>
<l>            endif</l>
<l>        else</l>
<l>            Message[2] := 'Scene normals are inverted'</l>
<l>            FindNames := [FindNames,'scene_invert_normals']</l>
<l>            FindValues := [FindValues,'true']</l>
<l>        endif</l>
<l>        MessageChanged := 1</l>
<l>    endif</l>
<c></c>
<c>    * Update the menu window</c>
<l>    if (MessageChanged)</l>
<l>        clear_window (WindowHandleBufferMenu)</l>
<l>        set_color (WindowHandleBufferMenu, 'black')</l>
<l>        disp_menu_ext (MenuRegions, WindowHandleBufferMenu, MenuText, CasesDone, CurrentCase, WindowScaling)</l>
<c>        * </c>
<l>        smallest_rectangle1 (MenuRegions, Row1, Column1, Row2, Column2)</l>
<l>        set_tposition (WindowHandleBufferMenu, max(Row2) + 6, 1)</l>
<l>        write_note (WindowHandleBufferMenu, 'instruction', Message[0])</l>
<l>        write_note (WindowHandleBufferMenu, 'info', Message[1])</l>
<l>        write_note (WindowHandleBufferMenu, 'info', Message[2])</l>
<l>        write_note (WindowHandleBufferMenu, 'none', Message[3])</l>
<l>        copy_rectangle (WindowHandleBufferMenu, WindowHandleMenu, 0, 0, Height - 1, Width * 2 - 1, 0, 0)</l>
<l>        MessageChanged := 0</l>
<l>    endif</l>
<l>until (DidFinish1 or DidFinish2)</l>
<c>* </c>
<c>* Send termination message to all subthreads</c>
<l>create_message (MessageHandle)</l>
<l>set_message_tuple (MessageHandle, 'type', 'exit')</l>
<l>enqueue_message (MessageQueues1[1], MessageHandle, [], [])</l>
<l>create_message (MessageHandle)</l>
<l>set_message_tuple (MessageHandle, 'type', 'exit')</l>
<l>enqueue_message (MessageQueues2[1], MessageHandle, [], [])</l>
<c>* </c>
<l>convert_vector_to_tuple (TI, TIT)</l>
<l>par_join (TIT)</l>
<c>* </c>
<l>return ()</l>
</body>
<docu id="inspect_normal_direction">
<chapters lang="en_US">
<item>3D Object Model</item>
<item>Features</item>
</chapters>
<library lang="en_US">MVTec Standard Procedures</library>
<parameters>
<parameter id="CasesDone"/>
<parameter id="CreateNames"/>
<parameter id="CreateValues"/>
<parameter id="CurrentCase"/>
<parameter id="FindNames"/>
<parameter id="FindValues"/>
<parameter id="FontSize"/>
<parameter id="GenParamNames"/>
<parameter id="GenParamValues"/>
<parameter id="KeyPointFraction"/>
<parameter id="MenuRegions"/>
<parameter id="MenuText"/>
<parameter id="MinScore"/>
<parameter id="ObjectModel3DScene">
<default_type>integer</default_type>
<mixed_type>false</mixed_type>
<sem_type>object_model_3d</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="RelSamplingDistance"/>
<parameter id="SurfaceMatchingResultID"/>
<parameter id="SurfaceModelID">
<default_type>integer</default_type>
<mixed_type>false</mixed_type>
<sem_type>surface_model</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="WindowHandle1">
<default_type>integer</default_type>
<mixed_type>false</mixed_type>
<sem_type>window</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="WindowHandle2">
<default_type>integer</default_type>
<mixed_type>false</mixed_type>
<sem_type>window</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="WindowHandleMenu">
<default_type>integer</default_type>
<mixed_type>false</mixed_type>
<sem_type>window</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="WindowScaling"/>
</parameters>
</docu>
</procedure>
<procedure name="inspect_scene_edge_directions" access="local">
<interface>
<ic>
<par name="WindowHandle1" base_type="ctrl" dimension="0"/>
<par name="WindowHandle2" base_type="ctrl" dimension="0"/>
<par name="SurfaceModelID" base_type="ctrl" dimension="0"/>
<par name="ObjectModel3DScene" base_type="ctrl" dimension="0"/>
<par name="SurfaceMatchingResultID" base_type="ctrl" dimension="0"/>
<par name="MaxGapIn" base_type="ctrl" dimension="0"/>
<par name="MinAmplitudeIn" base_type="ctrl" dimension="0"/>
<par name="ViewpointIn" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="Viewpoint" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c>* Initial, Minimum and Maximum parameter values</c>
<l>get_surface_model_param (SurfaceModelID, 'diameter', Diameter)</l>
<l>DefaultAmplitude := MinAmplitudeIn</l>
<l>MinAmplitude := 0.0001 * Diameter</l>
<l>MaxAmplitude := Diameter</l>
<l>DefaultMaxGap := MaxGapIn</l>
<c>* </c>
<l>get_object_model_3d_params (ObjectModel3DScene, 'mapping_size', MappingSize)</l>
<l>MinMaxGap := 0</l>
<l>MaxMaxGap := max(MappingSize)</l>
<c>* </c>
<l>get_object_model_3d_params (ObjectModel3DScene, 'center', CenterScene)</l>
<l>get_object_model_3d_params (ObjectModel3DScene, 'diameter', DiameterScene)</l>
<c>* </c>
<l>get_surface_model_param (SurfaceModelID, 'diameter', DiameterModel)</l>
<l>Viewpoint := ViewpointIn</l>
<l>ViewpointStr := Viewpoint[0] + ' ' + Viewpoint[1] + ' ' + Viewpoint[2]</l>
<c>* With this method, the viewpoint would be very far away in view 2, leading to not-so-nice</c>
<c>* visualization. Adapt the distance to be always &lt;= SceneDiameter.</c>
<l>Direction := Viewpoint - CenterScene</l>
<l>Length := sqrt(sum(Direction * Direction))</l>
<l>LengthRel := Length / DiameterScene</l>
<l>if (LengthRel &gt; 1)</l>
<l>    Direction := Direction / LengthRel</l>
<l>endif</l>
<l>ViewpointViz := CenterScene + Direction</l>
<c>* </c>
<l>try</l>
<l>    get_surface_matching_result (SurfaceMatchingResultID, 'sampled_scene', 0, ObjectModel3DSceneSampled)</l>
<l>    edges_object_model_3d (ObjectModel3DScene, DefaultAmplitude, ['max_gap','viewpoint'], [DefaultMaxGap,ViewpointStr], ObjectModel3DEdges)</l>
<l>    sample_object_model_3d (ObjectModel3DEdges, 'fast_compute_normals', DiameterModel * 0.02, [], [], ObjectModel3DEdges)</l>
<l>    get_object_model_3d_params (ObjectModel3DEdges, 'edge_dir_' + ['x','y','z'], EdgeDirs)</l>
<l>    set_object_model_3d_attrib (ObjectModel3DEdges, 'point_normal_' + ['x','y','z'], [], EdgeDirs, ObjectModel3DEdgeDirs)</l>
<l>catch (Exception)</l>
<c>    * Unable to extract edges -&gt; create a dummy 3D object model instead</c>
<l>    gen_empty_object_model_3d (ObjectModel3DEdges)</l>
<l>    gen_empty_object_model_3d (ObjectModel3DEdgeDirs)</l>
<l>endtry</l>
<c>* </c>
<c>* We only define a viewpoint, not a full camera. "Fake" a camera that looks towards the center of</c>
<c>* gravity of the scene. Do not point it towards the center of the bounding box, since that is rather</c>
<c>* unstable (a single outlier point would distort it).</c>
<l>moments_object_model_3d (ObjectModel3DScene, 'mean_points', CenterSceneGravity)</l>
<l>gen_camera_facing_scene (ViewpointViz, CenterSceneGravity, DiameterModel * 2, OM3DCamera)</l>
<l>gen_object_model_3d_from_points ([ViewpointViz[0],CenterScene[0]], [ViewpointViz[1],CenterScene[1]], [ViewpointViz[2],CenterScene[2]], OM3DLineSphereToScene)</l>
<l>set_object_model_3d_attrib_mod (OM3DLineSphereToScene, 'lines', [], [2,0,1])</l>
<c>* </c>
<c>* Convert input viewpoint into initial pose</c>
<l>Direction := Viewpoint - CenterScene</l>
<l>DirectionLength := sqrt(sum(Direction * Direction))</l>
<l>if (DirectionLength &lt; 1e-1 * DiameterModel)</l>
<c>    * The viewpoint is in the center of the scene.</c>
<c>    * We cannot build a camera pose that looks "onto" the scene when we</c>
<c>    * are in its center. Look into the Z-direction instead.</c>
<l>    Direction := [0,0,1]</l>
<l>    DirectionLength := sqrt(sum(Direction * Direction))</l>
<l>endif</l>
<c></c>
<c>* Create a rotation such that the camera faces the center of gravity of the scene</c>
<l>DirNorm := Direction / DirectionLength</l>
<l>if (sum(DirNorm * [0,0,-1]) &gt; 0.99999)</l>
<c>    * We are already looking into the right direction</c>
<l>    ViewpointAsPoseIn := [0,0,0,0,0,0,0]</l>
<l>    AngleToX := 0</l>
<l>else</l>
<l>    if (sum(DirNorm * [0,0,-1]) &gt; -0.99999)</l>
<c>        * Angle between the vectors is &gt; 0.25°</c>
<l>        Axis := DirNorm + [0,0,-1]</l>
<l>        AxisNorm := Axis / sqrt(sum(Axis * Axis))</l>
<l>        tuple_vector_cross_product (DirNorm, [0,0,1], OrthogonalDirection)</l>
<l>        OrthogonalDirection := OrthogonalDirection / sqrt(sum(OrthogonalDirection * OrthogonalDirection))</l>
<l>    else</l>
<l>        Axis := [0,1,0]</l>
<l>        OrthogonalDirection := [1,0,0]</l>
<l>    endif</l>
<c>    * </c>
<l>    tuple_vector_cross_product ([0,0,1], OrthogonalDirection, RotationAxis)</l>
<l>    tuple_vector_cross_product ([0,0,1], RotationAxis, DirectionProjected)</l>
<l>    AngleToX := atan2(DirectionProjected[0],DirectionProjected[1])</l>
<l>    hom_mat3d_identity (HomMat3DIdentity)</l>
<l>    hom_mat3d_rotate_local (HomMat3DIdentity, rad(180), Axis, HomMat3DRotate)</l>
<l>    hom_mat3d_to_pose (HomMat3DRotate, ViewpointAsPoseIn)</l>
<l>endif</l>
<c>* </c>
<l>ViewpointAsPoseIn[0:2] := Viewpoint</l>
<l>pose_invert (ViewpointAsPoseIn, ViewpointAsPoseIn)</l>
<c>* </c>
<c>* Start the first 3D visualization window</c>
<c>* In this window, one can set the viewpoint position</c>
<l>Instructions[0] := 'Rotate: Left button'</l>
<l>Instructions[1] := 'Zoom:   Shift + left button'</l>
<l>Instructions[2] := 'Move:   Ctrl  + left button'</l>
<c>* </c>
<l>get_window_extents (WindowHandle1, Row, Column, Width, Height)</l>
<l>gen_cam_par_area_scan_division (0.005, 0, 5.2e-06, 5.2e-06, Width * 0.5 + 0.5, Height * 0.5 + 0.5, Width, Height, CameraParam)</l>
<l>Buttons := ['Continue','right','bottom',-1,-1,'Reset','left','bottom',-1,-1]</l>
<l>create_visualization_message_queues (MessageQueues1)</l>
<l>par_start&lt;TI.at(0)&gt; : visualize_object_model_3d_ext (WindowHandle1, [ObjectModel3DSceneSampled,ObjectModel3DEdges], CameraParam, ViewpointAsPoseIn, ['color_0','color_1','disp_pose'], ['gray','red','true'], 'Define Viewpoint', [], Instructions, MessageQueues1, Buttons, [], [], 'false', [])</l>
<l>PreviousState1 := []</l>
<l>DidFinish1 := false</l>
<c>* </c>
<c>* Start the second 3D visualization window</c>
<c>* Here, the edge directions are visualized</c>
<c>* Find a viewpoint such that we see the scene and the camera "from the side".</c>
<c>* This makes it easier to see what is going on.</c>
<c>* To keep the scene upright, we first rotate around the x-axis, then around the</c>
<c>* (original) z-axis.</c>
<l>get_object_models_center ([ObjectModel3DSceneSampled,OM3DCamera], VizCenter)</l>
<l>hom_mat3d_identity (HomMat3DIdentity1)</l>
<l>hom_mat3d_rotate (HomMat3DIdentity1, rad(-90), [1,0,0], VizCenter[0], VizCenter[1], VizCenter[2], HomMat3DRotate)</l>
<l>hom_mat3d_rotate_local (HomMat3DRotate, AngleToX, [0,0,1], HomMat3DRotate)</l>
<l>hom_mat3d_to_pose (HomMat3DRotate, PoseIn)</l>
<l>determine_optimum_pose_distance ([ObjectModel3DSceneSampled,OM3DCamera], CameraParam, 0.5, PoseIn, VizposeIn)</l>
<c>* </c>
<l>Buttons := ['Hide Viewing Direction','left','bottom',-1,-1,'Hide Edge Direction','right','bottom',-1,-1]</l>
<l>ShowViewDir := true</l>
<l>ShowEdgeDir := true</l>
<l>create_visualization_message_queues (MessageQueues2)</l>
<l>par_start&lt;TI.at(1)&gt; : visualize_object_model_3d_ext (WindowHandle2, [ObjectModel3DSceneSampled,ObjectModel3DEdges,ObjectModel3DEdgeDirs,OM3DCamera,OM3DLineSphereToScene], CameraParam, VizposeIn, ['color_0','color_1','color_2','color_3','color_4','disp_pose','disp_normals_1','disp_normals_2'], ['gray','green','red','gray','white','true','true','true'], 'Inspect Edges', ['','','','Viewpoint',''], [], MessageQueues2, Buttons, [], [], 'false', [])</l>
<l>PreviousState2 := []</l>
<c>* </c>
<l>while (not DidFinish1)</l>
<l>    process_visualize_events_generic (WindowHandle1, MessageQueues1, PreviousState1, DidFinish1, PreviousState1, ButtonPressed, Pose)</l>
<l>    if (ButtonPressed == 0 or DidFinish1)</l>
<c>        * Exit button pressed</c>
<l>        break</l>
<l>    elseif (ButtonPressed == 1)</l>
<c>        * Reset button pressed</c>
<l>        Viewpoint := [0,0,0]</l>
<l>        create_message (MessageHandle)</l>
<l>        set_message_tuple (MessageHandle, 'type', 'set_pose')</l>
<l>        set_message_tuple (MessageHandle, 'poses', ViewpointAsPoseIn)</l>
<l>        enqueue_message (MessageQueues1[1], MessageHandle, [], [])</l>
<c>        * Also update the second view below</c>
<l>        Pose := ViewpointAsPoseIn</l>
<l>    endif</l>
<l>    if (Pose != [])</l>
<c>        * The pose of view 1 was updated</c>
<c>        * -&gt; Update the viewpoint in view 2</c>
<l>        pose_to_hom_mat3d (Pose[0:6], HomMat3D)</l>
<l>        hom_mat3d_invert (HomMat3D, HomMat3DInvert)</l>
<l>        affine_trans_point_3d (HomMat3DInvert, 0, 0, 0, Qx, Qy, Qz)</l>
<l>        Viewpoint := [Qx,Qy,Qz]</l>
<l>        ViewpointStr := Viewpoint[0] + ' ' + Viewpoint[1] + ' ' + Viewpoint[2]</l>
<c>        * With this method, the viewpoint would be very far away in view 2, leading to not-so-nice</c>
<c>        * visualization. Adapt the distance to be always &lt;= SceneDiameter.</c>
<l>        Direction := Viewpoint - CenterScene</l>
<l>        Length := sqrt(sum(Direction * Direction))</l>
<l>        LengthRel := Length / DiameterScene</l>
<l>        if (LengthRel &gt; 1)</l>
<l>            Direction := Direction / LengthRel</l>
<l>        endif</l>
<l>        ViewpointViz := CenterScene + Direction</l>
<c>        * </c>
<c>        * Update title of left visualization window</c>
<l>        create_message (MessageHandle)</l>
<l>        set_message_tuple (MessageHandle, 'type', 'change_title')</l>
<l>        set_message_tuple (MessageHandle, 'title', ['Define Viewpoint','Current Viewpoint: [' + Viewpoint[0] + ',' + Viewpoint[1] + ',' + Viewpoint[2] + ']'])</l>
<l>        enqueue_message (MessageQueues1[1], MessageHandle, [], [])</l>
<c>        * </c>
<l>        gen_camera_facing_scene (ViewpointViz, CenterSceneGravity, DiameterModel * 2, OM3DCamera)</l>
<c></c>
<l>        gen_object_model_3d_from_points ([ViewpointViz[0],CenterScene[0]], [ViewpointViz[1],CenterScene[1]], [ViewpointViz[2],CenterScene[2]], OM3DLineSphereToScene)</l>
<l>        set_object_model_3d_attrib_mod (OM3DLineSphereToScene, 'lines', [], [2,0,1])</l>
<l>        try</l>
<l>            edges_object_model_3d (ObjectModel3DScene, DefaultAmplitude, ['max_gap','viewpoint'], [DefaultMaxGap,ViewpointStr], ObjectModel3DEdges)</l>
<l>            sample_object_model_3d (ObjectModel3DEdges, 'fast_compute_normals', DiameterModel * 0.02, [], [], ObjectModel3DEdges)</l>
<c>            * </c>
<l>            get_object_model_3d_params (ObjectModel3DEdges, 'edge_dir_' + ['x','y','z'], EdgeDirs)</l>
<l>            set_object_model_3d_attrib (ObjectModel3DEdges, 'point_normal_' + ['x','y','z'], [], EdgeDirs, ObjectModel3DEdgeDirs)</l>
<l>        catch (Exception)</l>
<c>            * Unable to extract edges -&gt; create a dummy 3D object model instead</c>
<l>            gen_empty_object_model_3d (ObjectModel3DEdges)</l>
<l>            gen_empty_object_model_3d (ObjectModel3DEdgeDirs)</l>
<l>        endtry</l>
<c>        * </c>
<l>        create_message (MessageHandle)</l>
<l>        set_message_tuple (MessageHandle, 'type', 'replace_object_model')</l>
<l>        set_message_tuple (MessageHandle, 'index', [1,2,3,4])</l>
<l>        set_message_tuple (MessageHandle, 'model', [ObjectModel3DEdges,ObjectModel3DEdgeDirs,OM3DCamera,OM3DLineSphereToScene])</l>
<l>        enqueue_message (MessageQueues2[1], MessageHandle, [], [])</l>
<l>    endif</l>
<c></c>
<l>    process_visualize_events_generic (WindowHandle2, MessageQueues2, PreviousState2, DidFinish2, PreviousState2, ButtonPressed, Poses)</l>
<l>    if (DidFinish2)</l>
<l>        break</l>
<l>    endif</l>
<l>    if (ButtonPressed == 0)</l>
<l>        ShowViewDir := not ShowViewDir</l>
<c>        * Toggle viewing direction</c>
<l>        create_message (MessageHandle)</l>
<l>        set_message_tuple (MessageHandle, 'type', 'toggle_param')</l>
<l>        set_message_tuple (MessageHandle, 'param', 'disp_normals_1')</l>
<l>        enqueue_message (MessageQueues2[1], MessageHandle, [], [])</l>
<l>        create_message (MessageHandle)</l>
<l>        set_message_tuple (MessageHandle, 'type', 'change_button_text')</l>
<l>        set_message_tuple (MessageHandle, 'index', 0)</l>
<l>        if (ShowViewDir)</l>
<l>            set_message_tuple (MessageHandle, 'text', 'Hide Viewing Direction')</l>
<l>        else</l>
<l>            set_message_tuple (MessageHandle, 'text', 'Show Viewing Direction')</l>
<l>        endif</l>
<l>        enqueue_message (MessageQueues2[1], MessageHandle, [], [])</l>
<l>    elseif (ButtonPressed == 1)</l>
<l>        ShowEdgeDir := not ShowEdgeDir</l>
<c>        * Toggle viewing direction</c>
<l>        create_message (MessageHandle)</l>
<l>        set_message_tuple (MessageHandle, 'type', 'toggle_param')</l>
<l>        set_message_tuple (MessageHandle, 'param', 'disp_normals_2')</l>
<l>        enqueue_message (MessageQueues2[1], MessageHandle, [], [])</l>
<l>        create_message (MessageHandle)</l>
<l>        set_message_tuple (MessageHandle, 'type', 'change_button_text')</l>
<l>        set_message_tuple (MessageHandle, 'index', 1)</l>
<l>        if (ShowEdgeDir)</l>
<l>            set_message_tuple (MessageHandle, 'text', 'Hide Edge Direction')</l>
<l>        else</l>
<l>            set_message_tuple (MessageHandle, 'text', 'Show Edge Direction')</l>
<l>        endif</l>
<l>        enqueue_message (MessageQueues2[1], MessageHandle, [], [])</l>
<l>    endif</l>
<l>endwhile</l>
<c></c>
<l>create_message (MessageHandle)</l>
<l>set_message_tuple (MessageHandle, 'type', 'exit')</l>
<l>enqueue_message (MessageQueues1[1], MessageHandle, [], [])</l>
<l>create_message (MessageHandle)</l>
<l>set_message_tuple (MessageHandle, 'type', 'exit')</l>
<l>enqueue_message (MessageQueues2[1], MessageHandle, [], [])</l>
<c>* </c>
<l>convert_vector_to_tuple (TI, TIT)</l>
<l>par_join (TIT)</l>
<c></c>
<l>return ()</l>
</body>
<docu id="inspect_scene_edge_directions">
<chapters lang="en_US">
<item>3D Object Model</item>
<item>Features</item>
</chapters>
<library lang="en_US">MVTec Standard Procedures</library>
<parameters>
<parameter id="MaxGapIn"/>
<parameter id="MinAmplitudeIn"/>
<parameter id="ObjectModel3DScene">
<default_type>integer</default_type>
<mixed_type>false</mixed_type>
<sem_type>object_model_3d</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="SurfaceMatchingResultID">
<default_type>integer</default_type>
<mixed_type>false</mixed_type>
<sem_type>surface_matching_result</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="SurfaceModelID">
<default_type>integer</default_type>
<mixed_type>false</mixed_type>
<sem_type>surface_model</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="Viewpoint"/>
<parameter id="ViewpointIn"/>
<parameter id="WindowHandle1">
<default_type>integer</default_type>
<mixed_type>false</mixed_type>
<sem_type>window</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="WindowHandle2">
<default_type>integer</default_type>
<mixed_type>false</mixed_type>
<sem_type>window</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
</parameters>
</docu>
</procedure>
<procedure name="inspect_scene_edge_directions_find_box_3d" access="local">
<interface>
<ic>
<par name="WindowHandle1" base_type="ctrl" dimension="0"/>
<par name="WindowHandle2" base_type="ctrl" dimension="0"/>
<par name="ObjectModel3DBox" base_type="ctrl" dimension="0"/>
<par name="ObjectModel3DScene" base_type="ctrl" dimension="0"/>
<par name="BoxInformation" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="Viewpoint" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c>* Get Dictionary with generic parameters.</c>
<l>get_dict_tuple (BoxInformation, 'gen_param', GenParamDict)</l>
<c>* Prepare initial, minimal and maximal parameter values.</c>
<c>* Initialize params.</c>
<l>get_dict_tuple (GenParamDict, '3d_edge_min_amplitude', DefaultAmplitude)</l>
<l>get_dict_tuple (GenParamDict, 'max_gap', DefaultMaxGap)</l>
<l>get_dict_tuple (GenParamDict, 'viewpoint', Viewpoint)</l>
<l>ViewpointStr := Viewpoint[0] + ' ' + Viewpoint[1] + ' ' + Viewpoint[2]</l>
<c>* With this method, the viewpoint would be very far away in view 2, leading to not-so-nice</c>
<c>* visualization. Adapt the distance to be always &lt;= SceneDiameter.</c>
<l>get_object_model_3d_params (ObjectModel3DScene, 'center', CenterScene)</l>
<l>get_object_model_3d_params (ObjectModel3DScene, 'diameter', DiameterScene)</l>
<l>Direction := Viewpoint - CenterScene</l>
<l>Length := sqrt(sum(Direction * Direction))</l>
<l>LengthRel := Length / DiameterScene</l>
<l>if (LengthRel &gt; 1)</l>
<l>    Direction := Direction / LengthRel</l>
<l>endif</l>
<l>ViewpointViz := CenterScene + Direction</l>
<c>* </c>
<l>get_aggregated_models_diameter (ObjectModel3DBox, ModelDiameterAggregated)</l>
<l>try</l>
<l>    get_dict_tuple (BoxInformation, 'sampled_scene', ObjectModel3DSceneSampled)</l>
<l>    edges_object_model_3d (ObjectModel3DScene, DefaultAmplitude, ['max_gap','viewpoint'], [DefaultMaxGap,ViewpointStr], ObjectModel3DEdges)</l>
<l>    sample_object_model_3d (ObjectModel3DEdges, 'fast_compute_normals', ModelDiameterAggregated * 0.02, [], [], ObjectModel3DEdges)</l>
<l>    get_object_model_3d_params (ObjectModel3DEdges, 'edge_dir_' + ['x','y','z'], EdgeDirs)</l>
<l>    set_object_model_3d_attrib (ObjectModel3DEdges, 'point_normal_' + ['x','y','z'], [], EdgeDirs, ObjectModel3DEdgeDirs)</l>
<l>catch (Exception)</l>
<c>    * Unable to extract edges -&gt; create a dummy 3D object model instead.</c>
<l>    gen_empty_object_model_3d (ObjectModel3DEdges)</l>
<l>    gen_empty_object_model_3d (ObjectModel3DEdgeDirs)</l>
<l>endtry</l>
<c>* </c>
<c>* We only define a viewpoint, not a full camera. "Fake" a camera that looks towards the center of</c>
<c>* gravity of the scene. Do not point it towards the center of the bounding box, since that is rather</c>
<c>* unstable (a single outlier point would distort it).</c>
<l>moments_object_model_3d (ObjectModel3DScene, 'mean_points', CenterSceneGravity)</l>
<l>gen_camera_facing_scene (ViewpointViz, CenterSceneGravity, ModelDiameterAggregated * 2, OM3DCamera)</l>
<l>gen_object_model_3d_from_points ([ViewpointViz[0],CenterScene[0]], [ViewpointViz[1],CenterScene[1]], [ViewpointViz[2],CenterScene[2]], OM3DLineSphereToScene)</l>
<l>set_object_model_3d_attrib_mod (OM3DLineSphereToScene, 'lines', [], [2,0,1])</l>
<c>* </c>
<c>* Convert input viewpoint into initial pose</c>
<l>Direction := Viewpoint - CenterScene</l>
<l>DirectionLength := sqrt(sum(Direction * Direction))</l>
<l>if (DirectionLength &lt; 1e-1 * ModelDiameterAggregated)</l>
<c>    * The viewpoint is in the center of the scene.</c>
<c>    * We cannot build a camera pose that looks "onto" the scene when we</c>
<c>    * are in its center. Look into the Z-direction instead.</c>
<l>    Direction := [0,0,1]</l>
<l>    DirectionLength := sqrt(sum(Direction * Direction))</l>
<l>endif</l>
<c>* </c>
<c>* Create a rotation such that the camera faces the center of gravity of the scene.</c>
<l>DirNorm := Direction / DirectionLength</l>
<l>if (sum(DirNorm * [0,0,-1]) &gt; 0.99999)</l>
<c>    * We are already looking into the right direction.</c>
<l>    ViewpointAsPoseIn := [0,0,0,0,0,0,0]</l>
<l>    AngleToX := 0</l>
<l>else</l>
<l>    if (sum(DirNorm * [0,0,-1]) &gt; -0.99999)</l>
<c>        * Angle between the vectors is &gt; 0.25°.</c>
<l>        Axis := DirNorm + [0,0,-1]</l>
<l>        AxisNorm := Axis / sqrt(sum(Axis * Axis))</l>
<l>        tuple_vector_cross_product (DirNorm, [0,0,1], OrthogonalDirection)</l>
<l>        OrthogonalDirection := OrthogonalDirection / sqrt(sum(OrthogonalDirection * OrthogonalDirection))</l>
<l>    else</l>
<l>        Axis := [0,1,0]</l>
<l>        OrthogonalDirection := [1,0,0]</l>
<l>    endif</l>
<c>    * </c>
<l>    tuple_vector_cross_product ([0,0,1], OrthogonalDirection, RotationAxis)</l>
<l>    tuple_vector_cross_product ([0,0,1], RotationAxis, DirectionProjected)</l>
<l>    AngleToX := atan2(DirectionProjected[0],DirectionProjected[1])</l>
<l>    hom_mat3d_identity (HomMat3DIdentity)</l>
<l>    hom_mat3d_rotate_local (HomMat3DIdentity, rad(180), Axis, HomMat3DRotate)</l>
<l>    hom_mat3d_to_pose (HomMat3DRotate, ViewpointAsPoseIn)</l>
<l>endif</l>
<c>* </c>
<l>ViewpointAsPoseIn[0:2] := Viewpoint</l>
<l>pose_invert (ViewpointAsPoseIn, ViewpointAsPoseIn)</l>
<c>* </c>
<c>* Start the first 3D visualization window.</c>
<c>* In this window, one can set the viewpoint position.</c>
<l>Instructions[0] := 'Rotate: Left button'</l>
<l>Instructions[1] := 'Zoom:   Shift + left button'</l>
<l>Instructions[2] := 'Move:   Ctrl  + left button'</l>
<c>* </c>
<l>get_window_extents (WindowHandle1, Row, Column, Width, Height)</l>
<l>gen_cam_par_area_scan_division (0.005, 0, 5.2e-06, 5.2e-06, Width * 0.5 + 0.5, Height * 0.5 + 0.5, Width, Height, CameraParam)</l>
<l>Buttons := ['Continue','right','bottom',-1,-1,'Reset','left','bottom',-1,-1]</l>
<l>create_visualization_message_queues (MessageQueues1)</l>
<l>par_start&lt;TI.at(0)&gt; : visualize_object_model_3d_ext (WindowHandle1, [ObjectModel3DSceneSampled,ObjectModel3DEdges], CameraParam, ViewpointAsPoseIn, ['color_0','color_1','disp_pose'], ['gray','red','true'], 'Define Viewpoint', [], Instructions, MessageQueues1, Buttons, [], [], 'false', [])</l>
<l>PreviousState1 := []</l>
<l>DidFinish1 := false</l>
<c>* </c>
<c>* Start the second 3D visualization window.</c>
<c>* Here, the edge directions are visualized.</c>
<c>* Find a viewpoint such that we see the scene and the camera "from the side".</c>
<c>* This makes it easier to see what is going on.</c>
<c>* To keep the scene upright, we first rotate around the x-axis, then around the</c>
<c>* (original) z-axis.</c>
<l>get_object_models_center ([ObjectModel3DSceneSampled,OM3DCamera], VizCenter)</l>
<l>hom_mat3d_identity (HomMat3DIdentity1)</l>
<l>hom_mat3d_rotate (HomMat3DIdentity1, rad(-90), [1,0,0], VizCenter[0], VizCenter[1], VizCenter[2], HomMat3DRotate)</l>
<l>hom_mat3d_rotate_local (HomMat3DRotate, AngleToX, [0,0,1], HomMat3DRotate)</l>
<l>hom_mat3d_to_pose (HomMat3DRotate, PoseIn)</l>
<l>determine_optimum_pose_distance ([ObjectModel3DSceneSampled,OM3DCamera], CameraParam, 0.5, PoseIn, VizposeIn)</l>
<c>* </c>
<l>Buttons := ['Hide Viewing Direction','left','bottom',-1,-1,'Hide Edge Direction','right','bottom',-1,-1]</l>
<l>ShowViewDir := true</l>
<l>ShowEdgeDir := true</l>
<l>create_visualization_message_queues (MessageQueues2)</l>
<l>par_start&lt;TI.at(1)&gt; : visualize_object_model_3d_ext (WindowHandle2, [ObjectModel3DSceneSampled,ObjectModel3DEdges,ObjectModel3DEdgeDirs,OM3DCamera,OM3DLineSphereToScene], CameraParam, VizposeIn, ['color_0','color_1','color_2','color_3','color_4','disp_pose','disp_normals_1','disp_normals_2'], ['gray','green','red','gray','white','true','true','true'], 'Inspect Edges', ['','','','Viewpoint',''], [], MessageQueues2, Buttons, [], [], 'false', [])</l>
<l>PreviousState2 := []</l>
<c>* </c>
<l>while (not DidFinish1)</l>
<l>    process_visualize_events_generic (WindowHandle1, MessageQueues1, PreviousState1, DidFinish1, PreviousState1, ButtonPressed, Pose)</l>
<l>    if (ButtonPressed == 0 or DidFinish1)</l>
<c>        * Exit button pressed.</c>
<l>        break</l>
<l>    elseif (ButtonPressed == 1)</l>
<c>        * Reset button pressed.</c>
<l>        Viewpoint := [0,0,0]</l>
<l>        create_message (MessageHandle)</l>
<l>        set_message_tuple (MessageHandle, 'type', 'set_pose')</l>
<l>        set_message_tuple (MessageHandle, 'poses', ViewpointAsPoseIn)</l>
<l>        enqueue_message (MessageQueues1[1], MessageHandle, [], [])</l>
<c>        * Also update the second view below.</c>
<l>        Pose := ViewpointAsPoseIn</l>
<l>    endif</l>
<l>    if (Pose != [])</l>
<c>        * The pose of view 1 was updated.</c>
<c>        * -&gt; Update the viewpoint in view 2.</c>
<l>        pose_to_hom_mat3d (Pose[0:6], HomMat3D)</l>
<l>        hom_mat3d_invert (HomMat3D, HomMat3DInvert)</l>
<l>        affine_trans_point_3d (HomMat3DInvert, 0, 0, 0, Qx, Qy, Qz)</l>
<l>        Viewpoint := [Qx,Qy,Qz]</l>
<l>        ViewpointStr := Viewpoint[0] + ' ' + Viewpoint[1] + ' ' + Viewpoint[2]</l>
<c>        * With this method, the viewpoint would be very far away in view 2, leading to not-so-nice</c>
<c>        * visualization. Adapt the distance to be always &lt;= SceneDiameter.</c>
<l>        Direction := Viewpoint - CenterScene</l>
<l>        Length := sqrt(sum(Direction * Direction))</l>
<l>        LengthRel := Length / DiameterScene</l>
<l>        if (LengthRel &gt; 1)</l>
<l>            Direction := Direction / LengthRel</l>
<l>        endif</l>
<l>        ViewpointViz := CenterScene + Direction</l>
<c>        * </c>
<c>        * Update title of left visualization window.</c>
<l>        create_message (MessageHandle)</l>
<l>        set_message_tuple (MessageHandle, 'type', 'change_title')</l>
<l>        set_message_tuple (MessageHandle, 'title', ['Define Viewpoint','Current Viewpoint: [' + Viewpoint[0] + ',' + Viewpoint[1] + ',' + Viewpoint[2] + ']'])</l>
<l>        enqueue_message (MessageQueues1[1], MessageHandle, [], [])</l>
<c>        * </c>
<l>        gen_camera_facing_scene (ViewpointViz, CenterSceneGravity, ModelDiameterAggregated * 2, OM3DCamera)</l>
<c>        * </c>
<l>        gen_object_model_3d_from_points ([ViewpointViz[0],CenterScene[0]], [ViewpointViz[1],CenterScene[1]], [ViewpointViz[2],CenterScene[2]], OM3DLineSphereToScene)</l>
<l>        set_object_model_3d_attrib_mod (OM3DLineSphereToScene, 'lines', [], [2,0,1])</l>
<l>        try</l>
<l>            edges_object_model_3d (ObjectModel3DScene, DefaultAmplitude, ['max_gap','viewpoint'], [DefaultMaxGap,ViewpointStr], ObjectModel3DEdges)</l>
<l>            sample_object_model_3d (ObjectModel3DEdges, 'fast_compute_normals', ModelDiameterAggregated * 0.02, [], [], ObjectModel3DEdges)</l>
<c>            * </c>
<l>            get_object_model_3d_params (ObjectModel3DEdges, 'edge_dir_' + ['x','y','z'], EdgeDirs)</l>
<l>            set_object_model_3d_attrib (ObjectModel3DEdges, 'point_normal_' + ['x','y','z'], [], EdgeDirs, ObjectModel3DEdgeDirs)</l>
<l>        catch (Exception)</l>
<c>            * Unable to extract edges -&gt; create a dummy 3D object model instead.</c>
<l>            gen_empty_object_model_3d (ObjectModel3DEdges)</l>
<l>            gen_empty_object_model_3d (ObjectModel3DEdgeDirs)</l>
<l>        endtry</l>
<c>        * </c>
<l>        create_message (MessageHandle)</l>
<l>        set_message_tuple (MessageHandle, 'type', 'replace_object_model')</l>
<l>        set_message_tuple (MessageHandle, 'index', [1,2,3,4])</l>
<l>        set_message_tuple (MessageHandle, 'model', [ObjectModel3DEdges,ObjectModel3DEdgeDirs,OM3DCamera,OM3DLineSphereToScene])</l>
<l>        enqueue_message (MessageQueues2[1], MessageHandle, [], [])</l>
<l>    endif</l>
<c>    * </c>
<l>    process_visualize_events_generic (WindowHandle2, MessageQueues2, PreviousState2, DidFinish2, PreviousState2, ButtonPressed, Poses)</l>
<l>    if (DidFinish2)</l>
<l>        break</l>
<l>    endif</l>
<l>    if (ButtonPressed == 0)</l>
<l>        ShowViewDir := not ShowViewDir</l>
<c>        * Toggle viewing direction.</c>
<l>        create_message (MessageHandle)</l>
<l>        set_message_tuple (MessageHandle, 'type', 'toggle_param')</l>
<l>        set_message_tuple (MessageHandle, 'param', 'disp_normals_1')</l>
<l>        enqueue_message (MessageQueues2[1], MessageHandle, [], [])</l>
<l>        create_message (MessageHandle)</l>
<l>        set_message_tuple (MessageHandle, 'type', 'change_button_text')</l>
<l>        set_message_tuple (MessageHandle, 'index', 0)</l>
<l>        if (ShowViewDir)</l>
<l>            set_message_tuple (MessageHandle, 'text', 'Hide Viewing Direction')</l>
<l>        else</l>
<l>            set_message_tuple (MessageHandle, 'text', 'Show Viewing Direction')</l>
<l>        endif</l>
<l>        enqueue_message (MessageQueues2[1], MessageHandle, [], [])</l>
<l>    elseif (ButtonPressed == 1)</l>
<l>        ShowEdgeDir := not ShowEdgeDir</l>
<c>        * Toggle viewing direction.</c>
<l>        create_message (MessageHandle)</l>
<l>        set_message_tuple (MessageHandle, 'type', 'toggle_param')</l>
<l>        set_message_tuple (MessageHandle, 'param', 'disp_normals_2')</l>
<l>        enqueue_message (MessageQueues2[1], MessageHandle, [], [])</l>
<l>        create_message (MessageHandle)</l>
<l>        set_message_tuple (MessageHandle, 'type', 'change_button_text')</l>
<l>        set_message_tuple (MessageHandle, 'index', 1)</l>
<l>        if (ShowEdgeDir)</l>
<l>            set_message_tuple (MessageHandle, 'text', 'Hide Edge Direction')</l>
<l>        else</l>
<l>            set_message_tuple (MessageHandle, 'text', 'Show Edge Direction')</l>
<l>        endif</l>
<l>        enqueue_message (MessageQueues2[1], MessageHandle, [], [])</l>
<l>    endif</l>
<l>endwhile</l>
<c>* </c>
<l>create_message (MessageHandle)</l>
<l>set_message_tuple (MessageHandle, 'type', 'exit')</l>
<l>enqueue_message (MessageQueues1[1], MessageHandle, [], [])</l>
<l>create_message (MessageHandle)</l>
<l>set_message_tuple (MessageHandle, 'type', 'exit')</l>
<l>enqueue_message (MessageQueues2[1], MessageHandle, [], [])</l>
<c>* </c>
<l>convert_vector_to_tuple (TI, TIT)</l>
<l>par_join (TIT)</l>
<c>* </c>
<l>return ()</l>
</body>
<docu id="inspect_scene_edge_directions_find_box_3d">
<chapters lang="en_US">
<item>3D Object Model</item>
<item>Features</item>
</chapters>
<library lang="en_US">MVTec Standard Procedures</library>
<parameters>
<parameter id="BoxInformation">
<default_type>handle</default_type>
<description lang="en_US">Dictionary with results of the box finder.</description>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>dict</sem_type>
<type_list>
<item>handle</item>
</type_list>
</parameter>
<parameter id="ObjectModel3DBox">
<default_type>handle</default_type>
<description lang="en_US">3D object models of the found boxes.</description>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>object_model_3d</sem_type>
<type_list>
<item>handle</item>
</type_list>
</parameter>
<parameter id="ObjectModel3DScene">
<default_type>handle</default_type>
<description lang="en_US">The scene where the object is to be found, as passed to find_box_3d.</description>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>object_model_3d</sem_type>
<type_list>
<item>handle</item>
</type_list>
</parameter>
<parameter id="Viewpoint"/>
<parameter id="WindowHandle1">
<default_type>integer</default_type>
<mixed_type>false</mixed_type>
<sem_type>window</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="WindowHandle2">
<default_type>integer</default_type>
<mixed_type>false</mixed_type>
<sem_type>window</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
</parameters>
</docu>
</procedure>
<procedure name="inspect_scene_edge_parameters" access="local">
<interface>
<ic>
<par name="WindowHandle1" base_type="ctrl" dimension="0"/>
<par name="WindowHandle2" base_type="ctrl" dimension="0"/>
<par name="SurfaceModelID" base_type="ctrl" dimension="0"/>
<par name="ObjectModel3DScene" base_type="ctrl" dimension="0"/>
<par name="SurfaceMatchingResultID" base_type="ctrl" dimension="0"/>
<par name="MaxGapIn" base_type="ctrl" dimension="0"/>
<par name="MinAmplitudeAbsIn" base_type="ctrl" dimension="0"/>
<par name="ViewpointIn" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="MaxGap" base_type="ctrl" dimension="0"/>
<par name="MinAmplitudeAbs" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c>* Initial, Minimum and Maximum parameter values</c>
<l>get_surface_model_param (SurfaceModelID, 'diameter', Diameter)</l>
<l>DefaultAmplitude := MinAmplitudeAbsIn / Diameter</l>
<l>MinAmplitude := 0.0001</l>
<l>MaxAmplitude := 1</l>
<l>DefaultMaxGap := MaxGapIn</l>
<l>get_object_model_3d_params (ObjectModel3DScene, 'mapping_size', MappingSize)</l>
<l>MinMaxGap := 0</l>
<l>MaxMaxGap := max(MappingSize)</l>
<l>ViewpointStr := sum(ViewpointIn + ' ')</l>
<c>* </c>
<l>get_surface_matching_result (SurfaceMatchingResultID, 'sampled_scene', 0, ObjectModel3DSceneSampled)</l>
<l>edges_object_model_3d (ObjectModel3DScene, DefaultAmplitude * Diameter, ['max_gap','viewpoint'], [DefaultMaxGap,ViewpointStr], ObjectModel3DEdges)</l>
<c>* </c>
<c>* Start the 3D visualization window</c>
<l>Instructions[0] := 'Rotate: Left button'</l>
<l>Instructions[1] := 'Zoom:   Shift + left button'</l>
<l>Instructions[2] := 'Move:   Ctrl  + left button'</l>
<c>* </c>
<l>Buttons := ['Continue','right','bottom',-1,-1]</l>
<l>create_visualization_message_queues (MessageQueues1)</l>
<l>par_start&lt;TI.at(0)&gt; : visualize_object_model_3d_ext (WindowHandle1, [ObjectModel3DSceneSampled,ObjectModel3DEdges], [], [], ['color_0','color_1','disp_pose'], ['gray','red','true'], 'Inspection', [], Instructions, MessageQueues1, Buttons, [], [], 'false', [])</l>
<c>* </c>
<l>PreviousState1 := []</l>
<l>DidFinish1 := false</l>
<c>* </c>
<c>* Start the 2D Slider window</c>
<l>create_visualization_message_queues (MessageQueues2)</l>
<l>par_start&lt;TI.at(1)&gt; : set_edge_parameter_sliders (WindowHandle2, ObjectModel3DScene, MessageQueues2, MessageQueues1, Diameter, [MinAmplitude,MaxAmplitude,DefaultAmplitude], [MinMaxGap,MaxMaxGap,DefaultMaxGap], ViewpointIn, MinAmplitudeRel, MaxGap)</l>
<c>* </c>
<l>get_object_model_3d_params (ObjectModel3DScene, 'point_coord_x', XXScene)</l>
<l>get_object_model_3d_params (ObjectModel3DScene, 'point_coord_y', YYScene)</l>
<l>get_object_model_3d_params (ObjectModel3DScene, 'point_coord_z', ZZScene)</l>
<c>* </c>
<l>PreviousState2 := []</l>
<c>* </c>
<l>while (not DidFinish1)</l>
<l>    process_visualize_events_generic (WindowHandle1, MessageQueues1, PreviousState1, DidFinish1, PreviousState1, ButtonPressed, Poses)</l>
<c></c>
<l>    if (ButtonPressed == 0 or DidFinish1)</l>
<c>        * Exit button pressed</c>
<l>        break</l>
<l>    endif</l>
<c></c>
<l>    process_slider_events (WindowHandle2, MessageQueues2, PreviousState2, PreviousState2, DidFinish2)</l>
<l>    if (DidFinish2)</l>
<c>        * Window closed</c>
<l>        break</l>
<l>    endif</l>
<l>endwhile</l>
<c></c>
<l>create_message (MessageHandle)</l>
<l>set_message_tuple (MessageHandle, 'type', 'exit')</l>
<l>enqueue_message (MessageQueues1[1], MessageHandle, [], [])</l>
<l>create_message (MessageHandle)</l>
<l>set_message_tuple (MessageHandle, 'type', 'exit')</l>
<l>enqueue_message (MessageQueues2[1], MessageHandle, [], [])</l>
<c>* </c>
<l>convert_vector_to_tuple (TI, TIT)</l>
<l>par_join (TIT)</l>
<c>* </c>
<c>* Convert from relative to absolute</c>
<l>MinAmplitudeAbs := MinAmplitudeRel * Diameter</l>
<c>* </c>
<l>return ()</l>
</body>
<docu id="inspect_scene_edge_parameters">
<chapters lang="en_US">
<item>3D Object Model</item>
<item>Features</item>
</chapters>
<library lang="en_US">MVTec Standard Procedures</library>
<parameters>
<parameter id="MaxGap"/>
<parameter id="MaxGapIn"/>
<parameter id="MinAmplitudeAbs"/>
<parameter id="MinAmplitudeAbsIn"/>
<parameter id="ObjectModel3DScene">
<default_type>integer</default_type>
<mixed_type>false</mixed_type>
<sem_type>object_model_3d</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="SurfaceMatchingResultID">
<default_type>integer</default_type>
<mixed_type>false</mixed_type>
<sem_type>surface_matching_result</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="SurfaceModelID">
<default_type>integer</default_type>
<mixed_type>false</mixed_type>
<sem_type>surface_model</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="ViewpointIn"/>
<parameter id="WindowHandle1">
<default_type>integer</default_type>
<mixed_type>false</mixed_type>
<sem_type>window</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="WindowHandle2">
<default_type>integer</default_type>
<mixed_type>false</mixed_type>
<sem_type>window</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
</parameters>
</docu>
</procedure>
<procedure name="inspect_scene_edge_parameters_find_box_3d" access="local">
<interface>
<ic>
<par name="WindowHandle1" base_type="ctrl" dimension="0"/>
<par name="WindowHandle2" base_type="ctrl" dimension="0"/>
<par name="ObjectModel3DBox" base_type="ctrl" dimension="0"/>
<par name="ObjectModel3DScene" base_type="ctrl" dimension="0"/>
<par name="BoxInformation" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="MaxGapOut" base_type="ctrl" dimension="0"/>
<par name="MinAmplitude" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c>* Get Dictionary with generic parameters.</c>
<l>get_dict_tuple (BoxInformation, 'gen_param', GenParamDict)</l>
<c>* Prepare initial, minimal and maximal parameter values.</c>
<c>* Get MinAmplitude param and prepare MinMinAmplitude and MaxMinAmplitude.</c>
<l>get_dict_tuple (GenParamDict, '3d_edge_min_amplitude', DefaultAmplitude)</l>
<l>if (DefaultAmplitude == 0.0)</l>
<l>    get_min_amplitude (BoxInformation, DefaultAmplitude)</l>
<l>endif</l>
<l>MinMinAmplitude := 0.0001</l>
<l>get_max_min_amplitude (BoxInformation, MaxMinAmplitude)</l>
<c>* Get max_gap param and prepare MinMaxGap and MaxMaxGap.</c>
<l>get_dict_tuple (GenParamDict, 'max_gap', DefaultMaxGap)</l>
<l>get_object_model_3d_params (ObjectModel3DScene, 'mapping_size', MappingSize)</l>
<l>MinMaxGap := 0</l>
<l>MaxMaxGap := max(MappingSize)</l>
<c>* Get viewpoint param.</c>
<l>get_dict_tuple (GenParamDict, 'viewpoint', Viewpoint)</l>
<l>ViewpointStr := Viewpoint[0] + ' ' + Viewpoint[1] + ' ' + Viewpoint[2]</l>
<c>* </c>
<c>* Get edges in scene with the Params used for the call to find_box_3d.</c>
<l>get_dict_tuple (BoxInformation, 'sampled_scene', ObjectModel3DSceneSampled)</l>
<l>edges_object_model_3d (ObjectModel3DScene, DefaultAmplitude, ['max_gap','viewpoint'], [DefaultMaxGap,ViewpointStr], ObjectModel3DEdges)</l>
<c>* </c>
<c>* Start the 3D visualization window.</c>
<l>Instructions[0] := 'Rotate: Left button'</l>
<l>Instructions[1] := 'Zoom:   Shift + left button'</l>
<l>Instructions[2] := 'Move:   Ctrl  + left button'</l>
<c>* </c>
<l>Buttons := ['Continue','right','bottom',-1,-1]</l>
<l>create_visualization_message_queues (MessageQueues1)</l>
<l>par_start&lt;TI.at(0)&gt; : visualize_object_model_3d_ext (WindowHandle1, [ObjectModel3DSceneSampled,ObjectModel3DEdges], [], [], ['color_0','color_1','disp_pose'], ['gray','red','true'], 'Inspection', [], Instructions, MessageQueues1, Buttons, [], [], 'false', [])</l>
<c>* </c>
<l>PreviousState1 := []</l>
<l>DidFinish1 := false</l>
<c>* </c>
<c>* Start the 2D Slider window.</c>
<l>create_visualization_message_queues (MessageQueues2)</l>
<l>par_start&lt;TI.at(1)&gt; : set_edge_parameter_sliders_find_box_3d (WindowHandle2, ObjectModel3DScene, MessageQueues2, MessageQueues1, [MinMinAmplitude,MaxMinAmplitude,DefaultAmplitude], [MinMaxGap,MaxMaxGap,DefaultMaxGap], Viewpoint, MinAmplitude, MaxGapOut)</l>
<c>* </c>
<l>get_object_model_3d_params (ObjectModel3DScene, 'point_coord_x', XXScene)</l>
<l>get_object_model_3d_params (ObjectModel3DScene, 'point_coord_y', YYScene)</l>
<l>get_object_model_3d_params (ObjectModel3DScene, 'point_coord_z', ZZScene)</l>
<c>* </c>
<l>PreviousState2 := []</l>
<c>* </c>
<l>while (not DidFinish1)</l>
<l>    process_visualize_events_generic (WindowHandle1, MessageQueues1, PreviousState1, DidFinish1, PreviousState1, ButtonPressed, Poses)</l>
<c>    * </c>
<l>    if (ButtonPressed == 0 or DidFinish1)</l>
<c>        * Exit button pressed.</c>
<l>        break</l>
<l>    endif</l>
<c>    * </c>
<l>    process_slider_events (WindowHandle2, MessageQueues2, PreviousState2, PreviousState2, DidFinish2)</l>
<l>    if (DidFinish2)</l>
<c>        * Window closed.</c>
<l>        break</l>
<l>    endif</l>
<l>endwhile</l>
<c>* </c>
<l>create_message (MessageHandle)</l>
<l>set_message_tuple (MessageHandle, 'type', 'exit')</l>
<l>enqueue_message (MessageQueues1[1], MessageHandle, [], [])</l>
<l>create_message (MessageHandle)</l>
<l>set_message_tuple (MessageHandle, 'type', 'exit')</l>
<l>enqueue_message (MessageQueues2[1], MessageHandle, [], [])</l>
<c>* </c>
<l>convert_vector_to_tuple (TI, TIT)</l>
<l>par_join (TIT)</l>
<c>* </c>
<l>return ()</l>
</body>
<docu id="inspect_scene_edge_parameters_find_box_3d">
<chapters lang="en_US">
<item>3D Object Model</item>
<item>Features</item>
</chapters>
<library lang="en_US">MVTec Standard Procedures</library>
<parameters>
<parameter id="BoxInformation">
<default_type>handle</default_type>
<description lang="en_US">Dictionary with results of the box finder.</description>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>dict</sem_type>
<type_list>
<item>handle</item>
</type_list>
</parameter>
<parameter id="MaxGapOut"/>
<parameter id="MinAmplitude"/>
<parameter id="ObjectModel3DBox">
<default_type>handle</default_type>
<description lang="en_US">3D object models of the found boxes.</description>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>object_model_3d</sem_type>
<type_list>
<item>handle</item>
</type_list>
</parameter>
<parameter id="ObjectModel3DScene">
<default_type>handle</default_type>
<description lang="en_US">The scene where the object is to be found, as passed to find_box_3d.</description>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>object_model_3d</sem_type>
<type_list>
<item>handle</item>
</type_list>
</parameter>
<parameter id="WindowHandle1">
<default_type>integer</default_type>
<mixed_type>false</mixed_type>
<sem_type>window</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="WindowHandle2">
<default_type>integer</default_type>
<mixed_type>false</mixed_type>
<sem_type>window</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
</parameters>
</docu>
</procedure>
<procedure name="list_image_and_annotation_files" access="local">
<interface>
<ic>
<par name="Type" base_type="ctrl" dimension="0"/>
<par name="ImageDir" base_type="ctrl" dimension="0"/>
<par name="AnnotationDir" base_type="ctrl" dimension="0"/>
<par name="ImageListIn" base_type="ctrl" dimension="0"/>
<par name="GenParam" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="ImageListOut" base_type="ctrl" dimension="0"/>
<par name="LabelListOut" base_type="ctrl" dimension="0"/>
<par name="AnnotationListOut" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c>* </c>
<c>* This procedure generates lists of images and corresponding annotation files,</c>
<c>* whereby the first one can also be handed over through ImageListIn.</c>
<c>* The lists are generated by listing the files in the given directory:</c>
<c>*  - ImageDir specifies the base directory for the images,</c>
<c>*  - AnnotationDir specifies the base directory for the annotation files.</c>
<c>* </c>
<c>* The file base names of images and annotation files must be unique</c>
<c>* in the sense that for each image exactly one annotation is matched based on</c>
<c>* their file names. With the parameters specified in GenParam, the lists can be</c>
<c>* limited to specific file names.</c>
<c>* </c>
<c>* Set defaults.</c>
<l>ImageSubDirs := []</l>
<l>AnnotationSubDirs := []</l>
<l>FileNameImageOnly := ''</l>
<l>FileNameAnnoOnly := ''</l>
<l>IgnoreUnmatched := false</l>
<c>* </c>
<c>* Overwrite defaults.</c>
<l>if (GenParam != [])</l>
<l>    get_dict_param (GenParam, 'keys', [], Keys)</l>
<l>    for KeyIndex := 0 to |Keys| - 1 by 1</l>
<l>        if (Keys[KeyIndex] == 'image_sub_dirs')</l>
<l>            get_dict_tuple (GenParam, 'image_sub_dirs', ImageSubDirs)</l>
<l>        elseif (Keys[KeyIndex] == 'annotation_sub_dirs')</l>
<l>            get_dict_tuple (GenParam, 'annotation_sub_dirs', AnnotationSubDirs)</l>
<l>        elseif (Keys[KeyIndex] == 'file_name_image_only')</l>
<l>            get_dict_tuple (GenParam, 'file_name_image_only', FileNameImageOnly)</l>
<l>        elseif (Keys[KeyIndex] == 'file_name_annotation_only')</l>
<l>            get_dict_tuple (GenParam, 'file_name_annotation_only', FileNameAnnoOnly)</l>
<l>        elseif (Keys[KeyIndex] == 'ignore_unmatched_images')</l>
<l>            get_dict_tuple (GenParam, 'ignore_unmatched_images', IgnoreUnmatched)</l>
<l>        else</l>
<l>            throw ('Unknown generic parameter name : \'' + Keys[KeyIndex] + '\'')</l>
<l>        endif</l>
<l>    endfor</l>
<l>endif</l>
<c>* </c>
<c>* Check generic parameters.</c>
<l>if (ImageSubDirs != [])</l>
<l>    tuple_is_string (ImageSubDirs, IsString)</l>
<l>    if (min(IsString) == 0)</l>
<l>        throw ('\'image_sub_dirs\' must be a tuple of strings')</l>
<l>    endif</l>
<l>endif</l>
<l>if (AnnotationSubDirs != [])</l>
<l>    tuple_is_string (AnnotationSubDirs, IsString)</l>
<l>    if (min(IsString) == 0)</l>
<l>        throw ('\'' + Type + '_sub_dirs\' must be a tuple of strings')</l>
<l>    endif</l>
<l>endif</l>
<l>if (FileNameImageOnly != '')</l>
<l>    if (|FileNameImageOnly| != 1)</l>
<l>        throw ('\'file_name_image_only\' must be a single string')</l>
<l>    elseif (not is_string(FileNameImageOnly))</l>
<l>        throw ('\'file_name_image_only\' must be a string')</l>
<l>    endif</l>
<l>endif</l>
<l>if (FileNameAnnoOnly != '')</l>
<l>    if (|FileNameAnnoOnly| != 1)</l>
<l>        throw ('\'file_name_' + Type + '_only\' must be a single string')</l>
<l>    elseif (not is_string(FileNameAnnoOnly))</l>
<l>        throw ('\'file_name_' + Type + '_only\' must be a string')</l>
<l>    endif</l>
<l>endif</l>
<l>if (IgnoreUnmatched != false and IgnoreUnmatched != true)</l>
<l>    throw ('Unsupported value for \'ignore_unmatched_images\' : ' + IgnoreUnmatched)</l>
<l>endif</l>
<c>* </c>
<c>* * Prepare image list.</c>
<c>* </c>
<c>* Get all image directories.</c>
<l>if (ImageSubDirs != [])</l>
<l>    ImageDirs := ImageDir + '/' + ImageSubDirs</l>
<l>else</l>
<l>    ImageDirs := ImageDir</l>
<l>endif</l>
<c>* </c>
<l>if (ImageListIn == [])</l>
<c>    * List all image files.</c>
<l>    prepare_image_lists (ImageDirs, 'default', ImageBaseNames, ImageExtensions, ImageDirectories)</l>
<l>else</l>
<l>    parse_filename (ImageListIn, ImageBaseNames, ImageExtensions, ImageDirectories)</l>
<l>endif</l>
<c>* </c>
<l>if (|ImageBaseNames| == 0)</l>
<l>    throw ('Error: Could not find any image files in folder: "' + ImageDir + '"')</l>
<l>endif</l>
<c>* </c>
<c>* Get file paths of images relative to ImageDir.</c>
<l>tuple_regexp_match (ImageDirectories[0], '.*' + ImageDir, CommonBasePathImage)</l>
<l>tuple_regexp_replace (ImageDirectories, CommonBasePathImage, '', ImageDirectoriesRel)</l>
<c>* </c>
<l>if (FileNameImageOnly != '')</l>
<c>    * Select only the images which include the specified string.</c>
<l>    tuple_regexp_match (ImageBaseNames, FileNameImageOnly, ImageMatches)</l>
<l>    tuple_find (ImageMatches [!=] '', 1, MatchIndices)</l>
<l>    ImageBaseNames := ImageBaseNames[MatchIndices]</l>
<l>    ImageExtensions := ImageExtensions[MatchIndices]</l>
<l>    ImageDirectories := ImageDirectories[MatchIndices]</l>
<l>    ImageDirectoriesRel := ImageDirectoriesRel[MatchIndices]</l>
<c>    * Remove the prefix or suffix of the image file name which is not included in the annotation file name.</c>
<l>    tuple_regexp_replace (ImageBaseNames, FileNameImageOnly, '', ImageBaseNamesToMatch)</l>
<l>else</l>
<l>    ImageBaseNamesToMatch := ImageBaseNames</l>
<l>endif</l>
<c>* </c>
<c>* Get ground truth labels from the image directory names.</c>
<l>tuple_regexp_match ('/' + ImageDirectories, '.*/([^/]+)/$', GroundTruthLabels)</l>
<c>* </c>
<c>* </c>
<c>* * Prepare annotation file list.</c>
<c>* </c>
<c>* Get all annotation directories.</c>
<l>if (AnnotationSubDirs != [])</l>
<l>    AnnotationDirs := AnnotationDir + '/' + AnnotationSubDirs</l>
<l>else</l>
<l>    AnnotationDirs := AnnotationDir</l>
<l>endif</l>
<c>* </c>
<c>* List all annotation files.</c>
<l>if (Type == 'anomaly_detection')</l>
<l>    AnomalyExtensions := ['hobj','ima','tif','tiff','gif','bmp','jpg','jpeg','jp2','jxr','png','pcx','ras','xwd','pbm','pnm','pgm','ppm']</l>
<l>    prepare_image_lists (AnnotationDirs, AnomalyExtensions, AnnoBaseNames, AnnoExtensions, AnnoDirectories)</l>
<l>else</l>
<l>    prepare_image_lists (AnnotationDirs, 'default', AnnoBaseNames, AnnoExtensions, AnnoDirectories)</l>
<l>endif</l>
<c>* </c>
<l>if (|AnnoBaseNames| == 0)</l>
<l>    if (Type == 'segmentation')</l>
<l>        throw ('No segmentation images found')</l>
<l>    elseif (Type == 'anomaly_detection')</l>
<l>        ImageListOut := ImageDirectoriesRel + ImageBaseNames + '.' + ImageExtensions</l>
<l>        tuple_regexp_replace (ImageListOut, '^/', '', ImageListOut)</l>
<l>        LabelListOut := GroundTruthLabels</l>
<l>        AnnotationListOut := gen_tuple_const(|ImageBaseNames|,'')</l>
<l>        return ()</l>
<l>    else</l>
<l>        throw ('Invalid dataset type \'' + Type + '\'')</l>
<l>    endif</l>
<l>endif</l>
<c>* </c>
<c>* Get paths of annotation files relative to AnnotationDir.</c>
<l>tuple_regexp_match (AnnoDirectories[0], '.*' + AnnotationDir, CommonBasePathAnno)</l>
<l>tuple_regexp_replace (AnnoDirectories, CommonBasePathAnno, '', AnnoDirectoriesRel)</l>
<c>* </c>
<l>if (FileNameAnnoOnly != '')</l>
<c>    * Select only the annotations which include the specified string.</c>
<l>    tuple_regexp_match (AnnoBaseNames, FileNameAnnoOnly, AnnoMatches)</l>
<l>    tuple_find (AnnoMatches [!=] '', 1, MatchIndices)</l>
<l>    AnnoBaseNames := AnnoBaseNames[MatchIndices]</l>
<l>    AnnoExtensions := AnnoExtensions[MatchIndices]</l>
<l>    AnnoDirectories := AnnoDirectories[MatchIndices]</l>
<l>    AnnoDirectoriesRel := AnnoDirectoriesRel[MatchIndices]</l>
<c>    * Remove the prefix or suffix of the annotation file name which is not included in the image file name.</c>
<l>    tuple_regexp_replace (AnnoBaseNames, FileNameAnnoOnly, '', AnnoBaseNamesToMatch)</l>
<l>else</l>
<l>    AnnoBaseNamesToMatch := AnnoBaseNames</l>
<l>endif</l>
<c>* </c>
<c>* </c>
<c>* * Match image and annotation lists.</c>
<c>* </c>
<c>* Match a annotation file to each image file by file name.</c>
<l>AnnoMatchIndices := []</l>
<l>ImageMatchIndices := []</l>
<l>for ImageIndex := 0 to |ImageBaseNames| - 1 by 1</l>
<c>    * Find the match based on file names.</c>
<l>    tuple_regexp_match (AnnoBaseNamesToMatch, ImageBaseNamesToMatch[ImageIndex], Match)</l>
<l>    tuple_find (Match [!=] '', 1, AnnoMatchIndex)</l>
<l>    if (AnnoMatchIndex &gt; -1 and |AnnoMatchIndex| == 1)</l>
<c>        * Exactly one match was found.</c>
<l>        AnnoMatchIndices := [AnnoMatchIndices,AnnoMatchIndex]</l>
<l>        ImageMatchIndices := [ImageMatchIndices,ImageIndex]</l>
<l>    elseif (|AnnoMatchIndex| &gt; 1)</l>
<c>        * There should be only one annotation file matching each image.</c>
<l>        ImagePath := ImageDirectoriesRel[ImageIndex] + ImageBaseNames[ImageIndex] + '.' + ImageExtensions[ImageIndex]</l>
<l>        throw ('Multiple matching ' + Type + ' files for image ' + ImagePath)</l>
<l>    endif</l>
<l>endfor</l>
<c>* </c>
<c>* </c>
<c>* * Final checks.</c>
<c>* </c>
<c>* Check if the corresponding matches are collected correctly.</c>
<l>if (|AnnoMatchIndices| != |ImageMatchIndices|)</l>
<l>    throw ('An error occurred while trying to match annotation and image files')</l>
<l>endif</l>
<c>* Check if each match is unique.</c>
<l>if (uniq(sort(AnnoMatchIndices)) != sort(AnnoMatchIndices))</l>
<l>    throw ('A single ' + Type + ' file has matched with multiple images')</l>
<l>endif</l>
<c>* </c>
<l>ImageIndices := ImageMatchIndices</l>
<l>if (Type == 'anomaly_detection')</l>
<c>    * For anomaly detection, images without a matching annotation file are okay.</c>
<c>    * So in this case, we use all images and not only the ones with a match.</c>
<l>    ImageIndices := [0:|ImageBaseNames| - 1]</l>
<l>elseif (not IgnoreUnmatched)</l>
<c>    * Check if every image matched with an annotation file.</c>
<l>    if (|ImageMatchIndices| != |ImageBaseNames|)</l>
<l>        throw ('Not every image in ImageDir has a corresponding ' + Type + ' file')</l>
<l>    endif</l>
<l>endif</l>
<c>* </c>
<c>* Create final image list.</c>
<l>ImageListOut := ImageDirectoriesRel + ImageBaseNames + '.' + ImageExtensions</l>
<l>ImageListOut := ImageListOut[ImageIndices]</l>
<l>tuple_regexp_replace (ImageListOut, '^/', '', ImageListOut)</l>
<c>* </c>
<c>* Create final ground truth label list.</c>
<l>LabelListOut := GroundTruthLabels[ImageIndices]</l>
<c>* </c>
<c>* Create final annotation list.</c>
<l>AnnotationListOut := AnnoDirectoriesRel + AnnoBaseNames + '.' + AnnoExtensions</l>
<l>if (Type == 'anomaly_detection')</l>
<l>    AnnotationList := gen_tuple_const(|ImageListOut|,'')</l>
<l>    AnnotationList[ImageMatchIndices] := AnnotationListOut[AnnoMatchIndices]</l>
<l>    AnnotationListOut := AnnotationList</l>
<l>else</l>
<l>    AnnotationListOut := AnnotationListOut[AnnoMatchIndices]</l>
<l>endif</l>
<l>tuple_regexp_replace (AnnotationListOut, '^/', '', AnnotationListOut)</l>
<c>* </c>
<l>return ()</l>
</body>
<docu id="list_image_and_annotation_files">
<abstract lang="en_US">This procedure generates lists of images and corresponding annotation files, whereby first one can also be handed over through ImageListIn.
The lists are generated by listing the images in the given directory:
- ImageDir specifies the base directory for the images,
- AnnotationDir specifies the base directory for the annotations.
The file base names of images and annotation files must be unique in the sense that for each image exactly one annotation file is matched based on their file names.

ImageListIn can either contain the full paths of the images or the paths relative to ImageDir. If it is an empty tuple, the image list is generated as well.

The image and annotation lists can be constrained. For this, use the dictionary GenParam, allowing the following keys:
- 'image_sub_dirs': List of directories located in ImageDir. Constrain the image list to these directories. The default value is: [], meaning all directories in ImageDir are considered.
- 'annotation_sub_dirs': List of directories located in AnnotationDir. Constrain the annotation files list to these directories. The default value is: [], meaning all directories in AnnoationDir are considered.
- 'file_name_image_only': Prefix or suffix, that has to be part of the image file names but is not part of the annotation file names. The default value is: ''.
- 'file_name_annotation_only': String that has to be part of the annotation file names. Note, this serves as identifier for the annotation files and thus should not be part of the image file names. The default value is: ''.
- 'ignore_unmatched_images': For a value 'false', an error is thrown in case not every image has a matching annotation image, in case the DLDataset is created for DL Semantic Segmentation. The default value is: false.</abstract>
<chapters lang="de_DE">
<item>Deep Learning</item>
<item>Semantische Segmentierung</item>
</chapters>
<chapters lang="en_US">
<item>Deep Learning</item>
<item>Semantic Segmentation</item>
</chapters>
<library lang="en_US">MVTec Standard Procedures</library>
<short lang="en_US">Generate image list and corresponding annotation file list.</short>
<parameters>
<parameter id="AnnotationDir">
<default_type>string</default_type>
<default_value>AnnotationDir</default_value>
<description lang="en_US">Base directory of the annotation files.</description>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>filename</sem_type>
<type_list>
<item>string</item>
</type_list>
</parameter>
<parameter id="AnnotationListOut">
<default_type>string</default_type>
<description lang="en_US">List of annotation file names and paths relative to AnnotationDir.</description>
<mixed_type>false</mixed_type>
<multivalue>optional</multivalue>
<sem_type>filename</sem_type>
<type_list>
<item>string</item>
</type_list>
</parameter>
<parameter id="GenParam">
<default_type>integer</default_type>
<default_value>[]</default_value>
<description lang="en_US">GenParam is a dictionary, which can be used to constrain the generated image and annotation lists. 
</description>
<mixed_type>false</mixed_type>
<sem_type>any</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="ImageDir">
<default_type>string</default_type>
<default_value>ImageDir</default_value>
<description lang="en_US">Base directory of the images.</description>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>filename</sem_type>
<type_list>
<item>string</item>
</type_list>
</parameter>
<parameter id="ImageListIn">
<default_type>string</default_type>
<default_value>[]</default_value>
<description lang="en_US">List of image file names that should be used for generating a corresponding annotation list.</description>
<mixed_type>false</mixed_type>
<multivalue>optional</multivalue>
<sem_type>filename</sem_type>
<type_list>
<item>string</item>
</type_list>
</parameter>
<parameter id="ImageListOut">
<default_type>string</default_type>
<description lang="en_US">List of image names and paths relative to ImageDir.</description>
<mixed_type>false</mixed_type>
<multivalue>optional</multivalue>
<sem_type>filename</sem_type>
<type_list>
<item>string</item>
</type_list>
</parameter>
<parameter id="LabelListOut">
<default_type>string</default_type>
<description lang="en_US">List of the image labels.</description>
<mixed_type>false</mixed_type>
<multivalue>optional</multivalue>
<sem_type>string</sem_type>
<type_list>
<item>string</item>
</type_list>
</parameter>
<parameter id="Type">
<default_type>string</default_type>
<description lang="en_US">Type of the dataset.</description>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>string</sem_type>
<type_list>
<item>string</item>
</type_list>
<values>
<item>'segmentation'</item>
<item>'anomaly_detection'</item>
</values>
</parameter>
</parameters>
</docu>
</procedure>
<procedure name="list_image_files">
<interface>
<ic>
<par name="ImageDirectory" base_type="ctrl" dimension="0"/>
<par name="Extensions" base_type="ctrl" dimension="0"/>
<par name="Options" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="ImageFiles" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c>* This procedure returns all files in a given directory</c>
<c>* with one of the suffixes specified in Extensions.</c>
<c>* </c>
<c>* Input parameters:</c>
<c>* ImageDirectory: Directory or a tuple of directories with images.</c>
<c>*    If a directory is not found locally, the respective directory</c>
<c>*    is searched under %HALCONIMAGES%/ImageDirectory.</c>
<c>*    See the Installation Guide for further information</c>
<c>*    in case %HALCONIMAGES% is not set.</c>
<c>* Extensions: A string tuple containing the extensions to be found</c>
<c>*    e.g. ['png','tif',jpg'] or others</c>
<c>* If Extensions is set to 'default' or the empty string '',</c>
<c>*    all image suffixes supported by HALCON are used.</c>
<c>* Options: as in the operator list_files, except that the 'files'</c>
<c>*    option is always used. Note that the 'directories' option</c>
<c>*    has no effect but increases runtime, because only files are</c>
<c>*    returned.</c>
<c>* </c>
<c>* Output parameter:</c>
<c>* ImageFiles: A tuple of all found image file names</c>
<c>* </c>
<l>if (Extensions == [] or Extensions == '' or Extensions == 'default')</l>
<l>    Extensions := ['ima','tif','tiff','gif','bmp','jpg','jpeg','jp2','jxr','png','pcx','ras','xwd','pbm','pnm','pgm','ppm']</l>
<c>    * </c>
<l>endif</l>
<l>ImageFiles := []</l>
<c>* Loop through all given image directories.</c>
<l>for ImageDirectoryIndex := 0 to |ImageDirectory| - 1 by 1</l>
<l>    ImageFilesTmp := []</l>
<l>    CurrentImageDirectory := ImageDirectory[ImageDirectoryIndex]</l>
<l>    if (CurrentImageDirectory == '')</l>
<l>        CurrentImageDirectory := '.'</l>
<l>    endif</l>
<l>    get_system ('image_dir', HalconImages)</l>
<l>    get_system ('operating_system', OS)</l>
<l>    if (OS{0:2} == 'Win')</l>
<l>        HalconImages := split(HalconImages,';')</l>
<l>    else</l>
<l>        HalconImages := split(HalconImages,':')</l>
<l>    endif</l>
<l>    Directories := CurrentImageDirectory</l>
<l>    for Index := 0 to |HalconImages| - 1 by 1</l>
<l>        Directories := [Directories,HalconImages[Index] + '/' + CurrentImageDirectory]</l>
<l>    endfor</l>
<l>    tuple_strlen (Directories, Length)</l>
<l>    tuple_gen_const (|Length|, false, NetworkDrive)</l>
<l>    if (OS{0:2} == 'Win')</l>
<l>        for Index := 0 to |Length| - 1 by 1</l>
<l>            if (strlen(Directories[Index]) &gt; 1)</l>
<l>                tuple_str_first_n (Directories[Index], 1, Substring)</l>
<l>                if (Substring == '//' or Substring == '\\\\')</l>
<l>                    NetworkDrive[Index] := true</l>
<l>                endif</l>
<l>            endif</l>
<l>        endfor</l>
<l>    endif</l>
<l>    ImageFilesTmp := []</l>
<l>    for Index := 0 to |Directories| - 1 by 1</l>
<l>        file_exists (Directories[Index], FileExists)</l>
<l>        if (FileExists)</l>
<l>            list_files (Directories[Index], ['files',Options], AllFiles)</l>
<l>            ImageFilesTmp := []</l>
<l>            for i := 0 to |Extensions| - 1 by 1</l>
<l>                tuple_regexp_select (AllFiles, ['.*' + Extensions[i] + '$','ignore_case'], Selection)</l>
<l>                ImageFilesTmp := [ImageFilesTmp,Selection]</l>
<l>            endfor</l>
<l>            tuple_regexp_replace (ImageFilesTmp, ['\\\\','replace_all'], '/', ImageFilesTmp)</l>
<l>            if (NetworkDrive[Index])</l>
<l>                tuple_regexp_replace (ImageFilesTmp, ['//','replace_all'], '/', ImageFilesTmp)</l>
<l>                ImageFilesTmp := '/' + ImageFilesTmp</l>
<l>            else</l>
<l>                tuple_regexp_replace (ImageFilesTmp, ['//','replace_all'], '/', ImageFilesTmp)</l>
<l>            endif</l>
<l>            break</l>
<l>        endif</l>
<l>    endfor</l>
<c>    * Concatenate the output image paths.</c>
<l>    ImageFiles := [ImageFiles,ImageFilesTmp]</l>
<l>endfor</l>
<l>return ()</l>
</body>
<docu id="list_image_files">
<abstract lang="en_US">This procedure returns all files in a given directory ImageDirectory with one of the suffixes specified in Extensions.

It is possible to use a tuple with multiple directories as input ImageDirectory. If a directory is not found locally, the respective directory is searched under %HALCONIMAGES%/ImageDirectory. See the Installation Guide for further information in case %HALCONIMAGES% is not set.
If Extensions is set to 'default' or the empty string '', all image suffixes supported by HALCON are used.
The parameter Options is used as in the operator list_files (see list_files for details), except that the 'files' option is always used. Note that the 'directories' option has no effect but increases runtime, because only files are returned.</abstract>
<alternatives>
<item>list_files</item>
</alternatives>
<chapters>
<item>File</item>
</chapters>
<chapters lang="de_DE">
<item>Datei</item>
<item>Sonstiges</item>
</chapters>
<chapters lang="en_US">
<item>File</item>
<item>Misc</item>
</chapters>
<example lang="en_US">list_image_files ('.',[] ,[] , ImageFiles)
for Index := 1 to |ImageFiles|  by 1
    read_image (Image,ImageFiles[Index-1])
*     do something
endfor</example>
<keywords lang="de_DE">
<item>Bilddateien auflisten</item>
</keywords>
<keywords lang="en_US">
<item>list image files</item>
</keywords>
<library lang="de_DE">MVTec Standard Procedures</library>
<library lang="en_US">MVTec Standard Procedures</library>
<predecessor>
<item>list_files</item>
</predecessor>
<see_also>
<item>list_files</item>
</see_also>
<short>Get all image files under the given path</short>
<short lang="de_DE">Get all image files under the given path</short>
<short lang="en_US">Get all image files under the given path</short>
<successor>
<item>read_image</item>
</successor>
<parameters>
<parameter id="Extensions">
<default_type>string</default_type>
<default_value>'default'</default_value>
<description lang="en_US">A string tuple containing the extensions to be found e.g. ['png','tif',jpg'] or others</description>
<mixed_type>false</mixed_type>
<multivalue>optional</multivalue>
<sem_type>string</sem_type>
<type_list>
<item>string</item>
</type_list>
<values>
<item>'ima'</item>
<item>'bmp'</item>
<item>'jpg'</item>
<item>'png'</item>
<item>'tiff'</item>
<item>'tif'</item>
<item>'gif'</item>
<item>'jpeg'</item>
<item>'pcx'</item>
<item>'pgm'</item>
<item>'ppm'</item>
<item>'pbm'</item>
<item>'xwd'</item>
<item>'pnm'</item>
</values>
</parameter>
<parameter id="ImageDirectory">
<default_type>string</default_type>
<description lang="en_US">The image directory</description>
<mixed_type>false</mixed_type>
<multivalue>optional</multivalue>
<sem_type>filename.dir</sem_type>
<type_list>
<item>string</item>
</type_list>
</parameter>
<parameter id="ImageFiles">
<default_type>string</default_type>
<description lang="en_US">A tuple of all found image file names</description>
<mixed_type>false</mixed_type>
<multivalue>optional</multivalue>
<sem_type>filename.read</sem_type>
<type_list>
<item>string</item>
</type_list>
</parameter>
<parameter id="Options">
<default_type>string</default_type>
<default_value>[]</default_value>
<description lang="en_US">Processing options</description>
<multivalue>optional</multivalue>
<sem_type>string</sem_type>
<type_list>
<item>string</item>
</type_list>
<values>
<item>'recursive'</item>
<item>'follow_links'</item>
<item>'max_depth 5'</item>
</values>
</parameter>
</parameters>
</docu>
</procedure>
<procedure name="make_neighboring_colors_distinguishable" access="local">
<interface>
<ic>
<par name="ColorsRainbow" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="Colors" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c>* </c>
<c>* Shuffle the input colors in a deterministic way</c>
<c>* to make adjacent colors more distinguishable.</c>
<c>* Neighboring colors from the input are distributed to every NumChunks</c>
<c>* position in the output.</c>
<c>* Depending on the number of colors, increase NumChunks.</c>
<l>NumColors := |ColorsRainbow|</l>
<l>if (NumColors &gt;= 8)</l>
<l>    NumChunks := 3</l>
<l>    if (NumColors &gt;= 40)</l>
<l>        NumChunks := 6</l>
<l>    elseif (NumColors &gt;= 20)</l>
<l>        NumChunks := 4</l>
<l>    endif</l>
<l>    Colors := gen_tuple_const(NumColors,-1)</l>
<c>    * Check if the Number of Colors is dividable by NumChunks.</c>
<l>    NumLeftOver := NumColors % NumChunks</l>
<l>    ColorsPerChunk := int(NumColors / NumChunks)</l>
<l>    StartIdx := 0</l>
<l>    for S := 0 to NumChunks - 1 by 1</l>
<l>        EndIdx := StartIdx + ColorsPerChunk - 1</l>
<l>        if (S &lt; NumLeftOver)</l>
<l>            EndIdx := EndIdx + 1</l>
<l>        endif</l>
<l>        IdxsLeft := [S:NumChunks:NumColors - 1]</l>
<l>        IdxsRight := [StartIdx:EndIdx]</l>
<l>        Colors[S:NumChunks:NumColors - 1] := ColorsRainbow[StartIdx:EndIdx]</l>
<l>        StartIdx := EndIdx + 1</l>
<l>    endfor</l>
<l>else</l>
<l>    Colors := ColorsRainbow</l>
<l>endif</l>
<l>return ()</l>
</body>
<docu id="make_neighboring_colors_distinguishable">
<abstract lang="en_US">Shuffles the tuple of input colors ColorsRainbow in a deterministic way such that adjacent colors are more distinguishable.
The method only shuffles the input if the input tuple has at least eight elements.</abstract>
<chapters lang="de_DE">
<item>Deep Learning</item>
<item>Modell</item>
</chapters>
<chapters lang="en_US">
<item>Deep Learning</item>
<item>Model</item>
</chapters>
<library lang="en_US">MVTec Standard Procedures</library>
<short lang="en_US">shuffles the input colors in a deterministic way</short>
<parameters>
<parameter id="Colors">
<description lang="en_US">Tuple of shuffled output colors.</description>
<multivalue>optional</multivalue>
<sem_type>string</sem_type>
</parameter>
<parameter id="ColorsRainbow">
<default_value>ColorsRainbow</default_value>
<description lang="en_US">Input colors to be shuffled</description>
<multivalue>optional</multivalue>
<sem_type>string</sem_type>
</parameter>
</parameters>
</docu>
</procedure>
<procedure name="max_line_width" access="local">
<interface>
<ic>
<par name="WindowHandle" base_type="ctrl" dimension="0"/>
<par name="Lines" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="MaxWidth" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c>* </c>
<l>MaxWidth := 0</l>
<l>for Index := 0 to |Lines| - 1 by 1</l>
<l>    get_string_extents (WindowHandle, Lines[Index], Ascent, Descent, LineWidth, LineHeight)</l>
<l>    MaxWidth := max([LineWidth,MaxWidth])</l>
<l>endfor</l>
<l>return ()</l>
</body>
<docu id="max_line_width">
<chapters lang="de_DE">
<item>Graphik</item>
<item>Ausgabe</item>
</chapters>
<chapters lang="en_US">
<item>Graphics</item>
<item>Output</item>
</chapters>
<library lang="en_US">MVTec Standard Procedures</library>
<short lang="en_US">Get string extends of several lines.</short>
<parameters>
<parameter id="Lines"/>
<parameter id="MaxWidth"/>
<parameter id="WindowHandle"/>
</parameters>
</docu>
</procedure>
<procedure name="obtain_3d_pose_of_match_moving_cam">
<interface>
<ic>
<par name="Row" base_type="ctrl" dimension="0"/>
<par name="Column" base_type="ctrl" dimension="0"/>
<par name="Angle" base_type="ctrl" dimension="0"/>
<par name="ToolInBasePose" base_type="ctrl" dimension="0"/>
<par name="HandEyeCalibData" base_type="ctrl" dimension="0"/>
<par name="Poses" base_type="ctrl" dimension="0"/>
<par name="RectificationData" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="ModelInBasePose" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c>* This procedure obtains the 3D pose from the model to the base of</c>
<c>* the robot.</c>
<l>read_dict_tuple (HandEyeCalibData, 'CamParam', CamParam)</l>
<l>read_dict_tuple (HandEyeCalibData, 'ToolInCamPose', ToolInCamPose)</l>
<l>read_dict_tuple (Poses, 'PlaneInModelPose', PlaneInModelPose)</l>
<l>read_dict_tuple (RectificationData, 'RectifyImage', RectifyImage)</l>
<l>if (RectifyImage != 'no_rectification')</l>
<l>    read_dict_tuple (RectificationData, 'ScaleRectification', ScaleRectification)</l>
<l>endif</l>
<l>read_dict_tuple (RectificationData, 'MatchingPlaneRectifiedPartInCamPose', MatchingPlaneRectifiedPartInCamPose)</l>
<c>* </c>
<c>* Keep track of the pose type used by the robot.</c>
<l>get_pose_type (ToolInBasePose, OrderOfTransform, OrderOfRotation, ViewOfTransform)</l>
<c>* Convert to default pose type.</c>
<l>convert_pose_type (MatchingPlaneRectifiedPartInCamPose, 'Rp+T', 'gba', 'point', MatchingPlaneRectifiedPartInCamPose)</l>
<l>convert_pose_type (PlaneInModelPose, 'Rp+T', 'gba', 'point', PlaneInModelPose)</l>
<l>convert_pose_type (ToolInBasePose, 'Rp+T', 'gba', 'point', ToolInBasePose)</l>
<l>convert_pose_type (ToolInCamPose, 'Rp+T', 'gba', 'point', ToolInCamPose)</l>
<l>if (|Row| == 1)</l>
<l>    vector_angle_to_rigid (0, 0, 0, Row, Column, Angle, HomMat2DObject)</l>
<c>    * Col = x, Row = y.</c>
<l>    if (RectifyImage == 'no_rectification')</l>
<l>        affine_trans_pixel (HomMat2DObject, 0, 0, RowObject, ColObject)</l>
<l>        image_points_to_world_plane (CamParam, MatchingPlaneRectifiedPartInCamPose, RowObject, ColObject, 'm', PXM, PYM)</l>
<l>        HomMat3DObject := [HomMat2DObject[4],HomMat2DObject[3],0,PXM,HomMat2DObject[1],HomMat2DObject[0],0,PYM,0,0,1,0]</l>
<l>        hom_mat3d_to_pose (HomMat3DObject, ModelToMatchInPlanePose)</l>
<l>        pose_compose (ModelToMatchInPlanePose, PlaneInModelPose, ModelInPlanePose)</l>
<l>        pose_compose (MatchingPlaneRectifiedPartInCamPose, ModelInPlanePose, ModelInCamPose)</l>
<l>    elseif (RectifyImage == 'only_rectify' or RectifyImage == 'align_and_rectify')</l>
<l>        HomMat3DObject := [HomMat2DObject[4],HomMat2DObject[3],0,HomMat2DObject[5] * ScaleRectification,HomMat2DObject[1],HomMat2DObject[0],0,HomMat2DObject[2] * ScaleRectification,0,0,1,0]</l>
<l>        hom_mat3d_to_pose (HomMat3DObject, ModelToMatchInPlanePartRectPose)</l>
<l>        pose_compose (ModelToMatchInPlanePartRectPose, PlaneInModelPose, ModelInMatchingPlaneRectifiedPartPose)</l>
<l>        pose_compose (MatchingPlaneRectifiedPartInCamPose, ModelInMatchingPlaneRectifiedPartPose, ModelInCamPose)</l>
<l>    else</l>
<l>        throw ('Please set the parameter RectifyImage correctly')</l>
<l>    endif</l>
<l>    pose_invert (ToolInBasePose, BaseInToolPose)</l>
<l>    pose_compose (ToolInCamPose, BaseInToolPose, BaseInCamPose)</l>
<l>    pose_invert (BaseInCamPose, CamInBasePose)</l>
<l>    pose_compose (CamInBasePose, ModelInCamPose, ModelInBasePose)</l>
<c>    * </c>
<l>    convert_pose_type (ModelInBasePose, OrderOfTransform, OrderOfRotation, ViewOfTransform, ModelInBasePose)</l>
<l>else</l>
<l>    throw ('Exactly one match should be given as input')</l>
<l>endif</l>
<l>return ()</l>
</body>
<docu id="obtain_3d_pose_of_match_moving_cam">
<abstract lang="en_US">This procedure obtains the pose of the matched model in the robot's base coordinate system to enable grasping it later.

The input parameters Row, Column, and Angle are those of the matched model.

The input dict HandEyeCalibData contains the camera parameters CamParam and ToolInCamPose. The input dict Poses contains the PlaneInModelPose.

The input dict RectificationData contains the RectifyImage which is the rectification option with the possible values 'no_rectification', 'only_rectify', and 'align_and_rectify' as explained in the procedure prepare_poses_and_rectification_data_moving_cam. Moreover, RectificationData contains MatchingPlaneRectifiedPartInCamPose. RectificationData also contains ScaleRectification if image rectification is set by the user. 

The output parameter ModelInBasePose is the pose of the matched model in the robot's base coordinate system.</abstract>
<chapters lang="de_DE">
<item>Transformationen</item>
<item>Sonstiges</item>
</chapters>
<chapters lang="en_US">
<item>Transformations</item>
<item>Misc</item>
</chapters>
<library lang="de_DE">MVTec Standard Procedures</library>
<library lang="en_US">MVTec Standard Procedures</library>
<predecessor>
<item>rectify_image_and_compute_matching_plane_moving_cam</item>
</predecessor>
<short lang="en_US">Obtain the pose of the matched model in the base coordinate system.</short>
<successor>
<item>calculate_tool_in_base_robot_path_poses</item>
</successor>
<parameters>
<parameter id="Angle">
<default_type>real</default_type>
<description lang="en_US">Angle of the matched model.</description>
<multivalue>false</multivalue>
<sem_type>angle.rad</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
<parameter id="Column">
<default_type>real</default_type>
<description lang="en_US">Column of the matched model.</description>
<multivalue>false</multivalue>
<sem_type>point.x</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
<parameter id="HandEyeCalibData">
<default_type>integer</default_type>
<description lang="en_US">Dict that should contain: CamParam and ToolInCamPose.</description>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>dict</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="ModelInBasePose">
<default_type>real</default_type>
<description lang="en_US">Pose of the model in the robot's base coordinate system.</description>
<multivalue>true</multivalue>
<sem_type>pose</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
<values>
<item>[]</item>
</values>
</parameter>
<parameter id="Poses">
<default_type>integer</default_type>
<description lang="en_US">Dict that should contain PlaneInModelPose.</description>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>dict</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="RectificationData">
<default_type>integer</default_type>
<description lang="en_US">Dict that should contain: RectifyImage, MatchingPlaneRectifiedPartInCamPose, and (if rectification is set) ScaleRectification.</description>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>dict</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="Row">
<default_type>real</default_type>
<description lang="en_US">Row of the matched model.</description>
<multivalue>false</multivalue>
<sem_type>point.y</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
<parameter id="ToolInBasePose">
<default_type>real</default_type>
<description lang="en_US">Current pose of the robot.</description>
<multivalue>true</multivalue>
<sem_type>pose</sem_type>
<type_list>
<item>real</item>
</type_list>
</parameter>
</parameters>
</docu>
</procedure>
<procedure name="obtain_3d_pose_of_match_stationary_cam">
<interface>
<ic>
<par name="Row" base_type="ctrl" dimension="0"/>
<par name="Column" base_type="ctrl" dimension="0"/>
<par name="Angle" base_type="ctrl" dimension="0"/>
<par name="HandEyeCalibData" base_type="ctrl" dimension="0"/>
<par name="Poses" base_type="ctrl" dimension="0"/>
<par name="RectificationData" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="ModelInBasePose" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c>* This procedure obtains the 3D pose from the model to the base of</c>
<c>* the robot.</c>
<l>read_dict_tuple (HandEyeCalibData, 'CamParam', CamParam)</l>
<l>read_dict_tuple (HandEyeCalibData, 'BaseInCamPose', BaseInCamPose)</l>
<l>read_dict_tuple (Poses, 'PlaneInModelPose', PlaneInModelPose)</l>
<l>read_dict_tuple (Poses, 'MatchingPlaneInCamPose', MatchingPlaneInCamPose)</l>
<l>read_dict_tuple (RectificationData, 'RectifyImage', RectifyImage)</l>
<l>if (RectifyImage == 'true')</l>
<l>    read_dict_tuple (RectificationData, 'ScaleRectification', ScaleRectification)</l>
<l>endif</l>
<c>* </c>
<c>* Keep track of the pose type used by the robot.</c>
<l>get_pose_type (PlaneInModelPose, OrderOfTransform, OrderOfRotation, ViewOfTransform)</l>
<c>* Convert to default pose type.</c>
<l>convert_pose_type (MatchingPlaneInCamPose, 'Rp+T', 'gba', 'point', MatchingPlaneInCamPose)</l>
<l>convert_pose_type (PlaneInModelPose, 'Rp+T', 'gba', 'point', PlaneInModelPose)</l>
<l>if (|Row| == 1 and |Column| == 1 and |Angle| == 1)</l>
<l>    vector_angle_to_rigid (0, 0, 0, Row, Column, Angle, HomMat2DObject)</l>
<c>    * col = x, row = y</c>
<l>    if (RectifyImage == 'false')</l>
<l>        affine_trans_pixel (HomMat2DObject, 0, 0, RowObject, ColObject)</l>
<l>        image_points_to_world_plane (CamParam, MatchingPlaneInCamPose, RowObject, ColObject, 'm', PXM, PYM)</l>
<l>        HomMat3DObject := [HomMat2DObject[4],HomMat2DObject[3],0,PXM,HomMat2DObject[1],HomMat2DObject[0],0,PYM,0,0,1,0]</l>
<l>        hom_mat3d_to_pose (HomMat3DObject, ModelToMatchInPlanePose)</l>
<l>        pose_compose (ModelToMatchInPlanePose, PlaneInModelPose, ModelInPlanePose)</l>
<l>        pose_compose (MatchingPlaneInCamPose, ModelInPlanePose, ModelInCamPose)</l>
<l>    elseif (RectifyImage == 'true')</l>
<l>        HomMat3DObject := [HomMat2DObject[4],HomMat2DObject[3],0,HomMat2DObject[5] * ScaleRectification,HomMat2DObject[1],HomMat2DObject[0],0,HomMat2DObject[2] * ScaleRectification,0,0,1,0]</l>
<l>        hom_mat3d_to_pose (HomMat3DObject, ModelToMatchInPlanePartRectPose)</l>
<l>        pose_compose (ModelToMatchInPlanePartRectPose, PlaneInModelPose, ModelInPlanePartRectPose)</l>
<l>        pose_compose (MatchingPlaneInCamPose, ModelInPlanePartRectPose, ModelInCamPose)</l>
<l>    else</l>
<l>        throw ('Please set the parameter RectifyImage correctly')</l>
<l>    endif</l>
<l>    pose_invert (BaseInCamPose, CamInBasePose)</l>
<l>    pose_compose (CamInBasePose, ModelInCamPose, ModelInBasePose)</l>
<c>    * </c>
<l>    convert_pose_type (ModelInBasePose, OrderOfTransform, OrderOfRotation, ViewOfTransform, ModelInBasePose)</l>
<l>else</l>
<l>    throw ('Exactly one match should be given as input')</l>
<l>endif</l>
<l>return ()</l>
</body>
<docu id="obtain_3d_pose_of_match_stationary_cam">
<abstract lang="en_US">This procedure obtains the pose of the matched model in the robot's base coordinate system to enable grasping it later, in a stationary camera setup.

The input parameters Row, Column, and Angle are those of the matched model.

The input dict HandEyeCalibData must contain the camera parameters CamParam and the pose BaseInCamPose.

The input dict Poses must contain the poses PlaneInModelPose and MatchingPlaneInCamPose.

The input dict RectificationData must contain the parameter RectifyImage ('true', 'false'), and, if the image is to be rectified, the parameter ScaleRectification.

The output parameter ModelInBasePose is the pose of the matched model in the robot's base coordinate system.</abstract>
<alternatives>
<item>obtain_3d_pose_of_match_moving_cam</item>
</alternatives>
<chapters lang="de_DE">
<item>Transformationen</item>
<item>Sonstiges</item>
</chapters>
<chapters lang="en_US">
<item>Transformations</item>
<item>Misc</item>
</chapters>
<library lang="de_DE">MVTec Standard Procedures</library>
<library lang="en_US">MVTec Standard Procedures</library>
<predecessor>
<item>prepare_poses_and_rectification_data_stationary_cam</item>
</predecessor>
<short lang="en_US">Obtain the pose of the matched model in the base coordinate system in a stationary camera setup.</short>
<successor>
<item>calculate_tool_in_base_robot_path_poses</item>
</successor>
<parameters>
<parameter id="Angle">
<default_type>real</default_type>
<description lang="en_US">Rotation angle of the found match of the model.</description>
<multivalue>false</multivalue>
<sem_type>angle.rad</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
<parameter id="Column">
<default_type>real</default_type>
<description lang="en_US">Column coordinate of the found match of the model.</description>
<multivalue>false</multivalue>
<sem_type>point.x</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
<parameter id="HandEyeCalibData">
<default_type>integer</default_type>
<description lang="en_US">Dict that should contain: CamParam and BaseInCamPose.</description>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>dict</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="ModelInBasePose">
<default_type>real</default_type>
<description lang="en_US">Pose of the matched model in the robot's base coordinate system.</description>
<multivalue>false</multivalue>
<sem_type>pose</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
<values>
<item>[]</item>
</values>
</parameter>
<parameter id="Poses">
<default_type>integer</default_type>
<description lang="en_US">Dict that should contain: PlaneInModelPose and MatchingPlaneInCamPose.</description>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>dict</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="RectificationData">
<default_type>integer</default_type>
<description lang="en_US">Dict that should contain: RectifyImage and ScaleRectification.</description>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>dict</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="Row">
<default_type>real</default_type>
<description lang="en_US">Row coordinate of the found match of the model.</description>
<multivalue>false</multivalue>
<sem_type>point.y</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
</parameters>
</docu>
</procedure>
<procedure name="open_child_window" access="local">
<interface>
<ic>
<par name="WindowHandleFather" base_type="ctrl" dimension="0"/>
<par name="Font" base_type="ctrl" dimension="0"/>
<par name="FontSize" base_type="ctrl" dimension="0"/>
<par name="Text" base_type="ctrl" dimension="0"/>
<par name="PrevWindowCoordinates" base_type="ctrl" dimension="0"/>
<par name="WindowHandleDict" base_type="ctrl" dimension="0"/>
<par name="WindowHandleKey" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="WindowHandleChild" base_type="ctrl" dimension="0"/>
<par name="PrevWindowCoordinatesOut" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c>* </c>
<c>* This procedure opens a window next to the given WindowHandleFather.</c>
<c>* </c>
<c>* Get the maximum width of the text to be displayed.</c>
<c>* The width should be at leat 200.</c>
<l>StringWidth := 150</l>
<l>for IndexText := 0 to |Text| - 1 by 1</l>
<l>    get_string_extents (WindowHandleFather, Text[IndexText], _, _, TextWidth, _)</l>
<l>    StringWidth := max2(StringWidth,TextWidth)</l>
<l>endfor</l>
<c>* </c>
<c>* Define window coordinates.</c>
<l>WindowRow := PrevWindowCoordinates[0]</l>
<l>WindowColumn := PrevWindowCoordinates[1] + PrevWindowCoordinates[2] + 5</l>
<l>WindowWidth := StringWidth + 2 * 12.0</l>
<l>WindowHeight := PrevWindowCoordinates[3]</l>
<c>* </c>
<l>dev_open_window (WindowRow, WindowColumn, WindowWidth, WindowHeight, 'black', WindowHandleChild)</l>
<l>set_display_font (WindowHandleChild, FontSize, Font, 'true', 'false')</l>
<c>* </c>
<c>* Return the coordinates of the new window.</c>
<l>PrevWindowCoordinatesOut := [WindowRow,WindowColumn,WindowWidth,WindowHeight]</l>
<c>* </c>
<c>* Set some meta information about the new child window handle.</c>
<l>get_dict_tuple (WindowHandleDict, 'meta_information', MetaInfo)</l>
<l>set_dict_tuple (MetaInfo, WindowHandleKey + '_child_window_coordinates', PrevWindowCoordinatesOut)</l>
<l>set_dict_tuple (WindowHandleDict, 'meta_information', MetaInfo)</l>
<c>* </c>
<l>return ()</l>
</body>
<docu id="open_child_window">
<chapters lang="de_DE">
<item>Graphik</item>
<item>Fenster</item>
</chapters>
<chapters lang="en_US">
<item>Graphics</item>
<item>Window</item>
</chapters>
<library lang="en_US">MVTec Standard Procedures</library>
<short lang="en_US">Open a window next to the given WindowHandleFather. </short>
<parameters>
<parameter id="Font">
<default_type>string</default_type>
<multivalue>false</multivalue>
<sem_type>string</sem_type>
<type_list>
<item>string</item>
</type_list>
</parameter>
<parameter id="FontSize">
<default_type>integer</default_type>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>integer</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="PrevWindowCoordinates">
<default_type>integer</default_type>
<mixed_type>false</mixed_type>
<multivalue>true</multivalue>
<sem_type>integer</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="PrevWindowCoordinatesOut">
<default_type>integer</default_type>
<mixed_type>false</mixed_type>
<multivalue>true</multivalue>
<sem_type>integer</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="Text">
<default_type>string</default_type>
<mixed_type>false</mixed_type>
<multivalue>optional</multivalue>
<sem_type>string</sem_type>
<type_list>
<item>string</item>
</type_list>
</parameter>
<parameter id="WindowHandleChild">
<default_type>integer</default_type>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>window</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="WindowHandleDict">
<default_type>integer</default_type>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>dict</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="WindowHandleFather">
<default_type>integer</default_type>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>window</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="WindowHandleKey">
<default_type>string</default_type>
<multivalue>false</multivalue>
<sem_type>string</sem_type>
<type_list>
<item>string</item>
</type_list>
</parameter>
</parameters>
</docu>
</procedure>
<procedure name="open_new_window" access="local">
<interface>
<oc>
<par name="WindowHandle" base_type="ctrl" dimension="0"/>
<par name="WindowHandleGraphics" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<l>wait_seconds (0.1)</l>
<l>dev_get_window (WindowHandle)</l>
<l>get_window_extents (WindowHandle, Row, Column, Width, Height)</l>
<l>dev_open_window_fit_size (0, Width + 8, Width, Height, 600, -1, WindowHandleGraphics)</l>
<l>set_display_font (WindowHandleGraphics, 14, 'mono', 'true', 'false')</l>
<l>set_part_style (WindowHandleGraphics, 2)</l>
<l>return ()</l>
</body>
<docu id="open_new_window">
<chapters lang="de_DE">
<item>Graphik</item>
<item>Fenster</item>
</chapters>
<chapters lang="en_US">
<item>Graphics</item>
<item>Window</item>
</chapters>
<library lang="en_US">MVTec Standard Procedures</library>
<short lang="en_US">Open a new window next to an existing one.</short>
<parameters>
<parameter id="WindowHandle">
<default_type>integer</default_type>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>window</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="WindowHandleGraphics">
<default_type>integer</default_type>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>window</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
</parameters>
</docu>
</procedure>
<procedure name="open_next_window" access="local">
<interface>
<ic>
<par name="Font" base_type="ctrl" dimension="0"/>
<par name="FontSize" base_type="ctrl" dimension="0"/>
<par name="ShowBottomDesc" base_type="ctrl" dimension="0"/>
<par name="WidthImage" base_type="ctrl" dimension="0"/>
<par name="HeightImage" base_type="ctrl" dimension="0"/>
<par name="MapColorBarWidth" base_type="ctrl" dimension="0"/>
<par name="ScaleWindows" base_type="ctrl" dimension="0"/>
<par name="ThresholdWidth" base_type="ctrl" dimension="0"/>
<par name="PrevWindowCoordinates" base_type="ctrl" dimension="0"/>
<par name="WindowHandleDict" base_type="ctrl" dimension="0"/>
<par name="WindowHandleKey" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="WindowHandleNew" base_type="ctrl" dimension="0"/>
<par name="WindowImageRatioHeight" base_type="ctrl" dimension="0"/>
<par name="PrevWindowCoordinatesOut" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c>* </c>
<c>* This procedure opens a new window, either next to</c>
<c>* the last ones, or in a new row.</c>
<c>* </c>
<c>* Get coordinates of previous window.</c>
<l>PrevWindowRow := PrevWindowCoordinates[0]</l>
<l>PrevWindowColumn := PrevWindowCoordinates[1]</l>
<l>PrevWindowWidth := PrevWindowCoordinates[2]</l>
<l>PrevWindowHeight := PrevWindowCoordinates[3]</l>
<c>* </c>
<l>if (PrevWindowColumn + PrevWindowWidth &gt; ThresholdWidth)</l>
<c>    * Open window in new row.</c>
<l>    WindowRow := PrevWindowRow + PrevWindowHeight + 55</l>
<l>    WindowColumn := 0</l>
<l>else</l>
<c>    * Open window in same row.</c>
<l>    WindowRow := PrevWindowRow</l>
<l>    WindowColumn := PrevWindowColumn + PrevWindowWidth</l>
<l>    if (WindowColumn != 0)</l>
<l>        WindowColumn := WindowColumn + 5</l>
<l>    endif</l>
<l>endif</l>
<c>* </c>
<l>dev_open_window_fit_size (WindowRow, WindowColumn, WidthImage, HeightImage, [500,800] * ScaleWindows, [400,600] * ScaleWindows, WindowHandleNew)</l>
<l>set_display_font (WindowHandleNew, FontSize, Font, 'true', 'false')</l>
<c>* </c>
<c>* Add MarginBottom and MapColorBarWidth to window.</c>
<l>if (ShowBottomDesc)</l>
<l>    get_string_extents (WindowHandleNew, 'Test_string', Ascent, Descent, _, _)</l>
<l>    MarginBottom := 2 * 12 + Ascent + Descent</l>
<l>else</l>
<l>    MarginBottom := 0</l>
<l>endif</l>
<l>get_window_extents (WindowHandleNew, _, _, WindowWidth, WindowHeight)</l>
<l>dev_set_window_extents (WindowRow, WindowColumn, WindowWidth + MapColorBarWidth, WindowHeight + MarginBottom)</l>
<c>* </c>
<c>* Get and set meta information of new window handle.</c>
<l>update_window_meta_information (WindowHandleNew, WidthImage, HeightImage, WindowRow, WindowColumn, MapColorBarWidth, MarginBottom, WindowImageRatioHeight, WindowImageRatioWidth, SetPartRow2, SetPartColumn2, PrevWindowCoordinatesOut)</l>
<c>* </c>
<c>* Set window handle and some meta information about the new window handle.</c>
<l>set_dict_tuple (WindowHandleDict, WindowHandleKey, WindowHandleNew)</l>
<l>get_dict_tuple (WindowHandleDict, 'meta_information', MetaInfo)</l>
<l>set_dict_tuple (MetaInfo, WindowHandleKey + '_window_image_ratio_height', WindowImageRatioHeight)</l>
<l>set_dict_tuple (MetaInfo, WindowHandleKey + '_window_image_ratio_width', WindowImageRatioWidth)</l>
<l>set_dict_tuple (MetaInfo, WindowHandleKey + '_set_part_row2', SetPartRow2)</l>
<l>set_dict_tuple (MetaInfo, WindowHandleKey + '_set_part_column2', SetPartColumn2)</l>
<l>set_dict_tuple (MetaInfo, WindowHandleKey + '_margin_bottom', MarginBottom)</l>
<l>set_dict_tuple (MetaInfo, WindowHandleKey + '_map_color_bar_with', MapColorBarWidth)</l>
<l>set_dict_tuple (MetaInfo, WindowHandleKey + '_window_coordinates', PrevWindowCoordinatesOut)</l>
<l>set_dict_tuple (WindowHandleDict, 'meta_information', MetaInfo)</l>
<c>* </c>
<l>return ()</l>
</body>
<docu id="open_next_window">
<chapters lang="de_DE">
<item>Graphik</item>
<item>Fenster</item>
</chapters>
<chapters lang="en_US">
<item>Graphics</item>
<item>Window</item>
</chapters>
<library lang="en_US">MVTec Standard Procedures</library>
<short lang="en_US">Open a new window, either next to the last ones, or in a new row.</short>
<parameters>
<parameter id="Font">
<default_type>string</default_type>
<multivalue>false</multivalue>
<sem_type>string</sem_type>
<type_list>
<item>string</item>
</type_list>
</parameter>
<parameter id="FontSize">
<default_type>integer</default_type>
<multivalue>false</multivalue>
<sem_type>integer</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="HeightImage">
<default_type>integer</default_type>
<multivalue>false</multivalue>
<sem_type>extent.y</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="MapColorBarWidth">
<default_type>integer</default_type>
<multivalue>false</multivalue>
<sem_type>integer</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="PrevWindowCoordinates">
<default_type>integer</default_type>
<multivalue>true</multivalue>
<sem_type>integer</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="PrevWindowCoordinatesOut">
<default_type>integer</default_type>
<mixed_type>false</mixed_type>
<multivalue>true</multivalue>
<sem_type>integer</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="ScaleWindows">
<default_type>real</default_type>
<default_value>1.0</default_value>
<multivalue>false</multivalue>
<sem_type>real</sem_type>
<type_list>
<item>real</item>
</type_list>
<values>
<item>0.5</item>
<item>0.75</item>
</values>
</parameter>
<parameter id="ShowBottomDesc"/>
<parameter id="ThresholdWidth">
<default_type>integer</default_type>
<multivalue>false</multivalue>
<sem_type>integer</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="WidthImage">
<default_type>integer</default_type>
<multivalue>false</multivalue>
<sem_type>extent.x</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="WindowHandleDict">
<default_type>integer</default_type>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>dict</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="WindowHandleKey">
<default_type>string</default_type>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>string</sem_type>
<type_list>
<item>string</item>
</type_list>
</parameter>
<parameter id="WindowHandleNew">
<default_type>integer</default_type>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>window</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="WindowImageRatioHeight">
<default_type>real</default_type>
<multivalue>false</multivalue>
<sem_type>real</sem_type>
<type_list>
<item>real</item>
</type_list>
</parameter>
</parameters>
</docu>
</procedure>
<procedure name="parse_filename">
<interface>
<ic>
<par name="FileName" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="BaseName" base_type="ctrl" dimension="0"/>
<par name="Extension" base_type="ctrl" dimension="0"/>
<par name="Directory" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c>* This procedure gets a filename (with full path) as input</c>
<c>* and returns the directory path, the base filename and the extension</c>
<c>* in three different strings.</c>
<c>* </c>
<c>* In the output path the path separators will be replaced</c>
<c>* by '/' in all cases.</c>
<c>* </c>
<c>* The procedure shows the possibilities of regular expressions in HALCON.</c>
<c>* </c>
<c>* Input parameters:</c>
<c>* FileName: The input filename</c>
<c>* </c>
<c>* Output parameters:</c>
<c>* BaseName: The filename without directory description and file extension</c>
<c>* Extension: The file extension</c>
<c>* Directory: The directory path</c>
<c>* </c>
<c>* Example:</c>
<c>* basename('C:/images/part_01.png',...) returns</c>
<c>* BaseName = 'part_01'</c>
<c>* Extension = 'png'</c>
<c>* Directory = 'C:\\images\\' (on Windows systems)</c>
<c>* </c>
<c>* Explanation of the regular expressions:</c>
<c>* </c>
<c>* '([^\\\\/]*?)(?:\\.[^.]*)?$':</c>
<c>* To start at the end, the '$' matches the end of the string,</c>
<c>* so it is best to read the expression from right to left.</c>
<c>* The part in brackets (?:\\.[^.}*) denotes a non-capturing group.</c>
<c>* That means, that this part is matched, but not captured</c>
<c>* in contrast to the first bracketed group ([^\\\\/], see below.)</c>
<c>* \\.[^.]* matches a dot '.' followed by as many non-dots as possible.</c>
<c>* So (?:\\.[^.]*)? matches the file extension, if any.</c>
<c>* The '?' at the end assures, that even if no extension exists,</c>
<c>* a correct match is returned.</c>
<c>* The first part in brackets ([^\\\\/]*?) is a capture group,</c>
<c>* which means, that if a match is found, only the part in</c>
<c>* brackets is returned as a result.</c>
<c>* Because both HDevelop strings and regular expressions need a '\\'</c>
<c>* to describe a backslash, inside regular expressions within HDevelop</c>
<c>* a backslash has to be written as '\\\\'.</c>
<c>* [^\\\\/] matches any character but a slash or backslash ('\\' in HDevelop)</c>
<c>* [^\\\\/]*? matches a string od 0..n characters (except '/' or '\\')</c>
<c>* where the '?' after the '*' switches the greediness off,</c>
<c>* that means, that the shortest possible match is returned.</c>
<c>* This option is necessary to cut off the extension</c>
<c>* but only if (?:\\.[^.]*)? is able to match one.</c>
<c>* To summarize, the regular expression matches that part of</c>
<c>* the input string, that follows after the last '/' or '\\' and</c>
<c>* cuts off the extension (if any) after the last '.'.</c>
<c>* </c>
<c>* '\\.([^.]*)$':</c>
<c>* This matches everything after the last '.' of the input string.</c>
<c>* Because ([^.]) is a capturing group,</c>
<c>* only the part after the dot is returned.</c>
<c>* </c>
<c>* '.*[\\\\/]':</c>
<c>* This matches the longest substring with a '/' or a '\\' at the end.</c>
<c>* </c>
<l>tuple_regexp_match (FileName, '.*[\\\\/]', DirectoryTmp)</l>
<l>tuple_substr (FileName, strlen(DirectoryTmp), strlen(FileName) - 1, Substring)</l>
<l>tuple_regexp_match (Substring, '([^\\\\/]*?)(?:\\.[^.]*)?$', BaseName)</l>
<l>tuple_regexp_match (Substring, '\\.([^.]*)$', Extension)</l>
<c>* </c>
<c>* </c>
<c>* Finally all found backslashes ('\\') are converted</c>
<c>* to a slash to get consistent paths</c>
<l>tuple_regexp_replace (DirectoryTmp, ['\\\\','replace_all'], '/', Directory)</l>
<l>return ()</l>
</body>
<docu id="parse_filename">
<abstract lang="en_US">This procedure gets a filename (with full path) as input and returns the directory path (Directory), the base filename (BaseName) and the extension (Extension) in three different strings.</abstract>
<alternatives>
<item>tuple_regexp_select</item>
<item>tuple_regexp_match</item>
<item>tuple_regexp_match</item>
</alternatives>
<attention lang="en_US">In case of hidden files of the form '.name' (e.g. '.profile' etc.), an empty BaseName and Extension=name are returned.</attention>
<chapters>
<item>File</item>
</chapters>
<chapters lang="de_DE">
<item>Datei</item>
<item>Sonstiges</item>
</chapters>
<chapters lang="en_US">
<item>File</item>
<item>Misc</item>
</chapters>
<example lang="en_US">FullFileNames:=['C:/images/image_01.png','C:/images/image_02.png','C:/training_image.png']
parse_filename (FullFileName, BaseName, Extension, Directory)
tuple_regexp_select(BaseName,'training',TrainingImages)</example>
<keywords lang="de_DE">
<item>Dateiname parsen</item>
</keywords>
<keywords lang="en_US">
<item>parse file name</item>
</keywords>
<library lang="de_DE">MVTec Standard Procedures</library>
<library lang="en_US">MVTec Standard Procedures</library>
<predecessor>
<item>list_files</item>
<item>list_image_files</item>
</predecessor>
<short>This procedure gets a filename (with full path) as input and returns the directory path, the base filename and the extension in three different strings.</short>
<short lang="de_DE">Parse a filename into directory, base filename, and extension</short>
<short lang="en_US">Parse a filename into directory, base filename, and extension</short>
<successor>
<item>tuple_regexp_select</item>
</successor>
<parameters>
<parameter id="BaseName">
<default_type>string</default_type>
<description lang="en_US">The filename without directory description and file extension</description>
<mixed_type>false</mixed_type>
<multivalue>optional</multivalue>
<sem_type>string</sem_type>
<type_list>
<item>string</item>
</type_list>
</parameter>
<parameter id="Directory">
<default_type>string</default_type>
<description lang="en_US">The directory path</description>
<mixed_type>false</mixed_type>
<sem_type>string</sem_type>
<type_list>
<item>string</item>
</type_list>
</parameter>
<parameter id="Extension">
<default_type>string</default_type>
<description lang="en_US">The file extension</description>
<mixed_type>false</mixed_type>
<sem_type>string</sem_type>
<type_list>
<item>string</item>
</type_list>
</parameter>
<parameter id="FileName">
<default_type>string</default_type>
<description lang="en_US">The input filename</description>
<mixed_type>false</mixed_type>
<multivalue>optional</multivalue>
<sem_type>string</sem_type>
<type_list>
<item>string</item>
</type_list>
</parameter>
</parameters>
</docu>
</procedure>
<procedure name="plot_dl_classifier_training_progress">
<interface>
<ic>
<par name="TrainingErrors" base_type="ctrl" dimension="0"/>
<par name="ValidationErrors" base_type="ctrl" dimension="0"/>
<par name="LearningRates" base_type="ctrl" dimension="0"/>
<par name="Epochs" base_type="ctrl" dimension="0"/>
<par name="NumEpochs" base_type="ctrl" dimension="0"/>
<par name="WindowHandle" base_type="ctrl" dimension="0"/>
</ic>
</interface>
<body>
<c>* This procedure plots the tuples training error and</c>
<c>* validation error with the y-axis on the left side,</c>
<c>* and the learning rate with the y-axis on the right side,</c>
<c>* versus the epochs over batches on the x-axis.</c>
<c>* The maximum number of epochs should be given by NumEpochs,</c>
<c>* to scale the x-axis appropriately.</c>
<c>* The plot is displayed in the graphics window given by WindowHandle.</c>
<c>* </c>
<c>* The procedure expects the input tuples TrainingErrors, ValidationErrors,</c>
<c>* LearningRates, and Epochs with their values sorted in chronological order,</c>
<c>* the current value in each case as last element.</c>
<c>* </c>
<c>* Check input parameters.</c>
<l>if (NumEpochs == [])</l>
<l>    NumEpochs := max(Epochs)</l>
<l>elseif (is_number(NumEpochs) != 1)</l>
<l>    throw ('NumEpochs must be a number or an empty tuple.')</l>
<l>endif</l>
<l>TrainingErrorPercent := TrainingErrors * 100</l>
<l>ValidationErrorPercent := ValidationErrors * 100</l>
<c>* </c>
<c>* Set the colors of the axes, plots and texts.</c>
<l>AxesColor := 'white'</l>
<l>TrainingErrorColor := 'magenta'</l>
<l>ValidationErrorColor := 'gold'</l>
<l>LearningRateColor := 'dark turquoise'</l>
<c>* </c>
<c>* Create functions from the input tuples.</c>
<l>create_funct_1d_pairs (Epochs, TrainingErrorPercent, TrainingErrorFunction)</l>
<l>create_funct_1d_pairs (Epochs, ValidationErrorPercent, ValidationErrorFunction)</l>
<l>create_funct_1d_pairs (Epochs, LearningRates, LearningRateFunction)</l>
<c>* </c>
<c>* Assemble generic parameters for the plots.</c>
<l>GenParamName := ['axis_location_x','end_x','ticks_x','start_y','margin_top','margin_right']</l>
<l>GenParamValue := ['origin',NumEpochs,NumEpochs / 5 + 1,0,70,100]</l>
<l>EndYError := max([TrainingErrorPercent,ValidationErrorPercent,0.1])</l>
<c>* Round the maximum value of the left Y-axis</c>
<c>* to an integer or a real value with one decimal.</c>
<l>if (EndYError &gt;= 1.0)</l>
<l>    EndYError := int(ceil(EndYError))</l>
<l>else</l>
<l>    EndYError := ceil(EndYError * 10.0) / 10.0</l>
<l>endif</l>
<l>EndYLearningRate := max(LearningRates)</l>
<c>* Display the first values as crosses</c>
<c>* for better visibility.</c>
<l>if (|Epochs| == 1)</l>
<l>    Style := 'cross'</l>
<l>else</l>
<l>    Style := 'line'</l>
<l>endif</l>
<c>* </c>
<c>* Disable flushing the graphics window temporarily</c>
<c>* to avoid flickering.</c>
<l>get_window_param (WindowHandle, 'flush', Flush)</l>
<l>set_window_param (WindowHandle, 'flush', 'false')</l>
<l>dev_clear_window ()</l>
<c>* </c>
<c>* Display plots.</c>
<l>plot_funct_1d (WindowHandle, TrainingErrorFunction, [], 'Error [%]', TrainingErrorColor, [GenParamName,'axes_color','end_y','ticks_y','style'], [GenParamValue,AxesColor,EndYError,EndYError / 5.0,Style])</l>
<l>plot_funct_1d (WindowHandle, ValidationErrorFunction, [], [], ValidationErrorColor, [GenParamName,'axes_color','end_y','style'], [GenParamValue,'none',EndYError,Style])</l>
<l>plot_funct_1d (WindowHandle, LearningRateFunction, [], 'Learning rate', LearningRateColor, [GenParamName,'axes_color','axis_location_y','end_y','ticks_y','format_y','style'], [GenParamValue,AxesColor,'right',EndYLearningRate,EndYLearningRate / 5.0,'.1e','step'])</l>
<c>* </c>
<c>* Display current values in appropriate colors.</c>
<l>IndexMinValError := find_last(ValidationErrorPercent,min(ValidationErrorPercent))</l>
<l>Text := 'Best validation error: ' + ValidationErrorPercent[IndexMinValError]$'.1f'</l>
<l>Text[1] := 'Associated training error: ' + TrainingErrorPercent[IndexMinValError]$'.1f'</l>
<l>dev_disp_text (Text + ' %', 'window', 'top', 'left', [ValidationErrorColor,TrainingErrorColor], 'box', 'false')</l>
<l>Text := 'Learning rate: ' + LearningRates[|LearningRates| - 1]$'.1e'</l>
<l>dev_disp_text (Text, 'window', 'top', 'right', LearningRateColor, 'box', 'false')</l>
<l>Text := 'Epoch: ' + Epochs[|Epochs| - 1]$'.1f'</l>
<l>dev_disp_text (Text, 'window', 'bottom', 'center', 'white', 'box', 'false')</l>
<c>* </c>
<c>* Flush the buffer and re-enable flushing.</c>
<l>flush_buffer (WindowHandle)</l>
<l>set_window_param (WindowHandle, 'flush', Flush)</l>
<l>return ()</l>
</body>
<docu id="plot_dl_classifier_training_progress">
<abstract lang="en_US">plot_dl_classifier_training_progress plots the training errors and validation errors with the y-axis on the left side, and the learning rates with the y-axis on the right side, versus the epochs on the x-axis. The total number of epochs should be give by NumEpochs, to scale the x-axis appropriately. If NumEpochs is an empty tuple, the maximum of Epochs is used as maximum x-value instead. Error typically stands for the top-1 error. The plot is displayed in the graphics window given by WindowHandle.

The procedure expects the input tuples TrainingErrors, ValidationErrors, LearningRates, and Epochs with their values sorted in chronological order, the current value in each case as last element. To plot the all the values of the actual classifier training and not only the current ones, you will have to accumulate them, e.g., by concatenation. 

At the top of the graphics window, the best validation error and the associated training error are displayed. In the HDevelop examples classify_fruit_deep_learning.hdev and classify_pill_defects_deep_learning.hdev, the best classifier is used accordingly for the classification after the training is finished.

To interpret these plots, please have a look at the operator reference, chapter 'Deep Learning'.</abstract>
<chapters lang="en_US">
<item>Legacy</item>
<item>DL Classification</item>
</chapters>
<example lang="en_US">for Epoch := 0 to NumEpochs-1 by 1
    for I := 0 to |TrainingImages|-1 by BatchSize
        if (Iteration % 20 == 0)
            * Output from evaluate_dl_classifier_traing_progress:
            TrainingError := [TrainingError, CurrentTrainingError]
            ValidationError := [ValidationError, CurrentValidationError]
            get_dl_classifier_param(DLClassifierHandle, 'learning_rate', CurrentLearningRate)
            LearningRate := [LearningRate,CurrentLearningRate]
            Epochs := [Epochs, Epoch]
            *
            plot_dl_classifier_training_progress (TrainingError, ValidationError, LearningRate, Epochs, WindowHandle)
        endif
    endfor
endfor</example>
<library lang="en_US">MVTec Standard Procedures</library>
<predecessor>
<item>evaluate_dl_classifier</item>
</predecessor>
<short lang="en_US">Plot the training error, validation error and learning rate during deep learning classifier training.</short>
<warning lang="en_US">plot_dl_classifier_training_progress is obsolete and is only provided for reasons of backward compatibility.</warning>
<parameters>
<parameter id="Epochs">
<default_type>integer</default_type>
<description lang="en_US">Tuple containing the concatenated epochs.</description>
<mixed_type>false</mixed_type>
<multivalue>optional</multivalue>
<sem_type>integer</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
<parameter id="LearningRates">
<default_type>real</default_type>
<description lang="en_US">Tuple containing the concatenated learning rates.</description>
<mixed_type>false</mixed_type>
<multivalue>optional</multivalue>
<sem_type>real</sem_type>
<type_list>
<item>real</item>
</type_list>
</parameter>
<parameter id="NumEpochs">
<default_type>integer</default_type>
<default_value>[]</default_value>
<description lang="en_US">Total number of epochs.</description>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>integer</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="TrainingErrors">
<default_type>real</default_type>
<description lang="en_US">Tuple containing the concatenated training errors.</description>
<mixed_type>false</mixed_type>
<multivalue>optional</multivalue>
<sem_type>real</sem_type>
<type_list>
<item>real</item>
</type_list>
</parameter>
<parameter id="ValidationErrors">
<default_type>real</default_type>
<description lang="en_US">Tuple containing the concatenated validation errors.</description>
<mixed_type>false</mixed_type>
<multivalue>optional</multivalue>
<sem_type>real</sem_type>
<type_list>
<item>real</item>
</type_list>
</parameter>
<parameter id="WindowHandle">
<default_type>integer</default_type>
<description lang="en_US">Handle of the graphics window.</description>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>window</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
</parameters>
</docu>
</procedure>
<procedure name="plot_dl_detection_histogram" access="local">
<interface>
<ic>
<par name="DataCollection" base_type="ctrl" dimension="0"/>
<par name="Color" base_type="ctrl" dimension="0"/>
<par name="GenParamName" base_type="ctrl" dimension="0"/>
<par name="GenParamValue" base_type="ctrl" dimension="0"/>
<par name="WindowHandle" base_type="ctrl" dimension="0"/>
</ic>
</interface>
<body>
<c>* This procedure generates and displays a histogram of the data given</c>
<c>* in DataCollection.</c>
<c>* </c>
<c>* Fixed display parameters.</c>
<l>LabelY := 'Frequency'</l>
<l>AxesColor := '#898b8f'</l>
<c>* </c>
<c>* Variable display parameters.</c>
<l>Title := ''</l>
<l>LabelX := ''</l>
<c>* </c>
<l>for GenParamIndex := 0 to |GenParamName| - 1 by 1</l>
<l>    if (GenParamName[GenParamIndex] == 'label_x')</l>
<l>        LabelX := GenParamValue[GenParamIndex]</l>
<l>    elseif (GenParamName[GenParamIndex] == 'title')</l>
<l>        Title := GenParamValue[GenParamIndex]</l>
<l>    else</l>
<l>        throw ('Unknown generic parameter ' + GenParamName[GenParamIndex] + '.')</l>
<l>    endif</l>
<l>endfor</l>
<c>* </c>
<c>* Get data histogram. Set minimum to 0 if it is greater than 0.</c>
<l>MinHisto := min(DataCollection)</l>
<l>if (MinHisto &gt; 0)</l>
<l>    MinHisto := 0</l>
<l>endif</l>
<l>tuple_histo_range (DataCollection, MinHisto, max(DataCollection), 100, DataHisto, DataBinSize)</l>
<c>* </c>
<c>* Set some window parameters.</c>
<l>set_display_font (WindowHandle, 16, 'mono', 'true', 'false')</l>
<l>set_window_param (WindowHandle, 'flush', 'false')</l>
<l>dev_set_line_width (2)</l>
<c>* </c>
<c>* Plot white background.</c>
<l>get_part (WindowHandle, PartRow1, PartColumn1, PartRow2, PartColumn2)</l>
<l>gen_rectangle1 (PlotBackground, PartRow1 + 40, PartColumn1 + 20, PartRow2 - 20, PartColumn2 - 20)</l>
<l>dev_set_color ('white')</l>
<l>dev_set_draw ('fill')</l>
<l>dev_display (PlotBackground)</l>
<c>* Plot title text.</c>
<l>dev_disp_text (Title, 'image', PartRow1 + 10, PartColumn1 + 20, 'black', 'box', 'false')</l>
<c>* </c>
<c>* Set data for x tick.</c>
<l>LeftX := MinHisto</l>
<l>RightX := max(DataCollection)</l>
<l>StepX := DataBinSize</l>
<l>if (StepX &gt; 1)</l>
<l>    StepX := int(StepX)</l>
<l>endif</l>
<l>StepY := max([max(DataHisto) / 7,1])</l>
<c>* </c>
<c>* Plot the histogram.</c>
<l>plot_tuple (WindowHandle, [LeftX:DataBinSize:RightX - DataBinSize / 2.], DataHisto, '', '', Color, ['axes_color','ticks_x','ticks_y','margin_top','margin_bottom','margin_left','margin_right'], [AxesColor,15 * StepX,StepY,75,60,70,60])</l>
<c>* Display the x and y labels.</c>
<l>LabelXShift := strlen(LabelX) * 10 + 25</l>
<l>dev_disp_text (LabelX, 'image', PartRow2 - 42, PartColumn2 - LabelXShift, AxesColor, 'box', 'false')</l>
<l>dev_disp_text (LabelY, 'image', PartRow1 + 45, PartColumn1 + 25, AxesColor, 'box', 'false')</l>
<c>* </c>
<l>flush_buffer (WindowHandle)</l>
<l>set_window_param (WindowHandle, 'flush', 'true')</l>
<c>* </c>
<l>return ()</l>
</body>
<docu id="plot_dl_detection_histogram">
<abstract lang="en_US">This procedure generates a histogram of the data given in DataCollection and displays it in the window given by WindowHandle.
Color determines the color of the plotted histogram.

Using GenParamName and GenParamValue, you can further influence the plot. The following entries are possible for GenParamName:
- 'title': Set a title for the plot.
- 'label_x' and 'label_y': Set x and y labels of the plot.</abstract>
<chapters lang="en_US">
<item>Deep Learning</item>
<item>Object Detection</item>
</chapters>
<library lang="en_US">MVTec Standard Procedures</library>
<short lang="en_US">This procedure generates a histogram out of the input and displays the plot.</short>
<parameters>
<parameter id="Color">
<default_type>string</default_type>
<description lang="en_US">Color for the histogram plot.</description>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>string</sem_type>
<type_list>
<item>string</item>
</type_list>
</parameter>
<parameter id="DataCollection">
<default_type>real</default_type>
<description lang="en_US">Data collection for which the histogram is to be calculated.</description>
<mixed_type>false</mixed_type>
<multivalue>optional</multivalue>
<sem_type>real</sem_type>
<type_list>
<item>real</item>
</type_list>
</parameter>
<parameter id="GenParamName">
<default_type>string</default_type>
<description lang="en_US">Names of the generic parameters with corresponding values given in GenParamValue.</description>
<mixed_type>false</mixed_type>
<multivalue>optional</multivalue>
<sem_type>string</sem_type>
<type_list>
<item>string</item>
</type_list>
</parameter>
<parameter id="GenParamValue">
<default_type>string</default_type>
<description lang="en_US">Generic parameter values with corresponding names given in GenParamName.</description>
<mixed_type>false</mixed_type>
<multivalue>optional</multivalue>
<sem_type>string</sem_type>
<type_list>
<item>string</item>
</type_list>
</parameter>
<parameter id="WindowHandle">
<default_type>integer</default_type>
<description lang="en_US">Window handle, where the histogram is displayed.</description>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>handle</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
</parameters>
</docu>
</procedure>
<procedure name="plot_funct_1d">
<interface>
<ic>
<par name="WindowHandle" base_type="ctrl" dimension="0"/>
<par name="Function" base_type="ctrl" dimension="0"/>
<par name="XLabel" base_type="ctrl" dimension="0"/>
<par name="YLabel" base_type="ctrl" dimension="0"/>
<par name="Color" base_type="ctrl" dimension="0"/>
<par name="GenParamName" base_type="ctrl" dimension="0"/>
<par name="GenParamValue" base_type="ctrl" dimension="0"/>
</ic>
</interface>
<body>
<c>* This procedure plots a function in a coordinate system.</c>
<c>* </c>
<c>* Input parameters:</c>
<c>* </c>
<c>* Function: 1D function</c>
<c>* </c>
<c>* XLabel: X-axis label</c>
<c>* </c>
<c>* YLabel: Y-axis label</c>
<c>* </c>
<c>* Color: Color of the plotted function</c>
<c>*        If [] is given, the currently set display color is used.</c>
<c>*        If 'none is given, the function is not plotted, but only</c>
<c>*        the coordinate axes as specified.</c>
<c>* </c>
<c>* GenParamName:  Generic parameters to control the presentation</c>
<c>*                The parameters are evaluated from left to right.</c>
<c>* </c>
<c>*                Possible Values:</c>
<c>*    'axes_color': coordinate system color</c>
<c>*                  Default: 'white'</c>
<c>*                  If 'none' is given, no coordinate system is shown.</c>
<c>*    'style': Graph style</c>
<c>*             Possible values: 'line' (default), 'cross', 'step', 'filled'</c>
<c>*    'clip': Clip graph to coordinate system area</c>
<c>*            Possible values: 'yes' (default), 'no'</c>
<c>*    'ticks': Control display of ticks on the axes</c>
<c>*             If 'min_max_origin' is given (default), ticks are shown</c>
<c>*             at the minimum and maximum values of the axes and at the</c>
<c>*             intercept point of x- and y-axis.</c>
<c>*             If 'none' is given, no ticks are shown.</c>
<c>*             If any number != 0 is given, it is interpreted as distance</c>
<c>*             between the ticks.</c>
<c>*    'ticks_x': Control display of ticks on x-axis only</c>
<c>*    'ticks_y': Control display of ticks on y-axis only</c>
<c>*    'format_x': Format of the values next to the ticks of the x-axis</c>
<c>*                (see tuple_string for more details).</c>
<c>*    'format_y': Format of the values next to the ticks of the y-axis</c>
<c>*                (see tuple_string for more details).</c>
<c>*    'grid': Control display of grid lines within the coordinate system</c>
<c>*            If 'min_max_origin' is given (default), grid lines are shown</c>
<c>*            at the minimum and maximum values of the axes.</c>
<c>*            If 'none' is given, no grid lines are shown.</c>
<c>*            If any number != 0 is given, it is interpreted as distance</c>
<c>*            between the grid lines.</c>
<c>*    'grid_x': Control display of grid lines for the x-axis only</c>
<c>*    'grid_y': Control display of grid lines for the y-axis only</c>
<c>*    'grid_color': Color of the grid (default: 'dim gray')</c>
<c>*    'margin': The distance in pixels of the coordinate system area</c>
<c>*              to all four window borders.</c>
<c>*    'margin_left': The distance in pixels of the coordinate system area</c>
<c>*                   to the left window border.</c>
<c>*    'margin_right': The distance in pixels of the coordinate system area</c>
<c>*                    to the right window border.</c>
<c>*    'margin_top': The distance in pixels of the coordinate system area</c>
<c>*                  to the upper window border.</c>
<c>*    'margin_bottom': The distance in pixels of the coordinate system area</c>
<c>*                     to the lower window border.</c>
<c>*    'start_x': Lowest x value of the x-axis</c>
<c>*               Default: min(XValues)</c>
<c>*    'end_x': Highest x value of the x-axis</c>
<c>*             Default: max(XValues)</c>
<c>*    'start_y': Lowest y value of the y-axis</c>
<c>*               Default: min(YValues)</c>
<c>*    'end_y': Highest y value of the y-axis</c>
<c>*             Default: max(YValues)</c>
<c>*    'axis_location_x': Either 'bottom', 'origin', or 'top'</c>
<c>*                to position the x-axis conveniently,</c>
<c>*                or the Y coordinate of the intercept point of x- and y-axis.</c>
<c>*                Default: 'bottom'</c>
<c>*                (Used to be called 'origin_y')</c>
<c>*    'axis_location_y': Either 'left', 'origin', or 'right'</c>
<c>*                to position the y-axis conveniently,</c>
<c>*                or the X coordinate of the intercept point of x- and y-axis.</c>
<c>*                Default: 'left'</c>
<c>*                (Used to be called 'origin_x')</c>
<c>* </c>
<c>* GenParamValue: Values of the generic parameters of GenericParamName</c>
<c>* </c>
<c>* </c>
<l>funct_1d_to_pairs (Function, XValues, YValues)</l>
<l>plot_tuple (WindowHandle, XValues, YValues, XLabel, YLabel, Color, GenParamName, GenParamValue)</l>
<l>return ()</l>
</body>
<docu id="plot_funct_1d">
<abstract lang="en_US">This procedure plots the function Function into the graphic window given in WindowHandle.
The axes of the coordinate system are labeled with XLabel and YLabel.
The appearance of the output can further be adapted using generic parameters given in GenericParamName and GenericParamValue.

In particular, following parameters can be set:

Function: A 1D function.

 XLabel: X-axis label.

 XLabel: Y-axis label.

 Color: Color of the plotted function.

        If [] is given, the currently set display color is used.
        If 'none' is given, the function is not plotted, but only
        the coordinate axes as specified.

 GenParamName: Generic parameters to control the presentation.

                Possible Values:

    'axes_color': coordinate system color.
                  Default: 'white'
                  If 'none' is given, no coordinate system is shown. 

    'style': Graph style.
             Possible values: 'line' (default), 'cross', 'step', 'filled'

    'clip': Clip graph to coordinate system area.
            Possible values: 'no' (default), 'yes''

    'ticks': Control display of ticks on the axes.
             If 'min_max_origin' is given (default), ticks are shown 
             at the minimum and maximum values of the axes and at the
             intercept point of x- and y-axis.
             If 'none' is given, no ticks are shown.
             If any number != 0 is given, it is interpreted as distance
             between the ticks.

    'ticks_x': Control display of ticks on x-axis only.

    'ticks_y': Control display of ticks on x-axis only.

    'format_x': Format of the values next to the ticks of the x-axis 
                (see tuple_string for more details).

    'format_y': Format of the values next to the ticks of the y-axis
                (see tuple_string for more details).

    'grid': Control display of grid lines within the coordinate system.
            If 'min_max_origin' is given (default), grid lines are shown 
            at the minimum and maximum values of the axes.
            If 'none' is given, no grid lines are shown.
            If any number != 0 is given, it is interpreted as distance
            between the grid lines.

    'grid_x': Control display of grid lines for the x-axis only.

    'grid_y': Control display of grid lines for the y-axis only.

    'grid_color': Color of the grid (default: 'dim gray').

    'margin': The distance in pixels of the coordinate system area
              to all four window borders.

    'margin_left': The distance in pixels of the coordinate system area
                   to the left window border.

    'margin_right': The distance in pixels of the coordinate system area
                    to the right window border.

    'margin_top': The distance in pixels of the coordinate system area
                    to the upper window border.

    'margin_bottom'': The distance in pixels of the coordinate system area
                    to the lower window border.

    'start_x': Lowest x value of the x-axis.
               Default: min(XValues)

    'end_x': Highest x value of the x-axis.
             Default: max(XValues)

    'start_y': Lowest y value of the y-axis.
               Default: min(YValues)

    'end_y': Highest y value of the y-axis.
             Default: max(YValues)

    'axis_location_x': Either 'bottom', 'origin', or 'top' to position the x-axis conveniently, or the Y coordinate of the intercept point of x- and y-axis.
                Default: 'bottom'
                (Used to be called 'origin_y')

    'axis_location_y': Either 'left', 'origin', or 'right' to position the y-axis conveniently, or the X coordinate of the intercept point of x- and y-axis.
                Default: 'left'
                (Used to be called 'origin_x')

 GenParamValue: Values of the generic parameters of GenericParamNames.</abstract>
<alternatives>
<item>plot_tuple</item>
</alternatives>
<chapters lang="de_DE">
<item>Graphik</item>
<item>Ausgabe</item>
</chapters>
<chapters lang="en_US">
<item>Graphics</item>
<item>Output</item>
</chapters>
<example lang="en_US">dev_open_window (0, 0, 512, 512, 'black', WindowHandle)
X := [-rad(180): 0.01: rad(180)]
Y := sin(X)
create_funct_1d_pairs (X, Y, Function)
invert_funct_1d (Function, InverseFunction)
GenParamName := []
GenParamValue := []
plot_funct_1d (WindowHandle, InverseFunction, 'x', 'sin^-1(x)', 'red', GenParamName, GenParamValue)
</example>
<keywords lang="en_US">
<item>plot</item>
<item>function</item>
<item>display</item>
<item>graph</item>
<item>curve</item>
</keywords>
<library lang="en_US">MVTec Standard Procedures</library>
<predecessor>
<item>create_funct_1d_pairs</item>
<item>create_funct_1d_array</item>
<item>compose_funct_1d</item>
</predecessor>
<short lang="en_US"> This procedure plots tuples representing functions or curves in a coordinate system.</short>
<parameters>
<parameter id="Color">
<default_type>string</default_type>
<default_value>[]</default_value>
<description lang="en_US">Color of the function plot.</description>
<multivalue>optional</multivalue>
<sem_type>color</sem_type>
<type_list>
<item>string</item>
</type_list>
<values>
<item>'red'</item>
<item>'green'</item>
<item>'yellow'</item>
<item>'white'</item>
<item>'black'</item>
<item>'cyan'</item>
<item>'magenta'</item>
<item>'blue'</item>
<item>'orange'</item>
</values>
</parameter>
<parameter id="Function">
<description lang="en_US">Function to be plotted</description>
<mixed_type>false</mixed_type>
<sem_type>function_1d</sem_type>
</parameter>
<parameter id="GenParamName">
<default_type>string</default_type>
<default_value>[]</default_value>
<description lang="en_US">Names of generic parameters.</description>
<mixed_type>false</mixed_type>
<multivalue>optional</multivalue>
<sem_type>string</sem_type>
<type_list>
<item>string</item>
</type_list>
<values>
<item>'axes_color'</item>
<item>'style'</item>
<item>'clip'</item>
<item>'ticks'</item>
<item>'ticks_x'</item>
<item>'ticks_y'</item>
<item>'grid'</item>
<item>'grid_x'</item>
<item>'grid_y'</item>
<item>'grid_color'</item>
<item>'margin'</item>
<item>'margin_left'</item>
<item>'margin_right'</item>
<item>'margin_top'</item>
<item>'margin_bottom'</item>
<item>'start_x'</item>
<item>'end_x'</item>
<item>'start_y'</item>
<item>'end_y'</item>
<item>'origin_y'</item>
<item>'origin_x'</item>
<item>'position_y'</item>
</values>
</parameter>
<parameter id="GenParamValue">
<default_type>string</default_type>
<default_value>[]</default_value>
<description lang="en_US">Generic parameter values.</description>
<mixed_type>optional</mixed_type>
<multivalue>optional</multivalue>
<sem_type>any</sem_type>
<type_list>
<item>string</item>
</type_list>
</parameter>
<parameter id="WindowHandle">
<default_type>integer</default_type>
<description lang="en_US">Window handle in which the plot should be displayed.</description>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>window</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="XLabel">
<default_value>[]</default_value>
<description lang="en_US">Label of the x-axis.</description>
</parameter>
<parameter id="YLabel">
<default_value>[]</default_value>
<description lang="en_US">Label of the y-axis.</description>
</parameter>
</parameters>
</docu>
</procedure>
<procedure name="plot_tuple">
<interface>
<ic>
<par name="WindowHandle" base_type="ctrl" dimension="0"/>
<par name="XValues" base_type="ctrl" dimension="0"/>
<par name="YValues" base_type="ctrl" dimension="0"/>
<par name="XLabel" base_type="ctrl" dimension="0"/>
<par name="YLabel" base_type="ctrl" dimension="0"/>
<par name="Color" base_type="ctrl" dimension="0"/>
<par name="GenParamName" base_type="ctrl" dimension="0"/>
<par name="GenParamValue" base_type="ctrl" dimension="0"/>
</ic>
</interface>
<body>
<c>* This procedure plots tuples representing functions</c>
<c>* or curves in a coordinate system.</c>
<c>* </c>
<c>* Input parameters:</c>
<c>* </c>
<c>* XValues: X values of the function to be plotted</c>
<c>*          If XValues is set to [], it is internally set to 0,1,2,...,|YValues|-1.</c>
<c>*          If XValues is a tuple of strings, the values are taken as categories.</c>
<c>* </c>
<c>* YValues: Y values of the function(s) to be plotted</c>
<c>*          If YValues is set to [], it is internally set to 0,1,2,...,|XValues|-1.</c>
<c>*          The number of y values must be equal to the number of x values</c>
<c>*          or an integral multiple. In the latter case,</c>
<c>*          multiple functions are plotted, that share the same x values.</c>
<c>* </c>
<c>* XLabel: X-axis label</c>
<c>* </c>
<c>* YLabel: Y-axis label</c>
<c>* </c>
<c>* Color: Color of the plotted function</c>
<c>*        If [] is given, the currently set display color is used.</c>
<c>*        If 'none is given, the function is not plotted, but only</c>
<c>*        the coordinate axes as specified.</c>
<c>*        If more than one color is given, multiple functions</c>
<c>*        can be displayed in different colors.</c>
<c>* </c>
<c>* GenParamName:  Generic parameters to control the presentation</c>
<c>*                Possible Values:</c>
<c>*    'axes_color': coordinate system color</c>
<c>*                  Default: 'white'</c>
<c>*                  If 'none' is given, no coordinate system is shown.</c>
<c>*    'style': Graph style</c>
<c>*             Possible values: 'line' (default), 'cross', 'step', 'filled'</c>
<c>*    'clip': Clip graph to coordinate system area</c>
<c>*            Possible values: 'yes', 'no' (default)</c>
<c>*    'ticks': Control display of ticks on the axes</c>
<c>*             If 'min_max_origin' is given (default), ticks are shown</c>
<c>*             at the minimum and maximum values of the axes and at the</c>
<c>*             intercept point of x- and y-axis.</c>
<c>*             If 'none' is given, no ticks are shown.</c>
<c>*             If any number != 0 is given, it is interpreted as distance</c>
<c>*             between the ticks.</c>
<c>*    'ticks_x': Control display of ticks on x-axis only</c>
<c>*    'ticks_y': Control display of ticks on y-axis only</c>
<c>*    'format_x': Format of the values next to the ticks of the x-axis</c>
<c>*                (see tuple_string for more details).</c>
<c>*    'format_y': Format of the values next to the ticks of the y-axis</c>
<c>*                (see tuple_string for more details).</c>
<c>*    'grid': Control display of grid lines within the coordinate system</c>
<c>*            If 'min_max_origin' is given (default), grid lines are shown</c>
<c>*            at the minimum and maximum values of the axes.</c>
<c>*            If 'none' is given, no grid lines are shown.</c>
<c>*            If any number != 0 is given, it is interpreted as distance</c>
<c>*            between the grid lines.</c>
<c>*    'grid_x': Control display of grid lines for the x-axis only</c>
<c>*    'grid_y': Control display of grid lines for the y-axis only</c>
<c>*    'grid_color': Color of the grid (default: 'dim gray')</c>
<c>*    'margin': The distance in pixels of the coordinate system area</c>
<c>*              to all four window borders.</c>
<c>*    'margin_left': The distance in pixels of the coordinate system area</c>
<c>*                   to the left window border.</c>
<c>*    'margin_right': The distance in pixels of the coordinate system area</c>
<c>*                    to the right window border.</c>
<c>*    'margin_top': The distance in pixels of the coordinate system area</c>
<c>*                  to the upper window border.</c>
<c>*    'margin_bottom': The distance in pixels of the coordinate system area</c>
<c>*                     to the lower window border.</c>
<c>*    'start_x': Lowest x value of the x-axis</c>
<c>*               Default: min(XValues)</c>
<c>*    'end_x': Highest x value of the x-axis</c>
<c>*             Default: max(XValues)</c>
<c>*    'start_y': Lowest y value of the y-axis</c>
<c>*               Default: min(YValues)</c>
<c>*    'end_y': Highest y value of the y-axis</c>
<c>*             Default: max(YValues)</c>
<c>*    'axis_location_x': Either 'bottom', 'origin', or 'top'</c>
<c>*                to position the x-axis conveniently,</c>
<c>*                or the Y coordinate of the intercept point of x- and y-axis.</c>
<c>*                Default: 'bottom'</c>
<c>*                (Used to be called 'origin_y')</c>
<c>*    'axis_location_y': Either 'left', 'origin', or 'right'</c>
<c>*                to position the y-axis conveniently,</c>
<c>*                or the X coordinate of the intercept point of x- and y-axis.</c>
<c>*                Default: 'left'</c>
<c>*                (Used to be called 'origin_x')</c>
<c>* </c>
<c>* GenParamValue: Values of the generic parameters of GenericParamName</c>
<c>* </c>
<c>* </c>
<c>* Store current display settings</c>
<l>dev_get_window (PreviousWindowHandle)</l>
<l>dev_set_window (WindowHandle)</l>
<l>get_system ('clip_region', ClipRegion)</l>
<l>get_window_extents (WindowHandle, Row, Column, Width, Height)</l>
<l>get_part (WindowHandle, PartRow1, PartColumn1, PartRow2, PartColumn2)</l>
<l>get_rgb (WindowHandle, Red, Green, Blue)</l>
<l>get_draw (WindowHandle, DrawMode)</l>
<l>get_line_style (WindowHandle, OriginStyle)</l>
<c>* </c>
<c>* Set display parameters</c>
<l>set_line_style (WindowHandle, [])</l>
<l>set_system ('clip_region', 'false')</l>
<l>dev_set_part (0, 0, Height - 1, Width - 1)</l>
<c>* </c>
<c>* Check input coordinates</c>
<c>* </c>
<l>if (XValues == [] and YValues == [])</l>
<c>    * Neither XValues nor YValues are given:</c>
<c>    * Set axes to interval [0,1]</c>
<l>    XAxisEndValue := 1</l>
<l>    YAxisEndValue := 1</l>
<l>    XAxisStartValue := 0</l>
<l>    YAxisStartValue := 0</l>
<l>    XValuesAreStrings := false</l>
<l>else</l>
<l>    if (XValues == [])</l>
<c>        * XValues are omitted:</c>
<c>        * Set equidistant XValues</c>
<l>        XValues := [0:|YValues| - 1]</l>
<l>        XValuesAreStrings := false</l>
<l>    elseif (YValues == [])</l>
<c>        * YValues are omitted:</c>
<c>        * Set equidistant YValues</c>
<l>        YValues := [0:|XValues| - 1]</l>
<l>    endif</l>
<l>    if (|YValues| % |XValues| != 0)</l>
<c>        * Number of YValues does not match number of XValues</c>
<l>        throw ('Number of YValues is no multiple of the number of XValues!')</l>
<l>        return ()</l>
<l>    endif</l>
<l>    XValuesAreStrings := is_string_elem(XValues)</l>
<l>    XValuesAreStrings := sum(XValuesAreStrings) == |XValuesAreStrings|</l>
<l>    if (XValuesAreStrings)</l>
<c>        * XValues are given as strings:</c>
<c>        * Show XValues as ticks</c>
<l>        XTickValues := XValues</l>
<l>        XTicks := 1</l>
<c>        * Set x-axis dimensions</c>
<l>        XValues := [1:|XValues|]</l>
<l>    endif</l>
<c>    * Set default x-axis dimensions</c>
<l>    if (|XValues| &gt; 1)</l>
<l>        XAxisStartValue := min(XValues)</l>
<l>        XAxisEndValue := max(XValues)</l>
<l>    else</l>
<l>        XAxisEndValue := XValues[0] + 0.5</l>
<l>        XAxisStartValue := XValues[0] - 0.5</l>
<l>    endif</l>
<l>endif</l>
<c>* Set default y-axis dimensions</c>
<l>if (|YValues| &gt; 1)</l>
<l>    YAxisStartValue := min(YValues)</l>
<l>    YAxisEndValue := max(YValues)</l>
<l>elseif (|YValues| == 1)</l>
<l>    YAxisStartValue := YValues[0] - 0.5</l>
<l>    YAxisEndValue := YValues[0] + 0.5</l>
<l>else</l>
<l>    YAxisStartValue := 0</l>
<l>    YAxisEndValue := 1</l>
<l>endif</l>
<c>* Set default interception point of x- and y- axis</c>
<l>YAxisPosition := 'default'</l>
<l>XAxisPosition := 'default'</l>
<c>* </c>
<c>* Set more defaults</c>
<l>LeftBorder := Width * 0.1</l>
<l>RightBorder := Width * 0.1</l>
<l>UpperBorder := Height * 0.1</l>
<l>LowerBorder := Height * 0.1</l>
<l>AxesColor := 'white'</l>
<l>Style := 'line'</l>
<l>Clip := 'no'</l>
<l>XTicks := 'min_max_origin'</l>
<l>YTicks := 'min_max_origin'</l>
<l>XGrid := 'none'</l>
<l>YGrid := 'none'</l>
<l>GridColor := 'dim gray'</l>
<l>YPosition := 'left'</l>
<l>FormatX := 'default'</l>
<l>FormatY := 'default'</l>
<c>* </c>
<c>* Parse generic parameters</c>
<c>* </c>
<l>NumGenParamNames := |GenParamName|</l>
<l>NumGenParamValues := |GenParamValue|</l>
<l>if (NumGenParamNames != NumGenParamValues)</l>
<l>    throw ('Number of generic parameter names does not match generic parameter values!')</l>
<l>    return ()</l>
<l>endif</l>
<c>* </c>
<l>for GenParamIndex := 0 to |GenParamName| - 1 by 1</l>
<c>    * </c>
<c>    * Set 'axes_color'</c>
<l>    if (GenParamName[GenParamIndex] == 'axes_color')</l>
<l>        AxesColor := GenParamValue[GenParamIndex]</l>
<c>        * </c>
<c>        * Set 'style'</c>
<l>    elseif (GenParamName[GenParamIndex] == 'style')</l>
<l>        Style := GenParamValue[GenParamIndex]</l>
<c>        * </c>
<c>        * Set 'clip'</c>
<l>    elseif (GenParamName[GenParamIndex] == 'clip')</l>
<l>        Clip := GenParamValue[GenParamIndex]</l>
<l>        if (Clip != 'yes' and Clip != 'no')</l>
<l>            throw ('Unsupported clipping option: \'' + Clip + '\'')</l>
<l>        endif</l>
<c>        * </c>
<c>        * Set 'ticks'</c>
<l>    elseif (GenParamName[GenParamIndex] == 'ticks')</l>
<l>        XTicks := GenParamValue[GenParamIndex]</l>
<l>        YTicks := GenParamValue[GenParamIndex]</l>
<c>        * </c>
<c>        * Set 'ticks_x'</c>
<l>    elseif (GenParamName[GenParamIndex] == 'ticks_x')</l>
<l>        XTicks := GenParamValue[GenParamIndex]</l>
<c>        * </c>
<c>        * Set 'ticks_y'</c>
<l>    elseif (GenParamName[GenParamIndex] == 'ticks_y')</l>
<l>        YTicks := GenParamValue[GenParamIndex]</l>
<c>        * </c>
<c>        * Set 'grid'</c>
<l>    elseif (GenParamName[GenParamIndex] == 'grid')</l>
<l>        XGrid := GenParamValue[GenParamIndex]</l>
<l>        YGrid := GenParamValue[GenParamIndex]</l>
<l>        XGridTicks := XTicks</l>
<c>        * </c>
<c>        * Set 'grid_x'</c>
<l>    elseif (GenParamName[GenParamIndex] == 'grid_x')</l>
<l>        XGrid := GenParamValue[GenParamIndex]</l>
<c>        * </c>
<c>        * Set 'grid_y'</c>
<l>    elseif (GenParamName[GenParamIndex] == 'grid_y')</l>
<l>        YGrid := GenParamValue[GenParamIndex]</l>
<c>        * </c>
<c>        * Set 'grid_color'</c>
<l>    elseif (GenParamName[GenParamIndex] == 'grid_color')</l>
<l>        GridColor := GenParamValue[GenParamIndex]</l>
<c>        * </c>
<c>        * Set 'start_x'</c>
<l>    elseif (GenParamName[GenParamIndex] == 'start_x')</l>
<l>        XAxisStartValue := GenParamValue[GenParamIndex]</l>
<c>        * </c>
<c>        * Set 'end_x'</c>
<l>    elseif (GenParamName[GenParamIndex] == 'end_x')</l>
<l>        XAxisEndValue := GenParamValue[GenParamIndex]</l>
<c>        * </c>
<c>        * Set 'start_y'</c>
<l>    elseif (GenParamName[GenParamIndex] == 'start_y')</l>
<l>        YAxisStartValue := GenParamValue[GenParamIndex]</l>
<c>        * </c>
<c>        * Set 'end_y'</c>
<l>    elseif (GenParamName[GenParamIndex] == 'end_y')</l>
<l>        YAxisEndValue := GenParamValue[GenParamIndex]</l>
<c>        * </c>
<c>        * Set 'axis_location_y' (old name 'origin_x')</c>
<l>    elseif (GenParamName[GenParamIndex] == 'axis_location_y' or GenParamName[GenParamIndex] == 'origin_x')</l>
<l>        YAxisPosition := GenParamValue[GenParamIndex]</l>
<c>        * </c>
<c>        * Set 'axis_location_x' (old name: 'origin_y')</c>
<l>    elseif (GenParamName[GenParamIndex] == 'axis_location_x' or GenParamName[GenParamIndex] == 'origin_y')</l>
<l>        XAxisPosition := GenParamValue[GenParamIndex]</l>
<c>        * </c>
<c>        * Set 'margin'</c>
<l>    elseif (GenParamName[GenParamIndex] == 'margin')</l>
<l>        LeftBorder := GenParamValue[GenParamIndex]</l>
<l>        RightBorder := GenParamValue[GenParamIndex]</l>
<l>        UpperBorder := GenParamValue[GenParamIndex]</l>
<l>        LowerBorder := GenParamValue[GenParamIndex]</l>
<c>        * </c>
<c>        * Set 'margin_left'</c>
<l>    elseif (GenParamName[GenParamIndex] == 'margin_left')</l>
<l>        LeftBorder := GenParamValue[GenParamIndex]</l>
<c>        * </c>
<c>        * Set 'margin_right'</c>
<l>    elseif (GenParamName[GenParamIndex] == 'margin_right')</l>
<l>        RightBorder := GenParamValue[GenParamIndex]</l>
<c>        * </c>
<c>        * Set 'margin_top'</c>
<l>    elseif (GenParamName[GenParamIndex] == 'margin_top')</l>
<l>        UpperBorder := GenParamValue[GenParamIndex]</l>
<c>        * </c>
<c>        * Set 'margin_bottom'</c>
<l>    elseif (GenParamName[GenParamIndex] == 'margin_bottom')</l>
<l>        LowerBorder := GenParamValue[GenParamIndex]</l>
<l>    elseif (GenParamName[GenParamIndex] == 'format_x')</l>
<l>        FormatX := GenParamValue[GenParamIndex]</l>
<l>    elseif (GenParamName[GenParamIndex] == 'format_y')</l>
<l>        FormatY := GenParamValue[GenParamIndex]</l>
<l>    else</l>
<l>        throw ('Unknown generic parameter: \'' + GenParamName[GenParamIndex] + '\'')</l>
<l>    endif</l>
<l>endfor</l>
<c>* </c>
<c>* Check consistency of start and end values</c>
<c>* of the axes.</c>
<l>if (XAxisStartValue &gt; XAxisEndValue)</l>
<l>    throw ('Value for \'start_x\' is greater than value for \'end_x\'')</l>
<l>endif</l>
<l>if (YAxisStartValue &gt; YAxisEndValue)</l>
<l>    throw ('Value for \'start_y\' is greater than value for \'end_y\'')</l>
<l>endif</l>
<c>* </c>
<c>* Set the position of the y-axis.</c>
<l>if (YAxisPosition == 'default')</l>
<l>    YAxisPosition := XAxisStartValue</l>
<l>endif</l>
<l>if (is_string(YAxisPosition) == 1)</l>
<l>    if (YAxisPosition == 'left')</l>
<l>        YAxisPosition := XAxisStartValue</l>
<l>    elseif (YAxisPosition == 'right')</l>
<l>        YAxisPosition := XAxisEndValue</l>
<l>    elseif (YAxisPosition == 'origin')</l>
<l>        YAxisPosition := 0</l>
<l>    else</l>
<l>        throw ('Unsupported axis_location_y: \'' + YAxisPosition + '\'')</l>
<l>    endif</l>
<l>endif</l>
<c>* Set the position of the ticks on the y-axis</c>
<c>* depending of the location of the y-axis.</c>
<l>if (mean([XAxisStartValue,XAxisEndValue]) &gt; YAxisPosition)</l>
<l>    YTickDirection := 'right'</l>
<l>else</l>
<l>    YTickDirection := 'left'</l>
<l>endif</l>
<c>* </c>
<c>* Set the position of the x-axis.</c>
<l>if (XAxisPosition == 'default')</l>
<l>    XAxisPosition := YAxisStartValue</l>
<l>endif</l>
<l>if (is_string(XAxisPosition) == 1)</l>
<l>    if (XAxisPosition == 'bottom')</l>
<l>        XAxisPosition := YAxisStartValue</l>
<l>    elseif (XAxisPosition == 'top')</l>
<l>        XAxisPosition := YAxisEndValue</l>
<l>    elseif (XAxisPosition == 'origin')</l>
<l>        XAxisPosition := 0</l>
<l>    else</l>
<l>        throw ('Unsupported axis_location_x: \'' + XAxisPosition + '\'')</l>
<l>    endif</l>
<l>endif</l>
<c>* Set the position of the ticks on the y-axis</c>
<c>* depending of the location of the y-axis.</c>
<l>if (mean([YAxisStartValue,YAxisEndValue]) &gt; XAxisPosition)</l>
<l>    XTickDirection := 'up'</l>
<l>else</l>
<l>    XTickDirection := 'down'</l>
<l>endif</l>
<c>* </c>
<c>* Calculate basic pixel coordinates and scale factors</c>
<c>* </c>
<l>XAxisWidthPx := Width - LeftBorder - RightBorder</l>
<l>XAxisWidth := XAxisEndValue - XAxisStartValue</l>
<l>if (XAxisWidth == 0)</l>
<l>    XAxisStartValue := XAxisStartValue - 0.5</l>
<l>    XAxisEndValue := XAxisEndValue + 0.5</l>
<l>    XAxisWidth := 1</l>
<l>endif</l>
<l>XScaleFactor := XAxisWidthPx / real(XAxisWidth)</l>
<l>YAxisHeightPx := Height - LowerBorder - UpperBorder</l>
<l>YAxisHeight := YAxisEndValue - YAxisStartValue</l>
<l>if (YAxisHeight == 0)</l>
<l>    YAxisStartValue := YAxisStartValue - 0.5</l>
<l>    YAxisEndValue := YAxisEndValue + 0.5</l>
<l>    YAxisHeight := 1</l>
<l>endif</l>
<l>YScaleFactor := YAxisHeightPx / real(YAxisHeight)</l>
<l>YAxisOffsetPx := (YAxisPosition - XAxisStartValue) * XScaleFactor</l>
<l>XAxisOffsetPx := (XAxisPosition - YAxisStartValue) * YScaleFactor</l>
<c>* </c>
<c>* Display grid lines</c>
<c>* </c>
<l>if (GridColor != 'none')</l>
<l>    DotStyle := [5,7]</l>
<l>    set_line_style (WindowHandle, DotStyle)</l>
<l>    dev_set_color (GridColor)</l>
<c>    * </c>
<c>    * Display x grid lines</c>
<l>    if (XGrid != 'none')</l>
<l>        if (XGrid == 'min_max_origin')</l>
<c>            * Calculate 'min_max_origin' grid line coordinates</c>
<l>            if (YAxisPosition == XAxisStartValue)</l>
<l>                XGridValues := [XAxisStartValue,XAxisEndValue]</l>
<l>            else</l>
<l>                XGridValues := [XAxisStartValue,YAxisPosition,XAxisEndValue]</l>
<l>            endif</l>
<l>        else</l>
<c>            * Calculate equidistant grid line coordinates</c>
<l>            XGridStart := ceil(XAxisStartValue / XGrid) * XGrid</l>
<l>            XGridValues := [XGridStart:XGrid:XAxisEndValue]</l>
<l>        endif</l>
<l>        XCoord := (XGridValues - XAxisStartValue) * XScaleFactor</l>
<c>        * Generate and display grid lines</c>
<l>        for IndexGrid := 0 to |XGridValues| - 1 by 1</l>
<l>            gen_contour_polygon_xld (ContourXGrid, [Height - LowerBorder,UpperBorder], [LeftBorder + XCoord[IndexGrid],LeftBorder + XCoord[IndexGrid]])</l>
<l>            dev_display (ContourXGrid)</l>
<l>        endfor</l>
<l>    endif</l>
<c>    * </c>
<c>    * Display y grid lines</c>
<l>    if (YGrid != 'none')</l>
<l>        if (YGrid == 'min_max_origin')</l>
<c>            * Calculate 'min_max_origin' grid line coordinates</c>
<l>            if (XAxisPosition == YAxisStartValue)</l>
<l>                YGridValues := [YAxisStartValue,YAxisEndValue]</l>
<l>            else</l>
<l>                YGridValues := [YAxisStartValue,XAxisPosition,YAxisEndValue]</l>
<l>            endif</l>
<l>        else</l>
<c>            * Calculate equidistant grid line coordinates</c>
<l>            YGridStart := ceil(YAxisStartValue / YGrid) * YGrid</l>
<l>            YGridValues := [YGridStart:YGrid:YAxisEndValue]</l>
<l>        endif</l>
<l>        YCoord := (YGridValues - YAxisStartValue) * YScaleFactor</l>
<c>        * Generate and display grid lines</c>
<l>        for IndexGrid := 0 to |YGridValues| - 1 by 1</l>
<l>            gen_contour_polygon_xld (ContourYGrid, [Height - LowerBorder - YCoord[IndexGrid],Height - LowerBorder - YCoord[IndexGrid]], [LeftBorder,Width - RightBorder])</l>
<l>            dev_display (ContourYGrid)</l>
<l>        endfor</l>
<l>    endif</l>
<l>endif</l>
<l>set_line_style (WindowHandle, [])</l>
<c>* </c>
<c>* </c>
<c>* Display the coordinate system axes</c>
<l>if (AxesColor != 'none')</l>
<c>    * Display axes</c>
<l>    dev_set_color (AxesColor)</l>
<l>    gen_arrow_contour_xld (XArrow, Height - LowerBorder - XAxisOffsetPx, LeftBorder, Height - LowerBorder - XAxisOffsetPx, Width - RightBorder, 0, 0)</l>
<l>    dev_display (XArrow)</l>
<l>    gen_arrow_contour_xld (YArrow, Height - LowerBorder, LeftBorder + YAxisOffsetPx, UpperBorder, LeftBorder + YAxisOffsetPx, 0, 0)</l>
<l>    dev_display (YArrow)</l>
<c>    * Display labels</c>
<l>    get_string_extents (WindowHandle, XLabel, Ascent, Descent, TextWidthXLabel, TextHeightXLabel)</l>
<l>    get_string_extents (WindowHandle, YLabel, Ascent, Descent, TextWidthYLabel, TextHeightYLabel)</l>
<l>    if (YTickDirection == 'right')</l>
<l>        if (XTickDirection == 'up')</l>
<l>            dev_disp_text (XLabel, 'image', Height - LowerBorder - TextHeightXLabel - 3, Width - RightBorder - TextWidthXLabel - 3, AxesColor, 'box', 'false')</l>
<l>            dev_disp_text (' ' + YLabel, 'image', UpperBorder, LeftBorder + 3 + YAxisOffsetPx, AxesColor, 'box', 'false')</l>
<l>        else</l>
<l>            dev_disp_text (XLabel, 'image', Height - LowerBorder + 3 - XAxisOffsetPx, Width - RightBorder - TextWidthXLabel - 3, AxesColor, 'box', 'false')</l>
<l>            dev_disp_text (' ' + YLabel, 'image', Height - LowerBorder - TextHeightXLabel - 3, LeftBorder + 3 + YAxisOffsetPx, AxesColor, 'box', 'false')</l>
<l>        endif</l>
<l>    else</l>
<l>        if (XTickDirection == 'up')</l>
<l>            dev_disp_text (XLabel, 'image', Height - LowerBorder - 2 * TextHeightXLabel + 3, LeftBorder - 3, AxesColor, 'box', 'false')</l>
<l>            dev_disp_text (' ' + YLabel, 'image', UpperBorder, Width - RightBorder - TextWidthYLabel - 13, AxesColor, 'box', 'false')</l>
<l>        else</l>
<l>            dev_disp_text (XLabel, 'image', Height - LowerBorder + 3 - XAxisOffsetPx, LeftBorder - 3, AxesColor, 'box', 'false')</l>
<l>            dev_disp_text (' ' + YLabel, 'image', Height - LowerBorder - TextHeightXLabel - 3, Width - RightBorder - 2 * TextWidthYLabel - 3, AxesColor, 'box', 'false')</l>
<l>        endif</l>
<l>    endif</l>
<l>endif</l>
<c>* </c>
<c>* Display ticks</c>
<c>* </c>
<l>if (AxesColor != 'none')</l>
<l>    dev_set_color (AxesColor)</l>
<l>    if (XTicks != 'none')</l>
<c>        * </c>
<c>        * Display x ticks</c>
<l>        if (XValuesAreStrings)</l>
<c>            * Display string XValues as categories</c>
<l>            XTicks := |XValues| / |XTickValues|</l>
<l>            XCoord := (XValues - XAxisStartValue) * XScaleFactor</l>
<l>        else</l>
<c>            * Display tick values</c>
<l>            if (XTicks == 'min_max_origin')</l>
<c>                * Calculate 'min_max_origin' tick coordinates</c>
<l>                if (YAxisPosition == XAxisStartValue)</l>
<l>                    XTickValues := [XAxisStartValue,XAxisEndValue]</l>
<l>                else</l>
<l>                    XTickValues := [XAxisStartValue,YAxisPosition,XAxisEndValue]</l>
<l>                endif</l>
<l>            else</l>
<c>                * Calculate equidistant tick coordinates</c>
<l>                XTickStart := ceil(XAxisStartValue / XTicks) * XTicks</l>
<l>                XTickValues := [XTickStart:XTicks:XAxisEndValue]</l>
<l>            endif</l>
<c>            * Remove ticks that are smaller than the x-axis start.</c>
<l>            Indices := find(XTickValues [&lt;] XAxisStartValue,1)</l>
<l>            XCoord := (XTickValues - XAxisStartValue) * XScaleFactor</l>
<l>            XCoord := remove(XCoord,Indices)</l>
<l>            XTickValues := remove(XTickValues,Indices)</l>
<c>            * </c>
<l>            if (FormatX == 'default')</l>
<l>                TypeTicks := type(XTicks)</l>
<l>                if (TypeTicks == H_TYPE_STRING)</l>
<c>                    * String ('min_max_origin')</c>
<c>                    * Format depends on actual values</c>
<l>                    TypeTicks := type(XTickValues)</l>
<l>                endif</l>
<l>                if (TypeTicks == H_TYPE_INT)</l>
<c>                    * Round to integer</c>
<l>                    XTickValues := int(XTickValues)</l>
<l>                else</l>
<c>                    * Use floating point numbers</c>
<l>                    XTickValues := XTickValues$'.2f'</l>
<l>                endif</l>
<l>            else</l>
<l>                XTickValues := XTickValues$FormatX</l>
<l>            endif</l>
<l>        endif</l>
<c>        * Generate and display ticks</c>
<l>        for IndexTicks := 0 to |XTickValues| - 1 by 1</l>
<l>            get_string_extents (WindowHandle, XTickValues[IndexTicks], Ascent1, Descent1, TextWidthXTicks, TextHeightXTicks)</l>
<l>            if (XTickDirection == 'up')</l>
<l>                gen_contour_polygon_xld (ContourXTick, [Height - LowerBorder - XAxisOffsetPx,Height - LowerBorder - XAxisOffsetPx - 5], [LeftBorder + XCoord[IndexTicks],LeftBorder + XCoord[IndexTicks]])</l>
<l>                dev_disp_text (XTickValues[IndexTicks], 'image', Height - LowerBorder + 2 - XAxisOffsetPx, LeftBorder + XCoord[IndexTicks], AxesColor, 'box', 'false')</l>
<l>            else</l>
<l>                gen_contour_polygon_xld (ContourXTick, [Height - LowerBorder - XAxisOffsetPx + 5,Height - LowerBorder - XAxisOffsetPx], [LeftBorder + XCoord[IndexTicks],LeftBorder + XCoord[IndexTicks]])</l>
<l>                dev_disp_text (XTickValues[IndexTicks], 'image', Height - LowerBorder - 2 * TextHeightXTicks - XAxisOffsetPx, LeftBorder + XCoord[IndexTicks], AxesColor, 'box', 'false')</l>
<l>            endif</l>
<l>            dev_display (ContourXTick)</l>
<l>        endfor</l>
<l>    endif</l>
<c>    * </c>
<l>    if (YTicks != 'none')</l>
<c>        * </c>
<c>        * Display y ticks</c>
<l>        if (YTicks == 'min_max_origin')</l>
<c>            * Calculate 'min_max_origin' tick coordinates</c>
<l>            if (XAxisPosition == YAxisStartValue)</l>
<l>                YTickValues := [YAxisStartValue,YAxisEndValue]</l>
<l>            else</l>
<l>                YTickValues := [YAxisStartValue,XAxisPosition,YAxisEndValue]</l>
<l>            endif</l>
<l>        else</l>
<c>            * Calculate equidistant tick coordinates</c>
<l>            YTickStart := ceil(YAxisStartValue / YTicks) * YTicks</l>
<l>            YTickValues := [YTickStart:YTicks:YAxisEndValue]</l>
<l>        endif</l>
<c>        * Remove ticks that are smaller than the y-axis start.</c>
<l>        Indices := find(YTickValues [&lt;] YAxisStartValue,1)</l>
<l>        YCoord := (YTickValues - YAxisStartValue) * YScaleFactor</l>
<l>        YCoord := remove(YCoord,Indices)</l>
<l>        YTickValues := remove(YTickValues,Indices)</l>
<c>        * </c>
<l>        if (FormatY == 'default')</l>
<l>            TypeTicks := type(YTicks)</l>
<l>            if (TypeTicks == H_TYPE_STRING)</l>
<c>                * String ('min_max_origin')</c>
<c>                * Format depends on actual values</c>
<l>                TypeTicks := type(YTickValues)</l>
<l>            endif</l>
<l>            if (TypeTicks == H_TYPE_INT)</l>
<c>                * Round to integer</c>
<l>                YTickValues := int(YTickValues)</l>
<l>            else</l>
<c>                * Use floating point numbers</c>
<l>                YTickValues := YTickValues$'.2f'</l>
<l>            endif</l>
<l>        else</l>
<l>            YTickValues := YTickValues$FormatY</l>
<l>        endif</l>
<c>        * Generate and display ticks</c>
<l>        for IndexTicks := 0 to |YTickValues| - 1 by 1</l>
<l>            get_string_extents (WindowHandle, YTickValues[IndexTicks], Ascent1, Descent1, TextWidthYTicks, TextHeightYTicks)</l>
<l>            if (YTickDirection == 'right')</l>
<l>                gen_contour_polygon_xld (ContourYTick, [Height - LowerBorder - YCoord[IndexTicks],Height - LowerBorder - YCoord[IndexTicks]], [LeftBorder + YAxisOffsetPx,LeftBorder + YAxisOffsetPx + 5])</l>
<l>                dev_disp_text (YTickValues[IndexTicks], 'image', Height - LowerBorder - TextHeightYTicks + 3 - YCoord[IndexTicks], LeftBorder - TextWidthYTicks - 2 + YAxisOffsetPx, AxesColor, 'box', 'false')</l>
<l>            else</l>
<l>                gen_contour_polygon_xld (ContourYTick, [Height - LowerBorder - YCoord[IndexTicks],Height - LowerBorder - YCoord[IndexTicks]], [LeftBorder + YAxisOffsetPx - 5,LeftBorder + YAxisOffsetPx])</l>
<l>                dev_disp_text (YTickValues[IndexTicks], 'image', Height - LowerBorder - TextHeightYTicks + 3 - YCoord[IndexTicks], LeftBorder + 2 + YAxisOffsetPx, AxesColor, 'box', 'false')</l>
<l>            endif</l>
<l>            dev_display (ContourYTick)</l>
<l>        endfor</l>
<l>    endif</l>
<l>endif</l>
<c>* </c>
<c>* Display function plot</c>
<c>* </c>
<l>if (Color != 'none')</l>
<l>    if (XValues != [] and YValues != [])</l>
<l>        Num := |YValues| / |XValues|</l>
<c>        * </c>
<c>        * Iterate over all functions to be displayed</c>
<l>        for I := 0 to Num - 1 by 1</l>
<c>            * Select y values for current function</c>
<l>            YSelected := YValues[I * |XValues|:(I + 1) * |XValues| - 1]</l>
<c>            * Set color</c>
<l>            if (Color == [])</l>
<l>                set_rgb (WindowHandle, Red, Green, Blue)</l>
<l>            else</l>
<l>                dev_set_color (Color[I % |Color|])</l>
<l>            endif</l>
<c>            * </c>
<c>            * Display in different styles</c>
<c>            * </c>
<l>            if (Style == 'line' or Style == [])</l>
<c>                * Line</c>
<l>                gen_contour_polygon_xld (Contour, Height - LowerBorder - YSelected * YScaleFactor + YAxisStartValue * YScaleFactor, XValues * XScaleFactor + LeftBorder - XAxisStartValue * XScaleFactor)</l>
<c>                * Clip, if necessary</c>
<l>                if (Clip == 'yes')</l>
<l>                    clip_contours_xld (Contour, Contour, UpperBorder, LeftBorder, Height - LowerBorder, Width - RightBorder)</l>
<l>                endif</l>
<l>                dev_display (Contour)</l>
<l>            elseif (Style == 'cross')</l>
<c>                * Cross</c>
<l>                gen_cross_contour_xld (Cross, Height - LowerBorder - YSelected * YScaleFactor + YAxisStartValue * YScaleFactor, XValues * XScaleFactor + LeftBorder - XAxisStartValue * XScaleFactor, 6, 0.785398)</l>
<c>                * Clip, if necessary</c>
<l>                if (Clip == 'yes')</l>
<l>                    clip_contours_xld (Cross, Cross, UpperBorder, LeftBorder, Height - LowerBorder, Width - RightBorder)</l>
<l>                endif</l>
<l>                dev_display (Cross)</l>
<l>            elseif (Style == 'filled')</l>
<c>                * Filled</c>
<l>                Y1Selected := [0 + XAxisPosition,YSelected,0 + XAxisPosition]</l>
<l>                X1Selected := [min(XValues),XValues,max(XValues)]</l>
<l>                dev_set_draw ('fill')</l>
<l>                gen_region_polygon_filled (Filled, Height - LowerBorder - Y1Selected * YScaleFactor + YAxisStartValue * YScaleFactor, X1Selected * XScaleFactor + LeftBorder - XAxisStartValue * XScaleFactor)</l>
<c>                * Clip, if necessary</c>
<l>                if (Clip == 'yes')</l>
<l>                    clip_region (Filled, Filled, UpperBorder, LeftBorder, Height - LowerBorder, Width - RightBorder)</l>
<l>                endif</l>
<l>                dev_display (Filled)</l>
<l>            elseif (Style == 'step')</l>
<l>                gen_empty_obj (Stair)</l>
<l>                for Index := 0 to |XValues| - 2 by 1</l>
<l>                    Row1 := Height - LowerBorder - YSelected[Index] * YScaleFactor + YAxisStartValue * YScaleFactor</l>
<l>                    Row2 := Height - LowerBorder - YSelected[Index + 1] * YScaleFactor + YAxisStartValue * YScaleFactor</l>
<l>                    Col1 := XValues[Index] * XScaleFactor + LeftBorder - XAxisStartValue * XScaleFactor</l>
<l>                    Col2 := XValues[Index + 1] * XScaleFactor + LeftBorder - XAxisStartValue * XScaleFactor</l>
<l>                    gen_contour_polygon_xld (StairTmp, [Row1,Row1,Row2], [Col1,Col2,Col2])</l>
<l>                    concat_obj (Stair, StairTmp, Stair)</l>
<l>                endfor</l>
<l>                union_adjacent_contours_xld (Stair, Stair, 0.1, 0.1, 'attr_keep')</l>
<l>                if (Clip == 'yes')</l>
<l>                    clip_region (Stair, Stair, UpperBorder, LeftBorder, Height - LowerBorder, Width - RightBorder)</l>
<l>                endif</l>
<l>                dev_display (Stair)</l>
<l>            else</l>
<l>                throw ('Unsupported style: ' + Style)</l>
<l>            endif</l>
<l>        endfor</l>
<l>    endif</l>
<l>endif</l>
<c>* </c>
<c>* </c>
<c>* Reset original display settings</c>
<l>dev_set_part (PartRow1, PartColumn1, PartRow2, PartColumn2)</l>
<l>dev_set_window (PreviousWindowHandle)</l>
<l>set_rgb (WindowHandle, Red, Green, Blue)</l>
<l>dev_set_draw (DrawMode)</l>
<l>set_line_style (WindowHandle, OriginStyle)</l>
<l>set_system ('clip_region', ClipRegion)</l>
<l>return ()</l>
</body>
<docu id="plot_tuple">
<abstract lang="en_US">This procedure plots the functions or curves represented by the coordinates in XValues and YValues into the graphic window given in WindowHandle.
The axes of the coordinate system are labeled with XLabel and YLabel.
The appearance of the output can further be adapted using generic parameters given in GenericParamName and GenericParamValue.

In particular, following parameters can be set:

XValues: X values of the function to be plotted.

          If XValues is set to [], it is internally set to 0,1,2,...,|YValues|-1.
          If XValues is a tuple of strings, the values are taken as categories.

 YValues: Y values of the function(s) to be plotted.

          If YValues is set to [], it is internally set to 0,1,2,...,|XValues|-1.
          The number of y values must be equal to the number of x values
          or an integral multiple. In the latter case,
          multiple functions are plotted, that share the same x values.

 XLabel: X-axis label.

 XLabel: Y-axis label.

 Color: Color of the plotted function.

        If [] is given, the currently set display color is used.
        If 'none' is given, the function is not plotted, but only
        the coordinate axes as specified.
        If more than one color is given, multiple functions 
        can be displayed in different colors.

 GenParamName: Generic parameters to control the presentation.

                Possible Values:

    'axes_color': coordinate system color.
                  Default: 'white'
                  If 'none' is given, no coordinate system is shown. 

    'style': Graph style.
             Possible values: 'line' (default), 'cross', 'step', 'filled'

    'clip': Clip graph to coordinate system area.
            Possible values: 'no' (default), 'yes''

    'ticks': Control display of ticks on the axes.
             If 'min_max_origin' is given (default), ticks are shown 
             at the minimum and maximum values of the axes and at the
             intercept point of x- and y-axis.
             If 'none' is given, no ticks are shown.
             If any number != 0 is given, it is interpreted as distance
             between the ticks.

    'ticks_x': Control display of ticks on x-axis only.

    'ticks_y': Control display of ticks on x-axis only.

    'format_x': Format of the values next to the ticks of the x-axis 
                (see tuple_string for more details).

    'format_y': Format of the values next to the ticks of the y-axis
                (see tuple_string for more details).

    'grid': Control display of grid lines within the coordinate system.
            If 'min_max_origin' is given (default), grid lines are shown 
            at the minimum and maximum values of the axes.
            If 'none' is given, no grid lines are shown.
            If any number != 0 is given, it is interpreted as distance
            between the grid lines.

    'grid_x': Control display of grid lines for the x-axis only.

    'grid_y': Control display of grid lines for the y-axis only.

    'grid_color': Color of the grid (default: 'dim gray').

    'margin': The distance in pixels of the coordinate system area
              to all four window borders.

    'margin_left': The distance in pixels of the coordinate system area
                   to the left window border.

    'margin_right': The distance in pixels of the coordinate system area
                    to the right window border.

    'margin_top': The distance in pixels of the coordinate system area
                    to the upper window border.

    'margin_bottom'': The distance in pixels of the coordinate system area
                    to the lower window border.

    'start_x': Lowest x value of the x-axis.
               Default: min(XValues)

    'end_x': Highest x value of the x-axis.
             Default: max(XValues)

    'start_y': Lowest y value of the y-axis.
               Default: min(YValues)

    'end_y': Highest y value of the y-axis.
             Default: max(YValues)

    'axis_location_x': Either 'bottom', 'origin', or 'top' to position the x-axis conveniently, or the Y coordinate of the intercept point of x- and y-axis.
                Default: 'bottom'
                (Used to be called 'origin_y')

    'axis_location_y': Either 'left', 'origin', or 'right' to position the y-axis conveniently, or the X coordinate of the intercept point of x- and y-axis.
                Default: 'left'
                (Used to be called 'origin_x')

 GenParamValue: Values of the generic parameters of GenericParamName.</abstract>
<chapters lang="de_DE">
<item>Graphik</item>
<item>Ausgabe</item>
</chapters>
<chapters lang="en_US">
<item>Graphics</item>
<item>Output</item>
</chapters>
<example lang="en_US">dev_open_window (0, 0, 512, 512, 'black', WindowHandle)
X := [-rad(180): 0.01: rad(180)]
Y1 := sin(X)
Y2 := (X * X) * 0.2 - 1
XLabel := 'x'
YLabel := 'y'
Color := ['medium slate blue', 'yellow']
GenParamName := []
GenParamValue := []
plot_tuple (WindowHandle, X, [Y1, Y2], XLabel, YLabel, Color, GenParamName, GenParamValue)
</example>
<keywords lang="en_US">
<item>plot</item>
<item>tuple</item>
<item>function</item>
<item>display</item>
<item>graph</item>
<item>curve</item>
</keywords>
<library lang="en_US">MVTec Standard Procedures</library>
<predecessor>
<item>funct_1d_to_pairs</item>
</predecessor>
<short lang="en_US"> This procedure plots tuples representing functions or curves in a coordinate system.</short>
<parameters>
<parameter id="Color">
<default_type>string</default_type>
<default_value>[]</default_value>
<description lang="en_US">Color of the function plot.</description>
<multivalue>optional</multivalue>
<sem_type>color</sem_type>
<type_list>
<item>string</item>
</type_list>
<values>
<item>'red'</item>
<item>'green'</item>
<item>'yellow'</item>
<item>'white'</item>
<item>'black'</item>
<item>'cyan'</item>
<item>'magenta'</item>
<item>'blue'</item>
<item>'orange'</item>
</values>
</parameter>
<parameter id="GenParamName">
<default_type>string</default_type>
<default_value>[]</default_value>
<description lang="en_US">Names of generic parameters.</description>
<mixed_type>false</mixed_type>
<multivalue>optional</multivalue>
<sem_type>string</sem_type>
<type_list>
<item>string</item>
</type_list>
<values>
<item>'axes_color'</item>
<item>'style'</item>
<item>'clip'</item>
<item>'ticks'</item>
<item>'ticks_x'</item>
<item>'ticks_y'</item>
<item>'grid'</item>
<item>'grid_x'</item>
<item>'grid_y'</item>
<item>'grid_color'</item>
<item>'margin'</item>
<item>'margin_left'</item>
<item>'margin_right'</item>
<item>'margin_top'</item>
<item>'margin_bottom'</item>
<item>'start_x'</item>
<item>'end_x'</item>
<item>'start_y'</item>
<item>'end_y'</item>
<item>'origin_y'</item>
<item>'origin_x'</item>
<item>'position_y'</item>
</values>
</parameter>
<parameter id="GenParamValue">
<default_type>string</default_type>
<default_value>[]</default_value>
<description lang="en_US">Generic parameter values.</description>
<mixed_type>optional</mixed_type>
<multivalue>optional</multivalue>
<sem_type>any</sem_type>
<type_list>
<item>string</item>
</type_list>
</parameter>
<parameter id="WindowHandle">
<default_type>integer</default_type>
<description lang="en_US">Window handle in which the plot should be displayed.</description>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>window</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="XLabel">
<default_value>[]</default_value>
<description lang="en_US">Label of the x-axis.</description>
</parameter>
<parameter id="XValues">
<default_type>real</default_type>
<default_value>[]</default_value>
<description lang="en_US">X values of the function to be plotted.</description>
<multivalue>optional</multivalue>
<sem_type>coordinates.x</sem_type>
<type_list>
<item>real</item>
</type_list>
</parameter>
<parameter id="YLabel">
<default_value>[]</default_value>
<description lang="en_US">Label of the y-axis.</description>
</parameter>
<parameter id="YValues">
<default_type>real</default_type>
<description lang="en_US">Y values of the function to be plotted.</description>
<multivalue>optional</multivalue>
<sem_type>coordinates.y</sem_type>
<type_list>
<item>real</item>
</type_list>
</parameter>
</parameters>
</docu>
</procedure>
<procedure name="plot_tuple_no_window_handling" access="local">
<interface>
<ic>
<par name="WindowHandle" base_type="ctrl" dimension="0"/>
<par name="XValues" base_type="ctrl" dimension="0"/>
<par name="YValues" base_type="ctrl" dimension="0"/>
<par name="XLabel" base_type="ctrl" dimension="0"/>
<par name="YLabel" base_type="ctrl" dimension="0"/>
<par name="Color" base_type="ctrl" dimension="0"/>
<par name="GenParamName" base_type="ctrl" dimension="0"/>
<par name="GenParamValue" base_type="ctrl" dimension="0"/>
</ic>
</interface>
<body>
<c>* </c>
<c>* This procedure plots tuples representing functions</c>
<c>* or curves in a coordinate system.</c>
<c></c>
<c>* In the following, the possible values are listed for the parameters:</c>
<c>* </c>
<c>* - XValues: X values of the function to be plotted. Thereby you have the following options:</c>
<c>*   -- []: XValues are internally set to 0,1,2,...,|YValues|-1.</c>
<c>*   -- a tuple of strings: These values are taken as categories.</c>
<c>* </c>
<c>* - YValues: Y values of the function(s) to be plotted. Thereby you have the following options:</c>
<c>*   -- []: YValues are internally set to 0,1,2,...,|XValues|-1.</c>
<c>*   -- a tuple of values: The number of y values must be equal to the number of x values or an integral multiple.</c>
<c>*      In the latter case, multiple functions are plotted, that share the same x values.</c>
<c>* </c>
<c>* - XLabel: X-axis label.</c>
<c>* </c>
<c>* - YLabel: Y-axis label.</c>
<c>* </c>
<c>* - Color: Color of the plotted function. Thereby you have the following options:</c>
<c>*   -- []: The currently set display color is used.</c>
<c>*   -- 'none': The function is not plotted, but only the coordinate axes as specified.</c>
<c>*   -- string: Defining the color of the plotted function.</c>
<c>*   -- tuple of strings: -nultiple functions can be displayed in different colors.</c>
<c>* </c>
<c>* - GenParamName: Generic parameter names to control the presentation.</c>
<c>*  The corresponding values are taken from GenParamValue. Possible Values string/value pairs:</c>
<c>*   -- 'axes_color': Color of the coordinate axes. The default value is 'white'.</c>
<c>*      If 'none' is given, no coordinate axes are shown.</c>
<c>*   -- 'style': Graph style. Possible values:</c>
<c>*      --- 'line' (default)</c>
<c>*      --- 'cross'</c>
<c>*      --- 'circle'</c>
<c>*      --- 'step'</c>
<c>*      --- 'filled'</c>
<c>*   -- 'clip': Clip graph to coordinate system area. Possible values:</c>
<c>*      --- 'no' (default)</c>
<c>*      --- 'yes''</c>
<c>*   -- 'ticks': Control display of ticks on the axes. Thereby you have the following options:</c>
<c>*      --- 'min_max_origin' (default): Ticks are shown at the minimum and maximum values</c>
<c>*          of the axes and at the intercept point of x- and y-axis.</c>
<c>*      --- 'none': No ticks are shown.</c>
<c>*      --- any number != 0: This number specifies the distance between the ticks.</c>
<c>*   -- 'ticks_x': Control display of ticks on x-axis only. You have the same options as for 'ticks'.</c>
<c>*   -- 'ticks_y': Control display of ticks on y-axis only. You have the same options as for 'ticks'.</c>
<c>*   -- 'format_x': Format of the values next to the ticks of the x-axis (see tuple_string for more details).</c>
<c>*   -- 'format_y': Format of the values next to the ticks of the y-axis (see tuple_string for more details).</c>
<c>*   -- 'grid': Control display of grid lines within the coordinate system.</c>
<c>*      Thereby you have the following options:</c>
<c>*     --- 'min_max_origin' (default): Grid lines are shown at the minimum and maximum values of the axes.</c>
<c>*     --- 'none': No grid lines are shown.</c>
<c>*     --- If any number != 0: This number specifies the distance between the grid lines.</c>
<c>*   -- 'grid_x': Control display of grid lines for the x-axis only.</c>
<c>*   -- 'grid_y': Control display of grid lines for the y-axis only.</c>
<c>*   -- 'grid_color': Color of the grid (default: 'dim gray').</c>
<c>*   -- 'margin': The distance in pixels of the plot area to all four window borders.</c>
<c>*   -- 'margin_left': The distance in pixels of the plot area to the left window border.</c>
<c>*   -- 'margin_right': The distance in pixels of the plot area to the right window border.</c>
<c>*   -- 'margin_top': The distance in pixels of the plot area to the upper window border.</c>
<c>*   -- 'margin_bottom'': The distance in pixels of the plot area to the lower window border.</c>
<c>*   -- 'start_x': Lowest x value of the x-axis. The default value is min(XValues).</c>
<c>*   -- 'end_x': Highest x value of the x-axis. The default value is max(XValues).</c>
<c>*   -- 'start_y': Lowest y value of the y-axis. The default value is min(YValues).</c>
<c>*   -- 'end_y': Highest y value of the y-axis. The default value is max(YValues).</c>
<c>*   -- 'axis_location_x': Position of the x-axis (Used to be called 'origin_y').</c>
<c>*      Thereby you have the following options:</c>
<c>*      --- 'bottom' (default)</c>
<c>*      --- 'origin'</c>
<c>*      --- 'top'</c>
<c>*      --- Y coordinate of the intercept point of x- and y-axis.</c>
<c>*   -- 'axis_location_y': Position of the y-axis (Used to be called 'origin_x').</c>
<c>*      Thereby you have the following options:</c>
<c>*      --- 'left' (default)</c>
<c>*      --- 'right'</c>
<c>*      --- 'origin'</c>
<c>*      --- X coordinate of the intercept point of x- and y-axis.</c>
<c>*   -- 'line_width': Line width of the plot.</c>
<c>*   -- 'log_y': If 'true', plot the YValue in logarithmic scale. Default is 'false'.</c>
<c>* </c>
<c>* </c>
<l>get_system ('clip_region', ClipRegion)</l>
<l>get_window_extents (WindowHandle, Row, Column, Width, Height)</l>
<l>get_part (WindowHandle, PartRow1, PartColumn1, PartRow2, PartColumn2)</l>
<l>Width := PartColumn2 - PartColumn1 + 1</l>
<l>Height := PartRow2 - PartRow1 + 1</l>
<l>get_rgb (WindowHandle, Red, Green, Blue)</l>
<l>get_draw (WindowHandle, DrawMode)</l>
<l>get_line_style (WindowHandle, OriginStyle)</l>
<c>* </c>
<c>* Set the display parameters.</c>
<l>set_line_style (WindowHandle, [])</l>
<l>set_system ('clip_region', 'false')</l>
<c></c>
<l>PartDiffers := 0 != PartRow1 or 0 != Column or Width - 1 != PartColumn2 or Height - 1 != PartRow2</l>
<c>* Only use set part if it differs.</c>
<l>if (PartDiffers)</l>
<l>    dev_set_part (0, 0, Height - 1, Width - 1)</l>
<l>endif</l>
<c>* </c>
<c>* Check if we need to plot y-values logarithmically.</c>
<c>* It is checked here because we want to convert the YValues tuple</c>
<c>* immediately so that derived values will be correct.</c>
<l>PlotYLog := false</l>
<l>if (|GenParamName| &gt; 0 and |GenParamName| == |GenParamValue|)</l>
<l>    tuple_find (GenParamName, 'log_y', YLogIndices)</l>
<l>    if (YLogIndices &gt;= 0)</l>
<l>        PlotYLogUser := GenParamValue[YLogIndices[0]]</l>
<l>        tuple_is_string (PlotYLogUser, IsString)</l>
<l>        if (IsString)</l>
<l>            if (PlotYLogUser == 'true')</l>
<l>                PlotYLog := true</l>
<l>            elseif (PlotYLogUser == 'false')</l>
<l>                PlotYLog := false</l>
<l>            else</l>
<l>                throw ('Unknown generic param value: \'' + PlotYLogUser + '\' for value: \'log_y\'')</l>
<l>            endif</l>
<l>            PlotYLog := PlotYLogUser == 'true'</l>
<l>        else</l>
<l>            PlotYLog := PlotYLogUser == true</l>
<l>        endif</l>
<l>    endif</l>
<l>endif</l>
<l>if (PlotYLog)</l>
<c>    * Clamp values to be &gt;= 0.00001.</c>
<l>    YInd := YValues [&lt;=] 0</l>
<l>    tuple_find (YInd, 1, Indices1)</l>
<l>    if (Indices1 &gt;= 0)</l>
<l>        YValues[Indices1] := 0.00001</l>
<l>    endif</l>
<l>    YValues := log10(YValues)</l>
<l>endif</l>
<c>* </c>
<c>* Check input coordinate values.</c>
<c>* </c>
<l>if (XValues == [] and YValues == [])</l>
<c>    * Neither XValues nor YValues are given:</c>
<c>    * Set axes to interval [0,1]</c>
<l>    XAxisEndValue := 1</l>
<l>    YAxisEndValue := 1</l>
<l>    XAxisStartValue := 0</l>
<l>    YAxisStartValue := 0</l>
<l>    XValuesAreStrings := false</l>
<l>else</l>
<l>    if (XValues == [])</l>
<c>        * XValues are omitted: Set equidistant XValues.</c>
<l>        XValues := [0:|YValues| - 1]</l>
<l>        XValuesAreStrings := false</l>
<l>    elseif (YValues == [])</l>
<c>        * YValues are omitted: Set equidistant YValues.</c>
<l>        YValues := [0:|XValues| - 1]</l>
<l>    endif</l>
<l>    if (|YValues| % |XValues| != 0)</l>
<c>        * Number of YValues does not match number of XValues.</c>
<l>        throw ('Number of YValues is no multiple of the number of XValues.')</l>
<l>        return ()</l>
<l>    endif</l>
<c></c>
<l>    XValuesAreStrings := is_string_elem(XValues)</l>
<l>    XValuesAreStrings := sum(XValuesAreStrings) == |XValuesAreStrings|</l>
<l>    if (XValuesAreStrings)</l>
<c>        * XValues are given as strings: Show XValues as ticks.</c>
<l>        XTickValues := XValues</l>
<l>        XTicks := 1</l>
<c>        * Set x-axis dimensions.</c>
<l>        XValues := [1:|XValues|]</l>
<l>    endif</l>
<c>    * Set default x-axis dimensions.</c>
<l>    if (|XValues| &gt; 1)</l>
<l>        XAxisStartValue := min(XValues)</l>
<l>        XAxisEndValue := max(XValues)</l>
<l>    else</l>
<l>        XAxisEndValue := XValues[0] + 0.5</l>
<l>        XAxisStartValue := XValues[0] - 0.5</l>
<l>    endif</l>
<l>endif</l>
<c>* Set default y-axis dimensions.</c>
<l>if (|YValues| &gt; 1)</l>
<l>    YAxisStartValue := min(YValues)</l>
<l>    YAxisEndValue := max(YValues)</l>
<l>elseif (|YValues| == 1)</l>
<l>    YAxisStartValue := YValues[0] - 0.5</l>
<l>    YAxisEndValue := YValues[0] + 0.5</l>
<l>else</l>
<l>    YAxisStartValue := 0</l>
<l>    YAxisEndValue := 1</l>
<l>endif</l>
<c>* Set default interception point of x- and y- axis.</c>
<l>YAxisPosition := 'default'</l>
<l>XAxisPosition := 'default'</l>
<c>* </c>
<c>* Set further default values:</c>
<l>LeftBorder := Width * 0.1</l>
<l>RightBorder := Width * 0.1</l>
<l>UpperBorder := Height * 0.1</l>
<l>LowerBorder := Height * 0.1</l>
<l>AxesColor := 'white'</l>
<l>Style := 'line'</l>
<l>Clip := 'no'</l>
<l>XTicks := 'min_max_origin'</l>
<l>YTicks := 'min_max_origin'</l>
<l>XGrid := 'none'</l>
<l>YGrid := 'none'</l>
<l>GridColor := 'dim gray'</l>
<l>YPosition := 'left'</l>
<l>FormatX := 'default'</l>
<l>FormatY := 'default'</l>
<l>LineWidth := 1</l>
<c>* </c>
<c>* Parse generic parameters.</c>
<c>* </c>
<l>NumGenParamNames := |GenParamName|</l>
<l>NumGenParamValues := |GenParamValue|</l>
<l>if (NumGenParamNames != NumGenParamValues)</l>
<l>    throw ('Number of generic parameter names does not match generic parameter values.')</l>
<l>    return ()</l>
<l>endif</l>
<c>* </c>
<l>for GenParamIndex := 0 to |GenParamName| - 1 by 1</l>
<c>    * </c>
<c>    * Set 'axes_color'.</c>
<l>    if (GenParamName[GenParamIndex] == 'axes_color')</l>
<l>        AxesColor := GenParamValue[GenParamIndex]</l>
<c>        * </c>
<c>        * Set 'style'.</c>
<l>    elseif (GenParamName[GenParamIndex] == 'style')</l>
<l>        Style := GenParamValue[GenParamIndex]</l>
<c>        * </c>
<c>        * Set 'clip'.</c>
<l>    elseif (GenParamName[GenParamIndex] == 'clip')</l>
<l>        Clip := GenParamValue[GenParamIndex]</l>
<l>        if (Clip != 'yes' and Clip != 'no')</l>
<l>            throw ('Unsupported clipping option: \'' + Clip + '\'')</l>
<l>        endif</l>
<c>        * </c>
<c>        * Set 'ticks'.</c>
<l>    elseif (GenParamName[GenParamIndex] == 'ticks')</l>
<l>        XTicks := GenParamValue[GenParamIndex]</l>
<l>        YTicks := GenParamValue[GenParamIndex]</l>
<c>        * </c>
<c>        * Set 'ticks_x'.</c>
<l>    elseif (GenParamName[GenParamIndex] == 'ticks_x')</l>
<l>        XTicks := GenParamValue[GenParamIndex]</l>
<c>        * </c>
<c>        * Set 'ticks_y'.</c>
<l>    elseif (GenParamName[GenParamIndex] == 'ticks_y')</l>
<l>        YTicks := GenParamValue[GenParamIndex]</l>
<c>        * </c>
<c>        * Set 'grid'.</c>
<l>    elseif (GenParamName[GenParamIndex] == 'grid')</l>
<l>        XGrid := GenParamValue[GenParamIndex]</l>
<l>        YGrid := GenParamValue[GenParamIndex]</l>
<l>        XGridTicks := XTicks</l>
<c>        * </c>
<c>        * Set 'grid_x'</c>
<l>    elseif (GenParamName[GenParamIndex] == 'grid_x')</l>
<l>        XGrid := GenParamValue[GenParamIndex]</l>
<c>        * </c>
<c>        * Set 'grid_y'.</c>
<l>    elseif (GenParamName[GenParamIndex] == 'grid_y')</l>
<l>        YGrid := GenParamValue[GenParamIndex]</l>
<c>        * </c>
<c>        * Set 'grid_color'.</c>
<l>    elseif (GenParamName[GenParamIndex] == 'grid_color')</l>
<l>        GridColor := GenParamValue[GenParamIndex]</l>
<c>        * </c>
<c>        * Set 'start_x'.</c>
<l>    elseif (GenParamName[GenParamIndex] == 'start_x')</l>
<l>        XAxisStartValue := GenParamValue[GenParamIndex]</l>
<c>        * </c>
<c>        * Set 'end_x'.</c>
<l>    elseif (GenParamName[GenParamIndex] == 'end_x')</l>
<l>        XAxisEndValue := GenParamValue[GenParamIndex]</l>
<c>        * </c>
<c>        * Set 'start_y'.</c>
<l>    elseif (GenParamName[GenParamIndex] == 'start_y')</l>
<l>        YAxisStartValue := GenParamValue[GenParamIndex]</l>
<l>        if (PlotYLog)</l>
<l>            YAxisStartValue := log10(max2(0.00000001,YAxisStartValue))</l>
<l>        endif</l>
<c>        * </c>
<c>        * Set 'end_y'.</c>
<l>    elseif (GenParamName[GenParamIndex] == 'end_y')</l>
<l>        YAxisEndValue := GenParamValue[GenParamIndex]</l>
<l>        if (PlotYLog)</l>
<l>            YAxisEndValue := log10(max2(0.00000001,YAxisEndValue))</l>
<l>        endif</l>
<c>        * </c>
<c>        * Set 'axis_location_y' (old name 'origin_x').</c>
<l>    elseif (GenParamName[GenParamIndex] == 'axis_location_y' or GenParamName[GenParamIndex] == 'origin_x')</l>
<l>        YAxisPosition := GenParamValue[GenParamIndex]</l>
<c>        * </c>
<c>        * Set 'axis_location_x' (old name: 'origin_y').</c>
<l>    elseif (GenParamName[GenParamIndex] == 'axis_location_x' or GenParamName[GenParamIndex] == 'origin_y')</l>
<l>        XAxisPosition := GenParamValue[GenParamIndex]</l>
<c>        * </c>
<c>        * Set 'margin'.</c>
<l>    elseif (GenParamName[GenParamIndex] == 'margin')</l>
<l>        LeftBorder := GenParamValue[GenParamIndex]</l>
<l>        RightBorder := GenParamValue[GenParamIndex]</l>
<l>        UpperBorder := GenParamValue[GenParamIndex]</l>
<l>        LowerBorder := GenParamValue[GenParamIndex]</l>
<c>        * </c>
<c>        * Set 'margin_left'.</c>
<l>    elseif (GenParamName[GenParamIndex] == 'margin_left')</l>
<l>        LeftBorder := GenParamValue[GenParamIndex]</l>
<c>        * </c>
<c>        * Set 'margin_right'.</c>
<l>    elseif (GenParamName[GenParamIndex] == 'margin_right')</l>
<l>        RightBorder := GenParamValue[GenParamIndex]</l>
<c>        * </c>
<c>        * Set 'margin_top'.</c>
<l>    elseif (GenParamName[GenParamIndex] == 'margin_top')</l>
<l>        UpperBorder := GenParamValue[GenParamIndex]</l>
<c>        * </c>
<c>        * Set 'margin_bottom'.</c>
<l>    elseif (GenParamName[GenParamIndex] == 'margin_bottom')</l>
<l>        LowerBorder := GenParamValue[GenParamIndex]</l>
<l>    elseif (GenParamName[GenParamIndex] == 'format_x')</l>
<l>        FormatX := GenParamValue[GenParamIndex]</l>
<l>    elseif (GenParamName[GenParamIndex] == 'format_y')</l>
<l>        FormatY := GenParamValue[GenParamIndex]</l>
<l>    elseif (GenParamName[GenParamIndex] == 'line_width')</l>
<l>        LineWidth := GenParamValue[GenParamIndex]</l>
<l>    elseif (GenParamName[GenParamIndex] == 'log_y')</l>
<c>        * log_y already checked before because some other values depend on it.</c>
<l>    else</l>
<l>        throw ('Unknown generic parameter: \'' + GenParamName[GenParamIndex] + '\'')</l>
<l>    endif</l>
<l>endfor</l>
<c>* </c>
<c>* Check consistency of start and end values of the axes.</c>
<l>if (XAxisStartValue &gt; XAxisEndValue)</l>
<l>    throw ('Value for \'start_x\' is greater than value for \'end_x\'')</l>
<l>endif</l>
<l>if (YAxisStartValue &gt; YAxisEndValue)</l>
<l>    throw ('Value for \'start_y\' is greater than value for \'end_y\'')</l>
<l>endif</l>
<c>* </c>
<c>* Set the position of the y-axis.</c>
<l>if (YAxisPosition == 'default')</l>
<l>    YAxisPosition := XAxisStartValue</l>
<l>endif</l>
<l>if (is_string(YAxisPosition) == 1)</l>
<l>    if (YAxisPosition == 'left')</l>
<l>        YAxisPosition := XAxisStartValue</l>
<l>    elseif (YAxisPosition == 'right')</l>
<l>        YAxisPosition := XAxisEndValue</l>
<l>    elseif (YAxisPosition == 'origin')</l>
<l>        YAxisPosition := 0</l>
<l>    else</l>
<l>        throw ('Unsupported axis_location_y: \'' + YAxisPosition + '\'')</l>
<l>    endif</l>
<l>endif</l>
<c>* Set the position of the ticks on the y-axis</c>
<c>* depending of the location of the y-axis.</c>
<l>if (mean([XAxisStartValue,XAxisEndValue]) &gt; YAxisPosition)</l>
<l>    YTickDirection := 'right'</l>
<l>else</l>
<l>    YTickDirection := 'left'</l>
<l>endif</l>
<c>* </c>
<c>* Set the position of the x-axis.</c>
<l>if (XAxisPosition == 'default')</l>
<l>    XAxisPosition := YAxisStartValue</l>
<l>endif</l>
<l>if (is_string(XAxisPosition) == 1)</l>
<l>    if (XAxisPosition == 'bottom')</l>
<l>        XAxisPosition := YAxisStartValue</l>
<l>    elseif (XAxisPosition == 'top')</l>
<l>        XAxisPosition := YAxisEndValue</l>
<l>    elseif (XAxisPosition == 'origin')</l>
<l>        XAxisPosition := 0</l>
<l>    else</l>
<l>        throw ('Unsupported axis_location_x: \'' + XAxisPosition + '\'')</l>
<l>    endif</l>
<l>endif</l>
<c>* Set the position of the ticks on the y-axis</c>
<c>* depending of the location of the y-axis.</c>
<l>if (mean([YAxisStartValue,YAxisEndValue]) &gt; XAxisPosition)</l>
<l>    XTickDirection := 'up'</l>
<l>else</l>
<l>    XTickDirection := 'down'</l>
<l>endif</l>
<c>* </c>
<c>* Calculate basic pixel coordinates and scale factors.</c>
<c>* </c>
<l>XAxisWidthPx := Width - LeftBorder - RightBorder</l>
<l>XAxisWidth := XAxisEndValue - XAxisStartValue</l>
<l>if (XAxisWidth == 0)</l>
<l>    XAxisStartValue := XAxisStartValue - 0.5</l>
<l>    XAxisEndValue := XAxisEndValue + 0.5</l>
<l>    XAxisWidth := 1</l>
<l>endif</l>
<l>XScaleFactor := XAxisWidthPx / real(XAxisWidth)</l>
<l>YAxisHeightPx := Height - LowerBorder - UpperBorder</l>
<l>YAxisHeight := YAxisEndValue - YAxisStartValue</l>
<l>if (YAxisHeight == 0)</l>
<l>    YAxisStartValue := YAxisStartValue - 0.5</l>
<l>    YAxisEndValue := YAxisEndValue + 0.5</l>
<l>    YAxisHeight := 1</l>
<l>endif</l>
<l>YScaleFactor := YAxisHeightPx / real(YAxisHeight)</l>
<l>YAxisOffsetPx := (YAxisPosition - XAxisStartValue) * XScaleFactor</l>
<l>XAxisOffsetPx := (XAxisPosition - YAxisStartValue) * YScaleFactor</l>
<c>* </c>
<c>* Display grid lines.</c>
<c>* </c>
<l>if (GridColor != 'none')</l>
<l>    DotStyle := [5,7]</l>
<l>    set_line_style (WindowHandle, DotStyle)</l>
<l>    dev_set_color (GridColor)</l>
<c>    * </c>
<c>    * Display x grid lines.</c>
<l>    if (XGrid != 'none')</l>
<l>        if (XGrid == 'min_max_origin')</l>
<c>            * Calculate 'min_max_origin' grid line coordinates.</c>
<l>            if (YAxisPosition == XAxisStartValue)</l>
<l>                XGridValues := [XAxisStartValue,XAxisEndValue]</l>
<l>            else</l>
<l>                XGridValues := [XAxisStartValue,YAxisPosition,XAxisEndValue]</l>
<l>            endif</l>
<l>        else</l>
<c>            * Calculate equidistant grid line coordinates.</c>
<l>            XGridStart := ceil(XAxisStartValue / XGrid) * XGrid</l>
<l>            XGridValues := [XGridStart:XGrid:XAxisEndValue]</l>
<l>        endif</l>
<l>        XCoord := (XGridValues - XAxisStartValue) * XScaleFactor</l>
<c>        * Generate and display grid lines.</c>
<l>        for IndexGrid := 0 to |XGridValues| - 1 by 1</l>
<l>            gen_contour_polygon_xld (ContourXGrid, [Height - LowerBorder,UpperBorder], [LeftBorder + XCoord[IndexGrid],LeftBorder + XCoord[IndexGrid]])</l>
<l>            dev_display (ContourXGrid)</l>
<l>        endfor</l>
<l>    endif</l>
<c>    * </c>
<c>    * Display y grid lines.</c>
<l>    if (YGrid != 'none')</l>
<l>        if (YGrid == 'min_max_origin')</l>
<c>            * Calculate 'min_max_origin' grid line coordinates.</c>
<l>            if (XAxisPosition == YAxisStartValue)</l>
<l>                YGridValues := [YAxisStartValue,YAxisEndValue]</l>
<l>            else</l>
<l>                YGridValues := [YAxisStartValue,XAxisPosition,YAxisEndValue]</l>
<l>            endif</l>
<l>        else</l>
<c>            * Calculate equidistant grid line coordinates.</c>
<l>            YGridStart := ceil(YAxisStartValue / YGrid) * YGrid</l>
<l>            YGridValues := [YGridStart:YGrid:YAxisEndValue]</l>
<l>        endif</l>
<l>        YCoord := (YGridValues - YAxisStartValue) * YScaleFactor</l>
<c>        * Generate and display grid lines.</c>
<l>        for IndexGrid := 0 to |YGridValues| - 1 by 1</l>
<l>            gen_contour_polygon_xld (ContourYGrid, [Height - LowerBorder - YCoord[IndexGrid],Height - LowerBorder - YCoord[IndexGrid]], [LeftBorder,Width - RightBorder])</l>
<l>            dev_display (ContourYGrid)</l>
<l>        endfor</l>
<l>    endif</l>
<l>endif</l>
<l>set_line_style (WindowHandle, [])</l>
<c>* </c>
<c>* </c>
<c>* Display the coordinate system axes.</c>
<l>if (AxesColor != 'none')</l>
<c>    * Display axes.</c>
<l>    dev_set_color (AxesColor)</l>
<l>    gen_arrow_contour_xld (XArrow, Height - LowerBorder - XAxisOffsetPx, LeftBorder, Height - LowerBorder - XAxisOffsetPx, Width - RightBorder, 0, 0)</l>
<l>    dev_display (XArrow)</l>
<l>    gen_arrow_contour_xld (YArrow, Height - LowerBorder, LeftBorder + YAxisOffsetPx, UpperBorder, LeftBorder + YAxisOffsetPx, 0, 0)</l>
<l>    dev_display (YArrow)</l>
<c>    * Display labels.</c>
<l>    get_string_extents (WindowHandle, XLabel, Ascent, Descent, TextWidthXLabel, TextHeightXLabel)</l>
<l>    get_string_extents (WindowHandle, YLabel, Ascent, Descent, TextWidthYLabel, TextHeightYLabel)</l>
<l>    if (YTickDirection == 'right')</l>
<l>        if (XTickDirection == 'up')</l>
<l>            dev_disp_text (XLabel, 'image', Height - LowerBorder - TextHeightXLabel - 3, Width - RightBorder - TextWidthXLabel - 3, AxesColor, 'box', 'false')</l>
<l>            dev_disp_text (' ' + YLabel, 'image', UpperBorder, LeftBorder + 3 + YAxisOffsetPx, AxesColor, 'box', 'false')</l>
<l>        else</l>
<l>            dev_disp_text (XLabel, 'image', Height - LowerBorder + 3 - XAxisOffsetPx, Width - RightBorder - TextWidthXLabel - 3, AxesColor, 'box', 'false')</l>
<l>            dev_disp_text (' ' + YLabel, 'image', Height - LowerBorder - TextHeightXLabel - 3, LeftBorder + 3 + YAxisOffsetPx, AxesColor, 'box', 'false')</l>
<l>        endif</l>
<l>    else</l>
<l>        if (XTickDirection == 'up')</l>
<l>            dev_disp_text (XLabel, 'image', Height - LowerBorder - 2 * TextHeightXLabel + 3, LeftBorder - 3, AxesColor, 'box', 'false')</l>
<l>            dev_disp_text (' ' + YLabel, 'image', UpperBorder, Width - RightBorder - TextWidthYLabel - 13, AxesColor, 'box', 'false')</l>
<l>        else</l>
<l>            dev_disp_text (XLabel, 'image', Height - LowerBorder + 3 - XAxisOffsetPx, LeftBorder - 3, AxesColor, 'box', 'false')</l>
<l>            dev_disp_text (' ' + YLabel, 'image', Height - LowerBorder - TextHeightXLabel - 3, Width - RightBorder - 2 * TextWidthYLabel - 3, AxesColor, 'box', 'false')</l>
<l>        endif</l>
<l>    endif</l>
<l>endif</l>
<c>* </c>
<c>* Display ticks.</c>
<c>* </c>
<l>if (AxesColor != 'none')</l>
<l>    dev_set_color (AxesColor)</l>
<l>    if (XTicks != 'none')</l>
<c>        * </c>
<c>        * Display x ticks.</c>
<l>        if (XValuesAreStrings)</l>
<c>            * Display string XValues as categories.</c>
<l>            XTicks := |XValues| / |XTickValues|</l>
<l>            XCoord := (XValues - XAxisStartValue) * XScaleFactor</l>
<l>        else</l>
<c>            * Display tick values.</c>
<l>            if (XTicks == 'min_max_origin')</l>
<c>                * Calculate 'min_max_origin' tick coordinates.</c>
<l>                if (YAxisPosition == XAxisStartValue)</l>
<l>                    XTickValues := [XAxisStartValue,XAxisEndValue]</l>
<l>                else</l>
<l>                    XTickValues := [XAxisStartValue,YAxisPosition,XAxisEndValue]</l>
<l>                endif</l>
<l>            else</l>
<c>                * Calculate equidistant tick coordinates.</c>
<l>                XTickStart := ceil(XAxisStartValue / XTicks) * XTicks</l>
<l>                XTickValues := [XTickStart:XTicks:XAxisEndValue]</l>
<l>            endif</l>
<c>            * Remove ticks that are smaller than the x-axis start.</c>
<l>            Indices := find(XTickValues [&lt;] XAxisStartValue,1)</l>
<l>            XCoord := (XTickValues - XAxisStartValue) * XScaleFactor</l>
<l>            XCoord := remove(XCoord,Indices)</l>
<l>            XTickValues := remove(XTickValues,Indices)</l>
<c>            * </c>
<l>            if (FormatX == 'default')</l>
<l>                TypeTicks := type(XTicks)</l>
<l>                if (TypeTicks == H_TYPE_STRING)</l>
<c>                    * String ('min_max_origin').</c>
<c>                    * Format depends on actual values.</c>
<l>                    TypeTicks := type(XTickValues)</l>
<l>                endif</l>
<l>                if (TypeTicks == H_TYPE_INT)</l>
<c>                    * Round to integer.</c>
<l>                    XTickValues := int(XTickValues)</l>
<l>                else</l>
<c>                    * Use floating point numbers.</c>
<l>                    XTickValues := XTickValues$'.2f'</l>
<l>                endif</l>
<l>            else</l>
<l>                XTickValues := XTickValues$FormatX</l>
<l>            endif</l>
<l>        endif</l>
<c>        * Generate and display ticks.</c>
<l>        for IndexTicks := 0 to |XTickValues| - 1 by 1</l>
<l>            get_string_extents (WindowHandle, XTickValues[IndexTicks], Ascent1, Descent1, TextWidthXTicks, TextHeightXTicks)</l>
<l>            if (XTickDirection == 'up')</l>
<l>                gen_contour_polygon_xld (ContourXTick, [Height - LowerBorder - XAxisOffsetPx,Height - LowerBorder - XAxisOffsetPx - 5], [LeftBorder + XCoord[IndexTicks],LeftBorder + XCoord[IndexTicks]])</l>
<l>                dev_disp_text (XTickValues[IndexTicks], 'image', Height - LowerBorder + 2 - XAxisOffsetPx, LeftBorder + XCoord[IndexTicks] - 0.5 * TextWidthXTicks, AxesColor, 'box', 'false')</l>
<l>            else</l>
<l>                gen_contour_polygon_xld (ContourXTick, [Height - LowerBorder - XAxisOffsetPx + 5,Height - LowerBorder - XAxisOffsetPx], [LeftBorder + XCoord[IndexTicks],LeftBorder + XCoord[IndexTicks]])</l>
<l>                dev_disp_text (XTickValues[IndexTicks], 'image', Height - LowerBorder - 2 * TextHeightXTicks - XAxisOffsetPx, LeftBorder + XCoord[IndexTicks] - 0.5 * TextWidthXTicks, AxesColor, 'box', 'false')</l>
<l>            endif</l>
<l>            dev_display (ContourXTick)</l>
<l>        endfor</l>
<l>    endif</l>
<c>    * </c>
<l>    if (YTicks != 'none')</l>
<c>        * </c>
<c>        * Display y ticks.</c>
<c></c>
<l>        if (YTicks == 'min_max_origin')</l>
<c>            * Calculate 'min_max_origin' tick coordinates.</c>
<l>            if (XAxisPosition == YAxisStartValue)</l>
<l>                YTickValues := [YAxisStartValue,YAxisEndValue]</l>
<l>            else</l>
<l>                YTickValues := [YAxisStartValue,XAxisPosition,YAxisEndValue]</l>
<l>            endif</l>
<l>        else</l>
<c>            * Calculate equidistant tick coordinates.</c>
<l>            YTickStart := ceil(YAxisStartValue / YTicks) * YTicks</l>
<l>            YTickValues := [YTickStart:YTicks:YAxisEndValue]</l>
<l>        endif</l>
<c></c>
<c>        * Remove ticks that are smaller than the y-axis start.</c>
<l>        Indices := find(YTickValues [&lt;] YAxisStartValue,1)</l>
<l>        YCoord := (YTickValues - YAxisStartValue) * YScaleFactor</l>
<l>        YCoord := remove(YCoord,Indices)</l>
<l>        YTickValues := remove(YTickValues,Indices)</l>
<c>        * </c>
<l>        if (PlotYLog)</l>
<l>            YTickValues := pow(10,YTickValues)</l>
<l>        endif</l>
<l>        if (FormatY == 'default')</l>
<l>            TypeTicks := type(YTicks)</l>
<l>            if (TypeTicks == H_TYPE_STRING)</l>
<c>                * String ('min_max_origin').</c>
<c>                * Format depends on actual values.</c>
<l>                TypeTicks := type(YTickValues)</l>
<l>            endif</l>
<l>            if (TypeTicks == H_TYPE_INT)</l>
<c>                * Round to integer.</c>
<l>                YTickValues := int(YTickValues)</l>
<l>            else</l>
<c>                * Use floating point numbers.</c>
<l>                YTickValues := YTickValues$'.2f'</l>
<l>            endif</l>
<l>        else</l>
<l>            YTickValues := YTickValues$FormatY</l>
<l>        endif</l>
<c>        * Generate and display ticks.</c>
<l>        for IndexTicks := 0 to |YTickValues| - 1 by 1</l>
<l>            get_string_extents (WindowHandle, YTickValues[IndexTicks], Ascent1, Descent1, TextWidthYTicks, TextHeightYTicks)</l>
<c>            * Since we only deal with numbers, use the Ascent as text height.</c>
<l>            TextHeightYTicks := Ascent</l>
<l>            if (YTickDirection == 'right')</l>
<l>                gen_contour_polygon_xld (ContourYTick, [Height - LowerBorder - YCoord[IndexTicks],Height - LowerBorder - YCoord[IndexTicks]], [LeftBorder + YAxisOffsetPx,LeftBorder + YAxisOffsetPx + 5])</l>
<l>                dev_disp_text (YTickValues[IndexTicks], 'image', Height - LowerBorder - TextHeightYTicks + 3 - YCoord[IndexTicks], LeftBorder - TextWidthYTicks - 4 + YAxisOffsetPx, Color, 'box', 'false')</l>
<l>            else</l>
<l>                gen_contour_polygon_xld (ContourYTick, [Height - LowerBorder - YCoord[IndexTicks],Height - LowerBorder - YCoord[IndexTicks]], [LeftBorder + YAxisOffsetPx - 5,LeftBorder + YAxisOffsetPx])</l>
<l>                dev_disp_text (YTickValues[IndexTicks], 'image', Height - LowerBorder - TextHeightYTicks + 3 - YCoord[IndexTicks], LeftBorder + 4 + YAxisOffsetPx, Color, 'box', 'false')</l>
<l>            endif</l>
<l>            dev_display (ContourYTick)</l>
<l>        endfor</l>
<l>    endif</l>
<l>endif</l>
<c>* </c>
<c>* Display function plot.</c>
<c>* </c>
<l>if (Color != 'none')</l>
<l>    if (XValues != [] and YValues != [])</l>
<l>        Num := |YValues| / |XValues|</l>
<c>        * </c>
<c>        * Iterate over all functions to be displayed.</c>
<l>        for I := 0 to Num - 1 by 1</l>
<c>            * Select y values for current function.</c>
<l>            YSelected := YValues[I * |XValues|:(I + 1) * |XValues| - 1]</l>
<c>            * Set color</c>
<l>            if (Color == [])</l>
<l>                set_rgb (WindowHandle, Red, Green, Blue)</l>
<l>            else</l>
<l>                dev_set_color (Color[I % |Color|])</l>
<l>            endif</l>
<c>            * </c>
<c>            * Display in different styles.</c>
<c>            * </c>
<l>            if (Style == 'line' or Style == [] or is_real(Style) or is_int(Style))</l>
<c>                * Style = Line. For real value, the line is plotted dashed.</c>
<l>                if (is_real(Style) or is_int(Style))</l>
<l>                    get_line_style (WindowHandle, StyleOriginal)</l>
<l>                    set_line_style (WindowHandle, [Style,Style / 2.0])</l>
<l>                endif</l>
<l>                gen_contour_polygon_xld (Contour, Height - LowerBorder - YSelected * YScaleFactor + YAxisStartValue * YScaleFactor, XValues * XScaleFactor + LeftBorder - XAxisStartValue * XScaleFactor)</l>
<c>                * Clip, if necessary.</c>
<l>                if (Clip == 'yes')</l>
<l>                    clip_contours_xld (Contour, Contour, UpperBorder, LeftBorder, Height - LowerBorder, Width - RightBorder)</l>
<l>                endif</l>
<l>                get_line_width (WindowHandle, OldLineWidth)</l>
<l>                dev_set_line_width (int(LineWidth))</l>
<l>                dev_display (Contour)</l>
<l>                dev_set_line_width (int(OldLineWidth))</l>
<l>                if (is_real(Style) or is_int(Style))</l>
<l>                    set_line_style (WindowHandle, StyleOriginal)</l>
<l>                endif</l>
<l>            elseif (Style == 'cross')</l>
<c>                * Style = Cross.</c>
<l>                get_line_width (WindowHandle, LineWidth)</l>
<l>                gen_cross_contour_xld (Cross, Height - LowerBorder - YSelected * YScaleFactor + YAxisStartValue * YScaleFactor, XValues * XScaleFactor + LeftBorder - XAxisStartValue * XScaleFactor, 6, 0.785398)</l>
<c>                * Clip, if necessary.</c>
<l>                if (Clip == 'yes')</l>
<l>                    clip_contours_xld (Cross, Cross, UpperBorder, LeftBorder, Height - LowerBorder, Width - RightBorder)</l>
<l>                endif</l>
<l>                dev_display (Cross)</l>
<l>            elseif (Style == 'circle')</l>
<c>                * Style = Circle.</c>
<l>                get_line_width (WindowHandle, LineWidth)</l>
<l>                tuple_gen_const (|YSelected|, 3 * LineWidth, Radii)</l>
<l>                gen_circle_contour_xld (Circle, Height - LowerBorder - YSelected * YScaleFactor + YAxisStartValue * YScaleFactor, XValues * XScaleFactor + LeftBorder - XAxisStartValue * XScaleFactor, Radii, 0, 6.28318, 'positive', 1)</l>
<c>                * Clip, if necessary.</c>
<l>                if (Clip == 'yes')</l>
<l>                    clip_contours_xld (Circle, Circle, UpperBorder, LeftBorder, Height - LowerBorder, Width - RightBorder)</l>
<l>                endif</l>
<l>                get_contour_style (WindowHandle, OldContourStyle)</l>
<l>                set_contour_style (WindowHandle, 'stroke_and_fill')</l>
<l>                dev_display (Circle)</l>
<l>                set_contour_style (WindowHandle, OldContourStyle)</l>
<l>            elseif (Style == 'filled')</l>
<c>                * Style = Filled.</c>
<l>                Y1Selected := [0 + XAxisPosition,YSelected,0 + XAxisPosition]</l>
<l>                X1Selected := [min(XValues),XValues,max(XValues)]</l>
<l>                dev_set_draw ('fill')</l>
<l>                gen_region_polygon_filled (Filled, Height - LowerBorder - Y1Selected * YScaleFactor + YAxisStartValue * YScaleFactor, X1Selected * XScaleFactor + LeftBorder - XAxisStartValue * XScaleFactor)</l>
<c>                * Clip, if necessary.</c>
<l>                if (Clip == 'yes')</l>
<l>                    clip_region (Filled, Filled, UpperBorder, LeftBorder, Height - LowerBorder, Width - RightBorder)</l>
<l>                endif</l>
<l>                dev_display (Filled)</l>
<l>            elseif (Style == 'step')</l>
<l>                gen_empty_obj (Stair)</l>
<l>                for Index := 0 to |XValues| - 2 by 1</l>
<l>                    Row1 := Height - LowerBorder - YSelected[Index] * YScaleFactor + YAxisStartValue * YScaleFactor</l>
<l>                    Row2 := Height - LowerBorder - YSelected[Index + 1] * YScaleFactor + YAxisStartValue * YScaleFactor</l>
<l>                    Col1 := XValues[Index] * XScaleFactor + LeftBorder - XAxisStartValue * XScaleFactor</l>
<l>                    Col2 := XValues[Index + 1] * XScaleFactor + LeftBorder - XAxisStartValue * XScaleFactor</l>
<l>                    gen_contour_polygon_xld (StairTmp, [Row1,Row1,Row2], [Col1,Col2,Col2])</l>
<l>                    concat_obj (Stair, StairTmp, Stair)</l>
<l>                endfor</l>
<l>                union_adjacent_contours_xld (Stair, Stair, 0.1, 0.1, 'attr_keep')</l>
<l>                if (Clip == 'yes')</l>
<l>                    clip_region (Stair, Stair, UpperBorder, LeftBorder, Height - LowerBorder, Width - RightBorder)</l>
<l>                endif</l>
<l>                dev_display (Stair)</l>
<l>            else</l>
<l>                throw ('Unsupported style: ' + Style)</l>
<l>            endif</l>
<l>        endfor</l>
<l>    endif</l>
<l>endif</l>
<c>* </c>
<c>* </c>
<l>set_rgb (WindowHandle, Red, Green, Blue)</l>
<l>dev_set_draw (DrawMode)</l>
<l>set_line_style (WindowHandle, OriginStyle)</l>
<l>set_system ('clip_region', ClipRegion)</l>
<l>return ()</l>
</body>
<docu id="plot_tuple_no_window_handling">
<abstract lang="en_US">This procedure plots the functions or curves represented by the coordinates in XValues and YValues into the graphic window given in WindowHandle.
The axes of the coordinate system are labeled with XLabel and YLabel.
Color sets the color of the plotted function.
Using GenParamName and GenParamValue, the appearance of the output can be adapted further.

In the following, the possible values are listed for the parameters:

- XValues: X values of the function to be plotted. Thereby you have the following options:
   -- []: XValues are internally set to 0,1,2,...,|YValues|-1.
   -- a tuple of strings: These values are taken as categories.

- YValues: Y values of the function(s) to be plotted. Thereby you have the following options:
   -- []: YValues are internally set to 0,1,2,...,|XValues|-1.
   -- a tuple of values: The number of y values must be equal to the number of x values or an integral multiple. In the latter case, multiple functions are plotted, that share the same x values.

- XLabel: X-axis label.

- YLabel: Y-axis label.

- Color: Color of the plotted function. Thereby you have the following options:
   -- []: The currently set display color is used.
   -- 'none': The function is not plotted, but only the coordinate axes as specified.
   -- string: Defining the color of the plotted function.
   -- tuple of strings: Multiple functions can be displayed in different colors.

- GenParamName: Generic parameter names to control the presentation. The corresponding values are taken from GenParamValue. Possible string/value pairs:
   -- 'axes_color': Color of the coordinate axes. The default value is 'white'. If 'none' is given, no coordinate axes are shown. 
   -- 'style': Graph style. Possible values:
      --- 'line' (default)
      --- 'cross'
      --- 'circle'
      --- 'step'
      --- 'filled'
   -- 'clip': Clip graph to coordinate system area. Possible values:
      --- 'no' (default)
      --- 'yes'
   -- 'ticks': Control display of ticks on the axes. Thereby you have the following options:
      --- 'min_max_origin' (default): Ticks are shown at the minimum and maximum values of the axes and at the intercept point of x- and y-axis.
      --- 'none': No ticks are shown.
      --- any number != 0: This number specifies the distance between the ticks.
   -- 'ticks_x': Control display of ticks on x-axis only. You have the same options as for 'ticks'.
   -- 'ticks_y': Control display of ticks on y-axis only. You have the same options as for 'ticks'.
   -- 'format_x': Format of the values next to the ticks of the x-axis (see tuple_string for more details).
   -- 'format_y': Format of the values next to the ticks of the y-axis (see tuple_string for more details).
   -- 'grid': Control display of grid lines within the coordinate system. Thereby you have the following options:
     --- 'min_max_origin' (default): Grid lines are shown at the minimum and maximum values of the axes.
     --- 'none': No grid lines are shown.
     --- If any number != 0: This number specifies the distance between the grid lines.
   -- 'grid_x': Control display of grid lines for the x-axis only.
   -- 'grid_y': Control display of grid lines for the y-axis only.
   -- 'grid_color': Color of the grid (default: 'dim gray').
   -- 'margin': The distance in pixels of the plot area to all four window borders.
   -- 'margin_left': The distance in pixels of the plot area to the left window border.
   -- 'margin_right': The distance in pixels of the plot area to the right window border.
   -- 'margin_top': The distance in pixels of the plot area to the upper window border.
   -- 'margin_bottom': The distance in pixels of the plot area to the lower window border.
   -- 'start_x': Lowest x value of the x-axis. The default value is min(XValues).
   -- 'end_x': Highest x value of the x-axis. The default value is max(XValues).
   -- 'start_y': Lowest y value of the y-axis. The default value is min(YValues).
   -- 'end_y': Highest y value of the y-axis. The default value is max(YValues).
   -- 'axis_location_x': Position of the x-axis (Used to be called 'origin_y'). Thereby you have the following options:
      --- 'bottom' (default)
      --- 'origin'
      --- 'top'
      --- Y coordinate of the intercept point of x- and y-axis.
   -- 'axis_location_y': Position of the y-axis (Used to be called 'origin_x'). Thereby you have the following options:
      --- 'left' (default)
      --- 'right'
      --- 'origin'
      --- X coordinate of the intercept point of x- and y-axis.</abstract>
<chapters lang="de_DE">
<item>Graphik</item>
<item>Ausgabe</item>
</chapters>
<chapters lang="en_US">
<item>Graphics</item>
<item>Output</item>
</chapters>
<example lang="en_US">dev_open_window (0, 0, 512, 512, 'black', WindowHandle)
X := [-rad(180): 0.01: rad(180)]
Y1 := sin(X)
Y2 := (X * X) * 0.2 - 1
XLabel := 'x'
YLabel := 'y'
Color := ['medium slate blue', 'yellow']
GenParamName := []
GenParamValue := []
plot_tuple (WindowHandle, X, [Y1, Y2], XLabel, YLabel, Color, GenParamName, GenParamValue)</example>
<keywords lang="en_US">
<item>plot</item>
<item>tuple</item>
<item>function</item>
<item>display</item>
<item>graph</item>
<item>curve</item>
</keywords>
<library lang="en_US">MVTec Standard Procedures</library>
<predecessor>
<item>funct_1d_to_pairs</item>
</predecessor>
<short lang="en_US">This procedure plots tuples representing functions or curves in a coordinate system.</short>
<parameters>
<parameter id="Color">
<default_type>string</default_type>
<default_value>[]</default_value>
<description lang="en_US">Color of the function plot.</description>
<multivalue>optional</multivalue>
<sem_type>color</sem_type>
<type_list>
<item>string</item>
</type_list>
<values>
<item>'red'</item>
<item>'green'</item>
<item>'yellow'</item>
<item>'white'</item>
<item>'black'</item>
<item>'cyan'</item>
<item>'magenta'</item>
<item>'blue'</item>
<item>'orange'</item>
</values>
</parameter>
<parameter id="GenParamName">
<default_type>string</default_type>
<default_value>[]</default_value>
<description lang="en_US">Names of the generic parameters, whose values are given in GenParamValue.</description>
<mixed_type>false</mixed_type>
<multivalue>optional</multivalue>
<sem_type>string</sem_type>
<type_list>
<item>string</item>
</type_list>
<values>
<item>'axes_color'</item>
<item>'style'</item>
<item>'clip'</item>
<item>'ticks'</item>
<item>'ticks_x'</item>
<item>'ticks_y'</item>
<item>'grid'</item>
<item>'grid_x'</item>
<item>'grid_y'</item>
<item>'grid_color'</item>
<item>'margin'</item>
<item>'margin_left'</item>
<item>'margin_right'</item>
<item>'margin_top'</item>
<item>'margin_bottom'</item>
<item>'start_x'</item>
<item>'end_x'</item>
<item>'start_y'</item>
<item>'end_y'</item>
<item>'origin_y'</item>
<item>'origin_x'</item>
<item>'position_y'</item>
</values>
</parameter>
<parameter id="GenParamValue">
<default_type>string</default_type>
<default_value>[]</default_value>
<description lang="en_US">Generic parameter values, whose names are given in GenParamName.</description>
<mixed_type>optional</mixed_type>
<multivalue>optional</multivalue>
<sem_type>any</sem_type>
<type_list>
<item>string</item>
</type_list>
</parameter>
<parameter id="WindowHandle">
<default_type>integer</default_type>
<description lang="en_US">Handle of the window in which the plot is to be displayed.</description>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>window</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="XLabel">
<default_value>[]</default_value>
<description lang="en_US">Label of the x-axis.</description>
</parameter>
<parameter id="XValues">
<default_type>real</default_type>
<default_value>[]</default_value>
<description lang="en_US">X values of the function to be plotted.</description>
<multivalue>optional</multivalue>
<sem_type>coordinates.x</sem_type>
<type_list>
<item>real</item>
</type_list>
</parameter>
<parameter id="YLabel">
<default_value>[]</default_value>
<description lang="en_US">Label of the y-axis.</description>
</parameter>
<parameter id="YValues">
<default_type>real</default_type>
<description lang="en_US">Y values of the function to be plotted.</description>
<multivalue>optional</multivalue>
<sem_type>coordinates.y</sem_type>
<type_list>
<item>real</item>
</type_list>
</parameter>
</parameters>
</docu>
</procedure>
<procedure name="prepare_image_lists" access="local">
<interface>
<ic>
<par name="ImageDirs" base_type="ctrl" dimension="0"/>
<par name="Extensions" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="ImageBaseNames" base_type="ctrl" dimension="0"/>
<par name="ImageExtensions" base_type="ctrl" dimension="0"/>
<par name="ImageDirectories" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c>* </c>
<c>* This procedure returns for all images in ImageDirs:</c>
<c>* - the base names,</c>
<c>* - the extensions,</c>
<c>* - the directories.</c>
<c></c>
<l>ImageBaseNames := []</l>
<l>ImageExtensions := []</l>
<l>ImageDirectories := []</l>
<l>for ImageDirIndex := 0 to |ImageDirs| - 1 by 1</l>
<l>    list_image_files (ImageDirs[ImageDirIndex], Extensions, ['recursive','follow_links'], ImageFilesTmp)</l>
<l>    parse_filename (ImageFilesTmp, ImageBaseNamesTmp, ImageExtensionsTmp, ImageDirectoriesTmp)</l>
<l>    ImageBaseNames := [ImageBaseNames,ImageBaseNamesTmp]</l>
<l>    ImageExtensions := [ImageExtensions,ImageExtensionsTmp]</l>
<l>    ImageDirectories := [ImageDirectories,ImageDirectoriesTmp]</l>
<l>endfor</l>
<l>return ()</l>
</body>
<docu id="prepare_image_lists">
<abstract lang="en_US">Get the base names, extensions and directories of all images in ImageDirs.</abstract>
<chapters lang="de_DE">
<item>File</item>
<item>Misc</item>
</chapters>
<chapters lang="en_US">
<item>File</item>
<item>Misc</item>
</chapters>
<library lang="en_US">MVTec Standard Procedures</library>
<parameters>
<parameter id="Extensions">
<default_type>string</default_type>
<default_value>'default'</default_value>
<description lang="en_US">Possible extensions for the images to be listed.</description>
<mixed_type>false</mixed_type>
<multivalue>optional</multivalue>
<sem_type>string</sem_type>
<type_list>
<item>string</item>
</type_list>
</parameter>
<parameter id="ImageBaseNames">
<default_type>string</default_type>
<description lang="en_US">List of base names of the images.</description>
<mixed_type>false</mixed_type>
<multivalue>optional</multivalue>
<sem_type>string</sem_type>
<type_list>
<item>string</item>
</type_list>
</parameter>
<parameter id="ImageDirectories">
<default_type>string</default_type>
<description lang="en_US">List of directories of the images.</description>
<mixed_type>false</mixed_type>
<multivalue>optional</multivalue>
<sem_type>string</sem_type>
<type_list>
<item>string</item>
</type_list>
</parameter>
<parameter id="ImageDirs">
<default_type>string</default_type>
<description lang="en_US">Directories of images.</description>
<mixed_type>false</mixed_type>
<multivalue>optional</multivalue>
<sem_type>filename</sem_type>
<type_list>
<item>string</item>
</type_list>
</parameter>
<parameter id="ImageExtensions">
<default_type>string</default_type>
<description lang="en_US">List of extensions of the images.</description>
<mixed_type>false</mixed_type>
<multivalue>optional</multivalue>
<sem_type>string</sem_type>
<type_list>
<item>string</item>
</type_list>
</parameter>
</parameters>
</docu>
</procedure>
<procedure name="prepare_poses_and_rectification_data_moving_cam">
<interface>
<ic>
<par name="ToolInBasePose" base_type="ctrl" dimension="0"/>
<par name="ObjectHeight" base_type="ctrl" dimension="0"/>
<par name="RectifyImage" base_type="ctrl" dimension="0"/>
<par name="HandEyeCalibData" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="Poses" base_type="ctrl" dimension="0"/>
<par name="RectificationData" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c>* Prepare the needed poses to match and grasp, and compute the rectification map.</c>
<c>* </c>
<c>* RectifyImage Parameter can have one of the following 3 values:</c>
<c>* 'no_rectification', 'align_and_rectify', or 'only_rectify'</c>
<c>* </c>
<l>read_dict_tuple (HandEyeCalibData, 'CamParam', CamParam)</l>
<l>read_dict_tuple (HandEyeCalibData, 'ToolInCamPose', ToolInCamPose)</l>
<l>read_dict_tuple (HandEyeCalibData, 'PlaneInBasePose0', PlaneInBasePose0)</l>
<c>* </c>
<c>* Check input</c>
<l>if (ObjectHeight &lt; 0.0)</l>
<l>    throw ('The parameter ObjectHeight cannot be negative')</l>
<l>endif</l>
<l>if (CamParam[0] =~ 'line_scan')</l>
<l>    throw ('Line-scan cameras are not supported')</l>
<l>endif</l>
<c>* </c>
<c>* Keep track of the pose type used by the robot.</c>
<l>get_pose_type (ToolInBasePose, OrderOfTransform, OrderOfRotation, ViewOfTransform)</l>
<c>* Convert to default pose type.</c>
<l>convert_pose_type (ToolInBasePose, 'Rp+T', 'gba', 'point', ToolInBasePose)</l>
<l>convert_pose_type (ToolInCamPose, 'Rp+T', 'gba', 'point', ToolInCamPose)</l>
<l>convert_pose_type (PlaneInBasePose0, 'Rp+T', 'gba', 'point', PlaneInBasePose0)</l>
<c>* </c>
<c>* Create the plane for matching and adapt the PlaneInBasePose0 such</c>
<c>* that the z-axis of the plane points away from the reference camera,</c>
<c>* and x/y coordinates are aligned with the current image, i.e.</c>
<c>* PlaneInCamPose0 has Rot_z=0.</c>
<l>pose_invert (ToolInBasePose, BaseInToolPose)</l>
<l>pose_compose (ToolInCamPose, BaseInToolPose, BaseInCamPose)</l>
<l>pose_compose (BaseInCamPose, PlaneInBasePose0, PlaneInCamPose0)</l>
<c>* The z-axis of the plane should point away from the camera.</c>
<l>PlaneInCamPose0Rot := PlaneInCamPose0</l>
<l>PlaneInCamPose0Rot[0:2] := [0,0,0]</l>
<l>pose_to_hom_mat3d (PlaneInCamPose0Rot, HomMat3D)</l>
<l>affine_trans_point_3d (HomMat3D, 0, 0, 1, Qx, Qy, CosAngleBetweenZAxis)</l>
<l>if (CosAngleBetweenZAxis &lt; 0)</l>
<l>    create_pose (0, 0, 0, 180, 0, 0, 'Rp+T', 'gba', 'point', SwitchZDirection)</l>
<l>    pose_compose (PlaneInCamPose0, SwitchZDirection, PlaneInCamPose1)</l>
<l>    PlaneInCamPose0 := PlaneInCamPose1</l>
<l>endif</l>
<c>* Align with the current image.</c>
<l>PlaneInCamPose := PlaneInCamPose0</l>
<l>PlaneInCamPose[5] := 0.0</l>
<c>* Adapt the PlaneInBasePose.</c>
<l>pose_invert (BaseInCamPose, CamInBasePose)</l>
<l>pose_compose (CamInBasePose, PlaneInCamPose, PlaneInBasePose)</l>
<c>* </c>
<c>* Create the plane for matching.</c>
<l>create_pose (0, 0, -ObjectHeight, 0, 0, 0, 'Rp+T', 'gba', 'point', MatchingPlaneInPlanePose)</l>
<l>pose_compose (PlaneInBasePose, MatchingPlaneInPlanePose, MatchingPlaneInBasePose)</l>
<l>pose_compose (PlaneInCamPose, MatchingPlaneInPlanePose, MatchingPlaneInCamPose)</l>
<c>* </c>
<l>if (RectifyImage == 'no_rectification')</l>
<l>    MatchingPlaneRectifiedPartInCamPose := MatchingPlaneInCamPose</l>
<l>    ScaleRectification := []</l>
<l>elseif (RectifyImage == 'only_rectify' or RectifyImage == 'align_and_rectify')</l>
<c>    * Determine the scale such that the mapped image has at least</c>
<c>    * the same resolution as the current image.</c>
<l>    get_cam_par_data (CamParam, 'image_width', Width)</l>
<l>    get_cam_par_data (CamParam, 'image_height', Height)</l>
<l>    gen_grid_region (RegionGrid, 20, 20, 'points', Width, Height)</l>
<l>    get_region_points (RegionGrid, Rows, Columns)</l>
<l>    gen_circle_contour_xld (ContCircle, Rows, Columns, gen_tuple_const(|Rows|,1.0), 0, 6.28318, 'positive', 0.1)</l>
<l>    contour_to_world_plane_xld (ContCircle, ContCircleWorldPlane, CamParam, MatchingPlaneInCamPose, 'm')</l>
<l>    fit_ellipse_contour_xld (ContCircleWorldPlane, 'fitzgibbon', -1, 0, 0, 200, 3, 2, Row, Column, Phi, Radius1, Radius2, StartPhi, EndPhi, PointOrder)</l>
<l>    ScaleRectification := min(Radius2)</l>
<c>    * </c>
<c>    * Rectify the current image and create the shape model.</c>
<c>    * </c>
<c>    * The image dimensions should cover the entire original field</c>
<c>    * of view in the current rectification.</c>
<c>    * Look at border of the current image in the world plane.</c>
<l>    get_system ('clip_region', ClipRegion)</l>
<l>    set_system ('clip_region', 'false')</l>
<l>    gen_rectangle1 (ImageArea, 0, 0, Height - 1, Width - 1)</l>
<l>    boundary (ImageArea, RegionBorder, 'outer')</l>
<l>    set_system ('clip_region', ClipRegion)</l>
<l>    get_region_points (RegionBorder, BorderRows, BorderColumns)</l>
<l>    image_points_to_world_plane (CamParam, MatchingPlaneInCamPose, BorderRows, BorderColumns, 'm', BorderX, BorderY)</l>
<c>    * Adapt parameters.</c>
<l>    create_pose (min(BorderX), min(BorderY), 0, 0, 0, 0, 'Rp+T', 'gba', 'point', MatchingPlaneRectifiedPartInMatchingPlanePose)</l>
<l>    pose_compose (MatchingPlaneInCamPose, MatchingPlaneRectifiedPartInMatchingPlanePose, MatchingPlaneRectifiedPartInCamPose)</l>
<l>    WidthRect := int((max(BorderX) - min(BorderX)) / ScaleRectification + 0.5)</l>
<l>    HeightRect := int((max(BorderY) - min(BorderY)) / ScaleRectification + 0.5)</l>
<c>    * </c>
<c>    * Create a map for repeated use.</c>
<l>    gen_image_to_world_plane_map (RectificationMap, CamParam, MatchingPlaneInCamPose, Width, Height, WidthRect, HeightRect, ScaleRectification, 'bilinear')</l>
<l>else</l>
<l>    throw ('Please set the parameter RectifyImage correctly')</l>
<l>endif</l>
<c>* Convert to output pose type.</c>
<l>convert_pose_type (PlaneInCamPose, OrderOfTransform, OrderOfRotation, ViewOfTransform, PlaneInCamPose)</l>
<l>convert_pose_type (CamInBasePose, OrderOfTransform, OrderOfRotation, ViewOfTransform, CamInBasePose)</l>
<l>convert_pose_type (PlaneInBasePose, OrderOfTransform, OrderOfRotation, ViewOfTransform, PlaneInBasePose)</l>
<l>convert_pose_type (MatchingPlaneInCamPose, OrderOfTransform, OrderOfRotation, ViewOfTransform, MatchingPlaneInCamPose)</l>
<l>convert_pose_type (MatchingPlaneInBasePose, OrderOfTransform, OrderOfRotation, ViewOfTransform, MatchingPlaneInBasePose)</l>
<l>convert_pose_type (MatchingPlaneRectifiedPartInCamPose, OrderOfTransform, OrderOfRotation, ViewOfTransform, MatchingPlaneRectifiedPartInCamPose)</l>
<c>* </c>
<l>create_pose (0, 0, ObjectHeight, 180, 0, 0, 'Rp+T', 'gba', 'point', ModelInPlanePose)</l>
<c>* Remember the transformation.</c>
<l>pose_invert (ModelInPlanePose, PlaneInModelPose)</l>
<c>* </c>
<c>* Create dict for Poses.</c>
<l>create_dict (Poses)</l>
<l>set_dict_tuple (Poses, 'PlaneInCamPose', PlaneInCamPose)</l>
<l>set_dict_tuple (Poses, 'CamInBasePose', CamInBasePose)</l>
<l>set_dict_tuple (Poses, 'PlaneInBasePose', PlaneInBasePose)</l>
<l>set_dict_tuple (Poses, 'MatchingPlaneInCamPose', MatchingPlaneInCamPose)</l>
<l>set_dict_tuple (Poses, 'MatchingPlaneInBasePose', MatchingPlaneInBasePose)</l>
<l>set_dict_tuple (Poses, 'PlaneInModelPose', PlaneInModelPose)</l>
<c>* </c>
<c>* Create dict for rectification data.</c>
<l>create_dict (RectificationData)</l>
<l>set_dict_tuple (RectificationData, 'RectifyImage', RectifyImage)</l>
<l>if (RectifyImage != 'no_rectification')</l>
<l>    set_dict_tuple (RectificationData, 'ScaleRectification', ScaleRectification)</l>
<l>    set_dict_object (RectificationMap, RectificationData, 'RectificationMap')</l>
<l>endif</l>
<l>set_dict_tuple (RectificationData, 'MatchingPlaneRectifiedPartInCamPose', MatchingPlaneRectifiedPartInCamPose)</l>
<l>return ()</l>
</body>
<docu id="prepare_poses_and_rectification_data_moving_cam">
<abstract lang="en_US">This procedure prepares the model needed to later match an object and grasp it in 3D, in a moving camera setup.

The input parameter ToolInBasePose describes the current pose of the robot tool. 

The input dict HandEyeCalibData must contain the poses ToolInCamPose and PlaneInBasePose0 as well as the camera parameters CamParam. Please refer to the example calibrate_hand_eye_scara_moving_cam.hdev for more details.

In ObjectHeight, the height of the object to be matched is passed.
 
The parameter RectifyImage can have on of three values: 'no_rectification', 'only_rectify', or 'align_and_rectify'. This parameter is then stored in the output dict RectificationData.

The output dict Poses contains the following data: 
- The pose PlaneInCamPose is the pose where x and y coordinates are aligned with the current image and the z-axis of the plane points away from the reference camera. 
- The pose PlaneInBasePose is the respective adaptation of PlaneInBasePose0.
- The pose PlaneInModelPose contains the pose of the plane with respect to the model.
- The pose CamInBasePose contains the pose of the camera in the base coordinate system.
- The matching plane is defined as the actual plane translated in the negative z-direction (towards the camera) by the object's height as given by ObjectHeight.The poses MatchingPlaneInCamPose and MatchingPlaneInBasePose are calculated accordingly.

The output dict RectificationData contains the following data:
- The above-mentioned parameter RectifyImage.
- The parameters ScaleRectification is the rectification scale as explained in the documentation of the image_to_world_plane operator. 
- The pose MatchingPlaneRectifiedPartInCamPose is the world pose in the camera coordinate system which is used to align the image as explained in image_to_world_plane operator.
- The RectificationMap that can be used with map_image.</abstract>
<alternatives>
<item>prepare_poses_and_rectification_data_stationary_cam</item>
</alternatives>
<chapters lang="de_DE">
<item>Kalibrierung</item>
<item>Hand-Auge</item>
</chapters>
<chapters lang="en_US">
<item>Calibration</item>
<item>Hand-Eye</item>
</chapters>
<library lang="de_DE">MVTec Standard Procedures</library>
<library lang="en_US">MVTec Standard Procedures</library>
<predecessor>
<item>set_dict_tuple</item>
</predecessor>
<short lang="en_US">Prepares the model to match and grasp.</short>
<successor>
<item>get_dict_tuple</item>
<item>get_dict_object</item>
<item>map_image</item>
<item>create_shape_model</item>
<item>rectify_image_and_compute_matching_plane_moving_cam</item>
<item>obtain_3d_pose_of_match_moving_cam</item>
</successor>
<parameters>
<parameter id="HandEyeCalibData">
<default_type>integer</default_type>
<description lang="en_US">Dict that should contain: ToolInCamPose, PlaneInBasePose0, and CamParam.</description>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>dict</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="ObjectHeight">
<default_type>real</default_type>
<description lang="en_US">Height of the object to be matched.</description>
<multivalue>false</multivalue>
<sem_type>real</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
<parameter id="Poses">
<default_type>integer</default_type>
<description lang="en_US">Dict that contains the poses PlaneInCamPose, PlaneInBasePose, PlaneInModelPose, CamInBasePose, MatchingPlaneInCamPose, and MatchingPlaneInBasePose.</description>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>dict</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="RectificationData">
<default_type>integer</default_type>
<description lang="en_US">Dict that contains RectifyImage, ScaleRectification, MatchingPlaneRectifiedPartInCamPose, and RectificationMap.</description>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>dict</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="RectifyImage">
<default_type>string</default_type>
<default_value>'only_rectify'</default_value>
<description lang="en_US">Only when the camera is perpendicular to your image plane with constant distance (might reduce runtime): 'no_rectification'
Align the images according to the matching training image and rectify: 'align_and_rectify'
Only rectify: 'only_rectify'</description>
<multivalue>false</multivalue>
<sem_type>string</sem_type>
<type_list>
<item>string</item>
</type_list>
<values>
<item>'no_rectification'</item>
<item>'align_and_rectify'</item>
<item>'only_rectify'</item>
</values>
</parameter>
<parameter id="ToolInBasePose">
<default_type>real</default_type>
<default_value>[]</default_value>
<description lang="en_US">Pose of the tool in the base coordinate system.</description>
<multivalue>true</multivalue>
<sem_type>pose</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
</parameters>
</docu>
</procedure>
<procedure name="prepare_poses_and_rectification_data_stationary_cam">
<interface>
<ic>
<par name="ObjectHeight" base_type="ctrl" dimension="0"/>
<par name="RectifyImage" base_type="ctrl" dimension="0"/>
<par name="HandEyeCalibData" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="Poses" base_type="ctrl" dimension="0"/>
<par name="RectificationData" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c>* Prepare the needed poses to match and grasp, and compute the rectification</c>
<c>* map in case rectification is set by the user.</c>
<c>* </c>
<l>read_dict_tuple (HandEyeCalibData, 'CamParam', CamParam)</l>
<l>read_dict_tuple (HandEyeCalibData, 'PlaneInCamPose0', PlaneInCamPose0)</l>
<c>* </c>
<c>* Check input</c>
<l>if (ObjectHeight &lt; 0.0)</l>
<l>    throw ('The parameter ObjectHeight cannot be negative')</l>
<l>endif</l>
<l>if (CamParam[0] =~ 'line_scan')</l>
<l>    throw ('Line-scan cameras are not supported')</l>
<l>endif</l>
<c>* Keep track of the pose type used by the robot.</c>
<l>get_pose_type (PlaneInCamPose0, OrderOfTransform, OrderOfRotation, ViewOfTransform)</l>
<c>* Convert to default pose type.</c>
<l>convert_pose_type (PlaneInCamPose0, 'Rp+T', 'gba', 'point', PlaneInCamPose0)</l>
<c>* The z-axis of the plane should point away from the camera.</c>
<l>PlaneInCamPose0Rot := PlaneInCamPose0</l>
<l>PlaneInCamPose0Rot[0:2] := [0,0,0]</l>
<l>pose_to_hom_mat3d (PlaneInCamPose0Rot, HomMat3D)</l>
<l>affine_trans_point_3d (HomMat3D, 0, 0, 1, Qx, Qy, CosAngleBetweenZAxis)</l>
<l>if (CosAngleBetweenZAxis &lt; 0)</l>
<l>    create_pose (0, 0, 0, 180, 0, 0, 'Rp+T', 'gba', 'point', SwitchZDirection)</l>
<l>    pose_compose (PlaneInCamPose0, SwitchZDirection, PlaneInCamPose0)</l>
<l>endif</l>
<c>* Align with the current image.</c>
<l>PlaneInCamPose := PlaneInCamPose0</l>
<l>PlaneInCamPose[5] := 0.0</l>
<c>* </c>
<c>* Create the plane for matching.</c>
<l>create_pose (0, 0, -ObjectHeight, 0, 0, 0, 'Rp+T', 'gba', 'point', MatchingPlaneInPlanePose)</l>
<l>pose_compose (PlaneInCamPose, MatchingPlaneInPlanePose, MatchingPlaneInCamPose)</l>
<c>* </c>
<l>if (RectifyImage == 'false')</l>
<l>    ScaleRectification := []</l>
<l>elseif (RectifyImage == 'true')</l>
<c>    * Determine the scale such that the mapped image has at least the same</c>
<c>    * resolution as the current image.</c>
<l>    get_cam_par_data (CamParam, 'image_width', Width)</l>
<l>    get_cam_par_data (CamParam, 'image_height', Height)</l>
<l>    gen_grid_region (RegionGrid, 20, 20, 'points', Width, Height)</l>
<l>    get_region_points (RegionGrid, Rows, Columns)</l>
<l>    gen_circle_contour_xld (ContCircle, Rows, Columns, gen_tuple_const(|Rows|,1.0), 0, 6.28318, 'positive', 0.1)</l>
<l>    contour_to_world_plane_xld (ContCircle, ContCircleWorldPlane, CamParam, MatchingPlaneInCamPose, 'm')</l>
<l>    fit_ellipse_contour_xld (ContCircleWorldPlane, 'fitzgibbon', -1, 0, 0, 200, 3, 2, Row, Column, Phi, Radius1, Radius2, StartPhi, EndPhi, PointOrder)</l>
<l>    ScaleRectification := min(Radius2)</l>
<c>    * </c>
<c>    * Rectify the current image and create the shape model.</c>
<c>    * </c>
<c>    * The image dimensions should cover the entire original field of view</c>
<c>    * in the current rectification.</c>
<c>    * Look at border of the current image in the world plane.</c>
<l>    get_system ('clip_region', ClipRegion)</l>
<l>    set_system ('clip_region', 'false')</l>
<l>    gen_rectangle1 (ImageArea, 0, 0, Height - 1, Width - 1)</l>
<l>    boundary (ImageArea, RegionBorder, 'outer')</l>
<l>    set_system ('clip_region', ClipRegion)</l>
<l>    get_region_points (RegionBorder, BorderRows, BorderColumns)</l>
<l>    image_points_to_world_plane (CamParam, MatchingPlaneInCamPose, BorderRows, BorderColumns, 'm', BorderX, BorderY)</l>
<c>    * Adapt parameters.</c>
<l>    create_pose (min(BorderX), min(BorderY), 0, 0, 0, 0, 'Rp+T', 'gba', 'point', PoseOffset)</l>
<l>    pose_compose (MatchingPlaneInCamPose, PoseOffset, MatchingPlaneInCamPose)</l>
<l>    WidthRect := int((max(BorderX) - min(BorderX)) / ScaleRectification + 0.5)</l>
<l>    HeightRect := int((max(BorderY) - min(BorderY)) / ScaleRectification + 0.5)</l>
<c>    * </c>
<c>    * Create a map for repeated use.</c>
<l>    gen_image_to_world_plane_map (RectificationMap, CamParam, MatchingPlaneInCamPose, Width, Height, WidthRect, HeightRect, ScaleRectification, 'bilinear')</l>
<l>else</l>
<l>    throw ('Please set the parameter RectifyImage correctly')</l>
<l>endif</l>
<c>* Convert to output pose type.</c>
<l>convert_pose_type (PlaneInCamPose, OrderOfTransform, OrderOfRotation, ViewOfTransform, PlaneInCamPose)</l>
<l>convert_pose_type (MatchingPlaneInCamPose, OrderOfTransform, OrderOfRotation, ViewOfTransform, MatchingPlaneInCamPose)</l>
<c>* </c>
<l>create_pose (0, 0, ObjectHeight, 180, 0, 0, 'Rp+T', 'gba', 'point', ModelInPlanePose)</l>
<c>* Remember the transformation.</c>
<l>pose_invert (ModelInPlanePose, PlaneInModelPose)</l>
<c>* </c>
<c>* Create dict for Poses.</c>
<l>create_dict (Poses)</l>
<l>set_dict_tuple (Poses, 'PlaneInModelPose', PlaneInModelPose)</l>
<l>set_dict_tuple (Poses, 'MatchingPlaneInCamPose', MatchingPlaneInCamPose)</l>
<l>set_dict_tuple (Poses, 'PlaneInCamPose', PlaneInCamPose)</l>
<c>* </c>
<c>* Create dict for rectification data.</c>
<l>create_dict (RectificationData)</l>
<l>set_dict_tuple (RectificationData, 'RectifyImage', RectifyImage)</l>
<l>if (RectifyImage == 'true')</l>
<l>    set_dict_tuple (RectificationData, 'ScaleRectification', ScaleRectification)</l>
<l>    set_dict_object (RectificationMap, RectificationData, 'RectificationMap')</l>
<l>endif</l>
<l>return ()</l>
</body>
<docu id="prepare_poses_and_rectification_data_stationary_cam">
<abstract lang="en_US">The procedure prepare_poses_and_rectification_data_stationary_cam prepares the model needed to later match an object and grasp it in 3D, in a stationary camera setup. 

In ObjectHeight, the height of the object to be matched is passed.

The parameter RectifyImage specifies whether the input image is to be rectified of not. To improve the 2D matching, it is recommended to set it 'true'. This parameter is then stored in the output dict RectificationData.

The input dict HandEyeCalibrationData contains the pose PlaneInCamPose0 and the camera parameters CamParam, which can be both found through hand-eye calibration in a moving camera setup. Please refer to the example calibrate_hand_eye_stationary_cam_approx.hdev for more details.

The output dict Poses contains the following data: 
- The output pose PlaneInCamPose is the pose where x and y coordinates are aligned with the current image and the z-axis of the plane points away from the reference camera.
- The pose PlaneInModelPose contains the pose of the plane with respect to the model.
- The matching plane is defined as the actual plane translated in the negative z-direction (towards the camera) by the object's height as given by ObjectHeight.The pose MatchingPlaneInCamPose is calculated accordingly.

The output dict RectificationData contains the following data:
- The above-mentioned parameter RectifyImage.
- The parameters ScaleRectification is the rectification scale as explained in the documentation of the image_to_world_plane operator. 
- The rectification map that can be used with map_image.</abstract>
<alternatives>
<item>prepare_poses_and_rectification_data_moving_cam</item>
</alternatives>
<chapters lang="de_DE">
<item>Kalibrierung</item>
<item>Hand-Auge</item>
</chapters>
<chapters lang="en_US">
<item>Calibration</item>
<item>Hand-Eye</item>
</chapters>
<library lang="en_US">MVTec Standard Procedures</library>
<predecessor>
<item>set_dict_tuple</item>
</predecessor>
<short lang="en_US">Prepares the model to match and grasp in a stationary camera setup.</short>
<successor>
<item>get_dict_tuple</item>
<item>get_dict_object</item>
<item>map_image</item>
<item>create_shape_model</item>
</successor>
<parameters>
<parameter id="HandEyeCalibData">
<default_type>integer</default_type>
<description lang="en_US">Dict that should contain CamParam and PlaneInCamPose0.</description>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>dict</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="ObjectHeight">
<default_type>real</default_type>
<description lang="en_US">Height of the object to be matched.</description>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>real</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
<parameter id="Poses">
<default_type>integer</default_type>
<description lang="en_US">Dict that contains: PlaneInModelPose, MatchingPlaneInCamPose, and PlaneInCamPose.</description>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>dict</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="RectificationData">
<default_type>integer</default_type>
<description lang="en_US">Dict that contains: RectifyImage, ScaleRectification, and RectificationMap.</description>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>dict</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="RectifyImage">
<default_type>string</default_type>
<default_value>'true'</default_value>
<description lang="en_US">Specify whether to rectify the image or not. Set it to 'false' only if the camera is orthogonal to your image plane with constant distance. This might reduce runtime.</description>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>string</sem_type>
<type_list>
<item>string</item>
</type_list>
<value_list>
<item>'true'</item>
<item>'false'</item>
</value_list>
</parameter>
</parameters>
</docu>
</procedure>
<procedure name="preprocess_dl_classifier_images">
<interface>
<io>
<par name="Images" base_type="iconic" dimension="0"/>
</io>
<oo>
<par name="ImagesPreprocessed" base_type="iconic" dimension="0"/>
</oo>
<ic>
<par name="GenParamName" base_type="ctrl" dimension="0"/>
<par name="GenParamValue" base_type="ctrl" dimension="0"/>
<par name="DLClassifierHandle" base_type="ctrl" dimension="0"/>
</ic>
</interface>
<body>
<c>* This procedure preprocesses the provided images given by Image</c>
<c>* so that they can be handled by</c>
<c>* train_dl_classifier_batch and apply_dl_classifier_batch.</c>
<c>* Note that depending on the images,</c>
<c>* additional preprocessing steps might be beneficial.</c>
<c>* </c>
<c>* Set defaults.</c>
<l>ContrastNormalization := 'false'</l>
<l>DomainHandling := 'full_domain'</l>
<c>* Set generic parameters.</c>
<l>for GenParamIndex := 0 to |GenParamName| - 1 by 1</l>
<l>    if (GenParamName[GenParamIndex] == 'contrast_normalization')</l>
<c>        * Set 'contrast_normalization'</c>
<l>        ContrastNormalization := GenParamValue[GenParamIndex]</l>
<l>    elseif (GenParamName[GenParamIndex] == 'domain_handling')</l>
<c>        * Set 'domain_handling'</c>
<l>        DomainHandling := GenParamValue[GenParamIndex]</l>
<l>    else</l>
<l>        throw ('Unknown generic parameter: \'' + GenParamName[GenParamIndex] + '\'')</l>
<l>    endif</l>
<l>endfor</l>
<c>* </c>
<c>* Get the network's image requirements</c>
<c>* from the handle of the classifier</c>
<c>* and use them as preprocessing parameters.</c>
<c>* </c>
<c>* Expected input image size:</c>
<l>get_dl_classifier_param (DLClassifierHandle, 'image_width', ImageWidth)</l>
<l>get_dl_classifier_param (DLClassifierHandle, 'image_height', ImageHeight)</l>
<c>* Expected gray value range:</c>
<l>get_dl_classifier_param (DLClassifierHandle, 'image_range_min', ImageRangeMin)</l>
<l>get_dl_classifier_param (DLClassifierHandle, 'image_range_max', ImageRangeMax)</l>
<c>* Expected number of channels:</c>
<l>get_dl_classifier_param (DLClassifierHandle, 'image_num_channels', ImageNumChannels)</l>
<c>* </c>
<c>* Preprocess the images.</c>
<c>* </c>
<l>if (DomainHandling == 'full_domain')</l>
<l>    full_domain (Images, Images)</l>
<l>elseif (DomainHandling == 'crop_domain')</l>
<l>    crop_domain (Images, Images)</l>
<l>else</l>
<l>    throw ('Unsupported parameter value for \'domain_handling\'')</l>
<l>endif</l>
<c>* </c>
<c>* Zoom images only if they have a different size than the specified size</c>
<l>get_image_size (Images, ImageWidthInput, ImageHeightInput)</l>
<l>EqualWidth := ImageWidth [==] ImageWidthInput</l>
<l>EqualHeight := ImageHeight [==] ImageHeightInput</l>
<l>if (min(EqualWidth) == 0 or min(EqualHeight) == 0)</l>
<l>    zoom_image_size (Images, Images, ImageWidth, ImageHeight, 'constant')</l>
<l>endif</l>
<l>if (ContrastNormalization == 'true')</l>
<c>    * Check the type of the input images.</c>
<c>    * Contrast normalization works here only for byte, integer and real images.</c>
<l>    get_image_type (Images, Type)</l>
<l>    tuple_regexp_test (Type, 'byte|int|real', NumMatches)</l>
<l>    count_obj (Images, NumImages)</l>
<l>    if (NumMatches != NumImages)</l>
<l>        throw ('In case of contrast normalization, please provide only images of type \'byte\', \'int1\', \'int2\', \'uint2\', \'int4\', \'int8\', or \'real\'.')</l>
<l>    endif</l>
<c>    * </c>
<c>    * Perform contrast normalization</c>
<l>    if (Type == 'byte')</l>
<c>        * Scale the gray values to [0-255].</c>
<l>        scale_image_max (Images, Images)</l>
<l>    else</l>
<c>        * Scale the gray values to [ImageRangeMin-ImageRangeMax].</c>
<c>        * Scaling is performed separately for each image.</c>
<l>        gen_empty_obj (ImagesNew)</l>
<l>        for ImageIndex := 1 to NumImages by 1</l>
<l>            select_obj (Images, ImageSelected, ImageIndex)</l>
<l>            min_max_gray (ImageSelected, ImageSelected, 0, Min, Max, Range)</l>
<l>            Scale := (ImageRangeMax - ImageRangeMin) / (Max - Min)</l>
<l>            Shift := -Scale * Min + ImageRangeMin</l>
<l>            scale_image (ImageSelected, ImageSelected, Scale, Shift)</l>
<l>            concat_obj (ImagesNew, ImageSelected, ImagesNew)</l>
<l>        endfor</l>
<l>        Images := ImagesNew</l>
<c>        * Integer image convert to real image</c>
<l>        if (Type != 'real')</l>
<l>            convert_image_type (Images, Images, 'real')</l>
<l>        endif</l>
<l>    endif</l>
<l>elseif (ContrastNormalization != 'false')</l>
<l>    throw ('Unsupported parameter value for \'contrast_normalization\'')</l>
<l>endif</l>
<c>* Check the type of the input images.</c>
<c>* If the type is not 'byte',</c>
<c>* the gray value scaling does not work correctly.</c>
<l>get_image_type (Images, Type)</l>
<l>tuple_regexp_test (Type, 'byte|real', NumMatches)</l>
<l>count_obj (Images, NumImages)</l>
<l>if (NumMatches != NumImages)</l>
<l>    throw ('Please provide only images of type \'byte\' or \'real\'.')</l>
<l>endif</l>
<l>EqualByte := Type [==] 'byte'</l>
<l>if (max(EqualByte) == 1)</l>
<l>    if (min(EqualByte) == 0)</l>
<l>        throw ('Passing mixed type images is not supported.')</l>
<l>    endif</l>
<c>    * Convert the image type from byte to real,</c>
<c>    * because the classifier expects 'real' images.</c>
<l>    convert_image_type (Images, Images, 'real')</l>
<c>    * Scale/Shift the gray values from [0-255] to the expected range.</c>
<l>    RescaleRange := (ImageRangeMax - ImageRangeMin) / 255.0</l>
<l>    scale_image (Images, Images, RescaleRange, ImageRangeMin)</l>
<l>else</l>
<c>    * For real images it is assumed that the range is already correct</c>
<l>endif</l>
<c></c>
<c>* Check the number of channels.</c>
<l>count_obj (Images, NumImages)</l>
<l>for ImageIndex := 1 to NumImages by 1</l>
<l>    select_obj (Images, ObjectSelected, ImageIndex)</l>
<l>    count_channels (ObjectSelected, NumChannels)</l>
<l>    if (NumChannels != ImageNumChannels)</l>
<c>        * </c>
<l>        if (NumChannels == 1 and ImageNumChannels == 3)</l>
<c>            * If the image is a grayscale image, but the classifier expects a color image:</c>
<c>            * convert it to an image with three channels.</c>
<l>            compose3 (ObjectSelected, ObjectSelected, ObjectSelected, ThreeChannelImage)</l>
<l>            replace_obj (Images, ThreeChannelImage, Images, ImageIndex)</l>
<l>        elseif (NumChannels == 3 and ImageNumChannels == 1)</l>
<c>            * If the image is a color image, but the classifier expects a grayscale image:</c>
<c>            * convert it to an image with only one channel.</c>
<l>            rgb1_to_gray (ObjectSelected, SingleChannelImage)</l>
<l>            replace_obj (Images, SingleChannelImage, Images, ImageIndex)</l>
<l>        else</l>
<l>            throw ('Number of channels not supported. Please provide a grayscale or an RGB image.')</l>
<l>        endif</l>
<c>        * </c>
<l>    endif</l>
<l>endfor</l>
<l>ImagesPreprocessed := Images</l>
<l>return ()</l>
</body>
<docu id="preprocess_dl_classifier_images">
<abstract lang="en_US">This procedure preprocesses the provided images given by Images so that they can be handled by train_dl_classifier_batch and apply_dl_classifier_batch. Note that depending on the data set, additional preprocessing steps might be beneficial. The preprocessed images are returned in ImagePreprocessed. The network's image requirements are provided by the DLClassifierHandle.

The deep-learning-based classifier has certain requirements on the images. In this procedure, the width, height, number of channels, and image type of each image is adapted accordingly. To do so, the following types are accepted for the input images: 'real', 'byte', and in case of 'contrast_normalization' equals 'true' also integer-formats.

It is required that all images passed to train_dl_classifier_batch and apply_dl_classifier_batch are provided as returned by this procedure. For the training, for example, you can do this step at the beginning of your program for all images, or alternatively for each batch that is trained separately. 

The following values for GenParamName are available:

  * 'domain_handling': By default, it is set to 'full_domain'. Thus, reduced domains of images are ignored and the complete image is preprocessed. You can set it to 'crop_domain' to use the domains that were specified before with, for example, reduce_domain, to crop the images. 

  * 'contrast_normalization': Depending on the images, it can be beneficial for the deep classification to apply a contrast normalization. If 'contrast_normalization' is set to 'true', the gray values of every image are scaled to the maximum value range. The default is 'false'. 

It is recommended to check the output images of this procedure to verify that they are suitable for a successful training of a classifier. For example, if after zooming defects on the images are no longer discernible, you have to choose a better image segment, where the defects are more prominent in the image.</abstract>
<chapters lang="en_US">
<item>Legacy</item>
<item>DL Classification</item>
</chapters>
<library lang="en_US">MVTec Standard Procedures</library>
<short lang="en_US">Preprocess images for deep-learning-based classification training and inference.</short>
<warning lang="en_US">preprocess_dl_classifier_images is obsolete and is only provided for reasons of backward compatibility.
New applications should use the general CNN-based procedure preprocess_dl_dataset.</warning>
<parameters>
<parameter id="DLClassifierHandle">
<default_type>integer</default_type>
<description lang="en_US">Handle of the deep-learning-based classifier.</description>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>dl_classifier</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="GenParamName">
<default_type>string</default_type>
<default_value>[]</default_value>
<description lang="en_US">Name of the generic parameter.</description>
<mixed_type>false</mixed_type>
<multivalue>optional</multivalue>
<sem_type>attribute.name</sem_type>
<type_list>
<item>string</item>
</type_list>
<values>
<item>'contrast_normalization'</item>
<item>'domain_handling'</item>
</values>
</parameter>
<parameter id="GenParamValue">
<default_type>string</default_type>
<default_value>[]</default_value>
<description lang="en_US">Value of the generic parameter.</description>
<mixed_type>optional</mixed_type>
<multivalue>optional</multivalue>
<sem_type>attribute.value</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
<item>string</item>
</type_list>
<values>
<item>'true'</item>
<item>'false'</item>
<item>'full_domain'</item>
<item>'crop_domain'</item>
</values>
</parameter>
<parameter id="Images">
<description lang="en_US">Images that are preprocessed.</description>
<multichannel>optional</multichannel>
<multivalue>optional</multivalue>
<sem_type>image</sem_type>
<type_list>
<item>byte</item>
<item>int1</item>
<item>int2</item>
<item>uint2</item>
<item>int4</item>
<item>int8</item>
<item>real</item>
</type_list>
</parameter>
<parameter id="ImagesPreprocessed">
<description lang="en_US">Preprocessed images.</description>
<multichannel>true</multichannel>
<multivalue>optional</multivalue>
<sem_type>image</sem_type>
<type_list>
<item>real</item>
</type_list>
</parameter>
</parameters>
</docu>
</procedure>
<procedure name="preprocess_dl_dataset">
<interface>
<ic>
<par name="DLDataset" base_type="ctrl" dimension="0"/>
<par name="DataDirectory" base_type="ctrl" dimension="0"/>
<par name="DLPreprocessParam" base_type="ctrl" dimension="0"/>
<par name="GenParam" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="DLDatasetFileName" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c>* </c>
<c>* This procedure preprocesses the samples in the dictionary DLDataset.</c>
<c>* </c>
<c>* ** Parameters values: ***</c>
<c>* </c>
<c>* Set the default values.</c>
<c>* Overwrite existing DLDataset file and DLSample directory.</c>
<l>OverwriteFiles := false</l>
<c>* By default we show the progress of preprocessing.</c>
<l>ShowProgress := true</l>
<c>* Class weights specified by user (needed for segmentation)</c>
<l>ClassWeightsSegmentation := []</l>
<c>* Set max weight. Parameter for calculating the weights (needed for segmentation).</c>
<l>MaxWeight := 1000</l>
<c>* </c>
<c>* Check the validity of the preprocessing parameters.</c>
<l>check_dl_preprocess_param (DLPreprocessParam)</l>
<c>* Get the model type.</c>
<l>get_dict_tuple (DLPreprocessParam, 'model_type', DLModelType)</l>
<c>* </c>
<c>* Initialize the generic parameters for gen_dl_samples.</c>
<l>GenParamGenDLSamples := []</l>
<c>* Check if the background class ID is part of the DLDataset class IDs.</c>
<l>if (DLModelType == 'segmentation')</l>
<l>    get_dict_tuple (DLDataset, 'class_ids', ClassIDsDataset)</l>
<l>    get_dict_tuple (DLPreprocessParam, 'set_background_id', SetBackgroundID)</l>
<l>    if (|SetBackgroundID| &gt; 0)</l>
<l>        tuple_find (ClassIDsDataset, SetBackgroundID, Indices)</l>
<l>        if (Indices == -1)</l>
<l>            throw ('The \'set_background_id\':\'' + SetBackgroundID + '\' needs to be part of the DLDataset \'class_ids\' tuple.')</l>
<l>        endif</l>
<l>    endif</l>
<l>elseif (DLModelType == 'detection')</l>
<l>    create_dict (GenParamGenDLSamples)</l>
<l>    get_dict_param (DLPreprocessParam, 'key_exists', 'instance_type', KeyExists)</l>
<l>    if (KeyExists)</l>
<l>        get_dict_tuple (DLPreprocessParam, 'instance_type', InstanceType)</l>
<l>        set_dict_tuple (GenParamGenDLSamples, 'instance_type', InstanceType)</l>
<l>    else</l>
<l>        set_dict_tuple (GenParamGenDLSamples, 'instance_type', 'rectangle1')</l>
<l>    endif</l>
<l>endif</l>
<c>* </c>
<c>* Set the parameters for preprocess_dl_samples.</c>
<l>set_dict_tuple (DLDataset, 'preprocess_param', DLPreprocessParam)</l>
<c>* </c>
<c>* Transfer generic parameters.</c>
<l>if (GenParam != [])</l>
<l>    get_dict_param (GenParam, 'keys', [], GenParamName)</l>
<l>    for GenParamIndex := 0 to |GenParamName| - 1 by 1</l>
<l>        if (GenParamName[GenParamIndex] == 'overwrite_files')</l>
<l>            get_dict_tuple (GenParam, 'overwrite_files', OverwriteFiles)</l>
<l>        elseif (GenParamName[GenParamIndex] == 'show_progress')</l>
<l>            get_dict_tuple (GenParam, 'show_progress', ShowProgress)</l>
<l>            ShowProgress := ShowProgress == 'true' or ShowProgress == true</l>
<l>        elseif (GenParamName[GenParamIndex] == 'max_weight')</l>
<l>            get_dict_tuple (GenParam, 'max_weight', MaxWeight)</l>
<l>            if (DLModelType != 'segmentation')</l>
<l>                throw ('The preprocessing parameter \'max_weight\' only applies for segmentation models.')</l>
<l>            endif</l>
<l>        elseif (GenParamName[GenParamIndex] == 'class_weights')</l>
<l>            get_dict_tuple (GenParam, 'class_weights', ClassWeightsSegmentation)</l>
<l>            if (DLModelType != 'segmentation')</l>
<l>                throw ('The preprocessing parameter \'class_weights\' only applies for segmentation models.')</l>
<l>            endif</l>
<l>        else</l>
<l>            throw ('Unknown generic parameter: \'' + GenParamName[GenParamIndex] + '\'')</l>
<l>        endif</l>
<l>    endfor</l>
<l>endif</l>
<c>* </c>
<c>* ** Clean/Create data directory: ***</c>
<l>tuple_regexp_replace (DataDirectory, '/+$', '', DataDirectory)</l>
<l>file_exists (DataDirectory, FileExists)</l>
<l>if (FileExists and not OverwriteFiles)</l>
<l>    throw ('The folder ' + DataDirectory + ' already exists. Either give a different directory or force overwriting using the parameter \'overwrite_files\'.')</l>
<l>endif</l>
<l>if (FileExists)</l>
<l>    remove_dir_recursively (DataDirectory)</l>
<l>endif</l>
<l>make_dir (DataDirectory)</l>
<c>* </c>
<c>* Create the directory for the DLSamples, if it does not exist.</c>
<c>* </c>
<c>* Sample directory name.</c>
<l>DLSampleDir := DataDirectory + '/samples'</l>
<l>make_dir (DLSampleDir)</l>
<c>* </c>
<c>* Set the output path.</c>
<l>set_dict_tuple (DLDataset, 'dlsample_dir', DLSampleDir)</l>
<c>* </c>
<c>* ** Preprocess all images in the dataset: ***</c>
<c>* During training/validation and testing those preprocessed images</c>
<c>* will be used for performance reasons.</c>
<c>* </c>
<c>* Get the samples to be preprocessed.</c>
<l>get_dict_tuple (DLDataset, 'samples', DLDatasetSamples)</l>
<c>* </c>
<c>* Initialize progress variables.</c>
<l>if (ShowProgress)</l>
<l>    Progress := ['Procedure: preprocess_dl_dataset','','','']</l>
<l>    if (DLModelType == 'segmentation')</l>
<l>        Progress := [Progress,'Task: 1/2: image preprocessing']</l>
<l>    endif</l>
<l>    count_seconds (SecondsStart)</l>
<l>    dev_inspect_ctrl (Progress)</l>
<l>endif</l>
<c>* </c>
<c>* Loop over all samples.</c>
<l>for SampleIndex := 0 to |DLDatasetSamples| - 1 by 1</l>
<c>    * </c>
<c>    * Generate the dictionary DLSample.</c>
<l>    gen_dl_samples (DLDataset, SampleIndex, DLModelType, GenParamGenDLSamples, DLSampleBatch)</l>
<c>    * </c>
<c>    * Preprocess the DLSample.</c>
<l>    preprocess_dl_samples (DLSampleBatch, DLPreprocessParam)</l>
<c>    * </c>
<c>    * Write the preprocessed images.</c>
<l>    write_dl_samples (DLDataset, SampleIndex, DLSampleBatch, [], [])</l>
<c>    * </c>
<c>    * Provide progress information.</c>
<l>    if (ShowProgress and (SampleIndex % 10 == 1 or SampleIndex == |DLDatasetSamples| - 1))</l>
<l>        estimate_progress (SecondsStart, 0, SampleIndex, |DLDatasetSamples| - 1, SecondsElapsed, SecondsRemaining, ProgressPercent, ProgressPerSecond)</l>
<l>        timespan_string (SecondsElapsed, 'auto', TimeElapsedString)</l>
<l>        timespan_string (SecondsRemaining, 'top2', TimeRemainingString)</l>
<l>        Progress[1] := 'Progress: ' + round(ProgressPercent) + ' %'</l>
<l>        Progress[2] := 'Time elapsed: ' + TimeElapsedString</l>
<l>        Progress[3] := 'Time left: ' + TimeRemainingString</l>
<l>    endif</l>
<l>endfor</l>
<c>* </c>
<c>* If the model is of type segmentation, generate weight images.</c>
<l>if (DLModelType == 'segmentation')</l>
<c>    * </c>
<l>    if (ShowProgress)</l>
<l>        Progress := ['Procedure: preprocess_dl_dataset','','']</l>
<l>        Progress[1] := 'Please wait...'</l>
<l>        Progress[2] := 'Task: 2/2: calculating class weights'</l>
<l>    endif</l>
<l>    if (|ClassWeightsSegmentation| == 0)</l>
<c>        * Calculate the class weights for segmentation.</c>
<l>        get_dict_tuple (DLPreprocessParam, 'ignore_class_ids', IgnoreClassIDs)</l>
<l>        calculate_dl_segmentation_class_weights (DLDataset, MaxWeight, IgnoreClassIDs, ClassWeightsSegmentation)</l>
<l>    endif</l>
<c>    * </c>
<c>    * Generate the weight images.</c>
<l>    gen_dl_segmentation_weight_images (DLDataset, DLPreprocessParam, ClassWeightsSegmentation, [])</l>
<l>endif</l>
<l>if (not ShowProgress)</l>
<l>    Progress := 'Done.'</l>
<l>    dev_close_inspect_ctrl (Progress)</l>
<l>endif</l>
<c>* </c>
<c>* Write the DLDataset dict.</c>
<l>DLDatasetFileName := DataDirectory + '/dl_dataset.hdict'</l>
<l>write_dict (DLDataset, DLDatasetFileName, [], [])</l>
<l>return ()</l>
</body>
<docu id="preprocess_dl_dataset">
<abstract lang="en_US">This procedure preprocesses the samples in the dictionary DLDataset according to the parameters in the dictionary DLPreprocessParam.
The modified dictionary DLDataset and the dictionaries of the preprocessed samples, DLSample, are written to files in the specified DataDirectory, whereby the name and path of the DLDataset is returned in the string DLDatasetFileName.

The steps this procedure executes:
- Generation of a DLSample dictionary for every sample using gen_dl_samples.
- Standard preprocessing using preprocess_dl_samples.
- Writing the DLSample dictionaries to files using write_dict and store the path of the files in the dictionary DLDataset in the entry 'dlsample_file_name'.
- Write the DLDataset dictionary including the paths of the generated and preprocessed DLSample dictionaries to DLDatasetFileName.
For details on the steps, please refer to the documentation of the individual procedures.

For models of type segmentation the weight images are created in addition. These steps are:
- Calculate the class weights using calculate_dl_segmentation_class_weights.
- Generate a weight image for each DLSample according to the calculated values and save the updated DLSamples.

This procedure accepts the following generic parameters in the dictionary GenParam:
- 'overwrite_files': If set to 'true', a possibly existing directory DataDirectory is removed before the files are written. If set to 'false' an error is thrown if the directory exists. The default is false.
- 'show_progress': If set to true, the progress of preprocessing is displayed in a window. The default is true.
- 'class_weights': Set a weight for each class in the DLDataset. If set to [] (default) the class weights are calculated using calculate_dl_segmentation_class_weights. This is only applicable for models of type segmentation.
- 'max_weight': Set the 'max_weight' parameter of calculate_dl_segmentation_class_weights, see respective documentation for details. The default is []. This is only applicable for models of type segmentation.

Attention:
Please note, that you should not change the content of this folder after preprocessing.
</abstract>
<chapters lang="de_DE">
<item>Deep Learning</item>
<item>Modell</item>
</chapters>
<chapters lang="en_US">
<item>Deep Learning</item>
<item>Model</item>
</chapters>
<library lang="en_US">MVTec Standard Procedures</library>
<short lang="en_US">Standard preprocessing on the entire dataset declared in DLDataset.</short>
<parameters>
<parameter id="DLDataset">
<default_type>integer</default_type>
<description lang="en_US">DLDataset dictionary to be preprocessed.</description>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>dict</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="DLDatasetFileName">
<default_type>string</default_type>
<description lang="en_US">File path of the written DLDataset dictionary.</description>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>string</sem_type>
<type_list>
<item>string</item>
</type_list>
</parameter>
<parameter id="DLPreprocessParam">
<default_type>integer</default_type>
<description lang="en_US">Dictionary containing the preprocessing parameters.</description>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>dict</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="DataDirectory">
<default_type>string</default_type>
<default_value>'dl_dataset'</default_value>
<description lang="en_US">Path where to store the data.</description>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>filename</sem_type>
<type_list>
<item>string</item>
</type_list>
</parameter>
<parameter id="GenParam">
<default_type>integer</default_type>
<default_value>[]</default_value>
<description lang="en_US">Dictionary with the generic parameters.
</description>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>any</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
</parameters>
</docu>
</procedure>
<procedure name="preprocess_dl_model_anomaly">
<interface>
<io>
<par name="AnomalyImages" base_type="iconic" dimension="0"/>
</io>
<oo>
<par name="AnomalyImagesPreprocessed" base_type="iconic" dimension="0"/>
</oo>
<ic>
<par name="DLPreprocessParam" base_type="ctrl" dimension="0"/>
</ic>
</interface>
<body>
<c>* </c>
<c>* This procedure preprocesses the anomaly images given by AnomalyImages</c>
<c>* according to the parameters in the dictionary DLPreprocessParam.</c>
<c>* Note that depending on the images,</c>
<c>* additional preprocessing steps might be beneficial.</c>
<c>* </c>
<c>* Check the validity of the preprocessing parameters.</c>
<l>check_dl_preprocess_param (DLPreprocessParam)</l>
<c>* </c>
<c>* Get the preprocessing parameters.</c>
<l>get_dict_tuple (DLPreprocessParam, 'image_width', ImageWidth)</l>
<l>get_dict_tuple (DLPreprocessParam, 'image_height', ImageHeight)</l>
<l>get_dict_tuple (DLPreprocessParam, 'image_range_min', ImageRangeMin)</l>
<l>get_dict_tuple (DLPreprocessParam, 'image_range_max', ImageRangeMax)</l>
<l>get_dict_tuple (DLPreprocessParam, 'domain_handling', DomainHandling)</l>
<l>get_dict_tuple (DLPreprocessParam, 'model_type', ModelType)</l>
<c>* </c>
<l>ImageNumChannels := 1</l>
<c>* </c>
<c>* Preprocess the images.</c>
<c>* </c>
<l>if (DomainHandling == 'full_domain')</l>
<l>    full_domain (AnomalyImages, AnomalyImages)</l>
<l>elseif (DomainHandling == 'crop_domain')</l>
<l>    crop_domain (AnomalyImages, AnomalyImages)</l>
<l>elseif (DomainHandling == 'keep_domain' and ModelType == 'anomaly_detection')</l>
<c>    * Anomaly detection models accept the additional option 'keep_domain'.</c>
<l>else</l>
<l>    throw ('Unsupported parameter value for \'domain_handling\'')</l>
<l>endif</l>
<c>* </c>
<l>min_max_gray (AnomalyImages, AnomalyImages, 0, Min, Max, Range)</l>
<l>if (Min &lt; 0.0)</l>
<l>    throw ('Values of anomaly image must not be smaller than 0.0.')</l>
<l>endif</l>
<c>* </c>
<c>* Zoom images only if they have a different size than the specified size.</c>
<l>get_image_size (AnomalyImages, ImageWidthInput, ImageHeightInput)</l>
<l>EqualWidth := ImageWidth [==] ImageWidthInput</l>
<l>EqualHeight := ImageHeight [==] ImageHeightInput</l>
<l>if (min(EqualWidth) == 0 or min(EqualHeight) == 0)</l>
<l>    zoom_image_size (AnomalyImages, AnomalyImages, ImageWidth, ImageHeight, 'nearest_neighbor')</l>
<l>endif</l>
<c>* </c>
<c>* Check the type of the input images.</c>
<l>get_image_type (AnomalyImages, Type)</l>
<l>tuple_regexp_test (Type, 'byte|real', NumMatches)</l>
<l>count_obj (AnomalyImages, NumImages)</l>
<l>if (NumMatches != NumImages)</l>
<l>    throw ('Please provide only images of type \'byte\' or \'real\'.')</l>
<l>endif</l>
<c>* </c>
<c>* If the type is 'byte', convert it to 'real' and scale it.</c>
<c>* The gray value scaling does not work on 'byte' images.</c>
<c>* For 'real' images it is assumed that the range is already correct.</c>
<l>EqualByte := Type [==] 'byte'</l>
<l>if (max(EqualByte) == 1)</l>
<l>    if (min(EqualByte) == 0)</l>
<l>        throw ('Passing mixed type images is not supported.')</l>
<l>    endif</l>
<c>    * Convert the image type from 'byte' to 'real',</c>
<c>    * because the model expects 'real' images.</c>
<l>    convert_image_type (AnomalyImages, AnomalyImages, 'real')</l>
<l>endif</l>
<c>* </c>
<c>* Check the number of channels.</c>
<l>count_obj (AnomalyImages, NumImages)</l>
<c>* Check all images for number of channels.</c>
<l>count_channels (AnomalyImages, NumChannelsAllImages)</l>
<l>tuple_gen_const (NumImages, ImageNumChannels, ImageNumChannelsTuple)</l>
<l>tuple_find (NumChannelsAllImages [!=] ImageNumChannelsTuple, 1, IndicesWrongChannels)</l>
<c>* </c>
<c>* Check for anomaly image channels.</c>
<c>* Only single channel images are accepted.</c>
<l>if (IndicesWrongChannels != -1)</l>
<l>    throw ('Number of channels in anomaly image is not supported. Please check for anomaly images with a number of channels different from 1.')</l>
<l>endif</l>
<c>* </c>
<c>* Write preprocessed image to output variable.</c>
<l>AnomalyImagesPreprocessed := AnomalyImages</l>
<c>* </c>
<l>return ()</l>
</body>
<docu id="preprocess_dl_model_anomaly">
<abstract lang="en_US">This procedure preprocesses the anomaly images given by AnomalyImages which can be used as ground truth for evaluation and visualization.
The dictionary DLPreprocessParam specifies the properties the images need to be used as ground truth for anomaly detection model.
The AnomalyImages are, if necessary, modified in order to fulfill the following requirements:
- image size: set to the sample image size
- image type: set to real
The preprocessed images are returned in AnomalyImagesPreprocessed.

The dictionary DLPreprocessParam can be created using e.g., create_dl_preprocess_param or create_dl_preprocess_param_from_model.
For further information on the parameters to be set in DLPreprocessParam, see the documentation of preprocess_dl_samples.</abstract>
<chapters lang="de_DE">
<item>Deep Learning</item>
<item>Modell</item>
</chapters>
<chapters lang="en_US">
<item>Deep Learning</item>
<item>Model</item>
</chapters>
<library lang="en_US">MVTec Standard Procedures</library>
<short lang="en_US">Preprocess anomaly images for evaluation and visualization of the deep-learning-based anomaly detection.</short>
<parameters>
<parameter id="AnomalyImages">
<description lang="en_US">Images to be preprocessed.</description>
<multichannel>optional</multichannel>
<multivalue>optional</multivalue>
<sem_type>image</sem_type>
<type_list>
<item>byte</item>
<item>int1</item>
<item>int2</item>
<item>uint2</item>
<item>int4</item>
<item>int8</item>
<item>real</item>
</type_list>
</parameter>
<parameter id="AnomalyImagesPreprocessed">
<description lang="en_US">Preprocessed images.</description>
<multichannel>optional</multichannel>
<multivalue>optional</multivalue>
<sem_type>image</sem_type>
<type_list>
<item>real</item>
</type_list>
</parameter>
<parameter id="DLPreprocessParam">
<default_type>integer</default_type>
<description lang="en_US">Dictionary containing the preprocessing parameters.</description>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>dict</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
</parameters>
</docu>
</procedure>
<procedure name="preprocess_dl_model_bbox_rect1" access="local">
<interface>
<io>
<par name="ImageRaw" base_type="iconic" dimension="0"/>
</io>
<ic>
<par name="DLSample" base_type="ctrl" dimension="0"/>
<par name="DLPreprocessParam" base_type="ctrl" dimension="0"/>
</ic>
</interface>
<body>
<c>* </c>
<c>* This procedure preprocesses the bounding boxes of type 'rectangle1' for a given sample.</c>
<c>* </c>
<c>* Check the validity of the preprocessing parameters.</c>
<l>check_dl_preprocess_param (DLPreprocessParam)</l>
<c>* </c>
<c>* Get the preprocessing parameters.</c>
<l>get_dict_tuple (DLPreprocessParam, 'image_width', ImageWidth)</l>
<l>get_dict_tuple (DLPreprocessParam, 'image_height', ImageHeight)</l>
<l>get_dict_tuple (DLPreprocessParam, 'domain_handling', DomainHandling)</l>
<c>* </c>
<c>* Get bounding box coordinates and labels.</c>
<l>try</l>
<l>    get_dict_tuple (DLSample, 'bbox_col1', BBoxCol1)</l>
<l>    get_dict_tuple (DLSample, 'bbox_col2', BBoxCol2)</l>
<l>    get_dict_tuple (DLSample, 'bbox_row1', BBoxRow1)</l>
<l>    get_dict_tuple (DLSample, 'bbox_row2', BBoxRow2)</l>
<l>    get_dict_tuple (DLSample, 'bbox_label_id', BBoxLabel)</l>
<l>catch (Exception)</l>
<l>    get_dict_tuple (DLSample, 'image_id', ImageId)</l>
<l>    if (Exception[0] == 1302)</l>
<l>        ExceptionMessage := 'A bounding box coordinate key is missing.'</l>
<l>    else</l>
<l>        ExceptionMessage := Exception[2]</l>
<l>    endif</l>
<l>    throw ('An error has occurred during preprocessing image_id ' + ImageId + ' when getting bounding box coordinates : ' + ExceptionMessage)</l>
<l>endtry</l>
<c>* </c>
<c>* Check that there are no invalid boxes.</c>
<l>if (|BBoxRow1| &gt; 0)</l>
<l>    BoxesInvalid := (BBoxRow1 [&gt;=] BBoxRow2) or (BBoxCol1 [&gt;=] BBoxCol2)</l>
<l>    if (sum(BoxesInvalid) &gt; 0)</l>
<l>        get_dict_tuple (DLSample, 'image_id', ImageId)</l>
<l>        throw ('An error has occurred during preprocessing image_id ' + ImageId + ': Sample contains at least one box with zero-area, i.e. bbox_col1 &gt;= bbox_col2 or bbox_row1 &gt;= bbox_row2.')</l>
<l>    endif</l>
<l>else</l>
<c>    * If there are no bounding box coordinates, there is nothing to do.</c>
<l>    return ()</l>
<l>endif</l>
<c>* </c>
<c>* If the domain is cropped, crop bounding boxes.</c>
<l>if (DomainHandling == 'crop_domain')</l>
<c>    * </c>
<c>    * Get domain.</c>
<l>    get_domain (ImageRaw, DomainRaw)</l>
<c>    * </c>
<c>    * Set the size of the raw image to the domain extensions.</c>
<l>    smallest_rectangle1 (DomainRaw, RowDomain1, ColumnDomain1, RowDomain2, ColumnDomain2)</l>
<c>    * The domain is always given as a pixel-precise region.</c>
<l>    WidthRaw := ColumnDomain2 - ColumnDomain1 + 1.0</l>
<l>    HeightRaw := RowDomain2 - RowDomain1 + 1.0</l>
<c>    * </c>
<c>    * Crop the bounding boxes.</c>
<l>    Row1 := max2(BBoxRow1,RowDomain1 - .5)</l>
<l>    Col1 := max2(BBoxCol1,ColumnDomain1 - .5)</l>
<l>    Row2 := min2(BBoxRow2,RowDomain2 + .5)</l>
<l>    Col2 := min2(BBoxCol2,ColumnDomain2 + .5)</l>
<l>    MaskDelete := (Row1 [&gt;=] Row2) or (Col1 [&gt;=] Col2)</l>
<l>    MaskNewBbox := 1 - MaskDelete</l>
<c>    * Store the preprocessed bounding box entries.</c>
<l>    BBoxCol1New := select_mask(Col1,MaskNewBbox) - ColumnDomain1</l>
<l>    BBoxCol2New := select_mask(Col2,MaskNewBbox) - ColumnDomain1</l>
<l>    BBoxRow1New := select_mask(Row1,MaskNewBbox) - RowDomain1</l>
<l>    BBoxRow2New := select_mask(Row2,MaskNewBbox) - RowDomain1</l>
<l>    BBoxLabelNew := select_mask(BBoxLabel,MaskNewBbox)</l>
<c>    * </c>
<l>elseif (DomainHandling == 'full_domain')</l>
<c>    * If the entire image is used, set the variables accordingly.</c>
<c>    * Get the original size.</c>
<l>    get_image_size (ImageRaw, WidthRaw, HeightRaw)</l>
<c>    * Set new coordinates to input coordinates.</c>
<l>    BBoxCol1New := BBoxCol1</l>
<l>    BBoxCol2New := BBoxCol2</l>
<l>    BBoxRow1New := BBoxRow1</l>
<l>    BBoxRow2New := BBoxRow2</l>
<l>    BBoxLabelNew := BBoxLabel</l>
<l>else</l>
<l>    throw ('Unsupported parameter value for \'domain_handling\'')</l>
<l>endif</l>
<c>* </c>
<c>* Rescale the bounding boxes.</c>
<c>* </c>
<c>* Get required images width and height.</c>
<c>* </c>
<c>* Only rescale bounding boxes if the required image dimensions are not the raw dimensions.</c>
<l>if (ImageHeight != HeightRaw or ImageWidth != WidthRaw)</l>
<c>    * Calculate rescaling factor.</c>
<l>    FactorResampleWidth := real(ImageWidth) / WidthRaw</l>
<l>    FactorResampleHeight := real(ImageHeight) / HeightRaw</l>
<c>    * Rescale the bounding box coordinates.</c>
<c>    * As we use XLD-coordinates we temporarily move the boxes by (.5,.5) for rescaling.</c>
<c>    * Doing so, the center of the XLD-coordinate system (-0.5,-0.5) is used</c>
<c>    * for scaling, hence the scaling is performed w.r.t. the pixel coordinate system.</c>
<l>    BBoxCol1New := (BBoxCol1New + .5) * FactorResampleWidth - .5</l>
<l>    BBoxCol2New := (BBoxCol2New + .5) * FactorResampleWidth - .5</l>
<l>    BBoxRow1New := (BBoxRow1New + .5) * FactorResampleHeight - .5</l>
<l>    BBoxRow2New := (BBoxRow2New + .5) * FactorResampleHeight - .5</l>
<c>    * </c>
<l>endif</l>
<c>* </c>
<c>* Make a final check and remove bounding boxes that have zero area.</c>
<l>if (|BBoxRow1New| &gt; 0)</l>
<l>    MaskDelete := (BBoxRow1New [&gt;=] BBoxRow2New) or (BBoxCol1New [&gt;=] BBoxCol2New)</l>
<l>    BBoxCol1New := select_mask(BBoxCol1New,1 - MaskDelete)</l>
<l>    BBoxCol2New := select_mask(BBoxCol2New,1 - MaskDelete)</l>
<l>    BBoxRow1New := select_mask(BBoxRow1New,1 - MaskDelete)</l>
<l>    BBoxRow2New := select_mask(BBoxRow2New,1 - MaskDelete)</l>
<l>    BBoxLabelNew := select_mask(BBoxLabelNew,1 - MaskDelete)</l>
<l>endif</l>
<c>* </c>
<c>* Set new bounding box coordinates in the dictionary.</c>
<l>set_dict_tuple (DLSample, 'bbox_col1', BBoxCol1New)</l>
<l>set_dict_tuple (DLSample, 'bbox_col2', BBoxCol2New)</l>
<l>set_dict_tuple (DLSample, 'bbox_row1', BBoxRow1New)</l>
<l>set_dict_tuple (DLSample, 'bbox_row2', BBoxRow2New)</l>
<l>set_dict_tuple (DLSample, 'bbox_label_id', BBoxLabelNew)</l>
<c>* </c>
<l>return ()</l>
</body>
<docu id="preprocess_dl_model_bbox_rect1">
<abstract lang="en_US">This procedure preprocesses the bounding boxes of type 'rectangle1' for a sample given by the dictionary DLSample.
In particular the bounding boxes are rescaled according to the rescaling of the images to the size required by the deep learning model.
All required parameters are provided through the dictionary DLPreprocessParam.

The dictionary DLPreprocessParam can be created using e.g., create_dl_preprocess_param or create_dl_preprocess_param_from_model.
For information to the preprocessing parameters, see the documentation of preprocess_dl_samples.
</abstract>
<chapters lang="de_DE">
<item>Deep Learning</item>
<item>Objektdetektion</item>
</chapters>
<chapters lang="en_US">
<item>Deep Learning</item>
<item>Object Detection</item>
</chapters>
<library lang="en_US">MVTec Standard Procedures</library>
<short lang="en_US">This procedure preprocesses the bounding boxes of type 'rectangle1' for a given sample.</short>
<parameters>
<parameter id="DLPreprocessParam">
<default_type>integer</default_type>
<description lang="en_US">Dictionary containing the preprocessing parameters.</description>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>dict</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="DLSample">
<default_type>integer</default_type>
<default_value>DLSample</default_value>
<description lang="en_US">Dictionary of the sample related to ImageRaw and containing the bounding boxes appertain.</description>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>dict</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="ImageRaw">
<description lang="en_US">Raw, not preprocessed image.</description>
<multichannel>optional</multichannel>
<multivalue>false</multivalue>
<sem_type>image</sem_type>
<type_list>
<item>byte</item>
<item>int1</item>
<item>int2</item>
<item>uint2</item>
<item>int4</item>
<item>int8</item>
<item>real</item>
<item>cyclic</item>
<item>direction</item>
<item>complex</item>
<item>vector_field</item>
</type_list>
</parameter>
</parameters>
</docu>
</procedure>
<procedure name="preprocess_dl_model_bbox_rect2" access="local">
<interface>
<io>
<par name="ImageRaw" base_type="iconic" dimension="0"/>
</io>
<ic>
<par name="DLSample" base_type="ctrl" dimension="0"/>
<par name="DLPreprocessParam" base_type="ctrl" dimension="0"/>
</ic>
</interface>
<body>
<c>* This procedure preprocesses the bounding boxes of type 'rectangle2' for a given sample.</c>
<c>* </c>
<l>check_dl_preprocess_param (DLPreprocessParam)</l>
<c>* </c>
<c>* Get preprocess parameters.</c>
<l>get_dict_tuple (DLPreprocessParam, 'image_width', ImageWidth)</l>
<l>get_dict_tuple (DLPreprocessParam, 'image_height', ImageHeight)</l>
<l>get_dict_tuple (DLPreprocessParam, 'domain_handling', DomainHandling)</l>
<c>* The keys 'ignore_direction' and 'class_ids_no_orientation' are optional.</c>
<l>IgnoreDirection := false</l>
<l>ClassIDsNoOrientation := []</l>
<l>get_dict_param (DLPreprocessParam, 'key_exists', ['ignore_direction','class_ids_no_orientation'], KeyExists)</l>
<l>if (KeyExists[0])</l>
<l>    get_dict_tuple (DLPreprocessParam, 'ignore_direction', IgnoreDirection)</l>
<l>    if (IgnoreDirection == 'true')</l>
<l>        IgnoreDirection := true</l>
<l>    elseif (IgnoreDirection == 'false')</l>
<l>        IgnoreDirection := false</l>
<l>    endif</l>
<l>endif</l>
<l>if (KeyExists[1])</l>
<l>    get_dict_tuple (DLPreprocessParam, 'class_ids_no_orientation', ClassIDsNoOrientation)</l>
<l>endif</l>
<c>* </c>
<c>* Get bounding box coordinates and labels.</c>
<l>try</l>
<l>    get_dict_tuple (DLSample, 'bbox_row', BBoxRow)</l>
<l>    get_dict_tuple (DLSample, 'bbox_col', BBoxCol)</l>
<l>    get_dict_tuple (DLSample, 'bbox_length1', BBoxLength1)</l>
<l>    get_dict_tuple (DLSample, 'bbox_length2', BBoxLength2)</l>
<l>    get_dict_tuple (DLSample, 'bbox_phi', BBoxPhi)</l>
<l>    get_dict_tuple (DLSample, 'bbox_label_id', BBoxLabel)</l>
<l>catch (Exception)</l>
<l>    get_dict_tuple (DLSample, 'image_id', ImageId)</l>
<l>    if (Exception[0] == 1302)</l>
<l>        ExceptionMessage := 'A bounding box coordinate key is missing.'</l>
<l>    else</l>
<l>        ExceptionMessage := Exception[2]</l>
<l>    endif</l>
<l>    throw ('An error has occurred during preprocessing image_id ' + ImageId + ' when getting bounding box coordinates : ' + ExceptionMessage)</l>
<l>endtry</l>
<c>* </c>
<c>* Check that there are no invalid boxes.</c>
<l>if (|BBoxRow| &gt; 0)</l>
<l>    BoxesInvalid := sum(BBoxLength1 [==] 0) + sum(BBoxLength2 [==] 0)</l>
<l>    if (BoxesInvalid &gt; 0)</l>
<l>        get_dict_tuple (DLSample, 'image_id', ImageId)</l>
<l>        throw ('An error has occurred during preprocessing image_id ' + ImageId + ': Sample contains at least one bounding box with zero-area, i.e. bbox_length1 == 0 or bbox_length2 == 0!')</l>
<l>    endif</l>
<l>endif</l>
<c>* </c>
<c>* If the domain is cropped, crop bounding boxes.</c>
<l>if (DomainHandling == 'crop_domain')</l>
<c>    * </c>
<c>    * Get domain.</c>
<l>    get_domain (ImageRaw, DomainRaw)</l>
<c>    * </c>
<c>    * Set the size of the raw image to the domain extensions.</c>
<l>    smallest_rectangle1 (DomainRaw, RowDomain1, ColumnDomain1, RowDomain2, ColumnDomain2)</l>
<l>    WidthRaw := ColumnDomain2 - ColumnDomain1 + 1</l>
<l>    HeightRaw := RowDomain2 - RowDomain1 + 1</l>
<c>    * </c>
<c>    * Crop the bounding boxes.</c>
<c>    * Remove the boxes with center outside of the domain.</c>
<l>    MaskDelete := (BBoxRow [&lt;] RowDomain1 or BBoxCol [&lt;] ColumnDomain1 or BBoxRow [&gt;] RowDomain2) or (BBoxCol [&gt;] ColumnDomain2)</l>
<l>    MaskNewBbox := 1 - MaskDelete</l>
<c>    * Store the preprocessed bounding box entries.</c>
<l>    BBoxRowNew := select_mask(BBoxRow,MaskNewBbox) - RowDomain1</l>
<l>    BBoxColNew := select_mask(BBoxCol,MaskNewBbox) - ColumnDomain1</l>
<l>    BBoxLength1New := select_mask(BBoxLength1,MaskNewBbox)</l>
<l>    BBoxLength2New := select_mask(BBoxLength2,MaskNewBbox)</l>
<l>    BBoxPhiNew := select_mask(BBoxPhi,MaskNewBbox)</l>
<l>    BBoxLabelNew := select_mask(BBoxLabel,MaskNewBbox)</l>
<c>    * </c>
<l>elseif (DomainHandling == 'full_domain')</l>
<c>    * If the entire image is used, set the variables accordingly.</c>
<c>    * Get the original size.</c>
<l>    get_image_size (ImageRaw, WidthRaw, HeightRaw)</l>
<c>    * Set new coordinates to input coordinates.</c>
<l>    BBoxRowNew := BBoxRow</l>
<l>    BBoxColNew := BBoxCol</l>
<l>    BBoxLength1New := BBoxLength1</l>
<l>    BBoxLength2New := BBoxLength2</l>
<l>    BBoxPhiNew := BBoxPhi</l>
<l>    BBoxLabelNew := BBoxLabel</l>
<l>else</l>
<l>    throw ('Unsupported parameter value for \'domain_handling\'')</l>
<l>endif</l>
<c>* </c>
<c>* Generate smallest enclosing axis-aligned bounding box for classes in ClassIDsNoOrientation.</c>
<l>ClassIDsNoOrientationIndices := []</l>
<l>for Index := 0 to |ClassIDsNoOrientation| - 1 by 1</l>
<l>    ClassIDsNoOrientationIndicesTmp := find(BBoxLabelNew [==] ClassIDsNoOrientation[Index],1)</l>
<l>    if (ClassIDsNoOrientationIndicesTmp != -1)</l>
<l>        ClassIDsNoOrientationIndices := [ClassIDsNoOrientationIndices,ClassIDsNoOrientationIndicesTmp]</l>
<l>    endif</l>
<l>endfor</l>
<l>if (|ClassIDsNoOrientationIndices| &gt; 0)</l>
<c>    * Calculate length1 and length2 using position of corners.</c>
<l>    DirectionLength1Row := -sin(BBoxPhiNew[ClassIDsNoOrientationIndices])</l>
<l>    DirectionLength1Col := cos(BBoxPhiNew[ClassIDsNoOrientationIndices])</l>
<l>    DirectionLength2Row := -DirectionLength1Col</l>
<l>    DirectionLength2Col := DirectionLength1Row</l>
<l>    Corner1Row := BBoxLength1New[ClassIDsNoOrientationIndices] * DirectionLength1Row + BBoxLength2New[ClassIDsNoOrientationIndices] * DirectionLength2Row</l>
<l>    Corner1Col := BBoxLength1New[ClassIDsNoOrientationIndices] * DirectionLength1Col + BBoxLength2New[ClassIDsNoOrientationIndices] * DirectionLength2Col</l>
<l>    Corner2Row := BBoxLength1New[ClassIDsNoOrientationIndices] * DirectionLength1Row - BBoxLength2New[ClassIDsNoOrientationIndices] * DirectionLength2Row</l>
<l>    Corner2Col := BBoxLength1New[ClassIDsNoOrientationIndices] * DirectionLength1Col - BBoxLength2New[ClassIDsNoOrientationIndices] * DirectionLength2Col</l>
<c>    * </c>
<l>    BBoxPhiNew[ClassIDsNoOrientationIndices] := 0.0</l>
<l>    BBoxLength1New[ClassIDsNoOrientationIndices] := max2(abs(Corner1Col),abs(Corner2Col))</l>
<l>    BBoxLength2New[ClassIDsNoOrientationIndices] := max2(abs(Corner1Row),abs(Corner2Row))</l>
<l>endif</l>
<c>* </c>
<c>* Rescale bounding boxes.</c>
<c>* </c>
<c>* Get required images width and height.</c>
<c>* </c>
<c>* Only rescale bounding boxes if the required image dimensions are not the raw dimensions.</c>
<l>if (ImageHeight != HeightRaw or ImageWidth != WidthRaw)</l>
<c>    * Calculate rescaling factor.</c>
<l>    FactorResampleWidth := real(ImageWidth) / WidthRaw</l>
<l>    FactorResampleHeight := real(ImageHeight) / HeightRaw</l>
<l>    if (FactorResampleHeight != FactorResampleWidth)</l>
<c>        * In order to preserve the correct orientation we have to transform the points individually.</c>
<c>        * Get the coordinates of the four corner points.</c>
<l>        convert_rect2_5to8param (BBoxRowNew, BBoxColNew, BBoxLength1New, BBoxLength2New, BBoxPhiNew, BBoxRow1, BBoxCol1, BBoxRow2, BBoxCol2, BBoxRow3, BBoxCol3, BBoxRow4, BBoxCol4)</l>
<c>        * </c>
<c>        * Rescale the coordinates.</c>
<l>        BBoxCol1New := BBoxCol1 * FactorResampleWidth</l>
<l>        BBoxCol2New := BBoxCol2 * FactorResampleWidth</l>
<l>        BBoxCol3New := BBoxCol3 * FactorResampleWidth</l>
<l>        BBoxCol4New := BBoxCol4 * FactorResampleWidth</l>
<l>        BBoxRow1New := BBoxRow1 * FactorResampleHeight</l>
<l>        BBoxRow2New := BBoxRow2 * FactorResampleHeight</l>
<l>        BBoxRow3New := BBoxRow3 * FactorResampleHeight</l>
<l>        BBoxRow4New := BBoxRow4 * FactorResampleHeight</l>
<c>        * </c>
<c>        * The rectangles will get sheared, that is why new rectangles have to be found.</c>
<c>        * Generate homography to scale rectangles.</c>
<l>        hom_mat2d_identity (HomMat2DIdentity)</l>
<l>        hom_mat2d_scale (HomMat2DIdentity, FactorResampleHeight, FactorResampleWidth, 0, 0, HomMat2DScale)</l>
<c>        * Generate XLD contours for the rectangles.</c>
<l>        gen_rectangle2_contour_xld (Rectangle2XLD, BBoxRowNew, BBoxColNew, BBoxPhiNew, BBoxLength1New, BBoxLength2New)</l>
<c>        * Scale the XLD contours --&gt; results in sheared regions.</c>
<l>        affine_trans_contour_xld (Rectangle2XLD, Rectangle2XLDSheared, HomMat2DScale)</l>
<l>        smallest_rectangle2_xld (Rectangle2XLDSheared, BBoxRowNew, BBoxColNew, BBoxPhiNew, BBoxLength1New, BBoxLength2New)</l>
<c>        * </c>
<c>        * smallest_rectangle2_xld might change the orientation of the bounding box.</c>
<c>        * Hence, take the orientation that is closest to the one obtained out of the 4 corner points.</c>
<l>        convert_rect2_8to5param (BBoxRow1New, BBoxCol1New, BBoxRow2New, BBoxCol2New, BBoxRow3New, BBoxCol3New, BBoxRow4New, BBoxCol4New, IgnoreDirection, _, _, _, _, BBoxPhiTmp)</l>
<l>        PhiDelta := fmod(BBoxPhiTmp - BBoxPhiNew,rad(360))</l>
<c>        * Guarantee that angles are positive.</c>
<l>        PhiDeltaNegativeIndices := find(PhiDelta [&lt;] 0.0,1)</l>
<l>        if (PhiDeltaNegativeIndices != -1)</l>
<l>            PhiDelta[PhiDeltaNegativeIndices] := PhiDelta[PhiDeltaNegativeIndices] + rad(360)</l>
<l>        endif</l>
<l>        IndicesRot90 := find((PhiDelta [&gt;] rad(45)) and (PhiDelta [&lt;=] rad(135)),1)</l>
<l>        IndicesRot180 := find((PhiDelta [&gt;] rad(135)) and (PhiDelta [&lt;=] rad(225)),1)</l>
<l>        IndicesRot270 := find((PhiDelta [&gt;] rad(225)) and (PhiDelta [&lt;=] rad(315)),1)</l>
<l>        SwapIndices := []</l>
<l>        if (IndicesRot90 != -1)</l>
<l>            BBoxPhiNew[IndicesRot90] := BBoxPhiNew[IndicesRot90] + rad(90)</l>
<l>            SwapIndices := [SwapIndices,IndicesRot90]</l>
<l>        endif</l>
<l>        if (IndicesRot180 != -1)</l>
<l>            BBoxPhiNew[IndicesRot180] := BBoxPhiNew[IndicesRot180] + rad(180)</l>
<l>        endif</l>
<l>        if (IndicesRot270 != -1)</l>
<l>            BBoxPhiNew[IndicesRot270] := BBoxPhiNew[IndicesRot270] + rad(270)</l>
<l>            SwapIndices := [SwapIndices,IndicesRot270]</l>
<l>        endif</l>
<l>        if (SwapIndices != [])</l>
<l>            Tmp := BBoxLength1New[SwapIndices]</l>
<l>            BBoxLength1New[SwapIndices] := BBoxLength2New[SwapIndices]</l>
<l>            BBoxLength2New[SwapIndices] := Tmp</l>
<l>        endif</l>
<c>        * Change angles such that they lie in the range (-180°, 180°].</c>
<l>        BBoxPhiNewIndices := find(BBoxPhiNew [&gt;] rad(180),1)</l>
<l>        if (BBoxPhiNewIndices != -1)</l>
<l>            BBoxPhiNew[BBoxPhiNewIndices] := BBoxPhiNew[BBoxPhiNewIndices] - rad(360)</l>
<l>        endif</l>
<l>    else</l>
<l>        BBoxColNew := BBoxColNew * FactorResampleWidth</l>
<l>        BBoxRowNew := BBoxRowNew * FactorResampleWidth</l>
<l>        BBoxLength1New := BBoxLength1New * FactorResampleWidth</l>
<l>        BBoxLength2New := BBoxLength2New * FactorResampleWidth</l>
<c>        * Phi stays the same.</c>
<l>    endif</l>
<c>    * </c>
<l>endif</l>
<c>* Check that there are no invalid boxes.</c>
<l>if (|BBoxRowNew| &gt; 0)</l>
<l>    BoxesInvalid := sum(BBoxLength1New [==] 0) + sum(BBoxLength2New [==] 0)</l>
<l>    if (BoxesInvalid &gt; 0)</l>
<l>        get_dict_tuple (DLSample, 'image_id', ImageId)</l>
<l>        throw ('An error has occurred during preprocessing image_id ' + ImageId + ': Sample contains at least one box with zero-area, i.e. bbox_length1 == 0 or bbox_length2 == 0!')</l>
<l>    endif</l>
<l>endif</l>
<l>set_dict_tuple (DLSample, 'bbox_row', BBoxRowNew)</l>
<l>set_dict_tuple (DLSample, 'bbox_col', BBoxColNew)</l>
<l>set_dict_tuple (DLSample, 'bbox_length1', BBoxLength1New)</l>
<l>set_dict_tuple (DLSample, 'bbox_length2', BBoxLength2New)</l>
<l>set_dict_tuple (DLSample, 'bbox_phi', BBoxPhiNew)</l>
<l>set_dict_tuple (DLSample, 'bbox_label_id', BBoxLabelNew)</l>
<c>* </c>
<l>return ()</l>
<c></c>
</body>
<docu id="preprocess_dl_model_bbox_rect2">
<abstract lang="en_US">This procedure preprocesses the bounding boxes of type 'rectangle2' for a sample given by the dictionary DLSample.
In particular the bounding boxes are rescaled according to the rescaling of the images to the size required by the deep learning model.
All required parameters are provided through the dictionary DLPreprocessParam.

The dictionary DLPreprocessParam can be created using e.g., create_dl_preprocess_param or create_dl_preprocess_param_from_model.
For information to the preprocessing parameters, see the documentation of preprocess_dl_samples.

Note: If the width and height are not rescaled by the same factor, rescaling the bounding boxes will usually result in a shearing.
In such a case the preprocessed rectangular bounding boxes will border a slightly different image area.
</abstract>
<chapters lang="de_DE">
<item>Deep Learning</item>
<item>Objektdetektion</item>
</chapters>
<chapters lang="en_US">
<item>Deep Learning</item>
<item>Object Detection</item>
</chapters>
<library lang="en_US">MVTec Standard Procedures</library>
<short lang="en_US">This procedure preprocesses the bounding boxes of type 'rectangle2' for a given sample.</short>
<parameters>
<parameter id="DLPreprocessParam">
<default_type>integer</default_type>
<default_value>[]</default_value>
<description lang="en_US">Dictionary containing the preprocessing parameters.</description>
<mixed_type>false</mixed_type>
<multivalue>optional</multivalue>
<sem_type>any</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="DLSample">
<default_type>integer</default_type>
<default_value>DLSample</default_value>
<description lang="en_US">Dictionary of the sample related to ImageRaw and containing the bounding boxes appertain.</description>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>dict</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="ImageRaw">
<description lang="en_US">Raw, not preprocessed image.</description>
<multichannel>optional</multichannel>
<multivalue>false</multivalue>
<sem_type>image</sem_type>
<type_list>
<item>byte</item>
<item>int1</item>
<item>int2</item>
<item>uint2</item>
<item>int4</item>
<item>int8</item>
<item>real</item>
<item>cyclic</item>
<item>direction</item>
<item>complex</item>
<item>vector_field</item>
</type_list>
</parameter>
</parameters>
</docu>
</procedure>
<procedure name="preprocess_dl_model_images">
<interface>
<io>
<par name="Images" base_type="iconic" dimension="0"/>
</io>
<oo>
<par name="ImagesPreprocessed" base_type="iconic" dimension="0"/>
</oo>
<ic>
<par name="DLPreprocessParam" base_type="ctrl" dimension="0"/>
</ic>
</interface>
<body>
<c>* </c>
<c>* This procedure preprocesses the provided Images</c>
<c>* according to the parameters in the dictionary DLPreprocessParam.</c>
<c>* Note that depending on the images,</c>
<c>* additional preprocessing steps might be beneficial.</c>
<c>* </c>
<c>* Check the validity of the preprocessing parameters.</c>
<l>check_dl_preprocess_param (DLPreprocessParam)</l>
<c>* </c>
<c>* Get the preprocessing parameters.</c>
<l>get_dict_tuple (DLPreprocessParam, 'image_width', ImageWidth)</l>
<l>get_dict_tuple (DLPreprocessParam, 'image_height', ImageHeight)</l>
<l>get_dict_tuple (DLPreprocessParam, 'image_num_channels', ImageNumChannels)</l>
<l>get_dict_tuple (DLPreprocessParam, 'image_range_min', ImageRangeMin)</l>
<l>get_dict_tuple (DLPreprocessParam, 'image_range_max', ImageRangeMax)</l>
<l>get_dict_tuple (DLPreprocessParam, 'domain_handling', DomainHandling)</l>
<l>get_dict_tuple (DLPreprocessParam, 'normalization_type', NormalizationType)</l>
<l>get_dict_tuple (DLPreprocessParam, 'model_type', ModelType)</l>
<c>* </c>
<c>* Preprocess the images.</c>
<c>* </c>
<l>if (DomainHandling == 'full_domain')</l>
<l>    full_domain (Images, Images)</l>
<l>elseif (DomainHandling == 'crop_domain')</l>
<l>    crop_domain (Images, Images)</l>
<l>elseif (DomainHandling == 'keep_domain' and ModelType == 'anomaly_detection')</l>
<c>    * Anomaly detection models accept the additional option 'keep_domain'.</c>
<l>else</l>
<l>    throw ('Unsupported parameter value for \'domain_handling\'')</l>
<l>endif</l>
<c>* </c>
<c>* Zoom images only if they have a different size than the specified size.</c>
<l>get_image_size (Images, ImageWidthInput, ImageHeightInput)</l>
<l>EqualWidth := ImageWidth [==] ImageWidthInput</l>
<l>EqualHeight := ImageHeight [==] ImageHeightInput</l>
<l>if (min(EqualWidth) == 0 or min(EqualHeight) == 0)</l>
<l>    zoom_image_size (Images, Images, ImageWidth, ImageHeight, 'constant')</l>
<l>endif</l>
<l>if (NormalizationType == 'all_channels')</l>
<c>    * Check the type of the input images.</c>
<c>    * Channel normalization works here only for byte, integer and real images.</c>
<l>    get_image_type (Images, Type)</l>
<l>    tuple_regexp_test (Type, 'byte|int|real', NumMatches)</l>
<l>    count_obj (Images, NumImages)</l>
<l>    if (NumMatches != NumImages)</l>
<l>        throw ('In case of normalization type \'all_channels\', please provide only images of type \'byte\', \'int1\', \'int2\', \'uint2\', \'int4\', \'int8\', or \'real\'.')</l>
<l>    endif</l>
<c>    * </c>
<c>    * Perform all channels normalization.</c>
<l>    if (Type == 'byte')</l>
<c>        * Scale the gray values to [0-255].</c>
<l>        scale_image_max (Images, Images)</l>
<l>    else</l>
<c>        * Scale the gray values to [ImageRangeMin-ImageRangeMax].</c>
<c>        * Scaling is performed for each image separately.</c>
<l>        gen_empty_obj (ImagesNew)</l>
<l>        for ImageIndex := 1 to NumImages by 1</l>
<l>            select_obj (Images, ImageSelected, ImageIndex)</l>
<l>            count_channels (Images, Channels)</l>
<c>            * </c>
<c>            * Calculate the channel-wise minimum and maximum grey values.</c>
<l>            gen_empty_obj (ImagesScaled)</l>
<l>            for ChannelIndex := 1 to Channels by 1</l>
<l>                access_channel (ImageSelected, Channel, ChannelIndex)</l>
<l>                min_max_gray (Channel, Channel, 0, MinChannel, MaxChannel, Range)</l>
<c>                * Scale and shift the channel.</c>
<l>                Scale := (ImageRangeMax - ImageRangeMin) / (MaxChannel - MinChannel)</l>
<l>                Shift := -Scale * MinChannel + ImageRangeMin</l>
<l>                scale_image (Channel, Channel, Scale, Shift)</l>
<l>                concat_obj (ImagesScaled, Channel, ImagesScaled)</l>
<l>            endfor</l>
<l>            channels_to_image (ImagesScaled, ImagesScaledMultiChannel)</l>
<l>            concat_obj (ImagesNew, ImagesScaledMultiChannel, ImagesNew)</l>
<l>        endfor</l>
<l>        Images := ImagesNew</l>
<c>        * Integer image convert to real image</c>
<l>        if (Type != 'real')</l>
<l>            convert_image_type (Images, Images, 'real')</l>
<l>        endif</l>
<l>    endif</l>
<l>elseif (NormalizationType == 'first_channel')</l>
<c>    * Check the type of the input images.</c>
<c>    * First channel normalization works here only for byte, integer and real images.</c>
<l>    get_image_type (Images, Type)</l>
<l>    tuple_regexp_test (Type, 'byte|int|real', NumMatches)</l>
<l>    count_obj (Images, NumImages)</l>
<l>    if (NumMatches != NumImages)</l>
<l>        throw ('In case of normalization type \'first_channel\', please provide only images of type \'byte\', \'int1\', \'int2\', \'uint2\', \'int4\', \'int8\', or \'real\'.')</l>
<l>    endif</l>
<c>    * </c>
<c>    * Perform first channel normalization.</c>
<l>    if (Type == 'byte')</l>
<c>        * Scale the gray values to [0-255].</c>
<l>        scale_image_max (Images, Images)</l>
<l>    else</l>
<c>        * Scale the gray values to [ImageRangeMin-ImageRangeMax].</c>
<c>        * Scaling is performed for each image separately.</c>
<l>        gen_empty_obj (ImagesNew)</l>
<l>        for ImageIndex := 1 to NumImages by 1</l>
<l>            select_obj (Images, ImageSelected, ImageIndex)</l>
<l>            min_max_gray (ImageSelected, ImageSelected, 0, Min, Max, Range)</l>
<l>            Scale := (ImageRangeMax - ImageRangeMin) / (Max - Min)</l>
<l>            Shift := -Scale * Min + ImageRangeMin</l>
<l>            scale_image (ImageSelected, ImageSelected, Scale, Shift)</l>
<l>            concat_obj (ImagesNew, ImageSelected, ImagesNew)</l>
<l>        endfor</l>
<l>        Images := ImagesNew</l>
<c>        * Integer image convert to real image</c>
<l>        if (Type != 'real')</l>
<l>            convert_image_type (Images, Images, 'real')</l>
<l>        endif</l>
<l>    endif</l>
<l>elseif (NormalizationType == 'constant_values')</l>
<c>    * </c>
<c>    * Constant values normalization works here only for byte, integer and real images.</c>
<l>    get_image_type (Images, Type)</l>
<l>    tuple_regexp_test (Type, 'byte|int|real', NumMatches)</l>
<l>    count_obj (Images, NumImages)</l>
<l>    if (NumMatches != NumImages)</l>
<l>        throw ('In case of normalization type \'constant_values\', please provide only images of type \'byte\', \'int1\', \'int2\', \'uint2\', \'int4\', \'int8\', or \'real\'.')</l>
<l>    endif</l>
<c>    * For a correct normalization we have to use real images.</c>
<l>    if (Type != 'real')</l>
<l>        convert_image_type (Images, Images, 'real')</l>
<l>    endif</l>
<c>    * </c>
<c>    * Get the normalization values set by create_dl_preprocess_param or</c>
<c>    * use predefined values.</c>
<l>    UsePredefinedNormalizationValues := 'false'</l>
<l>    try</l>
<l>        get_dict_tuple (DLPreprocessParam, 'mean_values_normalization', MeanValues)</l>
<l>        get_dict_tuple (DLPreprocessParam, 'deviation_values_normalization', DeviationValues)</l>
<l>    catch (Exception)</l>
<l>        UsePredefinedNormalizationValues := 'true'</l>
<l>    endtry</l>
<c>    * </c>
<l>    count_channels (Images, NumChannels)</l>
<l>    if (UsePredefinedNormalizationValues == 'true')</l>
<c>        * This type of normalization works for one-channel images by composing them to three-channel images.</c>
<l>        if (min(NumChannels) == 1 and max(NumChannels) == 1)</l>
<l>            compose3 (Images, Images, Images, Images)</l>
<l>            count_channels (Images, NumChannels)</l>
<l>        endif</l>
<c>        * Use predefined values for normalization.</c>
<l>        if (min(NumChannels) != 3 or max(NumChannels) != 3)</l>
<l>            throw ('Using predefined values for normalization type \'constant_values\' is allowed only for one- and three-channel images.')</l>
<l>        endif</l>
<c>        * Predefined values.</c>
<l>        MeanValues := [123.675,116.28,103.53]</l>
<l>        DeviationValues := [58.395,57.12,57.375]</l>
<l>    else</l>
<c>        * Use user-defined values.</c>
<l>        if (|MeanValues| != NumChannels or |DeviationValues| != NumChannels)</l>
<l>            throw ('The length for mean and deviation values for normalization type \'constant_values\' have to be the same size as the number of channels of the image')</l>
<l>        endif</l>
<l>    endif</l>
<c>    * </c>
<l>    gen_empty_obj (OutputNormImages)</l>
<l>    count_obj (Images, NumImages)</l>
<l>    for IndexImage := 1 to NumImages by 1</l>
<l>        select_obj (Images, Image, IndexImage)</l>
<l>        gen_empty_obj (ImageNormChannels)</l>
<l>        for IndexChannel := 1 to NumChannels by 1</l>
<l>            access_channel (Image, Channel, IndexChannel)</l>
<l>            get_image_size (Channel, ImageWidth, ImageHeight)</l>
<l>            scale_image (Channel, ImageNormChannel, 1 / real(DeviationValues[IndexChannel - 1]), -real(MeanValues[IndexChannel - 1]) / DeviationValues[IndexChannel - 1])</l>
<l>            append_channel (ImageNormChannels, ImageNormChannel, ImageNormChannels)</l>
<l>        endfor</l>
<l>        concat_obj (OutputNormImages, ImageNormChannels, OutputNormImages)</l>
<l>    endfor</l>
<l>    Images := OutputNormImages</l>
<l>elseif (NormalizationType != 'all_channels' and NormalizationType != 'first_channel' and NormalizationType != 'constant_values' and NormalizationType != 'none')</l>
<l>    throw ('Unsupported parameter value for \'normalization_type\'')</l>
<l>endif</l>
<c>* </c>
<c>* Check the type of the input images.</c>
<l>get_image_type (Images, Type)</l>
<l>tuple_regexp_test (Type, 'byte|real', NumMatches)</l>
<l>count_obj (Images, NumImages)</l>
<l>if (NumMatches != NumImages)</l>
<l>    throw ('Please provide only images of type \'byte\' or \'real\'.')</l>
<l>endif</l>
<c>* If the type is 'byte', convert it to 'real' and scale it.</c>
<c>* The gray value scaling does not work on 'byte' images.</c>
<c>* For 'real' images it is assumed that the range is already correct.</c>
<l>EqualByte := Type [==] 'byte'</l>
<l>if (max(EqualByte) == 1)</l>
<l>    if (min(EqualByte) == 0)</l>
<l>        throw ('Passing mixed type images is not supported.')</l>
<l>    endif</l>
<c>    * Convert the image type from 'byte' to 'real',</c>
<c>    * because the model expects 'real' images.</c>
<l>    convert_image_type (Images, Images, 'real')</l>
<c>    * Scale/Shift the gray values from [0-255] to the expected range.</c>
<l>    RescaleRange := (ImageRangeMax - ImageRangeMin) / 255.0</l>
<l>    scale_image (Images, Images, RescaleRange, ImageRangeMin)</l>
<l>endif</l>
<c>* </c>
<c>* Check the number of channels.</c>
<l>count_obj (Images, NumImages)</l>
<c>* Check all images for number of channels.</c>
<l>count_channels (Images, NumChannelsAllImages)</l>
<l>tuple_gen_const (NumImages, ImageNumChannels, ImageNumChannelsTuple)</l>
<l>tuple_find (NumChannelsAllImages [!=] ImageNumChannelsTuple, 1, IndicesWrongChannels)</l>
<c>* </c>
<c>* Correct images with a wrong number of channels.</c>
<c>* </c>
<l>if (IndicesWrongChannels != -1)</l>
<c>    * </c>
<l>    for IndexWrongImages := 0 to |IndicesWrongChannels| - 1 by 1</l>
<c>        * Get the index, the number of channels and the image</c>
<c>        * for each image with wrong number of channels.</c>
<l>        ImageIndex := IndicesWrongChannels[IndexWrongImages] + 1</l>
<l>        NumChannels := NumChannelsAllImages[ImageIndex - 1]</l>
<l>        select_obj (Images, ObjectSelected, ImageIndex)</l>
<c>        * </c>
<l>        if (NumChannels == 1 and ImageNumChannels == 3)</l>
<c>            * If the image is a grayscale image, but the model expects a color image:</c>
<c>            * convert it to an image with three channels.</c>
<l>            compose3 (ObjectSelected, ObjectSelected, ObjectSelected, ThreeChannelImage)</l>
<l>            replace_obj (Images, ThreeChannelImage, Images, ImageIndex)</l>
<l>        elseif (NumChannels == 3 and ImageNumChannels == 1)</l>
<c>            * If the image is a color image, but the model expects a grayscale image:</c>
<c>            * convert it to an image with only one channel.</c>
<l>            rgb1_to_gray (ObjectSelected, SingleChannelImage)</l>
<l>            replace_obj (Images, SingleChannelImage, Images, ImageIndex)</l>
<l>        else</l>
<l>            throw ('Number of channels is not supported. Please check for images with a number of channels different to 1 and 3 and perform their preprocessing yourself.')</l>
<l>        endif</l>
<c>        * </c>
<l>    endfor</l>
<l>endif</l>
<c>* </c>
<c>* Write preprocessed image to output variable.</c>
<l>ImagesPreprocessed := Images</l>
<c>* </c>
<l>return ()</l>
</body>
<docu id="preprocess_dl_model_images">
<abstract lang="en_US">This procedure preprocesses the provided Images according to the parameters in the dictionary DLPreprocessParam.
The dictionary DLPreprocessParam specifies the properties the images need for a successful model application.
The preprocessed images are returned in ImagesPreprocessed.

The dictionary DLPreprocessParam can be created using e.g., create_dl_preprocess_param or create_dl_preprocess_param_from_model.

Note that depending on the dataset, additional customized preprocessing steps might be beneficial, but they have to be done before this procedure is called.

It is recommended to check the output images of this procedure in order to verify that they are suitable for a successful training of a model. For example, if defects on the images are no longer discernible after zooming, it might help to increase the image dimensions.

Note that this procedure can only preprocess images fulfilling the following conditions:
  - number of channels equal to 1 or 3
  - image type equal to 'real', 'byte', or in case of normalization type 'all_channels', 'first_channel' or 'constant_values' also integer-types
If an input image differs in these points, please provide customized preprocessing yourself.</abstract>
<chapters lang="de_DE">
<item>Deep Learning</item>
<item>Modell</item>
</chapters>
<chapters lang="en_US">
<item>Deep Learning</item>
<item>Model</item>
</chapters>
<library lang="en_US">MVTec Standard Procedures</library>
<short lang="en_US">Preprocess images for deep-learning-based training and inference.</short>
<parameters>
<parameter id="DLPreprocessParam">
<default_type>integer</default_type>
<description lang="en_US">Dictionary containing the preprocessing parameters.</description>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>dict</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="Images">
<description lang="en_US">Images to be preprocessed.</description>
<multichannel>optional</multichannel>
<multivalue>optional</multivalue>
<sem_type>image</sem_type>
<type_list>
<item>byte</item>
<item>int1</item>
<item>int2</item>
<item>uint2</item>
<item>int4</item>
<item>int8</item>
<item>real</item>
</type_list>
</parameter>
<parameter id="ImagesPreprocessed">
<description lang="en_US">Preprocessed images.</description>
<multichannel>optional</multichannel>
<multivalue>optional</multivalue>
<sem_type>image</sem_type>
<type_list>
<item>real</item>
</type_list>
</parameter>
</parameters>
</docu>
</procedure>
<procedure name="preprocess_dl_model_segmentations">
<interface>
<io>
<par name="ImagesRaw" base_type="iconic" dimension="0"/>
<par name="Segmentations" base_type="iconic" dimension="0"/>
</io>
<oo>
<par name="SegmentationsPreprocessed" base_type="iconic" dimension="0"/>
</oo>
<ic>
<par name="DLPreprocessParam" base_type="ctrl" dimension="0"/>
</ic>
</interface>
<body>
<c>* </c>
<c>* This procedure preprocesses the segmentation or weight images</c>
<c>* given by Segmentations so that they can be handled by</c>
<c>* train_dl_model_batch and apply_dl_model.</c>
<c>* </c>
<c>* Check input data.</c>
<c>* Examine number of images.</c>
<l>count_obj (ImagesRaw, NumberImages)</l>
<l>count_obj (Segmentations, NumberSegmentations)</l>
<l>if (NumberImages != NumberSegmentations)</l>
<l>    throw ('Equal number of images given in ImagesRaw and Segmentations required')</l>
<l>endif</l>
<c>* Size of images.</c>
<l>get_image_size (ImagesRaw, Width, Height)</l>
<l>get_image_size (Segmentations, WidthSeg, HeightSeg)</l>
<l>if (Width != WidthSeg or Height != HeightSeg)</l>
<l>    throw ('Equal size of the images given in ImagesRaw and Segmentations required.')</l>
<l>endif</l>
<c>* Check the validity of the preprocessing parameters.</c>
<l>check_dl_preprocess_param (DLPreprocessParam)</l>
<c>* </c>
<c>* Get the relevant preprocessing parameters.</c>
<l>get_dict_tuple (DLPreprocessParam, 'model_type', DLModelType)</l>
<l>get_dict_tuple (DLPreprocessParam, 'image_width', ImageWidth)</l>
<l>get_dict_tuple (DLPreprocessParam, 'image_height', ImageHeight)</l>
<l>get_dict_tuple (DLPreprocessParam, 'image_num_channels', ImageNumChannels)</l>
<l>get_dict_tuple (DLPreprocessParam, 'image_range_min', ImageRangeMin)</l>
<l>get_dict_tuple (DLPreprocessParam, 'image_range_max', ImageRangeMax)</l>
<l>get_dict_tuple (DLPreprocessParam, 'domain_handling', DomainHandling)</l>
<c>* Segmentation specific parameters.</c>
<l>get_dict_tuple (DLPreprocessParam, 'set_background_id', SetBackgroundID)</l>
<l>get_dict_tuple (DLPreprocessParam, 'class_ids_background', ClassesToBackground)</l>
<l>get_dict_tuple (DLPreprocessParam, 'ignore_class_ids', IgnoreClassIDs)</l>
<c>* </c>
<c>* Check the input parameter for setting the background ID.</c>
<l>if (SetBackgroundID != [])</l>
<c>    * Check that the model is a segmentation model.</c>
<l>    if (DLModelType != 'segmentation')</l>
<l>        throw ('Setting class IDs to background is only implemented for segmentation.')</l>
<l>    endif</l>
<c>    * Check the background ID.</c>
<l>    tuple_is_int_elem (SetBackgroundID, IsInt)</l>
<l>    if (|SetBackgroundID| != 1)</l>
<l>        throw ('Only one class_id as \'set_background_id\' allowed.')</l>
<l>    elseif (not IsInt)</l>
<c>        * Given class_id has to be of type int.</c>
<l>        throw ('The class_id given as \'set_background_id\' has to be of type int.')</l>
<l>    endif</l>
<c>    * Check the values of ClassesToBackground.</c>
<l>    if (|ClassesToBackground| == 0)</l>
<c>        * Check that the given classes are of length &gt; 0.</c>
<l>        throw ('If \'set_background_id\' is given, \'class_ids_background\' must at least contain this class ID.')</l>
<l>    elseif (intersection(ClassesToBackground,IgnoreClassIDs) != [])</l>
<c>        * Check that class_ids_background is not included in the ignore_class_ids of the DLModel.</c>
<l>        throw ('The given \'class_ids_background\' must not be included in the \'ignore_class_ids\' of the model.')</l>
<l>    endif</l>
<l>endif</l>
<c>* </c>
<c>* Domain handling of the image to be preprocessed.</c>
<c>* </c>
<l>if (DomainHandling == 'full_domain')</l>
<l>    full_domain (Segmentations, Segmentations)</l>
<l>elseif (DomainHandling == 'crop_domain')</l>
<c>    * If the domain should be cropped the domain has to be transferred</c>
<c>    * from the raw image to the segmentation image.</c>
<l>    get_domain (ImagesRaw, Domain)</l>
<l>    for IndexImage := 1 to NumberImages by 1</l>
<l>        select_obj (Segmentations, SelectedSeg, IndexImage)</l>
<l>        select_obj (Domain, SelectedDomain, IndexImage)</l>
<l>        change_domain (SelectedSeg, SelectedDomain, SelectedSeg)</l>
<l>        replace_obj (Segmentations, SelectedSeg, Segmentations, IndexImage)</l>
<l>    endfor</l>
<l>    crop_domain (Segmentations, Segmentations)</l>
<l>else</l>
<l>    throw ('Unsupported parameter value for \'domain_handling\'')</l>
<l>endif</l>
<c>* </c>
<c>* Preprocess the segmentation images.</c>
<c>* </c>
<c>* Set all background classes to the given background class ID.</c>
<l>if (SetBackgroundID != [])</l>
<l>    reassign_pixel_values (Segmentations, Segmentations, ClassesToBackground, SetBackgroundID)</l>
<l>endif</l>
<c>* </c>
<c>* Zoom images only if they have a different size than the specified size.</c>
<l>get_image_size (Segmentations, ImageWidthRaw, ImageHeightRaw)</l>
<l>EqualWidth := ImageWidth [==] ImageWidthRaw</l>
<l>EqualHeight := ImageHeight [==] ImageHeightRaw</l>
<l>if (min(EqualWidth) == 0 or min(EqualHeight) == 0)</l>
<l>    zoom_image_size (Segmentations, Segmentations, ImageWidth, ImageHeight, 'nearest_neighbor')</l>
<l>endif</l>
<c>* </c>
<c>* Check the type of the input images</c>
<c>* and convert if necessary.</c>
<l>get_image_type (Segmentations, Type)</l>
<l>EqualReal := Type [==] 'real'</l>
<c>* </c>
<l>if (min(EqualReal) == 0)</l>
<c>    * Convert the image type to 'real',</c>
<c>    * because the model expects 'real' images.</c>
<l>    convert_image_type (Segmentations, Segmentations, 'real')</l>
<l>endif</l>
<c>* </c>
<c>* Write preprocessed Segmentations to output variable.</c>
<l>SegmentationsPreprocessed := Segmentations</l>
<l>return ()</l>
</body>
<docu id="preprocess_dl_model_segmentations">
<abstract lang="en_US">This procedure preprocesses the segmentation or weight images given by Segmentations so that they can be handled by train_dl_model_batch and apply_dl_model.
The dictionary DLPreprocessParam specifies the properties the images need for a successful model application. Next to the dimensions, also the image type is set (to 'real').
The preprocessed images are returned in SegmentationsPreprocessed.

The dictionary DLPreprocessParam can be created using e.g., create_dl_preprocess_param or create_dl_preprocess_param_from_model.
For further information on the parameters to be set in DLPreprocessParam, see the documentation of preprocess_dl_samples.</abstract>
<chapters lang="de_DE">
<item>Deep Learning</item>
<item>Semantische Segmentierung</item>
</chapters>
<chapters lang="en_US">
<item>Deep Learning</item>
<item>Semantic Segmentation</item>
</chapters>
<library lang="en_US">MVTec Standard Procedures</library>
<short lang="en_US">Preprocess segmentation and weight images for deep-learning-based segmentation training and inference.</short>
<parameters>
<parameter id="DLPreprocessParam">
<default_type>integer</default_type>
<description lang="en_US">Dictionary containing the preprocessing parameters.</description>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>dict</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="ImagesRaw">
<description lang="en_US">Raw, not preprocessed images.</description>
<multichannel>optional</multichannel>
<multivalue>optional</multivalue>
<sem_type>image</sem_type>
<type_list>
<item>byte</item>
<item>real</item>
</type_list>
</parameter>
<parameter id="Segmentations">
<description lang="en_US">Segmentation or weight images to be preprocessed.</description>
<multichannel>false</multichannel>
<multivalue>optional</multivalue>
<sem_type>image</sem_type>
<type_list>
<item>byte</item>
<item>int2</item>
<item>uint2</item>
<item>real</item>
</type_list>
</parameter>
<parameter id="SegmentationsPreprocessed">
<description lang="en_US">Preprocessed segmentation or weight images.</description>
<multichannel>false</multichannel>
<multivalue>optional</multivalue>
<sem_type>image</sem_type>
<type_list>
<item>real</item>
</type_list>
</parameter>
</parameters>
</docu>
</procedure>
<procedure name="preprocess_dl_samples">
<interface>
<ic>
<par name="DLSampleBatch" base_type="ctrl" dimension="0"/>
<par name="DLPreprocessParam" base_type="ctrl" dimension="0"/>
</ic>
</interface>
<body>
<c>* </c>
<c>* This procedure preprocesses all images of the sample dictionaries in the tuple DLSampleBatch.</c>
<c>* The images are preprocessed according to the parameters provided in DLPreprocessParam.</c>
<c>* </c>
<c>* Check the validity of the preprocessing parameters.</c>
<l>check_dl_preprocess_param (DLPreprocessParam)</l>
<l>get_dict_tuple (DLPreprocessParam, 'model_type', ModelType)</l>
<c>* </c>
<c>* Preprocess the sample entries.</c>
<c>* </c>
<l>for SampleIndex := 0 to |DLSampleBatch| - 1 by 1</l>
<c>    * </c>
<c>    * Check the existence of the sample keys.</c>
<l>    get_dict_param (DLSampleBatch[SampleIndex], 'key_exists', 'image', ImageExists)</l>
<c>    * </c>
<c>    * Preprocess the images.</c>
<l>    if (ImageExists)</l>
<c>        * </c>
<c>        * Get the image.</c>
<l>        get_dict_object (ImageRaw, DLSampleBatch[SampleIndex], 'image')</l>
<c>        * </c>
<c>        * Preprocess the image.</c>
<l>        preprocess_dl_model_images (ImageRaw, ImagePreprocessed, DLPreprocessParam)</l>
<c>        * </c>
<c>        * Replace the image in the dictionary.</c>
<l>        set_dict_object (ImagePreprocessed, DLSampleBatch[SampleIndex], 'image')</l>
<c>        * </c>
<c>        * Check existence of model specific sample keys:</c>
<c>        * - bbox_row1 for 'rectangle1'</c>
<c>        * - bbox_phi for 'rectangle2'</c>
<c>        * - segmentation_image for 'semantic segmentation'</c>
<l>        get_dict_param (DLSampleBatch[SampleIndex], 'key_exists', ['anomaly_ground_truth','bbox_row1','bbox_phi','segmentation_image'], KeysExists)</l>
<l>        AnomalyParamExist := KeysExists[0]</l>
<l>        Rectangle1ParamExist := KeysExists[1]</l>
<l>        Rectangle2ParamExist := KeysExists[2]</l>
<l>        SegmentationParamExist := KeysExists[3]</l>
<c>        * </c>
<c>        * Preprocess the anomaly ground truth if present.</c>
<l>        if (AnomalyParamExist)</l>
<c>            * </c>
<c>            * Get the anomaly image.</c>
<l>            get_dict_object (AnomalyImageRaw, DLSampleBatch[SampleIndex], 'anomaly_ground_truth')</l>
<c>            * </c>
<c>            * Preprocess the anomaly image.</c>
<l>            preprocess_dl_model_anomaly (AnomalyImageRaw, AnomalyImagePreprocessed, DLPreprocessParam)</l>
<c>            * </c>
<c>            * Set preprocessed anomaly image.</c>
<l>            set_dict_object (AnomalyImagePreprocessed, DLSampleBatch[SampleIndex], 'anomaly_ground_truth')</l>
<l>        endif</l>
<c>        * </c>
<c>        * Preprocess depending on the model type.</c>
<c>        * If bounding boxes are given, rescale them as well.</c>
<l>        if (Rectangle1ParamExist)</l>
<c>            * </c>
<c>            * Preprocess the bounding boxes of type 'rectangle1'.</c>
<l>            preprocess_dl_model_bbox_rect1 (ImageRaw, DLSampleBatch[SampleIndex], DLPreprocessParam)</l>
<l>        elseif (Rectangle2ParamExist)</l>
<c>            * </c>
<c>            * Preprocess the bounding boxes of type 'rectangle2'.</c>
<l>            preprocess_dl_model_bbox_rect2 (ImageRaw, DLSampleBatch[SampleIndex], DLPreprocessParam)</l>
<l>        endif</l>
<c>        * </c>
<c>        * Preprocess the segmentation image if present.</c>
<l>        if (SegmentationParamExist)</l>
<c>            * </c>
<c>            * Get the segmentation image.</c>
<l>            get_dict_object (SegmentationRaw, DLSampleBatch[SampleIndex], 'segmentation_image')</l>
<c>            * </c>
<c>            * Preprocess the segmentation image.</c>
<l>            preprocess_dl_model_segmentations (ImageRaw, SegmentationRaw, SegmentationPreprocessed, DLPreprocessParam)</l>
<c>            * </c>
<c>            * Set preprocessed segmentation image.</c>
<l>            set_dict_object (SegmentationPreprocessed, DLSampleBatch[SampleIndex], 'segmentation_image')</l>
<l>        endif</l>
<l>    else</l>
<l>        throw ('All samples processed need to include an image, but the sample with index ' + SampleIndex + ' does not.')</l>
<l>    endif</l>
<l>endfor</l>
<c>* </c>
<l>return ()</l>
</body>
<docu id="preprocess_dl_samples">
<abstract lang="en_US">This procedure preprocesses all images of the sample dictionaries in the tuple DLSampleBatch.
The images are preprocessed according to the parameters provided in DLPreprocessParam.
The preprocessing results overwrite the entries in the according sample dictionary DLSample.

The following model parameters influence the preprocessing: 
- 'image_height', 'image_width': See the documentation of get_dl_model_param.
- 'image_range_min', 'image_range_max': See the documentation of get_dl_model_param.
- 'image_num_channels': See the documentation of get_dl_model_param.
- 'domain_handling': The following values are possible:
   -- 'full_domain' (default): Reduced domains of images are ignored and the complete image is preprocessed.
   -- 'crop_domain': The preprocessed images are cropped to the domains that were specified before, e.g., by using reduce_domain. If 'crop_domain' is chosen, the segmentation image and the weight image are cropped to the same domain, if present in DLSample.
   -- 'keep_domain': The preprocessed images have the same domain as the original images. If the image size is changed during the preprocessing, the domains are zoomed accordingly. If a sample contains the key 'anomaly_ground_truth', the stored anomaly ground truth also keeps its domain. The option 'keep_domain' is only available for preprocessing parameters corresponding to a DL model of type 'anomaly_detection'.
- 'normalization_type': Depending on the images, it can be beneficial to apply a normalization. The following types are available:
   -- 'none' (default value): No normalization is applied on the images. 
   -- 'all_channels': The gray values of every image are scaled to the maximum value range. During this scaling, the image is converted temporarily to a 'byte' image. 
   -- 'first_channel': The gray values of the first channel of every image are scaled to the maximum value range. During this scaling, the image is converted temporarily to a 'byte' image.
   -- 'constant_values': The gray values of every image are scaled with constant values, namely for every channel i the pixel value p_i gets the mean value m(i) subtracted and the result divided by the standard deviation d(i). Note, the mean and standard deviation values need to be tuples with lengths equal to the number of image channels. If you do not want to use the default values, you can set the values by setting the following keys in the dictionary with the preprocessing parameters:
     --- 'mean_values_normalization': Tuple with the mean values to be subtracted, denoted above with m.
     --- 'deviation_values_normalization': Tuple with the standard deviations used as divisor, denoted above with d.
     The values of the mean values and standard deviations have to be in the gray value range as the input images. 
- 'set_background_id': In case of a segmentation model, it might be wanted to set indices of certain classes to the ID of a given background class, given through this parameter. If an empty tuple,[], is given, no changes will be applied (default). If this parameter is set to an ID, this class ID is not part of the 'class_ids_background'
- 'class_ids_background': Class IDs that should be additionally set to the Background Class ID given through 'set_background_id', thus, the ID given in 'set_background_id' is not to be included. Default is []. 

The dictionary DLPreprocessParam can be created using e.g., create_dl_preprocess_param or create_dl_preprocess_param_from_model.

It is recommended to check the output images of this procedure in order to verify that they are suitable for a successful training of a model. For example, if defects on the images are no longer discernible after zooming, it might help to increase the image dimensions.</abstract>
<chapters lang="de_DE">
<item>Deep Learning</item>
<item>Modell</item>
</chapters>
<chapters lang="en_US">
<item>Deep Learning</item>
<item>Model</item>
</chapters>
<library lang="en_US">MVTec Standard Procedures</library>
<short lang="en_US">Preprocess given DLSamples according to the preprocessing parameters given in DLPreprocessParam.</short>
<parameters>
<parameter id="DLPreprocessParam">
<default_type>integer</default_type>
<description lang="en_US">Dictionary containing the necessary preprocessing parameters.</description>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>dict</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="DLSampleBatch">
<default_type>integer</default_type>
<default_value>DLSampleBatch</default_value>
<description lang="en_US">Tuple of DLSample dictionaries.</description>
<mixed_type>false</mixed_type>
<multivalue>optional</multivalue>
<sem_type>dict</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
</parameters>
</docu>
</procedure>
<procedure name="pretty_print_tuple" access="local">
<interface>
<ic>
<par name="Tuple" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="TupleStr" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c>* </c>
<c>* This procedure prints a tuple of values to a string.</c>
<c>* </c>
<l>if (|Tuple| &gt; 1)</l>
<l>    TupleStr := '['</l>
<l>    for J := 0 to |Tuple| - 1 by 1</l>
<l>        if (J &gt; 0)</l>
<l>            TupleStr := TupleStr + ','</l>
<l>        endif</l>
<l>        TupleStr := TupleStr + Tuple[J]</l>
<l>    endfor</l>
<l>    TupleStr := TupleStr + ']'</l>
<l>else</l>
<l>    TupleStr := Tuple</l>
<l>endif</l>
<l>return ()</l>
</body>
<docu id="pretty_print_tuple">
<abstract lang="en_US">Prints a tuple of values to a string.</abstract>
<chapters lang="de_DE">
<item>Tuple</item>
<item>Konversion</item>
</chapters>
<chapters lang="en_US">
<item>Tuple</item>
<item>Conversion</item>
</chapters>
<library lang="en_US">MVTec Standard Procedures</library>
<short lang="en_US">Prints a tuple of values to a string.</short>
<parameters>
<parameter id="Tuple">
<description lang="en_US">Tuple to be pretty printed.</description>
<mixed_type>false</mixed_type>
<multivalue>optional</multivalue>
<sem_type>any</sem_type>
</parameter>
<parameter id="TupleStr">
<default_type>string</default_type>
<description lang="en_US">Pretty printed output string.</description>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>string</sem_type>
<type_list>
<item>string</item>
</type_list>
</parameter>
</parameters>
</docu>
</procedure>
<procedure name="process_slider_events" access="local">
<interface>
<ic>
<par name="WindowHandle" base_type="ctrl" dimension="0"/>
<par name="MessageQueues" base_type="ctrl" dimension="0"/>
<par name="PreviousState" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="CurrentState" base_type="ctrl" dimension="0"/>
<par name="DidFinish" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<l>CurrentState := PreviousState</l>
<c></c>
<l>DidFinish := false</l>
<l>try</l>
<l>    try</l>
<l>        dequeue_message (MessageQueues[2], 'timeout', 0, MessageHandle)</l>
<l>        get_message_tuple (MessageHandle, 'type', Type)</l>
<l>        if (Type == 'done')</l>
<c>            * The visualization function has finished and has exited</c>
<l>            DidFinish := true</l>
<l>        elseif (Type == 'exception')</l>
<l>            DidFinish := true</l>
<l>            get_message_tuple (MessageHandle, 'exception', Exception)</l>
<l>            throw (Exception)</l>
<l>        else</l>
<c>            * Unknown / unexpected Message</c>
<l>            stop ()</l>
<l>        endif</l>
<l>    catch (Exception)</l>
<c>        * Ignore timeout (no message in queue)</c>
<l>        if (Exception[0] != 9400)</l>
<l>            throw (Exception)</l>
<l>        endif</l>
<l>    endtry</l>
<c>    * </c>
<l>    get_mouse_info (WindowHandle, [], [], Row, Column, Button)</l>
<l>    Current := [Row,Column,Button]</l>
<l>    if (Current != PreviousState)</l>
<l>        create_message (MessageHandle)</l>
<l>        set_message_tuple (MessageHandle, 'type', 'mouse_event')</l>
<l>        set_message_tuple (MessageHandle, 'mouse_row', Row)</l>
<l>        set_message_tuple (MessageHandle, 'mouse_col', Column)</l>
<l>        set_message_tuple (MessageHandle, 'mouse_button', Button)</l>
<c>        * Remove any previous mouse message and overwrite it with the new</c>
<c>        * message. If the sub thread is too slow to process the mouse events,</c>
<c>        * we rather skip one and only use the last one. This avoids</c>
<c>        * the "lagging" GUI effect.</c>
<l>        try</l>
<l>            dequeue_message (MessageQueues[0], 'timeout', 0, MessageHandleIgnore)</l>
<l>        catch (Exception)</l>
<l>        endtry</l>
<l>        enqueue_message (MessageQueues[0], MessageHandle, [], [])</l>
<l>        CurrentState := Current</l>
<l>        EventHappened1 := true</l>
<l>    endif</l>
<l>catch (Exception)</l>
<l>    if (Exception[0] == 2891)</l>
<c>        * Message queue overflow</c>
<c>        * -&gt; there is already a mouse event in the queue, do not add another one</c>
<c>        *    to avoid overflowing the queue</c>
<l>        return ()</l>
<l>    elseif (Exception[0] == H_MSG_FAIL and Exception[5] == 'get_mposition_sub_pix')</l>
<c>        * Mouse not in window</c>
<c>        * Ignore</c>
<l>        wait_seconds (0.01)</l>
<l>    elseif (Exception[0] == 2454 or Exception[0] == 5100)</l>
<c>        * Handle was already cleared -&gt; indicates that the window was closed (by the user)</c>
<c>        * Abort gracefully.</c>
<l>        DidFinish := true</l>
<l>        return ()</l>
<l>    else</l>
<c>        * Unknown / Unexpected exception</c>
<l>        throw (Exception)</l>
<l>    endif</l>
<l>endtry</l>
<l>return ()</l>
<c></c>
</body>
<docu id="process_slider_events">
<chapters lang="en_US">
<item>Graphics</item>
<item>Output</item>
</chapters>
<library lang="en_US">MVTec Standard Procedures</library>
<parameters>
<parameter id="CurrentState"/>
<parameter id="DidFinish"/>
<parameter id="MessageQueues"/>
<parameter id="PreviousState"/>
<parameter id="WindowHandle"/>
</parameters>
</docu>
</procedure>
<procedure name="process_visualize_events_generic" access="local">
<interface>
<ic>
<par name="WindowHandle" base_type="ctrl" dimension="0"/>
<par name="MessageQueues" base_type="ctrl" dimension="0"/>
<par name="PreviousState" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="DidFinish" base_type="ctrl" dimension="0"/>
<par name="NewState" base_type="ctrl" dimension="0"/>
<par name="ButtonPressed" base_type="ctrl" dimension="0"/>
<par name="Poses" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<l>NewState := PreviousState</l>
<l>ButtonPressed := []</l>
<l>Poses := []</l>
<l>DidFinish := false</l>
<c>* </c>
<l>try</l>
<l>    try</l>
<l>        dequeue_message (MessageQueues[2], 'timeout', 0, MessageHandle)</l>
<l>        get_message_tuple (MessageHandle, 'type', Type)</l>
<l>        if (Type == 'done')</l>
<c>            * The visualization function has finished and has exited</c>
<l>            DidFinish := true</l>
<l>        elseif (Type == 'exception')</l>
<l>            DidFinish := true</l>
<l>            get_message_tuple (MessageHandle, 'exception', Exception)</l>
<l>            throw (Exception)</l>
<l>        elseif (Type == 'button_pressed')</l>
<c>            * The user pressed one of the buttons</c>
<l>            get_message_tuple (MessageHandle, 'button', ButtonID)</l>
<l>            ButtonPressed := ButtonID</l>
<l>        elseif (Type == 'redraw')</l>
<l>            get_message_tuple (MessageHandle, 'poses', Poses)</l>
<c>            * Nothing TBD</c>
<l>        else</l>
<c>            * Unknown / unexpected Message</c>
<l>            stop ()</l>
<l>        endif</l>
<l>    catch (Exception)</l>
<c>        * Ignore timeout (no message in queue)</c>
<l>        if (Exception[0] != 9400)</l>
<l>            throw (Exception)</l>
<l>        endif</l>
<l>    endtry</l>
<c></c>
<l>    get_mouse_info (WindowHandle, [], [], Row, Column, Button)</l>
<c></c>
<l>    Current := [Row,Column,Button]</l>
<l>    if (Current != PreviousState)</l>
<l>        create_message (MessageHandle)</l>
<l>        set_message_tuple (MessageHandle, 'type', 'mouse_event')</l>
<l>        set_message_tuple (MessageHandle, 'mouse_row', Row)</l>
<l>        set_message_tuple (MessageHandle, 'mouse_col', Column)</l>
<l>        set_message_tuple (MessageHandle, 'mouse_button', Button)</l>
<c>        * Remove any previous mouse message and overwrite it with the new</c>
<c>        * message. If the sub thread is too slow to process the mouse events,</c>
<c>        * we rather skip one and only use the last one. This avoids</c>
<c>        * the "lagging" GUI effect.</c>
<l>        try</l>
<l>            dequeue_message (MessageQueues[0], 'timeout', 0, MessageHandleIgnore)</l>
<l>        catch (Exception)</l>
<c>            * Ignore</c>
<l>        endtry</l>
<l>        enqueue_message (MessageQueues[0], MessageHandle, [], [])</l>
<l>        NewState := Current</l>
<l>    endif</l>
<l>catch (Exception)</l>
<l>    if (Exception[0] == 2891)</l>
<c>        * Message Queue overflow (usually of the mouse event queue)</c>
<l>        return ()</l>
<l>    elseif (Exception[0] == H_MSG_FAIL and Exception[5] == 'get_mposition_sub_pix')</l>
<c>        * Mouse not in window</c>
<c>        * Ignore</c>
<l>        wait_seconds (0.01)</l>
<l>    elseif (Exception[0] == 2454 or Exception[0] == 5100)</l>
<c>        * Handle was already cleared -&gt; indicates that the window was closed (by the user)</c>
<c>        * Abort gracefully.</c>
<l>        DidFinish := true</l>
<l>        return ()</l>
<l>    else</l>
<c>        * Unknown / Unexpected exception</c>
<l>        throw (Exception)</l>
<l>    endif</l>
<l>endtry</l>
<l>return ()</l>
</body>
<docu id="process_visualize_events_generic">
<chapters lang="en_US">
<item>System</item>
<item>Multithreading</item>
</chapters>
<library lang="en_US">MVTec Standard Procedures</library>
<short lang="en_US">Generic processor for events of visualize_object_model_3d_ext</short>
<parameters>
<parameter id="ButtonPressed">
<description lang="en_US">The index of the button pressed, or an empty tuple.</description>
<sem_type>integer</sem_type>
</parameter>
<parameter id="DidFinish">
<default_type>integer</default_type>
<description lang="en_US">Set to TRUE if the visualization procedure has finished.</description>
<sem_type>integer</sem_type>
<type_list>
<item>integer</item>
</type_list>
<values>
<item>0</item>
<item>1</item>
</values>
</parameter>
<parameter id="MessageQueues">
<default_type>integer</default_type>
<description lang="en_US">Message queues of the visualization.</description>
<mixed_type>false</mixed_type>
<multivalue>true</multivalue>
<sem_type>message_queue</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="NewState">
<description lang="en_US">New state of the mouse buttons.</description>
</parameter>
<parameter id="Poses">
<description lang="en_US">The new poses of the visualized 3D object models, or NULL if the poses are unchanged.</description>
<sem_type>pose</sem_type>
</parameter>
<parameter id="PreviousState">
<description lang="en_US">Previous state of the mouse.</description>
</parameter>
<parameter id="WindowHandle">
<default_type>integer</default_type>
<description lang="en_US">Window handle where the visualization runs in.</description>
<mixed_type>false</mixed_type>
<sem_type>window</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
</parameters>
</docu>
</procedure>
<procedure name="project_point_on_trackball" access="local">
<interface>
<ic>
<par name="X" base_type="ctrl" dimension="0"/>
<par name="Y" base_type="ctrl" dimension="0"/>
<par name="VirtualTrackball" base_type="ctrl" dimension="0"/>
<par name="TrackballSize" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="V" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c>* </c>
<l>if (VirtualTrackball == 'shoemake')</l>
<c>    * Virtual Trackball according to Shoemake</c>
<l>    R := sqrt(X * X + Y * Y)</l>
<l>    if (R &lt;= TrackballSize)</l>
<l>        XP := X</l>
<l>        YP := Y</l>
<l>        ZP := sqrt(TrackballSize * TrackballSize - R * R)</l>
<l>    else</l>
<l>        XP := X * TrackballSize / R</l>
<l>        YP := Y * TrackballSize / R</l>
<l>        ZP := 0</l>
<l>    endif</l>
<l>else</l>
<c>    * Virtual Trackball according to Bell</c>
<l>    R := sqrt(X * X + Y * Y)</l>
<l>    if (R &lt;= TrackballSize * 0.70710678)</l>
<l>        XP := X</l>
<l>        YP := Y</l>
<l>        ZP := sqrt(TrackballSize * TrackballSize - R * R)</l>
<l>    else</l>
<l>        XP := X</l>
<l>        YP := Y</l>
<l>        ZP := 0.6 * TrackballSize * TrackballSize / R</l>
<l>    endif</l>
<l>endif</l>
<l>V := [XP,YP,ZP]</l>
<l>return ()</l>
</body>
<docu id="project_point_on_trackball">
<chapters lang="de_DE">
<item>Graphik</item>
<item>Ausgabe</item>
</chapters>
<chapters lang="en_US">
<item>Graphics</item>
<item>Output</item>
</chapters>
<library lang="en_US">MVTec Standard Procedures</library>
<short lang="en_US">Project an image point onto the trackball</short>
<parameters>
<parameter id="TrackballSize"/>
<parameter id="V"/>
<parameter id="VirtualTrackball"/>
<parameter id="X"/>
<parameter id="Y"/>
</parameters>
</docu>
</procedure>
<procedure name="query_feature_group_names">
<interface>
<oc>
<par name="GroupNames" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c>* </c>
<c>* Return all available feature groups</c>
<c>* </c>
<l>gen_dummy_objects (Region, Image)</l>
<l>get_features (Region, Image, '', 'get_groups', GroupNames)</l>
<l>GroupNames := uniq(sort(GroupNames))</l>
<l>GroupNames := [GroupNames,'all']</l>
<l>return ()</l>
</body>
<docu id="query_feature_group_names">
<abstract lang="en_US">List all available feature group names.

For more information about the usage of the get_feature_set library, see documentation of calculate_features.</abstract>
<alternatives>
<item>query_feature_names_by_group</item>
</alternatives>
<chapters lang="de_DE">
<item>Klassifikation</item>
<item>Sonstiges</item>
</chapters>
<chapters lang="en_US">
<item>Classification</item>
<item>Misc</item>
</chapters>
<keywords lang="en_US">
<item>classification</item>
<item>features</item>
</keywords>
<library lang="en_US">MVTec Standard Procedures</library>
<see_also>
<item>calculate_features</item>
<item>get_custom_features</item>
</see_also>
<short lang="en_US">List all available feature group names.</short>
<successor>
<item>get_feature_names</item>
</successor>
<parameters>
<parameter id="GroupNames">
<default_type>string</default_type>
<description lang="en_US">All available feature group names.</description>
<mixed_type>false</mixed_type>
<sem_type>string</sem_type>
<type_list>
<item>string</item>
</type_list>
</parameter>
</parameters>
</docu>
</procedure>
<procedure name="query_feature_names_by_group">
<interface>
<ic>
<par name="GroupNames" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="FeatureNames" base_type="ctrl" dimension="0"/>
<par name="Groups" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c>* </c>
<c>* Return a table (consisting of two tuples)</c>
<c>* of all features and the groups they belong to.</c>
<c>* </c>
<l>FeatureNames := []</l>
<l>Groups := []</l>
<l>gen_dummy_objects (Region, Image)</l>
<l>for I := 0 to |GroupNames| - 1 by 1</l>
<l>    get_features (Region, Image, GroupNames[I], 'get_names', Names)</l>
<l>    FeatureNames := [FeatureNames,Names]</l>
<l>    Groups := [Groups,gen_tuple_const(|Names|,GroupNames[I])]</l>
<l>endfor</l>
<l>return ()</l>
</body>
<docu id="query_feature_names_by_group">
<abstract lang="en_US">query_feature_names_by_group returns the tuple FeatureNames, which contains a list of feature names that belong to the feature groups given in GroupNames, and the tuple Groups which contains the respective group names.
I.e., for any given index I, the feature FeatureNames[I] belongs to the group Groups[I].

Note, that groups normally consist of multiple features, and features may belong to multiple groups. Therfore feature names and group names will occur multiple times.
The feature names are sorted by groups, i.e., the resulting tuples may look like this, where 'name1' and 'name3' belong to the groups 1 and 2, and 'name2' only belongs to "GROUP1'.

FeatureNames == ['name1','name2','name3','name1','name3']
Groups == ['GROUP1','GROUP1','GROUP1','GROUP2','GROUP2']

For more information about the usage of the get_feature_set library, see documentation of calculate_features.

</abstract>
<alternatives>
<item>query_feature_group_names</item>
</alternatives>
<chapters lang="de_DE">
<item>Klassifikation</item>
<item>Sonstiges</item>
</chapters>
<chapters lang="en_US">
<item>Classification</item>
<item>Misc</item>
</chapters>
<keywords lang="en_US">
<item>calssification</item>
<item>features</item>
</keywords>
<library lang="en_US">MVTec Standard Procedures</library>
<see_also>
<item>get_feature_names</item>
<item>calculate_features</item>
<item>get_custom_features</item>
</see_also>
<short lang="en_US">Returns a table of feature names sorted by groups.</short>
<successor>
<item>get_feature_names</item>
</successor>
<parameters>
<parameter id="FeatureNames">
<default_type>string</default_type>
<description lang="en_US">Feature names.</description>
<multivalue>optional</multivalue>
<sem_type>string</sem_type>
<type_list>
<item>string</item>
</type_list>
</parameter>
<parameter id="GroupNames">
<default_type>string</default_type>
<description lang="en_US">Feature group names.</description>
<mixed_type>false</mixed_type>
<multivalue>optional</multivalue>
<sem_type>string</sem_type>
<type_list>
<item>string</item>
</type_list>
</parameter>
<parameter id="Groups">
<default_type>string</default_type>
<description lang="en_US">Group names corresponding to the features in FeatureNames.</description>
<mixed_type>false</mixed_type>
<multivalue>optional</multivalue>
<sem_type>string</sem_type>
<type_list>
<item>string</item>
</type_list>
</parameter>
</parameters>
</docu>
</procedure>
<procedure name="read_dict_object">
<interface>
<oo>
<par name="ObjectData" base_type="iconic" dimension="0"/>
</oo>
<ic>
<par name="DictHandle" base_type="ctrl" dimension="0"/>
<par name="Key" base_type="ctrl" dimension="0"/>
</ic>
</interface>
<body>
<l>try</l>
<l>    get_dict_object (ObjectData, DictHandle, Key)</l>
<l>catch (Exception)</l>
<l>    throw ('The key ' + Key + ' is missing from the dict ' + DictHandle)</l>
<l>endtry</l>
<l>return ()</l>
</body>
<docu id="read_dict_object">
<chapters lang="en_US">
<item>System</item>
<item>Multithreading</item>
</chapters>
<library lang="en_US">MVTec Standard Procedures</library>
<parameters>
<parameter id="DictHandle">
<default_type>integer</default_type>
<mixed_type>false</mixed_type>
<sem_type>dict</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="Key">
<sem_type>string</sem_type>
</parameter>
<parameter id="ObjectData">
<sem_type>object</sem_type>
</parameter>
</parameters>
</docu>
</procedure>
<procedure name="read_dict_tuple">
<interface>
<ic>
<par name="DictHandle" base_type="ctrl" dimension="0"/>
<par name="Key" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="TupleData" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<l>try</l>
<l>    get_dict_tuple (DictHandle, Key, TupleData)</l>
<l>catch (Exception)</l>
<l>    throw ('The key ' + Key + ' is missing from the dict ' + DictHandle)</l>
<l>endtry</l>
<l>return ()</l>
</body>
<docu id="read_dict_tuple">
<chapters lang="en_US">
<item>System</item>
<item>Multithreading</item>
</chapters>
<library lang="en_US">MVTec Standard Procedures</library>
<parameters>
<parameter id="DictHandle">
<default_type>integer</default_type>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>dict</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="Key">
<default_type>string</default_type>
<multivalue>false</multivalue>
<sem_type>string</sem_type>
<type_list>
<item>string</item>
</type_list>
</parameter>
<parameter id="TupleData">
<default_type>string</default_type>
<type_list>
<item>string</item>
</type_list>
</parameter>
</parameters>
</docu>
</procedure>
<procedure name="read_dl_classifier_data_set">
<interface>
<ic>
<par name="ImageDirectory" base_type="ctrl" dimension="0"/>
<par name="LabelSource" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="ImageFiles" base_type="ctrl" dimension="0"/>
<par name="GroundTruthLabels" base_type="ctrl" dimension="0"/>
<par name="LabelIndices" base_type="ctrl" dimension="0"/>
<par name="UniqueClasses" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c>* This procedures lists all ImageFiles</c>
<c>* located in ImageDirectory and its subdirectories,</c>
<c>* and returns the label of each image in GroundTruthLabels.</c>
<c>* LabelSource determines how the ground truth labels are extracted.</c>
<c>* Additionally, indices are assigned to the labels,</c>
<c>* which can be used for the training instead</c>
<c>* of the string labels, which is more time efficient.</c>
<c>* The order of indices corresponds with the returned</c>
<c>* unique Classes.</c>
<c>* </c>
<c>* Check the parameter ImageDirectory.</c>
<l>if (not is_string(ImageDirectory))</l>
<l>    throw ('ImageDirectory ' + ImageDirectory + 'is not a string.')</l>
<l>endif</l>
<c>* </c>
<c>* List all images in the provided directory</c>
<c>* and its subdirectories ('recursive').</c>
<l>list_image_files (ImageDirectory, ['hobj','ima','bmp','jpg','png','tiff','tif','gif','jpeg','pcx','pgm','ppm','pbm','xwd','pnm'], ['recursive','follow_links'], ImageFiles)</l>
<l>if (|ImageFiles| == 0)</l>
<l>    throw ('Error: Could not find any image files in folder: "' + ImageDirectory + '"')</l>
<l>endif</l>
<c>* </c>
<c>* Get the ground truth labels.</c>
<c>* Note that when configuring your own LabelSource mode,</c>
<c>* you might find the procedure parse_filename helpful.</c>
<l>if (LabelSource == 'last_folder')</l>
<c>    * The last folder name containing the image</c>
<c>    * is used as label.</c>
<l>    tuple_regexp_match (ImageFiles, '.*/([^/]+)/[^/]*$', GroundTruthLabels)</l>
<l>elseif (LabelSource == 'file_name')</l>
<c>    * The file name of each image is used as label.</c>
<l>    tuple_regexp_match (ImageFiles, '.*/([^/]+)[.][^/]*$', GroundTruthLabels)</l>
<l>elseif (LabelSource == 'file_name_remove_index')</l>
<c>    * The file name of each image is used as label.</c>
<c>    * All consecutive digits and underscores</c>
<c>    * at the end of the file name are removed.</c>
<l>    tuple_regexp_match (ImageFiles, '.*/([^/]+)[.][^/]*$', LabelsTmp)</l>
<l>    tuple_regexp_replace (LabelsTmp, '[0-9_]*$', '', GroundTruthLabels)</l>
<l>elseif (LabelSource == [])</l>
<l>    GroundTruthLabels := []</l>
<l>else</l>
<l>    throw ('LabelSource not supported.')</l>
<l>endif</l>
<c>* Get the unique elements of Labels,</c>
<c>* which represent the classes.</c>
<l>UniqueClasses := uniq(sort(GroundTruthLabels))</l>
<c>* Assign indices to the labels.</c>
<l>LabelIndices := GroundTruthLabels</l>
<l>for ClassIndex := 0 to |UniqueClasses| - 1 by 1</l>
<l>    LabelIndices[find(LabelIndices,UniqueClasses[ClassIndex])] := ClassIndex</l>
<l>endfor</l>
<l>return ()</l>
</body>
<docu id="read_dl_classifier_data_set">
<abstract lang="en_US">read_dl_classifier_data_set lists all ImageFiles located in ImageDirectory and its subdirectories, and returns the ground truth label of each image in GroundTruthLabels. LabelSource determines how the GroundTruthLabels are extracted. Additionally, indices are assigned to the labels, and the result is returned in LabelIndices. These indices can be used for the training instead of the string labels, which is more time efficient. The order of indices corresponds with the returned UniqueClasses.

The images are listed using the procedure list_image_files. Note that subfolders and links are included as well. For more information on the used default directories, please have a look at its documentation.

For LabelSource, three modes are supported: For 'last_folder', the last folder name containing the image is used as label. For 'file_name', the file name of each image is used as label. For 'file_name_remove_index', all consecutive digits and underscores at the end of the file name (e.g., '01', '_20180101') are removed. If you want to configure your own LabelSource mode, you might find the procedure parse_filename helpful.</abstract>
<chapters lang="en_US">
<item>Legacy</item>
<item>DL Classification</item>
</chapters>
<library lang="en_US">MVTec Standard Procedures</library>
<short lang="en_US">Read the data set containing the images and their respective ground truth labels.</short>
<warning lang="en_US">read_dl_classifier_data_set is obsolete and is only provided for reasons of backward compatibility.
New applications should use the general CNN-based procedure read_dl_dataset_classification.</warning>
<parameters>
<parameter id="GroundTruthLabels">
<default_type>string</default_type>
<description lang="en_US">Ground truth labels of the images.</description>
<mixed_type>false</mixed_type>
<multivalue>optional</multivalue>
<sem_type>string</sem_type>
<type_list>
<item>string</item>
</type_list>
</parameter>
<parameter id="ImageDirectory">
<default_type>string</default_type>
<description lang="en_US">The image directory.</description>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>filename.dir</sem_type>
<type_list>
<item>string</item>
</type_list>
</parameter>
<parameter id="ImageFiles">
<default_type>string</default_type>
<description lang="en_US">Tuple of the image paths.</description>
<mixed_type>false</mixed_type>
<multivalue>optional</multivalue>
<sem_type>string</sem_type>
<type_list>
<item>string</item>
</type_list>
</parameter>
<parameter id="LabelIndices">
<default_type>integer</default_type>
<description lang="en_US">The labels represented by indices.</description>
<multivalue>optional</multivalue>
<sem_type>integer</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="LabelSource">
<default_type>string</default_type>
<default_value>'last_folder'</default_value>
<description lang="en_US">The mode how the ground truth labels are extracted.</description>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>string</sem_type>
<type_list>
<item>string</item>
</type_list>
<values>
<item>'last_folder'</item>
<item>'file_name'</item>
<item>'file_name_remove_index'</item>
</values>
</parameter>
<parameter id="UniqueClasses">
<default_type>string</default_type>
<description lang="en_US">The unique classes.</description>
<mixed_type>false</mixed_type>
<multivalue>optional</multivalue>
<sem_type>string</sem_type>
<type_list>
<item>string</item>
</type_list>
</parameter>
</parameters>
</docu>
</procedure>
<procedure name="read_dl_dataset_anomaly">
<interface>
<ic>
<par name="ImageDir" base_type="ctrl" dimension="0"/>
<par name="AnomalyDir" base_type="ctrl" dimension="0"/>
<par name="ImageList" base_type="ctrl" dimension="0"/>
<par name="AnomalyList" base_type="ctrl" dimension="0"/>
<par name="GenParam" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="DLDataset" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c>* </c>
<c>* This procedure creates the dictionary DLDataset which serves as an input for deep-learning-based anomaly detection models.</c>
<c>* Information needed to create this dictionary is given through the input parameters.</c>
<c>* </c>
<c>* The output dictionary DLDataset has the following structure:</c>
<c>* </c>
<c>* DLDataset</c>
<c>* {</c>
<c>*     'image_dir'         : Common base path of all images</c>
<c>*     'anomaly_dir'       : Common base path of all anomaly annotation files (ground truth annotations indicating anomalies in the images)</c>
<c>*     'class_names'[]     : Tuple of class names ['ok','nok']</c>
<c>*     'class_ids'[]       : Tuple of class ids [0,1]</c>
<c>*     'samples'[]         : Tuple of dictionaries</c>
<c>*     {</c>
<c>*         'image_file_name'           : File path relative to 'image_dir' (including the file name)</c>
<c>*         'anomaly_file_name'         : File path relative to 'anomaly_dir' (including the file name), contains a file with ground truth annotations</c>
<c>*         'image_id'                  : Unique image ID</c>
<c>*         'anomaly_label'             : Label on image level : 'ok'/'nok'</c>
<c>*     }</c>
<c>* }</c>
<c>* </c>
<c>* Images are not required to have a anomaly ground truth file. However, images that do have a</c>
<c>* corresponding annotation file can be evaluated quantitatively later. Note: Unlike in</c>
<c>* read_dl_dataset_classification, the folder name is not directly converted into the</c>
<c>* 'anomaly_label'. For images without anomalies (images in the good/ok directory), the label</c>
<c>* is set to 'ok' and for all images containing anomalies (images in any directory except for</c>
<c>* good/ok), the label is set to the general label 'nok'.</c>
<c>* </c>
<c>* Convert Anomaly Detection specific keys to general keys.</c>
<l>GenParamCopy := []</l>
<l>if (GenParam != [])</l>
<l>    copy_dict (GenParam, [], [], GenParamCopy)</l>
<l>    get_dict_param (GenParamCopy, 'keys', [], Keys)</l>
<l>    for KeyIndex := 0 to |Keys| - 1 by 1</l>
<l>        CurrentKey := Keys[KeyIndex]</l>
<l>        if (CurrentKey == 'anomaly_sub_dirs')</l>
<l>            get_dict_tuple (GenParamCopy, CurrentKey, AnomalySubDirs)</l>
<l>            remove_dict_key (GenParamCopy, CurrentKey)</l>
<l>            set_dict_tuple (GenParamCopy, 'annotation_sub_dirs', AnomalySubDirs)</l>
<l>        elseif (CurrentKey == 'file_name_anomaly_only')</l>
<l>            get_dict_tuple (GenParamCopy, CurrentKey, FileNameAnomalyOnly)</l>
<l>            remove_dict_key (GenParamCopy, CurrentKey)</l>
<l>            set_dict_tuple (GenParamCopy, 'file_name_annotation_only', FileNameAnomalyOnly)</l>
<l>        endif</l>
<l>    endfor</l>
<l>endif</l>
<c>* </c>
<c>* Sanity checks of inputs.</c>
<c>* </c>
<c>* ImageDir has to be a single string.</c>
<l>if (|ImageDir| != 1)</l>
<l>    throw ('Exactly one base path is required as input for ImageDir')</l>
<l>elseif (not is_string(ImageDir))</l>
<l>    throw ('ImageDir has to be a string')</l>
<l>endif</l>
<c>* </c>
<c>* AnomalyDir has to be a single string.</c>
<l>AnomalyDirGiven := false</l>
<l>if (|AnomalyDir| &gt; 1)</l>
<l>    throw ('Exactly one base path is required as input for AnomalyDir')</l>
<l>elseif (|AnomalyDir| == 1)</l>
<l>    if (not is_string(AnomalyDir))</l>
<l>        throw ('AnomalyDir has to be a string')</l>
<l>    endif</l>
<l>    AnomalyDirGiven := true</l>
<l>endif</l>
<c>* </c>
<c>* Check AnomalyList in case it is not empty.</c>
<l>if (AnomalyList != [])</l>
<c>    * Check if ImageList and AnomalyList have the same length.</c>
<l>    if (|ImageList| != |AnomalyList|)</l>
<l>        throw ('AnomalyList must be empty or have the same length as ImageList')</l>
<l>    elseif (max(AnomalyList [!=] '') == 0)</l>
<l>        throw ('Please provide at least one valid anomaly file in AnomalyList or set the parameter to []')</l>
<l>    endif</l>
<l>endif</l>
<c>* </c>
<c>* Prepare the image lists.</c>
<c>* </c>
<c>* Convert backslashes to forward slashes for unified processing.</c>
<l>tuple_regexp_replace (ImageDir, ['\\\\+','replace_all'], '/', ImageDir)</l>
<l>tuple_regexp_replace (AnomalyDir, ['\\\\+','replace_all'], '/', AnomalyDir)</l>
<l>tuple_regexp_replace (ImageList, ['\\\\+','replace_all'], '/', ImageList)</l>
<l>tuple_regexp_replace (AnomalyList, ['\\\\+','replace_all'], '/', AnomalyList)</l>
<c>* </c>
<c>* Replace any forward slashes at the end.</c>
<l>tuple_regexp_replace (ImageDir, '/$', '', ImageDir)</l>
<l>tuple_regexp_replace (AnomalyDir, '/$', '', AnomalyDir)</l>
<c>* </c>
<c>* If no AnomalyList is given, create it out of the given ImageList or create both lists.</c>
<l>if (AnomalyList == [])</l>
<c>    * List given images (or all images if none given) and their corresponding labels,</c>
<c>    * as well as their anomaly annotation files (if present).</c>
<l>    list_image_and_annotation_files ('anomaly_detection', ImageDir, AnomalyDir, ImageList, GenParamCopy, ImageList, LabelList, AnomalyList)</l>
<l>else</l>
<c>    * Make sure that ImageList does not contain ImageDir.</c>
<l>    tuple_regexp_replace (ImageList, '.*?' + ImageDir, '', ImageList)</l>
<l>    tuple_regexp_replace (ImageList, '^/', '', ImageList)</l>
<c>    * Get ground truth labels from the image directory names.</c>
<l>    tuple_regexp_match ('/' + ImageList, '.*/([^/]+)/[^/]*$', LabelList)</l>
<c>    * Make sure that AnomalyList does not contain AnomalyDir.</c>
<l>    tuple_regexp_replace (AnomalyList, '.*?' + AnomalyDir, '', AnomalyList)</l>
<l>    tuple_regexp_replace (AnomalyList, '^/', '', AnomalyList)</l>
<l>endif</l>
<c>* </c>
<c>* Check that for a given anomaly directory at least one annotation file is found.</c>
<l>NoAnomalyIndices := find(AnomalyList,'')</l>
<l>if (|NoAnomalyIndices| == |ImageList| and AnomalyDirGiven)</l>
<l>    throw ('Error: Could not find any matching anomaly regions in folder: "' + AnomalyDir + '"')</l>
<l>endif</l>
<c>* </c>
<c>* If ImageDir or AnomalyDir is empty, we omit the path separator.</c>
<l>if (strlen(ImageDir) == 0)</l>
<l>    ImageDirSep := ''</l>
<l>else</l>
<l>    ImageDirSep := '/'</l>
<l>endif</l>
<l>if (strlen(AnomalyDir) == 0)</l>
<l>    AnomalyDirSep := ''</l>
<l>else</l>
<l>    AnomalyDirSep := '/'</l>
<l>endif</l>
<c>* </c>
<c>* Check if all images exist.</c>
<l>images_exist (ImageDir + ImageDirSep + ImageList)</l>
<c>* Check if all anomaly files exist.</c>
<l>AnomalyFileIndices := find(AnomalyList [!=] '',1)</l>
<l>if (AnomalyFileIndices != -1)</l>
<l>    images_exist (AnomalyDir + AnomalyDirSep + AnomalyList[AnomalyFileIndices])</l>
<l>endif</l>
<c>* </c>
<c>* Initialize the dictionary dataset.</c>
<l>create_dict (DLDataset)</l>
<c>* </c>
<c>* Set general information of the dataset.</c>
<l>set_dict_tuple (DLDataset, 'image_dir', ImageDir)</l>
<l>if (AnomalyDirGiven)</l>
<l>    set_dict_tuple (DLDataset, 'anomaly_dir', AnomalyDir)</l>
<l>endif</l>
<c>* We have the two anomaly labels 'ok' and 'nok'.</c>
<l>ClassNames := ['ok','nok']</l>
<l>tuple_gen_sequence (0, |ClassNames| - 1, 1, ClassIDs)</l>
<l>set_dict_tuple (DLDataset, 'class_names', ClassNames)</l>
<l>set_dict_tuple (DLDataset, 'class_ids', ClassIDs)</l>
<c>* </c>
<c>* Get number of samples to set unique image ID for each sample according to its index in ImageList.</c>
<l>NumSamples := |ImageList|</l>
<c>* </c>
<c>* Initialize sample tuple.</c>
<l>Samples := []</l>
<c>* Loop over samples.</c>
<l>for SampleIndex := 0 to NumSamples - 1 by 1</l>
<c>    * </c>
<c>    * Create the dictionary Sample.</c>
<l>    create_dict (Sample)</l>
<c>    * </c>
<c>    * Set information about this sample.</c>
<l>    set_dict_tuple (Sample, 'image_id', SampleIndex)</l>
<l>    set_dict_tuple (Sample, 'image_file_name', ImageList[SampleIndex])</l>
<c>    * </c>
<l>    Label := LabelList[SampleIndex]</l>
<l>    if (Label == '')</l>
<l>        throw ('Could not determine label for image: ' + ImageList[SampleIndex])</l>
<l>    endif</l>
<c>    * </c>
<c>    * Match for good labels.</c>
<l>    if (regexp_match(Label,['^ok$','ignore_case']) != '' or regexp_match(Label,['^good$','ignore_case']) != '')</l>
<l>        set_dict_tuple (Sample, 'anomaly_label', 'ok')</l>
<l>    else</l>
<l>        set_dict_tuple (Sample, 'anomaly_label', 'nok')</l>
<l>    endif</l>
<c>    * </c>
<c>    * Check if sample has a anomaly annotation.</c>
<l>    if (AnomalyDirGiven)</l>
<l>        AnomalyFileName := AnomalyList[SampleIndex]</l>
<l>        if (AnomalyFileName != '')</l>
<l>            set_dict_tuple (Sample, 'anomaly_file_name', AnomalyFileName)</l>
<l>        endif</l>
<l>    endif</l>
<c>    * </c>
<c>    * Append this sample.</c>
<l>    Samples := [Samples,Sample]</l>
<l>endfor</l>
<c>* </c>
<c>* Set the sample tuple.</c>
<l>set_dict_tuple (DLDataset, 'samples', Samples)</l>
<c>* </c>
<l>return ()</l>
</body>
<docu id="read_dl_dataset_anomaly">
<abstract lang="en_US">This procedure generates a DLDataset dictionary as required for a deep-learning-based anomaly detection model.

ImageDir specifies the base directory for the subfolders containing the images. The subfolder containing images without anomalies needs to be named either 'good' or 'ok' (capital letters are also accepted). The folder name for images containing anomalies can be any string except 'good' and 'ok'. AnomalyDir specifies the base directory for the anomaly annotation files and is an optional parameter. To use DL Anomaly Detection, it is not necessary to have anomaly annotations. They can be used to evaluate the model after training. If available, the anomaly annotations need to be given as ground truth images or as HALCON regions saved as .hobj files. In order to create the correspondence between an anomaly annotation file and an image, the full file name of the image needs to be contained in the file name of the anomaly annotation file. E.g. for an image named 'test_crack_001.png', the anomaly ground truth file needs to contain the string 'test_crack_001' in its name.

Example for a folder structure:

ImageDir
|
|---&gt; good (contains all images without anomalies, file names are arbitrary)
|
|---------&gt; good_001.png
|---------&gt; good_002.png
|
|---&gt; (other names) (optional, contains anomalous images)
|
|---------&gt; crack_001.png
|---------&gt; contamination_002.png

AnomalyDir
|
|---&gt; (other names)
|
|---------&gt; crack_001_gt.hobj (corresponds to 'crack_001.png')
|---------&gt; contamination_002_gt.hobj (corresponds to 'contamination_002.png')

ImageList is a list specifying the images and AnomalyList a list with the corresponding anomaly files. These lists can either contain the full paths of the images and anomaly files or the paths relative to ImageDir and AnomalyDir, respectively. If both, ImageList and AnomalyList, are empty tuples, both lists are generated by listing image files in ImageDir and anomaly files in AnomalyDir, respectively. If only AnomalyList is an empty tuple, it is generated by listing all anomaly files in AnomalyDir and matching these files to the images in ImageList based on their file names. In case both ImageList and AnomalyList are not empty tuples, an anomaly file needs to be given for each of the images in ImageDir in the same order in AnomalyList. Since not every image requires a corresponding anomaly annotation, set the name in AnomalyList to '' (empty string) in case there is no anomaly file for the image.

The image and anomaly lists can be constrained. For this, use the dictionary GenParam, allowing the following keys:
- 'image_sub_dirs': List of directories located in ImageDir. Constrain the image list to these directories. The default value is [], meaning all directories in ImageDir are considered.
- 'anomaly_sub_dirs': List of directories located in AnomalyDir. Constrain the anomaly list to these directories. The default value is [], meaning all directories in AnomalyDir are considered.
- 'file_name_image_only': Prefix or suffix, that has to be part of the image file names but is not part of the anomaly file names. The default value is ''.
- 'file_name_anomaly_only': String that has to be part of the anomaly file names (note, this serves as identifier for the anomaly files and thus should not be part of the image file names). The default value is ''.

The output of the procedure is the dictionary DLDataset, which serves as a database. The keys of the dictionary are:
- 'image_dir'
- 'anomaly_dir'
- 'class_names'
- 'class_ids'
- 'samples'

The value for the key 'samples' is a tuple of dictionaries with the keys:
- 'image_id' - a unique integer ID for each sample,
- 'image_file_name' - the relative path of the sample image,
- 'anomaly_label' - label for the entire image which is either 'ok' or 'nok',
- 'anomaly_file_name' - the relative path of the sample annotated anomaly file.

For further information on these dictionaries and their usage, please see the chapter Deep Learning / Model.</abstract>
<chapters lang="en_US">
<item>Deep Learning</item>
<item>Anomaly Detection</item>
</chapters>
<library lang="en_US">MVTec Standard Procedures</library>
<short lang="en_US">Generate a DLDataset dictionary for anomaly detection.</short>
<parameters>
<parameter id="AnomalyDir">
<default_type>string</default_type>
<default_value>[]</default_value>
<description lang="en_US">Base directory of the folders containing the anomaly ground truth files.</description>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>filename.dir</sem_type>
<type_list>
<item>string</item>
</type_list>
</parameter>
<parameter id="AnomalyList">
<default_type>string</default_type>
<default_value>[]</default_value>
<description lang="en_US">List of paths of anomaly ground truth files.
If it is an empty tuple, the anomaly list is generated automatically.</description>
<mixed_type>false</mixed_type>
<multivalue>optional</multivalue>
<sem_type>string</sem_type>
<type_list>
<item>string</item>
</type_list>
</parameter>
<parameter id="DLDataset">
<default_type>integer</default_type>
<description lang="en_US">The generated dataset dictionary.</description>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>dict</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="GenParam">
<default_type>integer</default_type>
<default_value>[]</default_value>
<description lang="en_US">GenParam is a dictionary, which can be used to constrain the generated image and anomaly file lists.</description>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>dict</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="ImageDir">
<default_type>integer</default_type>
<description lang="en_US">Base directory of the folders containing the images.</description>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>filename.dir</sem_type>
<type_list>
<item>integer</item>
<item>string</item>
</type_list>
</parameter>
<parameter id="ImageList">
<default_type>string</default_type>
<default_value>[]</default_value>
<description lang="en_US">List of image paths.
If it is an empty tuple, the image list is generated automatically.</description>
<mixed_type>false</mixed_type>
<multivalue>optional</multivalue>
<sem_type>string</sem_type>
<type_list>
<item>string</item>
</type_list>
</parameter>
</parameters>
</docu>
</procedure>
<procedure name="read_dl_dataset_classification">
<interface>
<ic>
<par name="RawImageFolder" base_type="ctrl" dimension="0"/>
<par name="LabelSource" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="DLDataset" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c>* </c>
<c>* This procedure creates a dictionary DLDataset,</c>
<c>* which serves as an input for deep-learning-based classification models.</c>
<c>* Information needed to create this dictionary is given through the input parameters.</c>
<c>* </c>
<c>* The output dictionary DLDataset has the following structure:</c>
<c>* </c>
<c>* DLDataset</c>
<c>* {</c>
<c>*     'image_dir'         : Common base path of all images</c>
<c>*     'class_names'[]     : Tuple of strings</c>
<c>*     'class_ids'[]       : Tuple of integers [0, ..., |ClassNames|-1]</c>
<c>*     'samples'[]         : Tuple of dictionaries</c>
<c>*     {</c>
<c>*         'image_file_name'    : File path relative to 'image_dir' (including the file name)</c>
<c>*         'image_id'           : Unique image ID</c>
<c>*         'image_label_id'     : Class ID assigned to the image</c>
<c>*     }</c>
<c>* }</c>
<c>* </c>
<c>* Sanity checks of inputs.</c>
<c>* </c>
<c>* Check the parameter RawImageFolder.</c>
<l>for IndexFolder := 0 to |RawImageFolder| - 1 by 1</l>
<l>    if (not is_string(RawImageFolder[IndexFolder]))</l>
<l>        throw ('RawImageFolder ' + RawImageFolder[IndexFolder] + ' is not a string.')</l>
<l>    endif</l>
<l>endfor</l>
<c>* Check options of LabelSource.</c>
<l>if (|LabelSource| != 1)</l>
<l>    throw ('Parameter "LabelSource" has to be of length 1.')</l>
<l>endif</l>
<l>LabelSourceValidOptions := ['last_folder','file_name','file_name_remove_index']</l>
<l>tuple_find (LabelSourceValidOptions, LabelSource, Index)</l>
<l>if (Index == -1)</l>
<l>    throw ('Unknown option for LabelSource: "' + LabelSource + '".')</l>
<l>endif</l>
<c>* </c>
<c>* Prepare the image lists and get class names and image folders.</c>
<c>* </c>
<l>tuple_uniq (RawImageFolder, RawImageFolder)</l>
<c>* Replace doubled backward slashes by forward slashes.</c>
<l>tuple_regexp_replace (RawImageFolder, ['\\\\+','replace_all'], '/', RawImageFolder)</l>
<c>* Replace any forward slashes at the end.</c>
<l>tuple_regexp_replace (RawImageFolder, '/$', '', RawImageFolder)</l>
<c>* Replace windows path separators</c>
<l>tuple_regexp_replace (RawImageFolder, ['\\\\+','replace_all'], '/', RawImageFolder)</l>
<c></c>
<c>* </c>
<c>* List all images in the provided image folders</c>
<c>* and its subfolders ('recursive').</c>
<l>list_image_files (RawImageFolder, ['hobj','ima','bmp','jpg','png','tiff','tif','gif','jpeg','pcx','pgm','ppm','pbm','xwd','pnm'], ['recursive','follow_links'], ImageFiles)</l>
<l>if (|ImageFiles| == 0)</l>
<l>    throw ('Error: Could not find any image files in folder: "' + RawImageFolder + '"')</l>
<l>endif</l>
<c>* </c>
<c>* Get the ground truth labels and with them the classes to be distinguished.</c>
<c>* Note that when configuring your own LabelSource mode,</c>
<c>* you might find the procedure parse_filename helpful.</c>
<l>if (LabelSource == LabelSourceValidOptions[0])</l>
<c>    * The name of the last folder containing the image is used as label.</c>
<l>    tuple_regexp_match (ImageFiles, '([^/]+)/[^/]*$', GroundTruthLabels)</l>
<l>elseif (LabelSource == LabelSourceValidOptions[1])</l>
<c>    * The file name of each image is used as label.</c>
<l>    tuple_regexp_match (ImageFiles, '.*/([^/]+)[.][^/]*$', GroundTruthLabels)</l>
<l>elseif (LabelSource == LabelSourceValidOptions[2])</l>
<c>    * The file name of each image is used as label.</c>
<c>    * All consecutive digits and underscores</c>
<c>    * at the end of the file name are removed.</c>
<l>    tuple_regexp_match (ImageFiles, '.*/([^/]+)[.][^/]*$', LabelsTmp)</l>
<l>    tuple_regexp_replace (LabelsTmp, '[0-9_]*$', '', GroundTruthLabels)</l>
<l>elseif (LabelSource == [])</l>
<l>    GroundTruthLabels := []</l>
<l>endif</l>
<c>* Get the unique elements of GroundTruthLabels.</c>
<l>ClassNames := uniq(sort(GroundTruthLabels))</l>
<l>tuple_gen_sequence (0, |ClassNames| - 1, 1, ClassIDs)</l>
<c>* Assign indices to the class labels.</c>
<l>LabelIndices := GroundTruthLabels</l>
<l>for ClassIndex := 0 to |ClassNames| - 1 by 1</l>
<l>    LabelIndices[find(LabelIndices,ClassNames[ClassIndex])] := ClassIndex</l>
<l>endfor</l>
<c>* </c>
<c>* Set the common parent folder of entries in RawImageFolder as image folders.</c>
<l>ImageDir := RawImageFolder[0]</l>
<l>tuple_regexp_match (ImageDir, '^/', LeadingSlash)</l>
<l>for RawFolderIndex := 1 to |RawImageFolder| - 1 by 1</l>
<l>    CurrentRawFolder := RawImageFolder[RawFolderIndex]</l>
<l>    tuple_regexp_match (CurrentRawFolder, '^/', CurrentLeadingSlash)</l>
<l>    tuple_split (ImageDir, '/', ImageDirSubstrings)</l>
<l>    tuple_split (CurrentRawFolder, '/', CurrentSubstrings)</l>
<l>    Length := min2(|ImageDirSubstrings|,|CurrentSubstrings|)</l>
<l>    if (LeadingSlash != CurrentLeadingSlash or Length &lt; 1)</l>
<l>        ImageDir := '.'</l>
<l>        break</l>
<l>    endif</l>
<c>    * Get common parent folder of both paths.</c>
<l>    Common := ImageDirSubstrings[0:Length - 1] [==] CurrentSubstrings[0:Length - 1]</l>
<l>    ImageDirTmp := ''</l>
<l>    Index := 0</l>
<l>    while (Index &lt; |Common|)</l>
<l>        if (Common[Index] == 1)</l>
<l>            ImageDirTmp := ImageDirTmp + '/' + ImageDirSubstrings[Index]</l>
<l>        else</l>
<l>            break</l>
<l>        endif</l>
<l>        Index := Index + 1</l>
<l>    endwhile</l>
<l>    if (Index == 0)</l>
<l>        ImageDir := '.'</l>
<l>        break</l>
<l>    endif</l>
<c>    * Set correct leading slash.</c>
<l>    tuple_regexp_replace (ImageDirTmp, '^/', '', ImageDirTmp)</l>
<l>    ImageDir := LeadingSlash + ImageDirTmp</l>
<l>endfor</l>
<c>* </c>
<c>* Initialize the dictionary dataset.</c>
<l>create_dict (DLDataset)</l>
<c>* </c>
<c>* Set general information of the dataset.</c>
<l>set_dict_tuple (DLDataset, 'image_dir', ImageDir)</l>
<l>set_dict_tuple (DLDataset, 'class_names', ClassNames)</l>
<l>set_dict_tuple (DLDataset, 'class_ids', ClassIDs)</l>
<c>* </c>
<c>* Get number of samples to set unique image ID for each sample according to its index in ImageList.</c>
<l>NumSamples := |ImageFiles|</l>
<c>* </c>
<c>* Initialize sample tuple.</c>
<l>Samples := []</l>
<c>* Loop over samples.</c>
<l>for SampleIndex := 0 to NumSamples - 1 by 1</l>
<c>    * </c>
<c>    * Create the dictionary Sample.</c>
<l>    create_dict (Sample)</l>
<c>    * Set information about this sample.</c>
<l>    ImageID := SampleIndex</l>
<l>    set_dict_tuple (Sample, 'image_id', ImageID)</l>
<c>    * 'image_file_name' has to be relative to ImageDir.</c>
<l>    ImageFile := ImageFiles[SampleIndex]</l>
<l>    if (ImageDir == '.')</l>
<l>        tuple_strstr (ImageFile, RawImageFolder, Positions)</l>
<l>        Position := Positions[find(Positions [!=] -1,1)]</l>
<l>    else</l>
<l>        tuple_strstr (ImageFile, ImageDir, Position)</l>
<l>        tuple_strlen (ImageDir, ImageDirLength)</l>
<l>        Position := Position + ImageDirLength + 1</l>
<l>    endif</l>
<l>    ImageFileName := str_lastn(ImageFile,Position)</l>
<c>    * Test if the image path is correct.</c>
<l>    file_exists (ImageDir + '/' + ImageFileName, FileExists)</l>
<l>    if (not FileExists)</l>
<l>        throw ('An error occured when adding the following image to the dataset: ' + ImageFile)</l>
<l>    endif</l>
<l>    set_dict_tuple (Sample, 'image_file_name', ImageFileName)</l>
<c>    * Set class ID.</c>
<l>    set_dict_tuple (Sample, 'image_label_id', LabelIndices[SampleIndex])</l>
<c>    * </c>
<c>    * Append this sample.</c>
<l>    Samples := [Samples,Sample]</l>
<l>endfor</l>
<c>* </c>
<c>* Set the sample tuple.</c>
<l>set_dict_tuple (DLDataset, 'samples', Samples)</l>
<c>* </c>
<l>return ()</l>
</body>
<docu id="read_dl_dataset_classification">
<abstract lang="en_US">This procedure can be used to generate a DLDataset dictionary as required for a deep-learning-based classification model.

RawImageFolder is a tuple of folders containing the images. All images located within these folders and their subfolders are added to the dictionary DLDataset

The images are listed using the procedure list_image_files. Note that subfolders and links are included as well. For more information on the used default directories, please have a look at its documentation.

LabelSource determines the mode that is used to extract the ground truth labels of the images. For LabelSource, three modes are supported: 
- 'last_folder': The name of the last folder containing the image is used as label.
- 'file_name': The file name of each image is used as label.
- 'file_name_remove_index': The file name of each image is used as label, but thereby all consecutive digits and underscores at the end of the file name (e.g., '01', '_20180101') are removed.
If you want to configure your own LabelSource mode, you might find the procedure parse_filename helpful.

The output of the procedure is a dictionary DLDataset, which serves as a database. The keys of the dictionary are:
- 'image_dir': Common base path of all images, given by the path of the deepest common parent folder of all directories in ImageDirectory.
- 'class_names': Tuple of strings with the names of the classes to be distinguished.
- 'class_ids': Tuple of integers.
- 'samples'

Thereby, the value for the key 'samples' is a tuple of dictionaries with the keys:
- 'image_file_name': The relative path of the sample image.
- 'image_id': A unique integer ID for each sample.
- 'image_label_id': Class ID assigned to the image.

Note that the procedure assumes that all folders in RawImageFolder are contained in a common parent folder. If this is not the case, an exception is thrown.

For further information on these dictionaries and their usage, please see the chapter Deep Learning / Model.</abstract>
<chapters lang="en_US">
<item>Deep Learning</item>
<item>Classification</item>
</chapters>
<library lang="en_US">MVTec Standard Procedures</library>
<short lang="en_US">Generate a DLDataset dictionary for classification.</short>
<successor>
<item>split_dl_dataset</item>
</successor>
<parameters>
<parameter id="DLDataset">
<default_type>integer</default_type>
<description lang="en_US">The generated dataset dictionary.</description>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>dict</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="LabelSource">
<default_type>string</default_type>
<default_value>'last_folder'</default_value>
<description lang="en_US">The mode how the ground truth labels are extracted.</description>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>string</sem_type>
<type_list>
<item>string</item>
</type_list>
</parameter>
<parameter id="RawImageFolder">
<default_type>string</default_type>
<description lang="en_US">Image folders containing the labeled images.</description>
<mixed_type>false</mixed_type>
<multivalue>optional</multivalue>
<sem_type>filename</sem_type>
<type_list>
<item>string</item>
</type_list>
</parameter>
</parameters>
</docu>
</procedure>
<procedure name="read_dl_dataset_from_coco">
<interface>
<ic>
<par name="CocoFileName" base_type="ctrl" dimension="0"/>
<par name="ImageDir" base_type="ctrl" dimension="0"/>
<par name="GenParam" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="DLDataset" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c>* </c>
<c>* This procedure reads a COCO file and creates a DLDataset dictionary out of it.</c>
<c>* Note, only the COCO annotation type 'Object Detection' is supported.</c>
<c>* The bounding boxes are parametrized for instance_type 'rectangle1'.</c>
<c>* </c>
<l>dev_update_off ()</l>
<c>* </c>
<c>* Sanity checks of procedure inputs.</c>
<c>* Check the given input for the COCO file CocoFileName.</c>
<l>if (|CocoFileName| != 1)</l>
<l>    throw ('Only one COCO file can be given.')</l>
<l>elseif (is_string(CocoFileName) != 1)</l>
<l>    throw ('CocoFileName is not a string.')</l>
<l>endif</l>
<l>if (|ImageDir| != 1)</l>
<l>    throw ('Only one base path for the images can be given.')</l>
<l>elseif (is_string(ImageDir) != 1)</l>
<l>    throw ('ImageDir is not a string.')</l>
<l>endif</l>
<c>* Make sure, ImageDir ends with a '/'.</c>
<l>if (ImageDir =~ '[^/]$')</l>
<l>    ImageDir := ImageDir + '/'</l>
<l>endif</l>
<c>* </c>
<c>* Check the dictionary GenParam and transfer the given values.</c>
<c>* </c>
<c>* Default values.</c>
<c>* Per default, do not read annotations which have the attribute 'iscrowd'.</c>
<l>ReadOnlyNonCrowd := 1</l>
<c>* Per default, do not transfer the raw format of the annotations.</c>
<l>ReadRawAnnotations := 0</l>
<c>* </c>
<c>* Transfer the given GenParam entries.</c>
<l>if (GenParam != [])</l>
<l>    get_dict_param (GenParam, 'keys', [], GenParamNames)</l>
<l>    for ParamIndex := 0 to |GenParamNames| - 1 by 1</l>
<l>        GenParamName := GenParamNames[ParamIndex]</l>
<l>        get_dict_tuple (GenParam, GenParamName, GenParamValue)</l>
<l>        if (GenParamName == 'read_only_non_crowd_detection')</l>
<l>            if (GenParamValue == 'true' or GenParamValue == 1)</l>
<l>                ReadOnlyNonCrowd := 1</l>
<l>            elseif (GenParamValue == 'false' or GenParamValue == 0)</l>
<l>                ReadOnlyNonCrowd := 0</l>
<l>            else</l>
<l>                throw ('GenParamValue for GenParamName read_only_non_crowd_detection is not supported.')</l>
<l>            endif</l>
<l>        elseif (GenParamName == 'coco_raw_annotations')</l>
<l>            if (GenParamValue == 'true' or GenParamValue == 1)</l>
<l>                ReadRawAnnotations := 1</l>
<l>            elseif (GenParamValue == 'false' or GenParamValue == 0)</l>
<l>                ReadRawAnnotations := 0</l>
<l>            else</l>
<l>                throw ('GenParamValue for GenParamName coco_raw_annotations is not supported.')</l>
<l>            endif</l>
<l>        else</l>
<l>            throw ('Unknown generic parameter: ' + GenParamName + '.')</l>
<l>        endif</l>
<l>    endfor</l>
<l>endif</l>
<c>* </c>
<c>* Read the COCO file into a dictionary.</c>
<l>read_dict (CocoFileName, [], [], DictCocoJson)</l>
<c>* </c>
<c>* Check topmost content of JSON file for categories.</c>
<l>ExceptionTopmostLevel := []</l>
<l>CategoryKeys := []</l>
<l>try</l>
<l>    get_dict_tuple (DictCocoJson, 'categories', CategoryList)</l>
<l>    get_dict_param (CategoryList, 'keys', [], CategoryKeys)</l>
<l>catch (ExceptionTopmostLevel)</l>
<l>endtry</l>
<l>if (ExceptionTopmostLevel != [] or |CategoryKeys| == 0)</l>
<l>    throw ('The COCO file has to contain categories on the topmost level.')</l>
<l>endif</l>
<c>* Check topmost content of JSON file for images.</c>
<l>ExceptionTopmostLevel := []</l>
<l>ImageKeys := []</l>
<l>try</l>
<l>    get_dict_tuple (DictCocoJson, 'images', ImageList)</l>
<l>    get_dict_param (ImageList, 'keys', [], ImageKeys)</l>
<l>catch (ExceptionTopmostLevel)</l>
<l>endtry</l>
<c></c>
<l>if (ExceptionTopmostLevel != [] or |ImageKeys| == 0)</l>
<l>    throw ('The COCO file has to contain images on the topmost level.')</l>
<l>endif</l>
<c>* Check topmost content of JSON file for annotations.</c>
<l>ExceptionTopmostLevel := []</l>
<l>AnnotationKeys := []</l>
<l>try</l>
<l>    get_dict_tuple (DictCocoJson, 'annotations', AnnotationList)</l>
<l>    get_dict_param (AnnotationList, 'keys', [], AnnotationKeys)</l>
<l>catch (ExceptionTopmostLevel)</l>
<l>endtry</l>
<c>* </c>
<l>if (ExceptionTopmostLevel != [] or |AnnotationKeys| == 0)</l>
<l>    throw ('The first COCO annotation does not contain the entries bounding box. This COCO format is not supported.')</l>
<l>endif</l>
<c>* </c>
<c>* Determine the purpose of this Dataset according to the content.</c>
<l>Purpose := []</l>
<l>get_dict_tuple (AnnotationList, AnnotationKeys[0], Annotation)</l>
<l>try</l>
<l>    get_dict_tuple (Annotation, 'bbox', BBox)</l>
<l>    Purpose := 'object_detection'</l>
<l>catch (ExceptionBBox)</l>
<l>    throw ('The first COCO annotation does not contain the entries bounding box. This COCO format is not supported.')</l>
<l>endtry</l>
<c>* </c>
<c>* Create the DLDataset dictionary.</c>
<l>create_dict (DLDataset)</l>
<c>* </c>
<c>* Set the base image directory.</c>
<l>set_dict_tuple (DLDataset, 'image_dir', ImageDir)</l>
<c>* </c>
<c>* Set the class information.</c>
<l>for Index := 0 to |CategoryKeys| - 1 by 1</l>
<l>    try</l>
<l>        get_dict_tuple (CategoryList, CategoryKeys[Index], Category)</l>
<l>        get_dict_tuple (Category, 'id', ID)</l>
<l>        get_dict_tuple (Category, 'name', Name)</l>
<l>    catch (ExceptionCategory)</l>
<l>        throw ('COCO category number ' + Index + ' does not contain the entry id or name.')</l>
<l>    endtry</l>
<l>    ClassIDs[Index] := ID</l>
<l>    ClassNames[Index] := Name</l>
<l>endfor</l>
<l>set_dict_tuple (DLDataset, 'class_ids', ClassIDs)</l>
<l>set_dict_tuple (DLDataset, 'class_names', ClassNames)</l>
<c>* </c>
<c>* Generate the samples.</c>
<c>* Get the 'image_id' for each annotation for looking it up later.</c>
<l>tuple_gen_const (|AnnotationKeys|, -1, AnnotImageIDs)</l>
<l>for Index := 0 to |AnnotationKeys| - 1 by 1</l>
<l>    try</l>
<l>        get_dict_tuple (AnnotationList, AnnotationKeys[Index], Annotation)</l>
<l>        get_dict_tuple (Annotation, 'image_id', ImageIDAnnot)</l>
<l>    catch (ExceptionAnnot)</l>
<l>        throw ('COCO annotation number ' + Index + ' does not contain image_id.')</l>
<l>    endtry</l>
<l>    AnnotImageIDs[Index] := ImageIDAnnot</l>
<l>endfor</l>
<c>* Iterate over the images and fill according sample.</c>
<l>for Index := 0 to |ImageKeys| - 1 by 1</l>
<c>    * </c>
<c>    * Get the image information.</c>
<l>    try</l>
<l>        get_dict_tuple (ImageList, ImageKeys[Index], Image)</l>
<l>        get_dict_tuple (Image, 'file_name', ImageName)</l>
<l>        get_dict_tuple (Image, 'id', ImageID)</l>
<l>    catch (ExceptionImage)</l>
<l>        throw ('COCO image number ' + Index + ' does not contain id or file_name.')</l>
<l>    endtry</l>
<c>    * </c>
<c>    * Check that the image is found at the given location.</c>
<l>    file_exists (ImageDir + ImageName, FileExists)</l>
<l>    if (not FileExists)</l>
<l>        throw ('COCO image number ' + Index + ' (id = ' + ImageID + ') could not be found at the location ImageDir + file_name = ' + ImageDir + ImageName)</l>
<l>    endif</l>
<c>    * </c>
<c>    * Get the annotation data for the selected image.</c>
<l>    tuple_find (AnnotImageIDs, ImageID, AnnotationIndicesThisImage)</l>
<l>    if (Purpose == 'object_detection')</l>
<c>        * For object detection, several annotations per image are possible.</c>
<l>        AnnotClassIDs := []</l>
<l>        AnnotBboxColumn1s := []</l>
<l>        AnnotBboxRow1s := []</l>
<l>        AnnotBboxColumn2s := []</l>
<l>        AnnotBboxRow2s := []</l>
<l>    endif</l>
<l>    if (AnnotationIndicesThisImage == -1)</l>
<c>        * If no annotation was found for this image.</c>
<l>        AnnotationPerImage := []</l>
<l>    else</l>
<c>        * Otherwise, process the annotations.</c>
<l>        AnnotationKeysThisImage := AnnotationKeys[AnnotationIndicesThisImage]</l>
<l>        tuple_gen_const (|AnnotationKeysThisImage|, HNULL, AnnotationPerImage)</l>
<l>        AnnotIndexCounter := 0</l>
<l>        for AnnotIndex := 0 to |AnnotationKeysThisImage| - 1 by 1</l>
<l>            get_dict_tuple (AnnotationList, AnnotationKeysThisImage[AnnotIndex], Annotation)</l>
<c>            * </c>
<l>            if (Purpose == 'object_detection')</l>
<l>                try</l>
<l>                    get_dict_tuple (Annotation, 'iscrowd', IsCrowd)</l>
<l>                catch (ExceptionIsCrowd)</l>
<c>                    * If IsCrowd is not set, we assume it is 0 and set IsCrowd=0.</c>
<l>                    IsCrowd := 0</l>
<l>                endtry</l>
<l>                if (ReadOnlyNonCrowd and IsCrowd)</l>
<l>                    continue</l>
<l>                endif</l>
<l>                if (ReadRawAnnotations)</l>
<l>                    AnnotationPerImage[AnnotIndexCounter] := Annotation</l>
<l>                endif</l>
<l>                try</l>
<l>                    get_dict_tuple (Annotation, 'category_id', AnnotClassID)</l>
<l>                    get_dict_tuple (Annotation, 'bbox', BBox)</l>
<l>                    get_dict_tuple (BBox, 0, AnnotBboxColumn1)</l>
<l>                    get_dict_tuple (BBox, 1, AnnotBboxRow1)</l>
<l>                    get_dict_tuple (BBox, 2, AnnotBboxWidth)</l>
<l>                    get_dict_tuple (BBox, 3, AnnotBboxHeight)</l>
<l>                catch (ExceptionAnnot)</l>
<l>                    throw ('A COCO annotation for the COCO image number ' + Index + ' (id = ' + ImageID + ') does not contain the entry category_id or correct bounding box.')</l>
<l>                endtry</l>
<c>                * Get the HALCON format for the bounding box coordinates.</c>
<c>                * COCO-format assumes that the origin of the coordinate-system</c>
<c>                * is shifted by (-.5, -.5) compared to the origin of the</c>
<c>                * HALCON coordinate-system.</c>
<l>                AnnotBboxRow1 := AnnotBboxRow1 - 0.5</l>
<l>                AnnotBboxColumn1 := AnnotBboxColumn1 - 0.5</l>
<l>                AnnotBboxRow2 := AnnotBboxRow1 + AnnotBboxHeight</l>
<l>                AnnotBboxColumn2 := AnnotBboxColumn1 + AnnotBboxWidth</l>
<c>                * Store the annotations.</c>
<l>                AnnotClassIDs[AnnotIndexCounter] := AnnotClassID</l>
<l>                AnnotBboxColumn1s[AnnotIndexCounter] := AnnotBboxColumn1</l>
<l>                AnnotBboxRow1s[AnnotIndexCounter] := AnnotBboxRow1</l>
<l>                AnnotBboxColumn2s[AnnotIndexCounter] := AnnotBboxColumn2</l>
<l>                AnnotBboxRow2s[AnnotIndexCounter] := AnnotBboxRow2</l>
<l>                AnnotIndexCounter := AnnotIndexCounter + 1</l>
<l>            endif</l>
<l>        endfor</l>
<l>    endif</l>
<c>    * Generate the sample for this image.</c>
<l>    create_dict (DLSample)</l>
<l>    set_dict_tuple (DLSample, 'image_id', ImageID)</l>
<l>    set_dict_tuple (DLSample, 'image_file_name', ImageName)</l>
<l>    if (Purpose == 'object_detection')</l>
<l>        set_dict_tuple (DLSample, 'bbox_row1', AnnotBboxRow1s)</l>
<l>        set_dict_tuple (DLSample, 'bbox_col1', AnnotBboxColumn1s)</l>
<l>        set_dict_tuple (DLSample, 'bbox_row2', AnnotBboxRow2s)</l>
<l>        set_dict_tuple (DLSample, 'bbox_col2', AnnotBboxColumn2s)</l>
<l>        set_dict_tuple (DLSample, 'bbox_label_id', AnnotClassIDs)</l>
<l>    endif</l>
<l>    if (ReadRawAnnotations)</l>
<l>        set_dict_tuple (DLSample, 'coco_raw_annotations', AnnotationPerImage)</l>
<l>    endif</l>
<c>    * Remember the sample for this image.</c>
<l>    DLSamples[Index] := DLSample</l>
<l>endfor</l>
<c>* Set the samples in the DLDataset dictionary.</c>
<l>set_dict_tuple (DLDataset, 'samples', DLSamples)</l>
<l>return ()</l>
</body>
<docu id="read_dl_dataset_from_coco">
<abstract lang="en_US">This procedure reads the COCO file specified by CocoFileName and creates the according dictionary DLDataset.
ImageDir specifies the base directory, which serves as a base for the file names and paths given for the images.

COCO files are JSON files with specific entries depending on the annotation type they are used for.
Note, only the COCO annotation type 'Object Detection' is supported. The bounding boxes are parametrized for instance_type 'rectangle1'.

The COCO file CocoFileName has to contain the following fields with certain entries:
- 'annotation': Has to contain the entries 'image_id', 'category_id', and 'bbox'.
- 'categories': Has to contain the entries 'id' and 'name'.
- 'image': Has to contain the entries 'id' and 'file_name'. Thereby 'file_name' gives the name of the images relative to the directory specified by the procedure parameter ImageDir.

Note that all images are added to the samples in DLDataset, even when there are no annotations for this image. Annotations assigned to images which are not contained in the field 'image' are ignored.

The parameter GenParam is a dictionary, which can have the following key and value pairs:
- 'coco_raw_annotations' (default 'false'): For 'true', all annotation information is copied to the samples in DLDataset.
- 'read_only_non_crowd_detection' (default 'true'): For 'false', all annotations are used to generate the samples in DLDataset. For 'true', only annotations with entry iscrowd=0 are used. If annotations do not have the entry iscrowd, a value iscrowd=0 is assumed. </abstract>
<chapters lang="de_DE">
<item>Deep Learning</item>
<item>Objektdetektion</item>
</chapters>
<chapters lang="en_US">
<item>Deep Learning</item>
<item>Object Detection</item>
</chapters>
<library lang="en_US">MVTec Standard Procedures</library>
<short lang="en_US">Read the COCO file and convert it to the dictionary DLDataset.</short>
<parameters>
<parameter id="CocoFileName">
<default_type>string</default_type>
<description lang="en_US">Name of the COCO JSON file to be read.</description>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>filename.read</sem_type>
<type_list>
<item>string</item>
</type_list>
</parameter>
<parameter id="DLDataset">
<default_type>integer</default_type>
<description lang="en_US">Dictionary containing information about the dataset.</description>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>dict</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="GenParam">
<default_type>integer</default_type>
<default_value>[]</default_value>
<description lang="en_US">Names and values of the generic parameters.</description>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>any</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="ImageDir">
<default_type>string</default_type>
<default_value>[]</default_value>
<description lang="en_US">Base directory of the images.</description>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>filename.dir</sem_type>
<type_list>
<item>string</item>
</type_list>
</parameter>
</parameters>
</docu>
</procedure>
<procedure name="read_dl_dataset_segmentation">
<interface>
<ic>
<par name="ImageDir" base_type="ctrl" dimension="0"/>
<par name="SegmentationDir" base_type="ctrl" dimension="0"/>
<par name="ClassNames" base_type="ctrl" dimension="0"/>
<par name="ClassIDs" base_type="ctrl" dimension="0"/>
<par name="ImageList" base_type="ctrl" dimension="0"/>
<par name="SegmentationList" base_type="ctrl" dimension="0"/>
<par name="GenParam" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="DLDataset" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c>* </c>
<c>* This procedure creates a dictionary DLDataset,</c>
<c>* which serves as an input for deep-learning-based semantic segmentation models.</c>
<c>* Information needed to create this dictionary is given through the input parameters.</c>
<c>* </c>
<c>* The output dictionary DLDataset has the following structure:</c>
<c></c>
<c>* DLDataset</c>
<c>* {</c>
<c>*     'image_dir'         : Common base path of all images</c>
<c>*     'segmentation_dir'  : Common base path of all segmentation images</c>
<c>*     'class_names'[]     : Tuple of strings</c>
<c>*     'class_ids'[]       : Tuple of integers</c>
<c>*     'samples'[]         : Tuple of dictionaries</c>
<c>*     {</c>
<c>*         'image_file_name'           : File path relative to 'image_dir' (including the file name)</c>
<c>*         'segmentation_file_name'    : File path relative to 'segmentation_dir' (including the file name)</c>
<c>*         'image_id'                  : Unique image ID</c>
<c>*     }</c>
<c>* }</c>
<c>* </c>
<c>* Convert Segmentation specific keys to general keys.</c>
<l>GenParamCopy := []</l>
<l>if (GenParam != [])</l>
<l>    copy_dict (GenParam, [], [], GenParamCopy)</l>
<l>    get_dict_param (GenParamCopy, 'keys', [], Keys)</l>
<l>    for KeyIndex := 0 to |Keys| - 1 by 1</l>
<l>        CurrentKey := Keys[KeyIndex]</l>
<l>        if (CurrentKey == 'segmentation_sub_dirs')</l>
<l>            get_dict_tuple (GenParamCopy, CurrentKey, SegmentationSubDirs)</l>
<l>            remove_dict_key (GenParamCopy, CurrentKey)</l>
<l>            set_dict_tuple (GenParamCopy, 'annotation_sub_dirs', SegmentationSubDirs)</l>
<l>        elseif (CurrentKey == 'file_name_segmentation_only')</l>
<l>            get_dict_tuple (GenParamCopy, CurrentKey, FileNameSegmentationOnly)</l>
<l>            remove_dict_key (GenParamCopy, CurrentKey)</l>
<l>            set_dict_tuple (GenParamCopy, 'file_name_annotation_only', FileNameSegmentationOnly)</l>
<l>        endif</l>
<l>    endfor</l>
<l>endif</l>
<c>* Sanity checks of inputs.</c>
<c>* </c>
<c>* The length of Classes has to match the length of ClassIDs.</c>
<l>if (|ClassNames| != |ClassIDs|)</l>
<l>    throw ('Number of class names does not match number of class IDs')</l>
<l>endif</l>
<c>* ClassIDs must be unique.</c>
<l>if (uniq(sort(ClassIDs)) != sort(ClassIDs))</l>
<l>    throw ('Class IDs are not unique')</l>
<l>endif</l>
<c>* ImageDir can only be one string.</c>
<l>if (|ImageDir| == 0)</l>
<l>    ImageDir := ''</l>
<l>endif</l>
<l>if (|ImageDir| != 1)</l>
<l>    throw ('Only one base path for the images can be given')</l>
<l>elseif (is_string(ImageDir) != 1)</l>
<l>    throw ('ImageDir is not a string')</l>
<l>endif</l>
<l>if (|SegmentationDir| == 0)</l>
<l>    SegmentationDir := ''</l>
<l>endif</l>
<c>* SegmentationDir can only be one string.</c>
<l>if (|SegmentationDir| != 1)</l>
<l>    throw ('Only one base path for the annotation images can be given')</l>
<l>elseif (is_string(SegmentationDir) != 1)</l>
<l>    throw ('SegmentationDir is not a string')</l>
<l>endif</l>
<c>* Check if ImageList and SegmentationList have the same length or if SegmentationList is empty.</c>
<l>if (SegmentationList != [] and |ImageList| != |SegmentationList|)</l>
<l>    throw ('SegmentationList must be empty or have the same length as ImageList')</l>
<l>endif</l>
<c>* </c>
<c>* Prepare the image lists.</c>
<c>* </c>
<c>* Replace windows path separators</c>
<l>tuple_regexp_replace (ImageDir, ['\\\\+','replace_all'], '/', ImageDir)</l>
<l>tuple_regexp_replace (SegmentationDir, ['\\\\+','replace_all'], '/', SegmentationDir)</l>
<c>* Replace any forward slashes at the end.</c>
<l>tuple_regexp_replace (ImageDir, '/$', '', ImageDir)</l>
<l>tuple_regexp_replace (SegmentationDir, '/$', '', SegmentationDir)</l>
<c>* </c>
<c>* If no SegmentationList is given, create it out of the given ImageList or create both lists.</c>
<l>if (SegmentationList == [])</l>
<c>    * Create the matching file lists for images and segmentations.</c>
<l>    list_image_and_annotation_files ('segmentation', ImageDir, SegmentationDir, ImageList, GenParamCopy, ImageList, LabelList, SegmentationList)</l>
<l>else</l>
<c>    * Replace windows path separators</c>
<l>    tuple_regexp_replace (ImageList, ['\\\\+','replace_all'], '/', ImageList)</l>
<l>    tuple_regexp_replace (SegmentationList, ['\\\\+','replace_all'], '/', SegmentationList)</l>
<c>    * Make sure that ImageList does not contain ImageDir.</c>
<l>    tuple_regexp_replace (ImageList, '.*?' + ImageDir, '', ImageList)</l>
<l>    tuple_regexp_replace (ImageList, '^/', '', ImageList)</l>
<c>    * Make sure that SegmentationList does not contain SegmentationDir.</c>
<l>    tuple_regexp_replace (SegmentationList, '.*?' + SegmentationDir, '', SegmentationList)</l>
<l>    tuple_regexp_replace (SegmentationList, '^/', '', SegmentationList)</l>
<l>endif</l>
<c>* If ImageDir is empty, we omit the path separator</c>
<l>if (strlen(ImageDir) == 0)</l>
<l>    ImageDirSep := ''</l>
<l>else</l>
<l>    ImageDirSep := '/'</l>
<l>endif</l>
<l>if (strlen(SegmentationDir) == 0)</l>
<l>    SegmentationDirSep := ''</l>
<l>else</l>
<l>    SegmentationDirSep := '/'</l>
<l>endif</l>
<c>* </c>
<c>* Check if all images exist.</c>
<l>images_exist (ImageDir + ImageDirSep + ImageList)</l>
<c>* Check if all segmentation images exist.</c>
<l>images_exist (SegmentationDir + SegmentationDirSep + SegmentationList)</l>
<c>* </c>
<c>* Initialize the dictionary dataset.</c>
<l>create_dict (DLDataset)</l>
<c>* </c>
<c>* Set general information of the dataset.</c>
<l>set_dict_tuple (DLDataset, 'image_dir', ImageDir)</l>
<l>set_dict_tuple (DLDataset, 'segmentation_dir', SegmentationDir)</l>
<l>set_dict_tuple (DLDataset, 'class_names', ClassNames)</l>
<l>set_dict_tuple (DLDataset, 'class_ids', ClassIDs)</l>
<c>* </c>
<c>* Get number of samples to set unique image ID for each sample according to its index in ImageList.</c>
<l>NumSamples := |ImageList|</l>
<c>* </c>
<c>* Initialize sample tuple.</c>
<l>Samples := []</l>
<c>* Loop over samples.</c>
<l>for SampleIndex := 0 to NumSamples - 1 by 1</l>
<c>    * </c>
<c>    * Create the dictionary Sample.</c>
<l>    create_dict (Sample)</l>
<c>    * Set information about this sample.</c>
<l>    ImageID := SampleIndex</l>
<l>    set_dict_tuple (Sample, 'image_id', ImageID)</l>
<l>    set_dict_tuple (Sample, 'image_file_name', ImageList[SampleIndex])</l>
<l>    set_dict_tuple (Sample, 'segmentation_file_name', SegmentationList[SampleIndex])</l>
<c>    * </c>
<c>    * Append this sample.</c>
<l>    Samples := [Samples,Sample]</l>
<l>endfor</l>
<c>* </c>
<c>* Set the sample tuple.</c>
<l>set_dict_tuple (DLDataset, 'samples', Samples)</l>
<l>return ()</l>
</body>
<docu id="read_dl_dataset_segmentation">
<abstract lang="en_US">This procedure can be used to generate a DLDataset dictionary as required for a deep-learning-based semantic segmentation model.

ImageDir specifies the base directory for the images.
SegmentationDir specifies the base directory for the annotated segmentations.
ClassNames is the list of all class names, ClassIDs specifies the corresponding class IDs.

ImageList is a list specifying the images and SegmentationList a list with the corresponding segmentation images. These lists can either contain the full paths of the images or the paths relative to ImageDir and SegmentationDir, respectively.
If SegmentationList is an empty tuple, it is generated by listing all images in SegmentationDir and matching the segmentation images to the images in ImageList based on their file names.
If both ImageList and SegmentationList are empty tuples, both lists are generated by listing image files in ImageDir and SegmentationDir respectively and matching the images based on their file names.

The image and segmentation lists can be constrained. For this, use the dictionary GenParam, allowing the following keys:
- 'image_sub_dirs': List of directories located in ImageDir. Constrain the image list to these directories. The default value is [], meaning all directories in ImageDir are considered.
- 'segmentation_sub_dirs': List of directories located in SegmentationDir. Constrain the segmentation list to these directories. The default value is [], meaning all directories in SegmentationDir are considered.
- 'file_name_image_only': Prefix or suffix, that has to be part of the image file names but is not part of the segmentation file names. The default value is ''.
- 'file_name_segmentation_only': String that has to be part of the segmentation file names (note, this serves as identifier for the segmentation images and thus should not be part of the image file names). The default value is ''.
- 'ignore_unmatched_images': For a value 'false', an error is thrown in case not every image has a matching segmentation image. The default value is 'false'.

The output of the procedure is a dictionary DLDataset, which serves as a database. The keys of the dictionary are:
- 'image_dir'
- 'segmentation_dir'
- 'class_names'
- 'class_ids'
- 'samples'

Thereby, the value for the key 'samples' is a tuple of dictionaries with the keys:
- 'image_id' - a unique integer ID for each sample,
- 'image_file_name' - the relative path of the sample image,
- 'segmentation_file_name' - the relative path of the sample annotated segmentations.

For further information on these dictionaries and their usage, please see the chapter Deep Learning / Model.</abstract>
<chapters lang="de_DE">
<item>Deep Learning</item>
<item>Semantische Segmentierung</item>
</chapters>
<chapters lang="en_US">
<item>Deep Learning</item>
<item>Semantic Segmentation</item>
</chapters>
<library lang="en_US">MVTec Standard Procedures</library>
<short lang="en_US">Generate a DLDataset dictionary for semantic segmentation.</short>
<parameters>
<parameter id="ClassIDs">
<default_type>integer</default_type>
<description lang="en_US">List of unique IDs for each class.</description>
<mixed_type>false</mixed_type>
<multivalue>optional</multivalue>
<sem_type>integer</sem_type>
<type_list>
<item>integer</item>
</type_list>
<value_min>0</value_min>
</parameter>
<parameter id="ClassNames">
<default_type>string</default_type>
<description lang="en_US">List of all class names.</description>
<mixed_type>false</mixed_type>
<multivalue>optional</multivalue>
<sem_type>string</sem_type>
<type_list>
<item>string</item>
</type_list>
</parameter>
<parameter id="DLDataset">
<default_type>integer</default_type>
<description lang="en_US">The generated dataset dictionary.</description>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>dict</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="GenParam">
<default_type>integer</default_type>
<default_value>[]</default_value>
<description lang="en_US">GenParam is a dictionary, which can be used to constrain the generated image and segmentation lists.
</description>
<mixed_type>false</mixed_type>
<sem_type>any</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="ImageDir">
<default_type>string</default_type>
<description lang="en_US">Base directory of the images.</description>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>filename.dir</sem_type>
<type_list>
<item>string</item>
</type_list>
</parameter>
<parameter id="ImageList">
<default_type>string</default_type>
<default_value>[]</default_value>
<description lang="en_US">List of image paths.
If it is an empty tuple, the image list is generated.</description>
<mixed_type>false</mixed_type>
<multivalue>optional</multivalue>
<sem_type>string</sem_type>
<type_list>
<item>string</item>
</type_list>
</parameter>
<parameter id="SegmentationDir">
<default_type>string</default_type>
<description lang="en_US">Base directory of the segmentation images.</description>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>filename.dir</sem_type>
<type_list>
<item>string</item>
</type_list>
</parameter>
<parameter id="SegmentationList">
<default_type>string</default_type>
<default_value>[]</default_value>
<description lang="en_US">List of segmentation image paths.
If it is an empty tuple, the segmentation image list is generated.</description>
<mixed_type>false</mixed_type>
<multivalue>true</multivalue>
<sem_type>string</sem_type>
<type_list>
<item>filename</item>
</type_list>
</parameter>
</parameters>
</docu>
</procedure>
<procedure name="read_dl_samples">
<interface>
<ic>
<par name="DLDataset" base_type="ctrl" dimension="0"/>
<par name="SampleIndices" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="DLSampleBatch" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c>* </c>
<c>* This procedure reads a batch of DLSample dictionaries from disk.</c>
<c>* The wanted samples are selected from a DLDataset by their indices.</c>
<c>* The indices of the wanted samples are handed over in SampleIndices.</c>
<c>* It returns the tuple of read-in dictionaries in DLSampleBatch.</c>
<c>* </c>
<c>* Sanity checks of inputs.</c>
<c>* </c>
<l>if (|SampleIndices| &lt;= 0)</l>
<c>    * Check the length of selected indices.</c>
<l>    throw ('Invalid length of SelectedIndices: ' + |SampleIndices|)</l>
<l>else</l>
<c>    * Get the samples from the DLDataset.</c>
<l>    get_dict_tuple (DLDataset, 'samples', DatasetSamples)</l>
<c>    * Get min and max value of given indices.</c>
<l>    tuple_min (SampleIndices, MinIndex)</l>
<l>    tuple_max (SampleIndices, MaxIndex)</l>
<l>    if ((MinIndex &lt; 0) or (MaxIndex &gt; (|DatasetSamples| - 1)))</l>
<c>        * Check the value range of the provided indices.</c>
<l>        throw ('The given SampleIndices are not within the range of available samples in DLDataset.')</l>
<l>    endif</l>
<l>endif</l>
<c>* </c>
<c>* Check if the key dlsample_dir is given.</c>
<l>get_dict_param (DLDataset, 'key_exists', 'dlsample_dir', KeyDirExists)</l>
<c>* </c>
<l>if (KeyDirExists)</l>
<c>    * </c>
<c>    * Get the dlsample_dir.</c>
<l>    get_dict_tuple (DLDataset, 'dlsample_dir', DictDir)</l>
<c>    * Get the samples to be processed.</c>
<l>    DLSamplesProc := DatasetSamples[SampleIndices]</l>
<c>    * </c>
<c>    * Initialize DLSampleBatch tuple.</c>
<l>    DLSampleBatch := []</l>
<c>    * </c>
<c>    * Read in all DLSamples into the batch.</c>
<l>    for ImageIndex := 0 to |SampleIndices| - 1 by 1</l>
<c>        * Check if dlsample key exist.</c>
<l>        get_dict_param (DLSamplesProc[ImageIndex], 'key_exists', 'dlsample_file_name', KeyFileExists)</l>
<c>        * </c>
<l>        if (not KeyFileExists)</l>
<c>            * </c>
<c>            * If the key does not exist, check if a corresponding file exists.</c>
<l>            get_dict_tuple (DLSamplesProc[ImageIndex], 'image_id', ImageID)</l>
<l>            FileNameRelative := ImageID + '_dlsample.hdict'</l>
<l>            FileNameSample := DictDir + '/' + FileNameRelative</l>
<c>            * </c>
<l>            file_exists (FileNameSample, FileExists)</l>
<l>            if (FileExists)</l>
<c>                * If it exists, create corresponding key.</c>
<l>                set_dict_tuple (DLSamplesProc[ImageIndex], 'dlsample_file_name', FileNameRelative)</l>
<l>            else</l>
<c>                * If not, throw an error.</c>
<l>                throw ('No \'dlsample_file_name\' and hdict file available for image ID ' + ImageID)</l>
<l>            endif</l>
<c>            * </c>
<l>        endif</l>
<c>        * </c>
<c>        * If dlsample dictionary is available for reading, read it.</c>
<l>        get_dict_tuple (DLSamplesProc[ImageIndex], 'dlsample_file_name', DictPath)</l>
<l>        try</l>
<l>            read_dict (DictDir + '/' + DictPath, [], [], DLSample)</l>
<l>        catch (Exception)</l>
<l>            throw ('An error has occurred while reading ' + DictDir + '/' + DictPath + ' , HALCON error # ' + Exception[0])</l>
<l>        endtry</l>
<c>        * Add it to the DLSampleBatch.</c>
<l>        DLSampleBatch := [DLSampleBatch,DLSample]</l>
<c>        * </c>
<l>    endfor</l>
<l>else</l>
<l>    throw ('The dataset needs to include the key \'dlsample_dir\' for reading a DLSample from file.')</l>
<l>endif</l>
<c></c>
<l>return ()</l>
</body>
<docu id="read_dl_samples">
<abstract lang="en_US">This procedure reads a batch of DLSample dictionaries that have previously been saved to disk.
SampleIndices determines which samples of the DLDataset are read.
The tuple of read-in dictionaries is returned in DLSampleBatch.

For each sample in DLDataset, the path of the DLSample dictionary is determined over the key 'dlsample_file_name' (in the dictionary 'sample') and the directory specified by the key 'dlsample_dir' (in the dictionary DLDataset).
Note, if for a sample there is no 'dlsample_file_name' key available, the procedure generates the key automatically. It does so, using the image ID with suffix '_dlsample.hdict' and tests whether the file exists in 'dlsample_dir'. If it exists, this file is read and the entry for the key 'dlsample_file_name' is created.</abstract>
<chapters lang="de_DE">
<item>Deep Learning</item>
<item>Modell</item>
</chapters>
<chapters lang="en_US">
<item>Deep Learning</item>
<item>Model</item>
</chapters>
<library lang="en_US">MVTec Standard Procedures</library>
<short lang="en_US">Read the dictionaries DLSamples from files.</short>
<parameters>
<parameter id="DLDataset">
<default_type>integer</default_type>
<description lang="en_US">Dictionary containing information about the dataset.</description>
<mixed_type>false</mixed_type>
<sem_type>dict</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="DLSampleBatch">
<default_type>integer</default_type>
<description lang="en_US">DLSample dictionary or tuple of DLSample dictionaries read from disk.</description>
<mixed_type>false</mixed_type>
<multivalue>optional</multivalue>
<sem_type>dict</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="SampleIndices">
<default_type>integer</default_type>
<default_value>[]</default_value>
<description lang="en_US">Indices of the samples in the dictionary DLDataset, out of which the DLSamples are read.</description>
<mixed_type>false</mixed_type>
<multivalue>optional</multivalue>
<sem_type>integer</sem_type>
<type_list>
<item>integer</item>
</type_list>
<value_min>0</value_min>
</parameter>
</parameters>
</docu>
</procedure>
<procedure name="reassign_pixel_values" access="local">
<interface>
<io>
<par name="Image" base_type="iconic" dimension="0"/>
</io>
<oo>
<par name="ImageOut" base_type="iconic" dimension="0"/>
</oo>
<ic>
<par name="ValuesToChange" base_type="ctrl" dimension="0"/>
<par name="NewValue" base_type="ctrl" dimension="0"/>
</ic>
</interface>
<body>
<c>* </c>
<c>* This procedure sets all pixels of Image</c>
<c>* with the values given in ValuesToChange to the given value NewValue.</c>
<c>* </c>
<l>gen_empty_region (RegionToChange)</l>
<l>for IndexReset := 0 to |ValuesToChange| - 1 by 1</l>
<l>    threshold (Image, RegionClass, ValuesToChange[IndexReset], ValuesToChange[IndexReset])</l>
<l>    union2 (RegionToChange, RegionClass, RegionToChange)</l>
<l>endfor</l>
<l>overpaint_region (Image, RegionToChange, NewValue, 'fill')</l>
<l>ImageOut := Image</l>
<l>return ()</l>
</body>
<docu id="reassign_pixel_values">
<abstract lang="en_US">The procedure changes all values of ValuesToChange in Image to NewValue.
</abstract>
<chapters lang="de_DE">
<item>Bild</item>
<item>Manipulation</item>
</chapters>
<chapters lang="en_US">
<item>Image</item>
<item>Manipulation</item>
</chapters>
<library lang="en_US">MVTec Standard Procedures</library>
<short lang="en_US">Changes a value of ValuesToChange in Image to NewValue.</short>
<parameters>
<parameter id="Image">
<description lang="en_US">Image to be edited.</description>
<multichannel>false</multichannel>
<multivalue>false</multivalue>
<sem_type>image</sem_type>
<type_list>
<item>byte</item>
<item>int1</item>
<item>int2</item>
<item>uint2</item>
<item>int4</item>
<item>int8</item>
<item>real</item>
<item>cyclic</item>
<item>direction</item>
<item>complex</item>
<item>vector_field</item>
</type_list>
</parameter>
<parameter id="ImageOut">
<description lang="en_US">Edited image.</description>
<multichannel>false</multichannel>
<multivalue>false</multivalue>
<sem_type>image</sem_type>
<type_list>
<item>byte</item>
<item>int1</item>
<item>int2</item>
<item>uint2</item>
<item>int4</item>
<item>int8</item>
<item>real</item>
<item>cyclic</item>
<item>direction</item>
<item>complex</item>
<item>vector_field</item>
</type_list>
</parameter>
<parameter id="NewValue">
<default_type>integer</default_type>
<default_value>0</default_value>
<description lang="en_US">All pixels with the values given in ValuesToChange are set to this value.</description>
<multivalue>false</multivalue>
<sem_type>number</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
<value_max>9999999.000000</value_max>
<value_min>0.000000</value_min>
<values>
<item>0</item>
<item>0.5</item>
<item>1</item>
<item>100</item>
</values>
</parameter>
<parameter id="ValuesToChange">
<default_type>integer</default_type>
<default_value>[]</default_value>
<description lang="en_US">Pixels with values of ValuesToChange are set to NewValue.</description>
<mixed_type>false</mixed_type>
<multivalue>optional</multivalue>
<sem_type>number</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
</parameters>
</docu>
</procedure>
<procedure name="rectify_image_and_compute_matching_plane_moving_cam">
<interface>
<io>
<par name="Image" base_type="iconic" dimension="0"/>
</io>
<oo>
<par name="ImageRectified" base_type="iconic" dimension="0"/>
</oo>
<ic>
<par name="ToolInBasePose" base_type="ctrl" dimension="0"/>
<par name="HandEyeCalibData" base_type="ctrl" dimension="0"/>
<par name="Poses" base_type="ctrl" dimension="0"/>
<par name="RectificationData" base_type="ctrl" dimension="0"/>
</ic>
</interface>
<body>
<c>* This procedure finds the pose of the matching part on the plane</c>
<c>* in the camera coordinate system. Rectification is applied if it</c>
<c>* is set by the user.</c>
<c>* </c>
<l>read_dict_tuple (HandEyeCalibData, 'CamParam', CamParam)</l>
<l>read_dict_tuple (HandEyeCalibData, 'ToolInCamPose', ToolInCamPose)</l>
<l>read_dict_tuple (RectificationData, 'RectifyImage', RectifyImage)</l>
<l>if (RectifyImage == 'only_rectify' or RectifyImage == 'align_and_rectify')</l>
<l>    read_dict_tuple (RectificationData, 'ScaleRectification', ScaleRectification)</l>
<l>endif</l>
<l>read_dict_tuple (Poses, 'MatchingPlaneInBasePose', MatchingPlaneInBasePose)</l>
<c>* </c>
<c>* Keep track of the pose type used by the robot.</c>
<l>get_pose_type (ToolInBasePose, OrderOfTransform, OrderOfRotation, ViewOfTransform)</l>
<c>* Convert to default pose type.</c>
<l>convert_pose_type (ToolInBasePose, 'Rp+T', 'gba', 'point', ToolInBasePose)</l>
<l>convert_pose_type (ToolInCamPose, 'Rp+T', 'gba', 'point', ToolInCamPose)</l>
<l>convert_pose_type (MatchingPlaneInBasePose, 'Rp+T', 'gba', 'point', MatchingPlaneInBasePose)</l>
<c>* </c>
<l>pose_invert (ToolInBasePose, BaseInToolPose)</l>
<l>pose_compose (ToolInCamPose, BaseInToolPose, BaseInCamPose)</l>
<l>pose_compose (BaseInCamPose, MatchingPlaneInBasePose, MatchingPlaneInCamPose)</l>
<c>* </c>
<l>if (RectifyImage == 'no_rectification')</l>
<l>    MatchingPlaneRectifiedPartInCamPose := MatchingPlaneInCamPose</l>
<l>    copy_obj (Image, ImageRectified, 1, 1)</l>
<l>elseif (RectifyImage == 'only_rectify' or RectifyImage == 'align_and_rectify')</l>
<l>    if (RectifyImage == 'only_rectify')</l>
<l>        MatchingPlaneInCamPose[5] := 0.0</l>
<l>    endif</l>
<c>    * The image dimensions should cover the entire original</c>
<c>    * field of view in the current rectification. Look at the</c>
<c>    * border of the current image in the world plane.</c>
<l>    get_cam_par_data (CamParam, 'image_width', Width)</l>
<l>    get_cam_par_data (CamParam, 'image_height', Height)</l>
<l>    get_system ('clip_region', ClipRegion)</l>
<l>    set_system ('clip_region', 'false')</l>
<l>    gen_rectangle1 (ImageArea, 0, 0, Height - 1, Width - 1)</l>
<l>    boundary (ImageArea, RegionBorder, 'outer')</l>
<l>    set_system ('clip_region', ClipRegion)</l>
<l>    get_region_points (RegionBorder, BorderRows, BorderColumns)</l>
<l>    image_points_to_world_plane (CamParam, MatchingPlaneInCamPose, BorderRows, BorderColumns, 'm', BorderX, BorderY)</l>
<c>    * Adapt parameters.</c>
<l>    create_pose (min(BorderX), min(BorderY), 0, 0, 0, 0, 'Rp+T', 'gba', 'point', MatchingPlaneRectifiedPartInMatchingPlanePose)</l>
<l>    pose_compose (MatchingPlaneInCamPose, MatchingPlaneRectifiedPartInMatchingPlanePose, MatchingPlaneRectifiedPartInCamPose)</l>
<l>    WidthRect := int((max(BorderX) - min(BorderX)) / ScaleRectification + 0.5)</l>
<l>    HeightRect := int((max(BorderY) - min(BorderY)) / ScaleRectification + 0.5)</l>
<c>    * </c>
<l>    image_to_world_plane (Image, ImageRectified, CamParam, MatchingPlaneRectifiedPartInCamPose, WidthRect, HeightRect, ScaleRectification, 'bilinear')</l>
<l>else</l>
<l>    throw ('Please set the parameter RectifyImage correctly')</l>
<l>endif</l>
<l>convert_pose_type (MatchingPlaneRectifiedPartInCamPose, OrderOfTransform, OrderOfRotation, ViewOfTransform, MatchingPlaneRectifiedPartInCamPose)</l>
<l>set_dict_tuple (RectificationData, 'MatchingPlaneRectifiedPartInCamPose', MatchingPlaneRectifiedPartInCamPose)</l>
<l>return ()</l>
</body>
<docu id="rectify_image_and_compute_matching_plane_moving_cam">
<abstract lang="en_US">This procedure prepares the input image in the online phase of robot picking by applying rectification if set by the user. Moreover, the pose of the matching part of the plane in the camera coordinate system is computed.

The input parameter Image is the current image containing potentially the object to be picked. Additionally, the pose ToolInBasePose specifies the current pose of the robot. 

The input dict HandEyeCalibData must contain the camera parameters CamParam and the pose ToolInCamPose. The input dict RectificationData must contain the parameter RectifyImage, and, if RectifyImage is 'only_rectify' or 'align_and_rectify', the parameter ScaleRectification. The input dict Poses must contain the pose MatchingPlaneInBasePose. 

The output parameter ImageRectified is the rectified image, if rectification is set. Additionally, the current MatchingPlaneRectifiedPartInCamPose is added to the dict RectificationData.</abstract>
<chapters lang="de_DE">
<item>Kalibrierung</item>
<item>Hand-Auge</item>
</chapters>
<chapters lang="en_US">
<item>Calibration</item>
<item>Hand-Eye</item>
</chapters>
<library lang="de_DE">MVTec Standard Procedures</library>
<library lang="en_US">MVTec Standard Procedures</library>
<predecessor>
<item>prepare_poses_and_rectification_data_moving_cam</item>
</predecessor>
<short lang="en_US">Prepare the input image for matching and compute the needed pose.</short>
<successor>
<item>obtain_3d_pose_of_match_moving_cam</item>
</successor>
<parameters>
<parameter id="HandEyeCalibData">
<default_type>integer</default_type>
<description lang="en_US">Dict that should contain: ToolInCamPose and CamParam.</description>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>dict</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="Image">
<description lang="en_US">Input image of the object to be matched.</description>
<multivalue>false</multivalue>
<sem_type>image</sem_type>
</parameter>
<parameter id="ImageRectified">
<description lang="en_US">Rectified Image.</description>
<multivalue>false</multivalue>
<sem_type>image</sem_type>
</parameter>
<parameter id="Poses">
<default_type>integer</default_type>
<description lang="en_US">Dict that should contain MatchingPlaneInBasePose.</description>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>dict</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="RectificationData">
<default_type>integer</default_type>
<description lang="en_US">Dict that contains MatchingPlaneRectifiedPartInCamPose.</description>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>dict</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="ToolInBasePose">
<default_type>real</default_type>
<default_value>[]</default_value>
<description lang="en_US">Current pose of the robot.</description>
<multivalue>true</multivalue>
<sem_type>pose</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
</parameters>
</docu>
</procedure>
<procedure name="reduce_dl_evaluation_result" access="local">
<interface>
<ic>
<par name="EvaluationResult" base_type="ctrl" dimension="0"/>
<par name="EvaluationComparisonKeys" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="Value" base_type="ctrl" dimension="0"/>
<par name="ValidEvaluationKeys" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c>* </c>
<c>* In order to compare a model we need to reduce the evaluation parameter/result</c>
<c>* to a single float Value which is comparable via &gt;.</c>
<c>* </c>
<c>* Check which keys exist in the evaluation result.</c>
<l>if (|EvaluationComparisonKeys| &gt; 0 and |EvaluationResult| &gt; 0)</l>
<c>    * We need to check for a special case: detection results.</c>
<c>    * They have a complex structure.</c>
<l>    get_dict_param (EvaluationResult, 'keys', [], KeysEvalResult)</l>
<l>    tuple_regexp_test (KeysEvalResult, 'max_num_detections_.*', NumMatches)</l>
<l>    if (NumMatches &gt; 0)</l>
<c>        * We use only the first results of every level.</c>
<l>        get_dict_tuple (EvaluationResult, KeysEvalResult[0], FirstMaxNumDetections)</l>
<l>        get_dict_param (FirstMaxNumDetections, 'keys', [], KeysFirstMaxNumDetections)</l>
<l>        get_dict_tuple (FirstMaxNumDetections, KeysFirstMaxNumDetections[0], DetectionResult)</l>
<c>        * We use this result here as the top level to retrieve values.</c>
<l>        EvaluationResult := DetectionResult</l>
<l>    endif</l>
<c>    * We need to check for a special case: classification results.</c>
<c>    * They have a complex structure.</c>
<l>    tuple_find (KeysEvalResult [==] 'global', 1, Index)</l>
<l>    if (Index != -1)</l>
<c>        * We use the results for key 'global'.</c>
<l>        get_dict_tuple (EvaluationResult, KeysEvalResult[Index], ClassificationResult)</l>
<l>        EvaluationResult := ClassificationResult</l>
<l>    endif</l>
<c>    * Reduce comparison to keys that exist.</c>
<l>    get_dict_param (EvaluationResult, 'key_exists', EvaluationComparisonKeys, KeysExist)</l>
<c>    * </c>
<l>    tuple_find (KeysExist, 1, Indices)</l>
<l>    if (Indices == -1)</l>
<l>        EvaluationComparisonKeys := []</l>
<l>    else</l>
<l>        EvaluationComparisonKeys := EvaluationComparisonKeys[Indices]</l>
<l>    endif</l>
<l>endif</l>
<c>* </c>
<l>ValidEvaluationKeys := EvaluationComparisonKeys</l>
<c>* </c>
<l>Value := 0.0</l>
<l>Values := []</l>
<l>if (|EvaluationResult| &gt; 0)</l>
<l>    for K := 0 to |EvaluationComparisonKeys| - 1 by 1</l>
<l>        Key := EvaluationComparisonKeys[K]</l>
<c>        * </c>
<l>        get_dict_tuple (EvaluationResult, Key, Tuple)</l>
<c>        * Use the mean in order to reduce tuples with length &gt; 1.</c>
<l>        Values := [Values,mean(Tuple)]</l>
<l>    endfor</l>
<l>else</l>
<l>    Value := -1</l>
<l>endif</l>
<l>if (|Values| &gt; 0)</l>
<l>    Value := mean(Values)</l>
<l>endif</l>
<c>* </c>
<l>return ()</l>
</body>
<docu id="reduce_dl_evaluation_result">
<abstract lang="en_US">The procedure reduces selected evaluation results to a single value.
EvaluationComparisonKeys determines, which evaluation results are to be reduced to a single value.
EvaluationResult is the dictionary with all current evaluation results.

This single value can be used to compare different evaluation results.
It is calculated as the mean over all values referred to by a given key. Thereby, if a key does not exist in EvaluationResult it is ignored.</abstract>
<chapters lang="de_DE">
<item>Deep Learning</item>
<item>Evaluierung</item>
</chapters>
<chapters lang="en_US">
<item>Deep Learning</item>
<item>Evaluation</item>
</chapters>
<library lang="en_US">MVTec Standard Procedures</library>
<short lang="en_US">Reduce the evaluation result to a single value.</short>
<parameters>
<parameter id="EvaluationComparisonKeys">
<default_type>string</default_type>
<description lang="en_US">Key names of the results to be used in the comparison. If a key does not exist in EvaluationResult it is ignored.</description>
<mixed_type>false</mixed_type>
<multivalue>optional</multivalue>
<sem_type>string</sem_type>
<type_list>
<item>string</item>
</type_list>
</parameter>
<parameter id="EvaluationResult">
<default_type>integer</default_type>
<description lang="en_US">Dictionary with the evaluation results which are to be reduced to a single value.</description>
<mixed_type>false</mixed_type>
<sem_type>dict</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="ValidEvaluationKeys">
<description lang="en_US">Keys having an entry and are thus applicable for the calculation of the output value.</description>
<multivalue>optional</multivalue>
<sem_type>string</sem_type>
</parameter>
<parameter id="Value">
<default_type>real</default_type>
<description lang="en_US">Output value, calculated as the mean over each value of the given keys.</description>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>real</sem_type>
<type_list>
<item>real</item>
</type_list>
</parameter>
</parameters>
</docu>
</procedure>
<procedure name="remove_dir_recursively">
<interface>
<ic>
<par name="DirName" base_type="ctrl" dimension="0"/>
</ic>
</interface>
<body>
<c>* Recursively delete all subdirectories.</c>
<l>list_files (DirName, 'directories', Dirs)</l>
<l>for I := 0 to |Dirs| - 1 by 1</l>
<l>    remove_dir_recursively (Dirs[I])</l>
<l>endfor</l>
<c>* Delete all files.</c>
<l>list_files (DirName, 'files', Files)</l>
<l>for I := 0 to |Files| - 1 by 1</l>
<l>    delete_file (Files[I])</l>
<l>endfor</l>
<c>* Remove empty directory.</c>
<l>remove_dir (DirName)</l>
<l>return ()</l>
</body>
<docu id="remove_dir_recursively">
<abstract lang="en_US">This procedure removes a directory recursively. I.e., different to remove_dir, remove_dir_recursively also deletes contained files and subdirectories. </abstract>
<chapters lang="en_US">
<item>File</item>
<item>Misc</item>
</chapters>
<keywords lang="en_US">
<item>remove directory</item>
<item>remove file</item>
</keywords>
<library lang="en_US">MVTec Standard Procedures</library>
<see_also>
<item>remove_dir</item>
<item>delete_file</item>
</see_also>
<short lang="en_US">This procedure removes a directory recursively.</short>
<parameters>
<parameter id="DirName">
<default_type>string</default_type>
<description lang="en_US">Path to the folder which is removed recursively.</description>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>filename.dir</sem_type>
<type_list>
<item>string</item>
</type_list>
</parameter>
</parameters>
</docu>
</procedure>
<procedure name="remove_dl_data_outliers" access="local">
<interface>
<ic>
<par name="DataCollection" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="DataCollectionReduced" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c>* This procedure removes a given ratio of the smallest and largest data</c>
<c>* points in the input DataCollection in order to remove possible outliers.</c>
<c>* </c>
<c>* The ratio of the data collections to be considered as outliers.</c>
<l>OutliersRatio := 0.0025</l>
<l>MinNumData := 1 / OutliersRatio - 1</l>
<c>* </c>
<c>* Remove outliers in the given data collection.</c>
<l>NumData := |DataCollection|</l>
<l>if (NumData &gt; MinNumData)</l>
<l>    DataSorted := sort(DataCollection)</l>
<l>    DataOutliers := int(OutliersRatio * NumData)</l>
<l>    DataCollectionReduced := DataSorted[DataOutliers:NumData - DataOutliers - 1]</l>
<l>else</l>
<l>    DataCollectionReduced := DataCollection</l>
<l>endif</l>
<c>* </c>
<l>return ()</l>
</body>
<docu id="remove_dl_data_outliers">
<abstract lang="en_US">This procedure removes a given ratio of smallest and largest data points in the data collection DataCollection in order to remove possible outliers. The reduced data collection is returned in DataCollectionReduced.

Removing possible outliers from the data collection is advantageous before further processing. In case the removed values are not real outliers (i.e., the fit well into the data collection), removing them will usually not have a significant impact on subsequent steps.</abstract>
<chapters lang="en_US">
<item>Deep Learning</item>
<item>Object Detection</item>
</chapters>
<library lang="en_US">MVTec Standard Procedures</library>
<short lang="en_US">This procedure removes a given ratio of the smallest and largest data points in the data collection DataCollection.</short>
<parameters>
<parameter id="DataCollection">
<default_type>real</default_type>
<default_value>[]</default_value>
<description lang="en_US">Data collection generated from the dataset.</description>
<mixed_type>false</mixed_type>
<multivalue>optional</multivalue>
<sem_type>real</sem_type>
<type_list>
<item>real</item>
</type_list>
</parameter>
<parameter id="DataCollectionReduced">
<default_type>real</default_type>
<description lang="en_US">Reduced data collection.</description>
<mixed_type>false</mixed_type>
<multivalue>optional</multivalue>
<sem_type>real</sem_type>
<type_list>
<item>real</item>
</type_list>
</parameter>
</parameters>
</docu>
</procedure>
<procedure name="replace_legacy_preprocessing_parameters" access="local">
<interface>
<ic>
<par name="DLPreprocessParam" base_type="ctrl" dimension="0"/>
</ic>
</interface>
<body>
<c>* </c>
<c>* This procedure adapts the dictionary DLPreprocessParam</c>
<c>* if a legacy preprocessing parameter is set.</c>
<c>* </c>
<c>* Map legacy value set to new parameter.</c>
<l>Exception := false</l>
<l>try</l>
<l>    get_dict_param (DLPreprocessParam, 'key_exists', 'normalization_type', NormalizationTypeExists)</l>
<c>    * </c>
<l>    if (NormalizationTypeExists)</l>
<l>        get_dict_tuple (DLPreprocessParam, 'normalization_type', NormalizationType)</l>
<l>        if (NormalizationType == 'true')</l>
<l>            NormalizationType := 'first_channel'</l>
<l>        elseif (NormalizationType == 'false')</l>
<l>            NormalizationType := 'none'</l>
<l>        endif</l>
<l>        set_dict_tuple (DLPreprocessParam, 'normalization_type', NormalizationType)</l>
<l>    endif</l>
<l>catch (Exception)</l>
<l>endtry</l>
<c>* </c>
<c>* Map legacy parameter to new parameter and corresponding value.</c>
<l>Exception := false</l>
<l>try</l>
<l>    get_dict_param (DLPreprocessParam, 'key_exists', 'contrast_normalization', LegacyNormalizationKeyExists)</l>
<l>    if (LegacyNormalizationKeyExists)</l>
<l>        get_dict_tuple (DLPreprocessParam, 'contrast_normalization', ContrastNormalization)</l>
<c>        * Replace 'contrast_normalization' by 'normalization_type'.</c>
<l>        if (ContrastNormalization == 'false')</l>
<l>            set_dict_tuple (DLPreprocessParam, 'normalization_type', 'none')</l>
<l>        elseif (ContrastNormalization == 'true')</l>
<l>            set_dict_tuple (DLPreprocessParam, 'normalization_type', 'first_channel')</l>
<l>        endif</l>
<l>        remove_dict_key (DLPreprocessParam, 'contrast_normalization')</l>
<l>    endif</l>
<l>catch (Exception)</l>
<l>endtry</l>
<l>return ()</l>
</body>
<docu id="replace_legacy_preprocessing_parameters">
<abstract lang="en_US">Legacy preprocessing parameters or values are replaced by their currently corresponding one.

The following parameters are replaced:
- 'contrast_normalization' is replaced by 'normalization_type'
- 'normalization_type' values 'true'/'false' are replaced by 'first_channel'/'none'</abstract>
<chapters lang="en_US">
<item>Deep Learning</item>
<item>Model</item>
</chapters>
<library lang="en_US">MVTec Standard Procedures</library>
<short lang="en_US">This procedure replaces legacy preprocessing parameters.</short>
<parameters>
<parameter id="DLPreprocessParam"/>
</parameters>
</docu>
</procedure>
<procedure name="scale_image_range">
<interface>
<io>
<par name="Image" base_type="iconic" dimension="0"/>
</io>
<oo>
<par name="ImageScaled" base_type="iconic" dimension="0"/>
</oo>
<ic>
<par name="Min" base_type="ctrl" dimension="0"/>
<par name="Max" base_type="ctrl" dimension="0"/>
</ic>
</interface>
<body>
<c>* Convenience procedure to scale the gray values of the</c>
<c>* input image Image from the interval [Min,Max]</c>
<c>* to the interval [0,255] (default).</c>
<c>* Gray values &lt; 0 or &gt; 255 (after scaling) are clipped.</c>
<c>* </c>
<c>* If the image shall be scaled to an interval different from [0,255],</c>
<c>* this can be achieved by passing tuples with 2 values [From, To]</c>
<c>* as Min and Max.</c>
<c>* Example:</c>
<c>* scale_image_range(Image:ImageScaled:[100,50],[200,250])</c>
<c>* maps the gray values of Image from the interval [100,200] to [50,250].</c>
<c>* All other gray values will be clipped.</c>
<c>* </c>
<c>* input parameters:</c>
<c>* Image: the input image</c>
<c>* Min: the minimum gray value which will be mapped to 0</c>
<c>*      If a tuple with two values is given, the first value will</c>
<c>*      be mapped to the second value.</c>
<c>* Max: The maximum gray value which will be mapped to 255</c>
<c>*      If a tuple with two values is given, the first value will</c>
<c>*      be mapped to the second value.</c>
<c>* </c>
<c>* Output parameter:</c>
<c>* ImageScale: the resulting scaled image.</c>
<c>* </c>
<l>if (|Min| == 2)</l>
<l>    LowerLimit := Min[1]</l>
<l>    Min := Min[0]</l>
<l>else</l>
<l>    LowerLimit := 0.0</l>
<l>endif</l>
<l>if (|Max| == 2)</l>
<l>    UpperLimit := Max[1]</l>
<l>    Max := Max[0]</l>
<l>else</l>
<l>    UpperLimit := 255.0</l>
<l>endif</l>
<c>* </c>
<c>* Calculate scaling parameters.</c>
<l>Mult := real(UpperLimit - LowerLimit) / (Max - Min)</l>
<l>Add := -Mult * Min + LowerLimit</l>
<c>* </c>
<c>* Scale image.</c>
<l>scale_image (Image, Image, Mult, Add)</l>
<c>* </c>
<c>* Clip gray values if necessary.</c>
<c>* This must be done for each image and channel separately.</c>
<l>gen_empty_obj (ImageScaled)</l>
<l>count_obj (Image, NumImages)</l>
<l>for ImageIndex := 1 to NumImages by 1</l>
<l>    select_obj (Image, ImageSelected, ImageIndex)</l>
<l>    count_channels (ImageSelected, Channels)</l>
<l>    for ChannelIndex := 1 to Channels by 1</l>
<l>        access_channel (ImageSelected, SelectedChannel, ChannelIndex)</l>
<l>        min_max_gray (SelectedChannel, SelectedChannel, 0, MinGray, MaxGray, Range)</l>
<l>        threshold (SelectedChannel, LowerRegion, min([MinGray,LowerLimit]), LowerLimit)</l>
<l>        threshold (SelectedChannel, UpperRegion, UpperLimit, max([UpperLimit,MaxGray]))</l>
<l>        paint_region (LowerRegion, SelectedChannel, SelectedChannel, LowerLimit, 'fill')</l>
<l>        paint_region (UpperRegion, SelectedChannel, SelectedChannel, UpperLimit, 'fill')</l>
<l>        if (ChannelIndex == 1)</l>
<l>            copy_obj (SelectedChannel, ImageSelectedScaled, 1, 1)</l>
<l>        else</l>
<l>            append_channel (ImageSelectedScaled, SelectedChannel, ImageSelectedScaled)</l>
<l>        endif</l>
<l>    endfor</l>
<l>    concat_obj (ImageScaled, ImageSelectedScaled, ImageScaled)</l>
<l>endfor</l>
<l>return ()</l>
</body>
<docu id="scale_image_range">
<abstract lang="en_US">Convenience procedure to scale the gray values of the input image Image from the interval [Min,Max] to the interval [0,255] (default).
Gray values &lt; 0 or &gt; 255 (after scaling) are clipped.
If the image shall be scaled to an interval different from [0,255], this can be achieved by passing tuples with 2 values [From, To] as Min and Max.
Example:
scale_image_range (Image, ImageScaled, [100,50], [200,250])
maps the gray values of Image from the interval [100,200] to [50,250].
All other gray values will be clipped.
</abstract>
<alternatives>
<item>scale_image</item>
<item>scale_image_max</item>
</alternatives>
<chapters>
<item>Filters</item>
<item>Arithmetic</item>
</chapters>
<chapters lang="de_DE">
<item>Filter</item>
<item>Arithmetik</item>
</chapters>
<chapters lang="en_US">
<item>Filters</item>
<item>Arithmetic</item>
</chapters>
<example lang="en_US">read_image (Image, 'fabrik')
scale_image_range (Image, ImageScaled, [100,50], [200,250])</example>
<keywords lang="de_DE">
<item>Grauwerte skalieren</item>
</keywords>
<keywords lang="en_US">
<item>scale gray values</item>
</keywords>
<library lang="de_DE">MVTec Standard Procedures</library>
<library lang="en_US">MVTec Standard Procedures</library>
<see_also>
<item>scale_image</item>
<item>scale_image_max</item>
</see_also>
<short>Scale the gray values of an image from the interval [Min,Max] to [0,255]</short>
<short lang="de_DE">Scale the gray values of an image from the interval [Min,Max] to [0,255]</short>
<short lang="en_US">Scale the gray values of an image from the interval [Min,Max] to [0,255]</short>
<parameters>
<parameter id="Image">
<description lang="en_US">The input image to be scaled</description>
<multichannel>optional</multichannel>
<multivalue>optional</multivalue>
<sem_type>image</sem_type>
<type_list>
<item>byte</item>
<item>int1</item>
<item>int2</item>
<item>uint2</item>
<item>int4</item>
<item>int8</item>
<item>real</item>
<item>cyclic</item>
<item>direction</item>
<item>complex</item>
</type_list>
</parameter>
<parameter id="ImageScaled">
<description lang="en_US">The scaled output image</description>
<multichannel>optional</multichannel>
<multivalue>optional</multivalue>
<sem_type>image</sem_type>
<type_list>
<item>byte</item>
<item>int1</item>
<item>int2</item>
<item>uint2</item>
<item>int4</item>
<item>int8</item>
<item>real</item>
<item>cyclic</item>
<item>direction</item>
<item>complex</item>
</type_list>
</parameter>
<parameter id="Max">
<default_type>integer</default_type>
<default_value>200</default_value>
<description lang="en_US">The maximum gray value which will be mapped to 255. If a tuple with two values is given, the first value will be mapped to the second value.</description>
<mixed_type>optional</mixed_type>
<multivalue>optional</multivalue>
<sem_type>number</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
<parameter id="Min">
<default_type>integer</default_type>
<default_value>100</default_value>
<description lang="en_US">The minimum gray value which will be mapped to 0. If a tuple with two values is given, the first value will be mapped to the second value.</description>
<mixed_type>optional</mixed_type>
<multivalue>true</multivalue>
<sem_type>number</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
</parameters>
</docu>
</procedure>
<procedure name="scale_rectangle2_bbox" access="local">
<interface>
<ic>
<par name="Row" base_type="ctrl" dimension="0"/>
<par name="Col" base_type="ctrl" dimension="0"/>
<par name="Length1" base_type="ctrl" dimension="0"/>
<par name="Length2" base_type="ctrl" dimension="0"/>
<par name="Phi" base_type="ctrl" dimension="0"/>
<par name="FactorHeight" base_type="ctrl" dimension="0"/>
<par name="FactorWidth" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="NewRow" base_type="ctrl" dimension="0"/>
<par name="NewCol" base_type="ctrl" dimension="0"/>
<par name="NewLength1" base_type="ctrl" dimension="0"/>
<par name="NewLength2" base_type="ctrl" dimension="0"/>
<par name="NewPhi" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c>* This procedure computes the parameters of a given bounding box of type</c>
<c>* rectangle2 for an image scaling by FactorHeight and FactorWidth.</c>
<c>* </c>
<c>* Generate XLD contour for the rectangle.</c>
<l>gen_rectangle2_contour_xld (Rectangle2XLD, Row, Col, Phi, Length1, Length2)</l>
<c>* Create scaling matrix.</c>
<l>hom_mat2d_identity (HomMat2DIdentity)</l>
<l>hom_mat2d_scale (HomMat2DIdentity, FactorHeight, FactorWidth, 0, 0, HomMat2DScale)</l>
<c>* </c>
<c>* Scale the XLD contours --&gt; results in sheared regions.</c>
<l>affine_trans_contour_xld (Rectangle2XLD, Rectangle2XLDSheared, HomMat2DScale)</l>
<l>smallest_rectangle2_xld (Rectangle2XLDSheared, NewRow, NewCol, NewPhi, NewLength1, NewLength2)</l>
<c>* </c>
<c>* Since the angle Phi can point to 4 different directions for the same rectangle2,</c>
<c>* it is possible that the new Phi returned by smallest_rectangle2_xld is not the one</c>
<c>* corresponding to the original Phi. Hence we need to get all 4 possible Phis and</c>
<c>* find the one closest to the original.</c>
<c>* </c>
<c>* At first, get the 4 angles.</c>
<l>NewPhi1 := NewPhi</l>
<l>NewPhi2 := NewPhi + rad(90)</l>
<l>NewPhi3 := NewPhi + rad(180)</l>
<l>NewPhi4 := NewPhi + rad(270)</l>
<c>* Clip the angles to the range -Pi to Pi.</c>
<l>Pi := rad(180)</l>
<l>MaskPhi2 := (NewPhi2 [&gt;] Pi) * 2 * Pi</l>
<l>MaskPhi3 := (NewPhi3 [&gt;] Pi) * 2 * Pi</l>
<l>MaskPhi4 := (NewPhi4 [&gt;] Pi) * 2 * Pi</l>
<l>NewPhi2 := NewPhi2 - MaskPhi2</l>
<l>NewPhi3 := NewPhi3 - MaskPhi3</l>
<l>NewPhi4 := NewPhi4 - MaskPhi4</l>
<c>* Calculate the distance between the new angles and the original one.</c>
<l>Diff1 := abs(NewPhi1 - Phi)</l>
<l>Diff2 := abs(NewPhi2 - Phi)</l>
<l>Diff3 := abs(NewPhi3 - Phi)</l>
<l>Diff4 := abs(NewPhi4 - Phi)</l>
<c>* Get the angles with the minimum distances. Therefore we compare the angle tuples pairwise.</c>
<c>* At first, NewPhi1 and NewPhi2 ...</c>
<l>MinDiff12 := min2(Diff1,Diff2)</l>
<c>* ... and store the tuple index of the minimum.</c>
<l>MinIndex12 := (Diff1 [&gt;=] Diff2) + 1</l>
<c>* Now, compare NewPhi3 and NewPhi4 ...</c>
<l>MinDiff34 := min2(Diff3,Diff4)</l>
<c>* ... and also store the tuple index of the minimum.</c>
<l>MinIndex34 := (Diff3 [&gt;=] Diff4) + 3</l>
<c>* At last, compare the results from previous comparisons ...</c>
<l>MinDiff1234 := min2(MinDiff12,MinDiff34)</l>
<c>* ... and store the final indices.</c>
<l>MinIndex12Mask := MinDiff12 [&lt;] MinDiff34</l>
<l>MinIndex34Mask := 1 - MinIndex12Mask</l>
<l>MinIndex12Masked := MinIndex12 * MinIndex12Mask</l>
<l>MinIndex34Masked := MinIndex34 * MinIndex34Mask</l>
<l>MinIndex1234 := MinIndex12Masked + MinIndex34Masked</l>
<c>* </c>
<c>* Using the final indices, we can create a mask for each of the angle tuples.</c>
<l>NewPhi1Masked := (MinIndex1234 [==] 1) * NewPhi1</l>
<l>NewPhi2Masked := (MinIndex1234 [==] 2) * NewPhi2</l>
<l>NewPhi3Masked := (MinIndex1234 [==] 3) * NewPhi3</l>
<l>NewPhi4Masked := (MinIndex1234 [==] 4) * NewPhi4</l>
<l>NewPhi := NewPhi1Masked + NewPhi2Masked + NewPhi3Masked + NewPhi4Masked</l>
<c>* In case the correct angle is the angle returned by smallest_rectangle2 + 90 or</c>
<c>* + 270 degrees, we need to swap length1 and length2.</c>
<l>SwapMask := (MinIndex1234 [==] 2) + (MinIndex1234 [==] 4)</l>
<l>SwapMaskInverted := 1 - SwapMask</l>
<l>Length1Tmp := NewLength1 * SwapMask</l>
<l>Length2Tmp := NewLength2 * SwapMask</l>
<l>NewLength1 := NewLength1 * SwapMaskInverted + Length2Tmp</l>
<l>NewLength2 := NewLength2 * SwapMaskInverted + Length1Tmp</l>
<c>* </c>
<l>return ()</l>
</body>
<docu id="scale_rectangle2_bbox">
<abstract lang="en_US">This procedure computes the parameters of a given bounding box of type rectangle2 for an image scaling by FactorHeight and FactorWidth.
As the strictly scaled bounding box is usually not a rectangle anymore, a transformation occurs which may cover a slightly different area.
</abstract>
<chapters lang="en_US">
<item>Deep Learning</item>
<item>Object Detection</item>
</chapters>
<library lang="en_US">MVTec Standard Procedures</library>
<short lang="en_US">This procedure calculates the scaled bounding box parameters for a bounding box of type rectangle2.</short>
<parameters>
<parameter id="Col">
<default_type>real</default_type>
<description lang="en_US">Column coordinate of the original bounding box.</description>
<mixed_type>false</mixed_type>
<multivalue>optional</multivalue>
<sem_type>real</sem_type>
<type_list>
<item>real</item>
</type_list>
</parameter>
<parameter id="FactorHeight">
<default_type>real</default_type>
<description lang="en_US">Scaling factor for the height direction.</description>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>real</sem_type>
<type_list>
<item>real</item>
</type_list>
</parameter>
<parameter id="FactorWidth">
<default_type>real</default_type>
<description lang="en_US">Scaling factor for the width direction.</description>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>real</sem_type>
<type_list>
<item>real</item>
</type_list>
</parameter>
<parameter id="Length1">
<default_type>real</default_type>
<description lang="en_US">Length1 of the original bounding box.</description>
<mixed_type>false</mixed_type>
<multivalue>optional</multivalue>
<sem_type>real</sem_type>
<type_list>
<item>real</item>
</type_list>
</parameter>
<parameter id="Length2">
<default_type>real</default_type>
<description lang="en_US">Length2 of the original bounding box.</description>
<mixed_type>false</mixed_type>
<multivalue>optional</multivalue>
<sem_type>real</sem_type>
<type_list>
<item>real</item>
</type_list>
</parameter>
<parameter id="NewCol">
<default_type>real</default_type>
<description lang="en_US">Column coordinate of the scaled bounding box.</description>
<mixed_type>false</mixed_type>
<multivalue>optional</multivalue>
<sem_type>real</sem_type>
<type_list>
<item>real</item>
</type_list>
</parameter>
<parameter id="NewLength1">
<default_type>real</default_type>
<description lang="en_US">Length1 of the scaled bounding box.</description>
<mixed_type>false</mixed_type>
<multivalue>optional</multivalue>
<sem_type>real</sem_type>
<type_list>
<item>real</item>
</type_list>
</parameter>
<parameter id="NewLength2">
<default_type>real</default_type>
<description lang="en_US">Length2 of the scaled bounding box.</description>
<mixed_type>false</mixed_type>
<multivalue>optional</multivalue>
<sem_type>real</sem_type>
<type_list>
<item>real</item>
</type_list>
</parameter>
<parameter id="NewPhi">
<default_type>real</default_type>
<description lang="en_US">Phi of the scaled bounding box.</description>
<mixed_type>false</mixed_type>
<multivalue>optional</multivalue>
<sem_type>real</sem_type>
<type_list>
<item>real</item>
</type_list>
</parameter>
<parameter id="NewRow">
<default_type>real</default_type>
<description lang="en_US">Row coordinate of the scaled bounding box.</description>
<mixed_type>false</mixed_type>
<multivalue>optional</multivalue>
<sem_type>real</sem_type>
<type_list>
<item>real</item>
</type_list>
</parameter>
<parameter id="Phi">
<default_type>real</default_type>
<description lang="en_US">Phi of the original bounding box.</description>
<mixed_type>false</mixed_type>
<multivalue>optional</multivalue>
<sem_type>real</sem_type>
<type_list>
<item>real</item>
</type_list>
</parameter>
<parameter id="Row">
<default_type>real</default_type>
<description lang="en_US">Row coordinate of the original bounding box.</description>
<mixed_type>false</mixed_type>
<multivalue>optional</multivalue>
<sem_type>real</sem_type>
<type_list>
<item>real</item>
</type_list>
</parameter>
</parameters>
</docu>
</procedure>
<procedure name="select_case" access="local">
<interface>
<io>
<par name="MenuRegions" base_type="iconic" dimension="0"/>
</io>
<ic>
<par name="WindowHandleMenu" base_type="ctrl" dimension="0"/>
<par name="MenuTexts" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="SelectedCase" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<l>while (1)</l>
<l>    try</l>
<l>        get_mposition (WindowHandleMenu, Row, Column, Button)</l>
<l>        if (Button == 1)</l>
<l>            count_obj (MenuRegions, Number)</l>
<l>            for Index := 1 to min2(Number,|MenuTexts|) by 1</l>
<l>                select_obj (MenuRegions, ObjectSelected, Index)</l>
<l>                test_region_point (ObjectSelected, Row, Column, IsInside)</l>
<l>                if (IsInside)</l>
<l>                    SelectedCase := Index - 1</l>
<l>                    return ()</l>
<l>                endif</l>
<l>            endfor</l>
<l>        endif</l>
<l>    catch (Exception)</l>
<l>        if (Exception[0] == 2454 or Exception[0] == 5100)</l>
<c>            * Handle was already cleared -&gt; indicates that the window was closed (by the user)</c>
<c>            * Abort gracefully.</c>
<l>            SelectedCase := -1</l>
<l>            return ()</l>
<l>        elseif (Exception[0] == H_MSG_FAIL)</l>
<c>            * Ignore -&gt; mouse outside of window</c>
<l>        else</l>
<c>            * Unknown / Unexpected exception</c>
<c>            * Ignore for now</c>
<l>        endif</l>
<l>    endtry</l>
<l>endwhile</l>
<l>return ()</l>
</body>
<docu id="select_case">
<chapters lang="en_US">
<item>Graphics</item>
<item>Mouse</item>
</chapters>
<library lang="en_US">MVTec Standard Procedures</library>
<parameters>
<parameter id="MenuRegions"/>
<parameter id="MenuTexts"/>
<parameter id="SelectedCase"/>
<parameter id="WindowHandleMenu"/>
</parameters>
</docu>
</procedure>
<procedure name="select_dl_detection_levels" access="local">
<interface>
<ic>
<par name="Areas" base_type="ctrl" dimension="0"/>
<par name="MinLevel" base_type="ctrl" dimension="0"/>
<par name="MaxLevel" base_type="ctrl" dimension="0"/>
<par name="AnchorNumSubscales" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="MinLevelToUse" base_type="ctrl" dimension="0"/>
<par name="MaxLevelToUse" base_type="ctrl" dimension="0"/>
<par name="AnchorNumSubscalesToUse" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c>* This procedure suggests levels and number of anchor subscales</c>
<c>* suiting best for a deep-learning-based object detection model</c>
<c>* based on the input Areas.</c>
<c>* </c>
<c>* Check that the input Areas has at least one value.</c>
<l>if (|Areas| &lt; 1)</l>
<l>    throw ('No bounding box areas to process.')</l>
<l>endif</l>
<c>* </c>
<c>* Try to find the minimum number of subscales required to get</c>
<c>* a good IoU for all bounding box sizes.</c>
<c>* </c>
<c>* As long as the IoU is above the following threshold value, it is</c>
<c>* considered to be good.</c>
<l>GoodIoU := 0.5</l>
<c>* Minimum ratio of all ground truth bounding boxes which need to have</c>
<c>* the good IoU stated above.</c>
<l>GoodIoURatio := 0.99</l>
<c>* </c>
<c>* Scaling constants and strides for anchor boxes of different levels.</c>
<l>AnchorScale := 4.</l>
<l>LevelScales := AnchorScale * pow(2.,[MinLevel:MaxLevel])</l>
<l>LevelHalfStrides := pow(2.,[MinLevel:MaxLevel]) / 2</l>
<l>LevelHalfStridesSq := LevelHalfStrides * LevelHalfStrides</l>
<c>* </c>
<c>* Ground truth bounding box widths.</c>
<l>GTBWidths := sqrt(Areas)</l>
<c>* </c>
<c>* Loop over the subscales (starting at 1) until a value is found for</c>
<c>* which all IoUs are good or the upper bound (given by AnchorNumSubscales)</c>
<c>* is reached.</c>
<l>AnchorNumSubscalesToUse := AnchorNumSubscales</l>
<l>for Subscales := 1 to AnchorNumSubscales by 1</l>
<c>    * Calculate scaling factors for the subscales.</c>
<l>    SubscaleFactors := pow(2,[0:Subscales - 1] / real(Subscales))</l>
<c>    * Calculate the widths of each sublevel (level + subscales).</c>
<l>    SubLevelWidths := []</l>
<l>    for Lvl := MinLevel to MaxLevel by 1</l>
<l>        AnchorWidths := SubscaleFactors * LevelScales[Lvl - MinLevel]</l>
<l>        SubLevelWidths := [SubLevelWidths,AnchorWidths]</l>
<l>    endfor</l>
<l>    SubLevelAreas := SubLevelWidths * SubLevelWidths</l>
<c>    * </c>
<c>    * For each sublevel one can determine the range of possible bounding</c>
<c>    * box widths leading to a good IoU. Therewith we can check, if every</c>
<c>    * ground truth bounding box width is between a minimum and a maximum</c>
<c>    * value.</c>
<c>    * </c>
<c>    * The minimum and maximum can be derived from the formula of the</c>
<c>    * IoU. To calculate the IoU, we need to consider the stride</c>
<c>    * length of the level. With a stride of d, the worst case</c>
<c>    * (minimum overlap) between the ground truth bounding box and</c>
<c>    * anchor bounding box looks like follows</c>
<c>    * </c>
<c>    *        ---------</c>
<c>    *       |         |&lt; d/2</c>
<c>    *       |    -----|--------</c>
<c>    *       |   |     |        |</c>
<c>    *       |   |     |        |</c>
<c>    *        ---------         |</c>
<c>    *        ^  |              |</c>
<c>    *       d/2 |              |</c>
<c>    *           |              |</c>
<c>    *            --------------</c>
<c>    * </c>
<c>    * With X = width of the smaller bounding box and Y = width of the larger</c>
<c>    * bounding box, r = GoodIoU, the IoU is calculated by</c>
<c>    * </c>
<c>    *             X^2 - 2*d/2*X + d^2/4</c>
<c>    *          -------------------------- &gt;= r</c>
<c>    *            Y^2 + (2*d/2*X - d^2/4)</c>
<c>    * </c>
<c>    *               X^2 - d*X + d^2/4</c>
<c>    *          -------------------------- &gt;= r</c>
<c>    *               Y^2 + d*X - d^2/4</c>
<c>    * </c>
<c>    *                   X^2 - d*X + d^2/4 &gt;= r * (Y^2 + d*X - d^2/4)</c>
<c>    *       X^2 - (1+r)*d*X + (1+r)*d^2/4 &gt;= r*Y^2</c>
<c>    * (X - (1+r)*d/2)^2 - (r^2 + r)*d^2/4 &gt;= r*Y^2</c>
<c>    * </c>
<c>    * By substituting the constants</c>
<c>    * C_1 = (1+r)*d/2</c>
<c>    * C_2 = (r^2 + r)*d^2/4,</c>
<c>    * we get</c>
<c>    * (X - C_1)^2 - C_2 &gt;= r*Y^2</c>
<c>    * </c>
<l>    Cs_1 := []</l>
<l>    Cs_2 := []</l>
<l>    for Lvl := MinLevel to MaxLevel by 1</l>
<l>        C_1 := (1 + GoodIoU) * LevelHalfStrides[Lvl - MinLevel]</l>
<l>        Cs_1 := [Cs_1,gen_tuple_const(Subscales,C_1)]</l>
<l>        C_2 := (pow(GoodIoU,2) + GoodIoU) * LevelHalfStridesSq[Lvl - MinLevel]</l>
<l>        Cs_2 := [Cs_2,gen_tuple_const(Subscales,C_2)]</l>
<l>    endfor</l>
<c>    * </c>
<c>    * In case the ground truth bounding box is smaller than the anchor bounding box</c>
<c>    * =&gt; ground truth bounding box width = X:</c>
<c>    * X &gt;= sqrt(r*Y^2 + C_2) + C_1</c>
<l>    SmallWidth := sqrt(GoodIoU * SubLevelAreas + Cs_2) + Cs_1</l>
<c>    * </c>
<c>    * In case the ground truth boudning box is larger than the anchor bounding box</c>
<c>    * =&gt; ground truth bounding box width = Y:</c>
<c>    * Y &lt;= sqrt(((X - C_1)^2 - C_2) * 1/r)</c>
<l>    SubLevelWidthMinusC1 := SubLevelWidths - Cs_1</l>
<l>    LargeWidth := sqrt((SubLevelWidthMinusC1 * SubLevelWidthMinusC1 - Cs_2) / GoodIoU)</l>
<c>    * </c>
<c>    * Check whether all ground truth bounding box widths lie within the above</c>
<c>    * calculated minimum and maximum widths of one sublevel.</c>
<l>    CheckResult := gen_tuple_const(|GTBWidths|,0)</l>
<c>    * Set CheckResult for ground truth bounding boxes smaller than the minimum</c>
<c>    * to 1 since these do not fit regardless of anchor_num_subscales.</c>
<l>    MinSmallWidth := min(SmallWidth)</l>
<l>    CheckResult := CheckResult + (GTBWidths [&lt;] MinSmallWidth)</l>
<c>    * Check for each sublevel whether the ground truth widths fit in.</c>
<l>    for Sublvl := 0 to |SubLevelWidths| - 1 by 1</l>
<l>        CheckResult := CheckResult + ((GTBWidths [&gt;=] SmallWidth[Sublvl]) and (GTBWidths [&lt;=] LargeWidth[Sublvl]))</l>
<l>    endfor</l>
<c>    * </c>
<l>    ZeroIndices := find(CheckResult,0)</l>
<c>    * In case there is only an insignificant number of ground truth widths which</c>
<c>    * do not fit in any of the sublevels, the current number of subscales is chosen.</c>
<l>    if ((ZeroIndices == -1) or (|ZeroIndices| &lt; (1 - GoodIoURatio) * |GTBWidths|))</l>
<l>        AnchorNumSubscalesToUse := Subscales</l>
<l>        break</l>
<l>    endif</l>
<l>endfor</l>
<c>* </c>
<c>* Get minimum ground truth bounding box width.</c>
<l>MinWidth := min(GTBWidths)</l>
<c>* Get last sublevel where the smallest object fits in.</c>
<l>MinSubLevel := find_last((SmallWidth [&lt;=] MinWidth) and (LargeWidth [&gt;=] MinWidth),1)</l>
<c>* If no sublevel could be found, take the sublevel with the SmallWidth</c>
<c>* closest to MinWidth.</c>
<l>if (MinSubLevel == -1)</l>
<l>    SmallWidthDistances := abs(SmallWidth - MinWidth)</l>
<l>    MinSubLevel := find_last(SmallWidthDistances,min(SmallWidthDistances))</l>
<l>endif</l>
<l>MinSubLevel := max([0,MinSubLevel])</l>
<c>* </c>
<c>* Get maximum ground truth bounding box width.</c>
<l>MaxWidth := max(GTBWidths)</l>
<c>* Get first sublevel where the largest object fits in.</c>
<l>MaxSubLevel := find_first((SmallWidth [&lt;=] MaxWidth) and (LargeWidth [&gt;=] MaxWidth),1)</l>
<c>* If no sublevel could be found, take the sublevel with the LargeWidth</c>
<c>* closest to MaxWidth.</c>
<l>if (MaxSubLevel == -1)</l>
<l>    LargeWidthDistances := abs(LargeWidth - MaxWidth)</l>
<l>    MaxSubLevel := find_first(LargeWidthDistances,min(LargeWidthDistances))</l>
<l>endif</l>
<l>MaxSubLevel := max([MinSubLevel,MaxSubLevel])</l>
<c>* </c>
<c>* Get the levels from the sublevels.</c>
<l>MinLevelToUse := MinSubLevel / AnchorNumSubscalesToUse + MinLevel</l>
<l>MaxLevelToUse := MaxSubLevel / AnchorNumSubscalesToUse + MinLevel</l>
<c>* </c>
<l>return ()</l>
</body>
<docu id="select_dl_detection_levels">
<abstract lang="en_US">This procedure suggests levels MinLevelToUse and MaxLevelToUse as well as the number of anchor subscales AnchorNumSubscalesToUse suiting best for a deep-learning-based object detection model.

The estimation bases on the input bounding box Areas:
- MinLevelToUse depends on the smallest area.
- MaxLevelToUse depends on the largest area.
- NumSubscalesToUse is determined by evaluating how well each of the areas fits into the different subscales.

Upper and lower bound values can be specified using the following input parameters:
- MinLevel: minimum level to choose from.
- MaxLevel: maximum level to choose from.
- AnchorNumSubscales: maximum number of anchor subscales.
</abstract>
<chapters lang="en_US">
<item>Deep Learning</item>
<item>Object Detection</item>
</chapters>
<library lang="en_US">MVTec Standard Procedures</library>
<short lang="en_US">This procedure suggests the minimum and maximum level as well as the number of anchor subscales for an object detection model.</short>
<parameters>
<parameter id="AnchorNumSubscales">
<default_type>integer</default_type>
<default_value>3</default_value>
<description lang="en_US">Start value to choose the number of subscales.</description>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>integer</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="AnchorNumSubscalesToUse">
<default_type>integer</default_type>
<description lang="en_US">Suggested number of anchor subscales.</description>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>integer</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="Areas">
<default_type>real</default_type>
<description lang="en_US">Bounding box areas.</description>
<mixed_type>false</mixed_type>
<multivalue>optional</multivalue>
<sem_type>real</sem_type>
<type_list>
<item>real</item>
</type_list>
</parameter>
<parameter id="MaxLevel">
<default_type>integer</default_type>
<default_value>7</default_value>
<description lang="en_US">Maximum level to choose from.</description>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>integer</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="MaxLevelToUse">
<default_type>integer</default_type>
<description lang="en_US">Suggested maximum model level.</description>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>integer</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="MinLevel">
<default_type>integer</default_type>
<default_value>2</default_value>
<description lang="en_US">Minimum possible level to choose from.</description>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>integer</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="MinLevelToUse">
<default_type>integer</default_type>
<description lang="en_US">Suggested minimum model level.</description>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>integer</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
</parameters>
</docu>
</procedure>
<procedure name="select_mask_obj">
<interface>
<io>
<par name="Objects" base_type="iconic" dimension="0"/>
</io>
<oo>
<par name="SelectedObjects" base_type="iconic" dimension="0"/>
</oo>
<ic>
<par name="Mask" base_type="ctrl" dimension="0"/>
</ic>
</interface>
<body>
<c>* select_mask_obj selects one or more single elements of the object array</c>
<c>* Objects and returns them in SelectedObjects.</c>
<c>* The elements of Mask determine if the corresponding elements of Objects are selected.</c>
<c>* If the value is greater than 0, the corresponding element is selected.</c>
<c>* </c>
<c>* Check number of elements</c>
<l>count_obj (Objects, Number)</l>
<l>if (Number != |Mask|)</l>
<l>    throw ('Number of elements in Objects and Mask do not match.')</l>
<l>endif</l>
<c>* </c>
<c>* Check type of mask elements</c>
<l>AllNumbers := sum(is_real_elem(Mask)) + sum(is_int_elem(Mask)) == |Mask|</l>
<l>if (not AllNumbers and Mask != [])</l>
<l>    throw ('Invalid type: Elements of Mask must be integer or real numbers.')</l>
<l>endif</l>
<c>* </c>
<c>* Use select_mask for tuples to generate a list of object indices.</c>
<l>Indices := select_mask([1:|Mask|],Mask)</l>
<l>select_obj (Objects, SelectedObjects, Indices)</l>
<l>return ()</l>
</body>
<docu id="select_mask_obj">
<abstract lang="en_US">select_mask_obj selects elements of the object array Objects based on the elements in Mask and returns them in SelectedObjects. For all elements of Mask that are greater than 0, the corresponding element of Objects is returned in SelectedObjects. Objects and Mask must have the same number of elements. Mask may only contain integer or float values.</abstract>
<alternatives>
<item>tuple_select_mask</item>
<item>select_obj</item>
<item>select_shape</item>
<item>select_shape_xld</item>
<item>select_contours_xld</item>
<item>select_region_point</item>
<item>select_xld_point</item>
</alternatives>
<chapters lang="de_DE">
<item>Objekt</item>
<item>Manipulation</item>
</chapters>
<chapters lang="en_US">
<item>Object</item>
<item>Manipulation</item>
</chapters>
<example lang="en_US">read_image (Image, 'tooth_rim')
edges_sub_pix (Image, Edges, 'canny', 1, 20, 40)
test_closed_xld (Edges, IsClosed)
* Select closed contours.
select_mask_obj (Edges, ClosedContours, IsClosed)
* Select open contours.
select_mask_obj (Edges, OpenContours, not IsClosed)
</example>
<library lang="en_US">MVTec Standard Procedures</library>
<predecessor>
<item>test_closed_xld</item>
<item>test_equal_obj</item>
<item>test_equal_region</item>
<item>test_region_point</item>
<item>test_self_intersection_xld</item>
<item>test_subset_region</item>
<item>test_xld_point</item>
<item>tuple_greater_elem</item>
<item>tuple_greater_equal_elem</item>
<item>tuple_equal_elem</item>
<item>tuple_is_int_elem</item>
<item>tuple_is_real_elem</item>
<item>tuple_is_string_elem</item>
<item>tuple_less_elem</item>
<item>tuple_less_equal_elem</item>
<item>tuple_not_equal_elem</item>
</predecessor>
<short lang="en_US">Select elements from object arrays using a mask.</short>
<parameters>
<parameter id="Mask">
<default_type>integer</default_type>
<description lang="en_US">&gt; 0 specifies the elements to select.</description>
<mixed_type>optional</mixed_type>
<multivalue>optional</multivalue>
<sem_type>number</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
<parameter id="Objects">
<description lang="en_US">Input object array.</description>
<multivalue>optional</multivalue>
<sem_type>object</sem_type>
</parameter>
<parameter id="SelectedObjects">
<description lang="en_US">Selected objects.</description>
<multivalue>optional</multivalue>
<sem_type>object</sem_type>
</parameter>
</parameters>
</docu>
</procedure>
<procedure name="select_percentage_dl_classifier_data">
<interface>
<ic>
<par name="ImageFiles" base_type="ctrl" dimension="0"/>
<par name="GroundTruthLabels" base_type="ctrl" dimension="0"/>
<par name="SelectPercentage" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="ImageFilesOut" base_type="ctrl" dimension="0"/>
<par name="LabelsOut" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c>* This procedure selects SelectPercentage percentages</c>
<c>* of the input data set ImageFiles and GroundTruthLabels and returns</c>
<c>* the result in ImageFilesOut and LabelsOut.</c>
<c>* The original ratio of class sizes is kept</c>
<c>* when applying this percentage.</c>
<c>* </c>
<c>* Check the input parameters.</c>
<l>if (|ImageFiles| &lt; 1)</l>
<l>    throw ('ImageFiles must not be empty.')</l>
<l>endif</l>
<l>if (|ImageFiles| != |GroundTruthLabels|)</l>
<l>    throw ('Please provide a label for every image.')</l>
<l>endif</l>
<l>if (SelectPercentage &lt; 0 or SelectPercentage &gt; 100)</l>
<l>    throw ('UsedPercentage must be between 0 and 100.')</l>
<l>endif</l>
<l>UniqueClasses := uniq(sort(GroundTruthLabels))</l>
<c>* </c>
<c>* Select the user-defined percentage of every class.</c>
<l>if (SelectPercentage == 100)</l>
<l>    ImageFilesOut := ImageFiles</l>
<l>    LabelsOut := GroundTruthLabels</l>
<l>else</l>
<l>    Ratio := SelectPercentage * 0.01</l>
<l>    ImageFilesOut := []</l>
<l>    LabelsOut := []</l>
<l>    for ClassIndex := 0 to |UniqueClasses| - 1 by 1</l>
<c>        * For each class, find the images with this label.</c>
<l>        Label := UniqueClasses[ClassIndex]</l>
<l>        LabelIndices := find(GroundTruthLabels,Label)</l>
<l>        ImageFilesLabel := ImageFiles[LabelIndices]</l>
<c>        * Shuffle the images with this label.</c>
<l>        tuple_shuffle (ImageFilesLabel, ImageFilesLabel)</l>
<c>        * Select images from the class according to the given percentage.</c>
<l>        IndexEnd := max2(0,int(floor(|ImageFilesLabel| * Ratio)) - 1)</l>
<l>        ImageFilesOut := [ImageFilesOut,ImageFilesLabel[0:IndexEnd]]</l>
<l>        LabelsOut := [LabelsOut,gen_tuple_const(IndexEnd + 1,Label)]</l>
<l>    endfor</l>
<l>endif</l>
<l>return ()</l>
</body>
<docu id="select_percentage_dl_classifier_data">
<abstract lang="en_US">This procedure selects SelectPercentage percentages of the input data set ImageFiles and GroundTruthLabels and returns the result in ImageFilesOut and LabelsOut. 

This procedure can for example be used to reduce the amount of data before applying the procedure apply_dl_classifier_batchwise and evaluate_dl_classifier. Thus, the run-time can be reduced.

UsedPercentage specifies how much of the input data is used for the evaluation, in percent. Therefore, it must be between 0 and 100. The original ratio of class sizes is preferably kept when applying this percentage. The actual percentage that is achieved can differ depending on the number of images and the number of images per class.</abstract>
<chapters lang="en_US">
<item>Legacy</item>
<item>DL Classification</item>
</chapters>
<library lang="en_US">MVTec Standard Procedures</library>
<short lang="en_US">Select a percentage of the given data.</short>
<warning lang="en_US">select_percentage_dl_classifier_data is obsolete and is only provided for reasons of backward compatibility.</warning>
<parameters>
<parameter id="GroundTruthLabels">
<default_type>string</default_type>
<description lang="en_US">Ground truth labels of the images.</description>
<mixed_type>false</mixed_type>
<multivalue>optional</multivalue>
<sem_type>string</sem_type>
<type_list>
<item>integer</item>
<item>string</item>
</type_list>
</parameter>
<parameter id="ImageFiles">
<default_type>string</default_type>
<description lang="en_US">Tuple of the image paths.</description>
<mixed_type>false</mixed_type>
<multivalue>optional</multivalue>
<sem_type>string</sem_type>
<type_list>
<item>string</item>
</type_list>
</parameter>
<parameter id="ImageFilesOut">
<default_type>string</default_type>
<description lang="en_US">The selected image file paths.</description>
<mixed_type>false</mixed_type>
<multivalue>optional</multivalue>
<sem_type>string</sem_type>
<type_list>
<item>string</item>
</type_list>
</parameter>
<parameter id="LabelsOut">
<default_type>string</default_type>
<description lang="en_US">The ground truth labels corresponding to the images in ImageFilesOut.</description>
<mixed_type>false</mixed_type>
<multivalue>optional</multivalue>
<sem_type>string</sem_type>
<type_list>
<item>string</item>
</type_list>
</parameter>
<parameter id="SelectPercentage">
<default_type>integer</default_type>
<description lang="en_US">Percentage of the given data that should be selected.</description>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>integer</sem_type>
<type_list>
<item>integer</item>
</type_list>
<value_max>100</value_max>
<value_min>0</value_min>
</parameter>
</parameters>
</docu>
</procedure>
<procedure name="send_pose_update" access="local">
<interface>
<ic>
<par name="Parameters" base_type="ctrl" dimension="0"/>
<par name="Poses" base_type="ctrl" dimension="0"/>
</ic>
</interface>
<body>
<l>get_message_tuple (Parameters, 'MessageQueue', MessageQueue)</l>
<l>if (MessageQueue != [])</l>
<l>    create_message (MessageHandle)</l>
<l>    set_message_tuple (MessageHandle, 'type', 'redraw')</l>
<l>    set_message_tuple (MessageHandle, 'poses', Poses)</l>
<l>    enqueue_message (MessageQueue[2], MessageHandle, [], [])</l>
<l>    clear_message (MessageHandle)</l>
<l>endif</l>
<l>return ()</l>
</body>
<docu id="send_pose_update">
<chapters lang="en_US">
<item>System</item>
<item>Multithreading</item>
</chapters>
<library lang="en_US">MVTec Standard Procedures</library>
<parameters>
<parameter id="Parameters"/>
<parameter id="Poses"/>
</parameters>
</docu>
</procedure>
<procedure name="serialize_train_dl_model_intermediate" access="local">
<interface>
<ic>
<par name="DLModelHandle" base_type="ctrl" dimension="0"/>
<par name="Epoch" base_type="ctrl" dimension="0"/>
<par name="Strategy" base_type="ctrl" dimension="0"/>
<par name="TrainInfos" base_type="ctrl" dimension="0"/>
<par name="EvaluationInfos" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="FilenameModel" base_type="ctrl" dimension="0"/>
<par name="FilenameMetaData" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c>* </c>
<c>* Serialize the model DLModelHandle with current meta information.</c>
<c>* </c>
<c>* We need the type of strategy used.</c>
<l>get_dict_tuple (Strategy, 'type', Type)</l>
<c></c>
<c>* Get basename/default.</c>
<l>try</l>
<l>    get_dict_tuple (Strategy, 'basename', Basename)</l>
<l>catch (Exception)</l>
<l>    Basename := Type</l>
<l>endtry</l>
<c>* </c>
<c>* If we serialize epochs we will add the epoch to the basename.</c>
<l>if (Type == 'epochs')</l>
<l>    Basename := 'model_at_epoch_' + Epoch$'.2f'</l>
<l>endif</l>
<c>* </c>
<c>* Filenames.</c>
<l>FilenameModel := Basename + '.hdl'</l>
<l>FilenameMetaData := Basename + '_info.hdict'</l>
<c>* </c>
<c>* Metadata.</c>
<l>create_dict (MetaData)</l>
<l>set_dict_tuple (MetaData, 'train_infos', TrainInfos)</l>
<l>set_dict_tuple (MetaData, 'evaluation_infos', EvaluationInfos)</l>
<l>set_dict_tuple (MetaData, 'epoch', Epoch)</l>
<c>* </c>
<c>* Write files.</c>
<l>write_dl_model (DLModelHandle, FilenameModel)</l>
<l>write_dict (MetaData, FilenameMetaData, [], [])</l>
<l>return ()</l>
</body>
<docu id="serialize_train_dl_model_intermediate">
<abstract lang="en_US">Serialize the model during training.</abstract>
<chapters lang="de_DE">
<item>Deep Learning</item>
<item>Modell</item>
</chapters>
<chapters lang="en_US">
<item>Deep Learning</item>
<item>Model</item>
</chapters>
<library lang="en_US">MVTec Standard Procedures</library>
<short lang="en_US">Serialize a DLModelHandle with current meta information.</short>
<parameters>
<parameter id="DLModelHandle">
<default_type>integer</default_type>
<description lang="en_US">Handle of the deep-learning-based model.</description>
<mixed_type>false</mixed_type>
<sem_type>dl_model</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="Epoch"/>
<parameter id="EvaluationInfos"/>
<parameter id="FilenameMetaData"/>
<parameter id="FilenameModel"/>
<parameter id="Strategy"/>
<parameter id="TrainInfos"/>
</parameters>
</docu>
</procedure>
<procedure name="set_cam_par_data">
<interface>
<ic>
<par name="CameraParamIn" base_type="ctrl" dimension="0"/>
<par name="ParamName" base_type="ctrl" dimension="0"/>
<par name="ParamValue" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="CameraParamOut" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c>* set_cam_par_data sets the value of the parameter that</c>
<c>* is given in ParamName in the tuple of camera parameters</c>
<c>* given in CameraParamIn. The modified camera parameters</c>
<c>* are returned in CameraParamOut.</c>
<c>* </c>
<c>* Check for consistent length of input parameters</c>
<l>if (|ParamName| != |ParamValue|)</l>
<l>    throw ('Different number of values in ParamName and ParamValue')</l>
<l>endif</l>
<c>* First, get the parameter names that correspond to the</c>
<c>* elements in the input camera parameter tuple.</c>
<l>get_cam_par_names (CameraParamIn, CameraType, CameraParamNames)</l>
<c>* </c>
<c>* Find the index of the requested camera data and return</c>
<c>* the corresponding value.</c>
<l>CameraParamOut := CameraParamIn</l>
<l>for Index := 0 to |ParamName| - 1 by 1</l>
<l>    ParamNameInd := ParamName[Index]</l>
<l>    I := find(CameraParamNames,ParamNameInd)</l>
<l>    if (I != -1)</l>
<l>        CameraParamOut[I] := ParamValue[Index]</l>
<l>    else</l>
<l>        throw ('Wrong ParamName ' + ParamNameInd)</l>
<l>    endif</l>
<c>    * Check the consistency of focus and telecentricity</c>
<l>    if (ParamNameInd == 'focus')</l>
<l>        IsTelecentric := strstr(CameraType,'telecentric') != -1 and strstr(CameraType,'image_side_telecentric') == -1</l>
<l>        if (IsTelecentric)</l>
<l>            throw ('Focus for telecentric lenses is always 0, and hence, cannot be changed.')</l>
<l>        endif</l>
<l>        if (not IsTelecentric and ParamValue[Index] == 0.0)</l>
<l>            throw ('Focus for non-telecentric lenses must not be 0.')</l>
<l>        endif</l>
<l>    endif</l>
<l>endfor</l>
<l>return ()</l>
</body>
<docu id="set_cam_par_data">
<abstract lang="en_US">set_cam_par_data sets the value of ParamName in the camera parameter tuple CameraParamIn. The modified camera parameters  are returned in CameraParamOut. The following parameter names can be set: 'focus' (m), 'magnification' (-), 'kappa' (m^-2), 'k1' (m^-2), 'k2' (m^-4), 'k3' (m^-6), 'p1' (m^-1), 'p2' (m^-1), 'image_plane_dist' (m), 'tilt' (deg), 'rot' (deg), 'sx' (m/px), 'sy' (m/px), 'cx' (px), 'cy' (px), 'vx' (m/scanline), 'vy' (m/scanline), 'vz' (m/scanline), 'image_width' (px), 'image_height' (px), where we indicate the HALCON default units in brackets. If the camera type does not support the requested value, an exception is raised.</abstract>
<chapters lang="de_DE">
<item>Kalibrierung</item>
<item>Kameraparameter</item>
</chapters>
<chapters lang="en_US">
<item>Calibration</item>
<item>Camera Parameters</item>
</chapters>
<example lang="en_US">read_cam_par ('campar.dat', CameraParam)
get_cam_par_data (CameraParam, 'sx', Sx) 
get_cam_par_data (CameraParam, 'sy', Sy)
get_cam_par_data (CameraParam, 'cx', Cx) 
get_cam_par_data (CameraParam, 'cy', Cy) 
get_cam_par_data (CameraParam, 'image_width', ImageWidth) 
get_cam_par_data (CameraParam, 'image_height', ImageHeight)
*
set_cam_par_data (CameraParam, 'sx', 2.0*Sx, CameraParam)
set_cam_par_data (CameraParam, 'sy', 2.0*Sy, CameraParam)
set_cam_par_data (CameraParam, 'cx', 0.5*Cx, CameraParam)
set_cam_par_data (CameraParam, 'cy', 0.5*Cy, CameraParam)
set_cam_par_data (CameraParam, 'image_width', 0.5*ImageWidth, CameraParam)
set_cam_par_data (CameraParam, 'image_height', 0.5*ImageHeight, CameraParam)</example>
<keywords lang="de_DE">
<item>Kameraparameter kalibrieren</item>
<item>Kamera-Kalibrierparameter erhalten</item>
<item>Kameramodell</item>
<item>interne Kameraparameter</item>
<item>interne Kameraparameter kalibrieren</item>
<item>kalibrierte interne Kameraparameter erhalten</item>
</keywords>
<keywords lang="en_US">
<item>camera calibration parameters</item>
<item>camera calibration result</item>
<item>calibrate camera parameters</item>
<item>calibrate internal camera parameters</item>
<item>calibrated internal camera parameters</item>
</keywords>
<library lang="en_US">MVTec Standard Procedures</library>
<predecessor>
<item>read_cam_par</item>
<item>deserialize_cam_par</item>
<item>get_calib_data</item>
<item>get_deformable_model_params</item>
<item>get_sheet_of_light_param</item>
<item>get_shape_model_3d_param</item>
</predecessor>
<see_also>
<item>calibrate_cameras</item>
<item>get_cam_par_data</item>
<item>get_cam_par_names</item>
<item>gen_cam_par_area_scan_division</item>
<item>gen_cam_par_area_scan_polynomial</item>
<item>gen_cam_par_area_scan_tilt_division</item>
<item>gen_cam_par_area_scan_tilt_polynomial</item>
<item>gen_cam_par_area_scan_telecentric_division</item>
<item>gen_cam_par_area_scan_telecentric_polynomial</item>
<item>gen_cam_par_area_scan_tilt_bilateral_telecentric_division</item>
<item>gen_cam_par_area_scan_tilt_bilateral_telecentric_polynomial</item>
<item>gen_cam_par_area_scan_tilt_object_side_telecentric_division</item>
<item>gen_cam_par_area_scan_tilt_object_side_telecentric_polynomial</item>
<item>gen_cam_par_area_scan_hypercentric_division</item>
<item>gen_cam_par_area_scan_hypercentric_polynomial</item>
<item>gen_cam_par_line_scan_division</item>
<item>gen_cam_par_line_scan_polynomial</item>
<item>gen_cam_par_line_scan_telecentric_division</item>
<item>gen_cam_par_line_scan_telecentric_polynomial</item>
</see_also>
<short lang="en_US">Set the value of a specified camera parameter in the camera parameter tuple.</short>
<parameters>
<parameter id="CameraParamIn">
<default_type>real</default_type>
<description lang="en_US">Input camera parameter tuple.</description>
<mixed_type>optional</mixed_type>
<sem_type>campar</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
<item>string</item>
</type_list>
</parameter>
<parameter id="CameraParamOut">
<default_type>real</default_type>
<description lang="en_US">Output camera parameter tuple.</description>
<mixed_type>optional</mixed_type>
<multivalue>true</multivalue>
<sem_type>campar</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
<item>string</item>
</type_list>
</parameter>
<parameter id="ParamName">
<default_type>string</default_type>
<default_value>'image_width'</default_value>
<description lang="en_US">Name of the camera parameter for that the value should be set.</description>
<mixed_type>false</mixed_type>
<multivalue>optional</multivalue>
<sem_type>string</sem_type>
<type_list>
<item>string</item>
</type_list>
<value_list>
<item>'focus'</item>
<item>'magnification'</item>
<item>'kappa'</item>
<item>'k1'</item>
<item>'k2'</item>
<item>'k3'</item>
<item>'p1'</item>
<item>'p2'</item>
<item>'image_plane_dist'</item>
<item>'tilt'</item>
<item>'rot'</item>
<item>'sx'</item>
<item>'sy'</item>
<item>'cx'</item>
<item>'cy'</item>
<item>'image_width'</item>
<item>'image_height'</item>
<item>'vx'</item>
<item>'vy'</item>
<item>'vz'</item>
</value_list>
</parameter>
<parameter id="ParamValue">
<default_type>real</default_type>
<description lang="en_US">Value of the camera parameter.</description>
<mixed_type>optional</mixed_type>
<multivalue>optional</multivalue>
<sem_type>real</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
</parameters>
</docu>
</procedure>
<procedure name="set_display_font">
<interface>
<ic>
<par name="WindowHandle" base_type="ctrl" dimension="0"/>
<par name="Size" base_type="ctrl" dimension="0"/>
<par name="Font" base_type="ctrl" dimension="0"/>
<par name="Bold" base_type="ctrl" dimension="0"/>
<par name="Slant" base_type="ctrl" dimension="0"/>
</ic>
</interface>
<body>
<c>* This procedure sets the text font of the current window with</c>
<c>* the specified attributes.</c>
<c>* </c>
<c>* Input parameters:</c>
<c>* WindowHandle: The graphics window for which the font will be set</c>
<c>* Size: The font size. If Size=-1, the default of 16 is used.</c>
<c>* Bold: If set to 'true', a bold font is used</c>
<c>* Slant: If set to 'true', a slanted font is used</c>
<c>* </c>
<l>get_system ('operating_system', OS)</l>
<l>if (Size == [] or Size == -1)</l>
<l>    Size := 16</l>
<l>endif</l>
<l>if (OS{0:2} == 'Win')</l>
<c>    * Restore previous behaviour</c>
<l>    Size := int(1.13677 * Size)</l>
<l>else</l>
<l>    Size := int(Size)</l>
<l>endif</l>
<l>if (Font == 'Courier')</l>
<l>    Fonts := ['Courier','Courier 10 Pitch','Courier New','CourierNew','Liberation Mono']</l>
<l>elseif (Font == 'mono')</l>
<l>    Fonts := ['Consolas','Menlo','Courier','Courier 10 Pitch','FreeMono','Liberation Mono']</l>
<l>elseif (Font == 'sans')</l>
<l>    Fonts := ['Luxi Sans','DejaVu Sans','FreeSans','Arial','Liberation Sans']</l>
<l>elseif (Font == 'serif')</l>
<l>    Fonts := ['Times New Roman','Luxi Serif','DejaVu Serif','FreeSerif','Utopia','Liberation Serif']</l>
<l>else</l>
<l>    Fonts := Font</l>
<l>endif</l>
<l>Style := ''</l>
<l>if (Bold == 'true')</l>
<l>    Style := Style + 'Bold'</l>
<l>elseif (Bold != 'false')</l>
<l>    Exception := 'Wrong value of control parameter Bold'</l>
<l>    throw (Exception)</l>
<l>endif</l>
<l>if (Slant == 'true')</l>
<l>    Style := Style + 'Italic'</l>
<l>elseif (Slant != 'false')</l>
<l>    Exception := 'Wrong value of control parameter Slant'</l>
<l>    throw (Exception)</l>
<l>endif</l>
<l>if (Style == '')</l>
<l>    Style := 'Normal'</l>
<l>endif</l>
<l>query_font (WindowHandle, AvailableFonts)</l>
<l>Font := ''</l>
<l>for Fdx := 0 to |Fonts| - 1 by 1</l>
<l>    Indices := find(AvailableFonts,Fonts[Fdx])</l>
<l>    if (|Indices| &gt; 0)</l>
<l>        if (Indices[0] &gt;= 0)</l>
<l>            Font := Fonts[Fdx]</l>
<l>            break</l>
<l>        endif</l>
<l>    endif</l>
<l>endfor</l>
<l>if (Font == '')</l>
<l>    throw ('Wrong value of control parameter Font')</l>
<l>endif</l>
<l>Font := Font + '-' + Style + '-' + Size</l>
<l>set_font (WindowHandle, Font)</l>
<l>return ()</l>
</body>
<docu id="set_display_font">
<abstract lang="en_US">This procedure sets the text font of the current window with the specified attributes Size, Bold and Slant. 
As font, the font name or one of the strings 'mono', 'sans', 'serif' can be used.</abstract>
<alternatives>
<item>set_font</item>
</alternatives>
<attention lang="en_US">For 'mono', 'sans', and 'serif', it is assumed that at least one of the following fonts is installed on the system:
'mono': 'Consolas', 'Menlo', 'Courier', 'Courier 10 Pitch', 'FreeMono'
'sans': 'Luxi Sans', 'DejaVu Sans', 'FreeSans', 'Arial'
'serif': 'Times New Roman', 'Luxi Serif', 'DejaVu Serif', 'FreeSerif', 'Utopia'</attention>
<chapters>
<item>Graphics</item>
<item>Text</item>
</chapters>
<chapters lang="de_DE">
<item>Graphik</item>
<item>Text</item>
</chapters>
<chapters lang="en_US">
<item>Graphics</item>
<item>Text</item>
</chapters>
<example lang="en_US">dev_open_window_fit_image(Image,0 , 0, 400, 400, WindowHandle)
set_display_font(WindowHandle, 16, 'mono', 'true', 'false')
disp_text (WindowHandle,'Hello World!', 'window', 10, 10, 'black', [], [])
</example>
<keywords lang="de_DE">
<item>Schriftart (Font) setzen</item>
</keywords>
<keywords lang="en_US">
<item>set font</item>
</keywords>
<library lang="de_DE">MVTec Standard Procedures</library>
<library lang="en_US">MVTec Standard Procedures</library>
<predecessor>
<item>dev_open_window</item>
<item>open_window</item>
<item>dev_open_window_fit_image</item>
<item>dev_open_window_fit_size</item>
</predecessor>
<see_also>
<item>set_font</item>
</see_also>
<short>Set font independent of OS</short>
<short lang="de_DE">Set font independent of OS</short>
<short lang="en_US">Set font independent of OS</short>
<successor>
<item>disp_text</item>
<item>disp_continue_message</item>
<item>set_tposition</item>
<item>write_string</item>
</successor>
<parameters>
<parameter id="Bold">
<default_type>string</default_type>
<default_value>'true'</default_value>
<description lang="en_US">If set to 'true', a bold font is used</description>
<multivalue>false</multivalue>
<sem_type>attribute.value</sem_type>
<type_list>
<item>string</item>
</type_list>
<value_list>
<item>'true'</item>
<item>'false'</item>
</value_list>
</parameter>
<parameter id="Font">
<default_type>string</default_type>
<default_value>'mono'</default_value>
<description lang="en_US">The font name. Either 'mono', 'sans',  'serif' or a specific font name can be used. 'mono' will be mapped to 'Courier New' on Windows, to 'courier' on Linux, and to 'Menlo' on OS X. 'sans' will be mapped to 'Arial' on Windows and OS X, and to 'helvetica' on Linux. 'serif' will be mapped to 'Times New Roman' on Windows and OS X, and to 'times' on Linux.
</description>
<multivalue>false</multivalue>
<sem_type>attribute.value</sem_type>
<type_list>
<item>string</item>
</type_list>
<values>
<item>'mono'</item>
<item>'sans'</item>
<item>'serif'</item>
</values>
</parameter>
<parameter id="Size">
<default_type>integer</default_type>
<default_value>16</default_value>
<description lang="en_US">The font size on Windows systems. If Size=-1, the default of 16 is used.
On Linux systems, ALL values are multiplied with 1.25 and then mapped to [11, 14, 17, 20, 25, 34].</description>
<multivalue>false</multivalue>
<sem_type>integer</sem_type>
<type_list>
<item>integer</item>
</type_list>
<values>
<item>[9, 11, 14, 16, 20, 27]</item>
</values>
</parameter>
<parameter id="Slant">
<default_type>string</default_type>
<default_value>'false'</default_value>
<description lang="en_US">If set to 'true', a slanted font is used</description>
<sem_type>attribute.value</sem_type>
<type_list>
<item>string</item>
</type_list>
<value_list>
<item>'true'</item>
<item>'false'</item>
</value_list>
</parameter>
<parameter id="WindowHandle">
<default_type>integer</default_type>
<description lang="en_US">The window handle of the window, where the font will be set</description>
<mixed_type>false</mixed_type>
<sem_type>window</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
</parameters>
</docu>
</procedure>
<procedure name="set_dl_model_param_based_on_preprocessing">
<interface>
<ic>
<par name="DLModelHandle" base_type="ctrl" dimension="0"/>
<par name="DLPreprocessParam" base_type="ctrl" dimension="0"/>
<par name="ClassIDs" base_type="ctrl" dimension="0"/>
</ic>
</interface>
<body>
<c>* </c>
<c>* This procedure sets the model parameters based on preprocessing parameters.</c>
<c>* Thereby, the deep-learning-based model has to be of type segmentation.</c>
<c>* </c>
<l>get_dl_model_param (DLModelHandle, 'type', ModelType)</l>
<c>* </c>
<l>if (ModelType == 'segmentation')</l>
<c>    * Get image dimensions from preprocessing.</c>
<l>    get_dict_tuple (DLPreprocessParam, 'image_width', ImageWidth)</l>
<l>    get_dict_tuple (DLPreprocessParam, 'image_height', ImageHeight)</l>
<l>    get_dict_tuple (DLPreprocessParam, 'image_num_channels', ImageNumChannels)</l>
<c>    * </c>
<c>    * Set the image dimensions in the model.</c>
<l>    set_dl_model_param (DLModelHandle, 'image_width', ImageWidth)</l>
<l>    set_dl_model_param (DLModelHandle, 'image_height', ImageHeight)</l>
<l>    set_dl_model_param (DLModelHandle, 'image_num_channels', ImageNumChannels)</l>
<c>    * </c>
<c>    * Check that image range is the same as in the model.</c>
<l>    get_dict_tuple (DLPreprocessParam, 'image_range_min', ImageRangeMin)</l>
<l>    get_dict_tuple (DLPreprocessParam, 'image_range_max', ImageRangeMax)</l>
<l>    get_dl_model_param (DLModelHandle, 'image_range_min', ImageRangeMinModel)</l>
<l>    get_dl_model_param (DLModelHandle, 'image_range_max', ImageRangeMaxModel)</l>
<l>    if (ImageRangeMin != ImageRangeMinModel or ImageRangeMax != ImageRangeMaxModel)</l>
<l>        throw ('Warning: The preprocessed image range should be equal to the model range.')</l>
<l>    endif</l>
<c>    * </c>
<c>    * Remove all background and ignore class IDs.</c>
<l>    get_dict_tuple (DLPreprocessParam, 'class_ids_background', ClassIDsBackground)</l>
<l>    get_dict_tuple (DLPreprocessParam, 'ignore_class_ids', IgnoreClassIDs)</l>
<l>    RemoveClassIDs := [ClassIDsBackground,IgnoreClassIDs]</l>
<l>    for Index := 0 to |RemoveClassIDs| - 1 by 1</l>
<l>        ClassID := RemoveClassIDs[Index]</l>
<l>        tuple_find_first (ClassIDs, ClassID, IndexFind)</l>
<l>        if (|IndexFind| &gt; 0 and IndexFind != -1)</l>
<l>            tuple_remove (ClassIDs, IndexFind, ClassIDs)</l>
<l>        endif</l>
<l>    endfor</l>
<c>    * Set class IDs.</c>
<l>    set_dl_model_param (DLModelHandle, 'class_ids', ClassIDs)</l>
<c>    * Set ignore class IDs.</c>
<l>    set_dl_model_param (DLModelHandle, 'ignore_class_ids', IgnoreClassIDs)</l>
<l>else</l>
<l>    throw ('Procedure is only applicable for models of type \'segmentation\'.')</l>
<l>endif</l>
<c>* </c>
<l>return ()</l>
</body>
<docu id="set_dl_model_param_based_on_preprocessing">
<abstract lang="en_US">This procedure sets the model parameters based on preprocessing parameters.
Thereby, the deep-learning-based model has to be of type segmentation.</abstract>
<chapters lang="de_DE">
<item>Deep Learning</item>
<item>Modell</item>
</chapters>
<chapters lang="en_US">
<item>Deep Learning</item>
<item>Model</item>
</chapters>
<library lang="en_US">MVTec Standard Procedures</library>
<short lang="en_US">Set the model parameters based on preprocessing parameters.</short>
<parameters>
<parameter id="ClassIDs">
<default_type>integer</default_type>
<description lang="en_US">Class IDs which might be reduced by preprocessing parameters. E.g. if the class ids contain background class ids these are removed before the model class ids are set.</description>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>integer</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="DLModelHandle">
<default_type>integer</default_type>
<description lang="en_US">Handle of the deep-learning-based model, which has to be adapted.</description>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>dl_model</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="DLPreprocessParam">
<default_type>integer</default_type>
<description lang="en_US">Dictionary containing the preprocessing parameters.</description>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>dict</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
</parameters>
</docu>
</procedure>
<procedure name="set_dl_model_param_max_gpu_batch_size">
<interface>
<ic>
<par name="DLModelHandle" base_type="ctrl" dimension="0"/>
<par name="BatchSizeUpperBound" base_type="ctrl" dimension="0"/>
</ic>
</interface>
<body>
<c>* </c>
<c>* This procedure sets the batch size of the deep-learning-based model DLModelHandle</c>
<c>* to the maximum possible value given the current GPU memory.</c>
<c>* </c>
<l>get_dl_model_param (DLModelHandle, 'type', ModelType)</l>
<l>if (ModelType != 'classification' and ModelType != 'detection' and ModelType != 'segmentation')</l>
<l>    throw ('Not implemented. Currently, this procedure only works for ' + 'classification, detection, and segmentation models.')</l>
<l>endif</l>
<c>* Get the current GPU ID.</c>
<l>get_dl_model_param (DLModelHandle, 'runtime', OriginalRuntime)</l>
<l>get_dl_model_param (DLModelHandle, 'gpu', GpuID)</l>
<l>try</l>
<c>    * First we free the GPU memory completely to get a clean model.</c>
<c>    * Note, this only works for hardware where 'cpu' is available.</c>
<l>    set_dl_model_param (DLModelHandle, 'runtime', 'cpu')</l>
<l>    set_dl_model_param (DLModelHandle, 'batch_size', 1)</l>
<c>    * </c>
<c>    * Create a copy which we want to use so that we do not modify the original model.</c>
<l>    serialize_dl_model (DLModelHandle, SerializedItemHandle)</l>
<l>    OriginalModel := DLModelHandle</l>
<l>    deserialize_dl_model (SerializedItemHandle, DLModelHandle)</l>
<l>catch (Exception)</l>
<c>    * In case no CPU hardware is available we try to find maximum batch size</c>
<c>    * directly.</c>
<l>    OriginalModel := []</l>
<l>endtry</l>
<c>* </c>
<c>* Initialize the bounds.</c>
<l>BatchSizeTestL := 1</l>
<l>BatchSizeTestR := BatchSizeUpperBound</l>
<l>BatchSizeTest := BatchSizeUpperBound</l>
<l>try</l>
<c>    * Set initial batch size to 1. This has to work. Otherwise an exception is thrown.</c>
<l>    set_dl_model_param (DLModelHandle, 'batch_size', BatchSizeTestL)</l>
<l>    set_dl_model_param (DLModelHandle, 'gpu', GpuID)</l>
<l>    set_dl_model_param (DLModelHandle, 'runtime', 'gpu')</l>
<l>    set_dl_model_param (DLModelHandle, 'runtime_init', 'immediately')</l>
<l>catch (Exception)</l>
<l>    if (Exception[0] != 4104 and Exception[0] != 4201)</l>
<c>        * Not an out of CUDA memory or cuDNN error. Hence, throw.</c>
<l>        throw (Exception)</l>
<l>    endif</l>
<l>    if (ModelType == 'classification' or ModelType == 'detection' or ModelType == 'segmentation')</l>
<l>        ErrorHint := 'Try to reduce image_dimension or use a GPU with more RAM.'</l>
<l>    else</l>
<l>        ErrorHint := 'Try to use a GPU with more RAM.'</l>
<l>    endif</l>
<l>    throw ('Error while trying to find the maximum batch size. Even the minimum (1) does not fit into memory. ' + ErrorHint)</l>
<l>    return ()</l>
<l>endtry</l>
<c>* </c>
<c>* Loop as long as we have not found the maximum batch size for the available GPU memory.</c>
<l>while (BatchSizeTestR - BatchSizeTestL &gt; 1)</l>
<c>    * </c>
<c>    * Check if an exception is thrown due to out of memory errors.</c>
<l>    ExceptionThrown := false</l>
<l>    try</l>
<c>        * Try to set the batch size.</c>
<l>        set_dl_model_param (DLModelHandle, 'batch_size', BatchSizeTest)</l>
<c>        * </c>
<c>        * Even if the batch size setting works it might be that a train step fails</c>
<c>        * because during training more data is needed.</c>
<c>        * </c>
<c>        * Hence, generate blank train samples here.</c>
<l>        gen_blank_dl_train_samples (DLModelHandle, TrainSamples)</l>
<c>        * </c>
<c>        * Do a few train steps to get the training data initialized.</c>
<l>        train_dl_model_batch (DLModelHandle, TrainSamples, TrainResult)</l>
<l>        train_dl_model_batch (DLModelHandle, TrainSamples, TrainResult)</l>
<l>        train_dl_model_batch (DLModelHandle, TrainSamples, TrainResult)</l>
<l>    catch (Exception)</l>
<l>        if (Exception[0] != 4104 and Exception[0] != 4201)</l>
<c>            * Not an out of CUDA memory or cuDNN error. Hence, throw.</c>
<l>            throw (Exception)</l>
<l>        endif</l>
<c>        * Update the upper bound.</c>
<l>        BatchSizeTestR := BatchSizeTest</l>
<l>        ExceptionThrown := true</l>
<l>    endtry</l>
<l>    if (not ExceptionThrown)</l>
<c>        * Update the lower bound.</c>
<l>        BatchSizeTestL := BatchSizeTest</l>
<l>    endif</l>
<c>    * Continue with next test.</c>
<l>    BatchSizeTest := BatchSizeTestL + (BatchSizeTestR - BatchSizeTestL) / 2</l>
<l>endwhile</l>
<l>BatchSize := BatchSizeTest</l>
<c>* In case we used a copy we clear it.</c>
<l>if (|OriginalModel| &gt; 0)</l>
<l>    clear_dl_model (DLModelHandle)</l>
<c>    * Use the original model again.</c>
<l>    DLModelHandle := OriginalModel</l>
<l>endif</l>
<l>set_dl_model_param (DLModelHandle, 'runtime', OriginalRuntime)</l>
<l>set_dl_model_param (DLModelHandle, 'batch_size', BatchSize)</l>
<l>return ()</l>
</body>
<docu id="set_dl_model_param_max_gpu_batch_size">
<abstract lang="en_US">This procedure calculates and sets the maximum batch size for a given deep-learning-based model by DLModelHandle and a given GPU.

The maximum batch size is found by bisection. Within the procedure, different batch sizes are set and checked for occuring exceptions.

Note, the resulting batch size is suited for training. For inference you might use even higher values because there is less memory needed.</abstract>
<chapters lang="de_DE">
<item>Deep Learning</item>
<item>Modell</item>
</chapters>
<chapters lang="en_US">
<item>Deep Learning</item>
<item>Model</item>
</chapters>
<library lang="en_US">MVTec Standard Procedures</library>
<short lang="en_US">Set the maximum batch size for a given DLModelHandle and GPU.</short>
<parameters>
<parameter id="BatchSizeUpperBound">
<default_type>integer</default_type>
<default_value>100</default_value>
<description lang="en_US">The maximum value to be tested.
</description>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>integer</sem_type>
<type_list>
<item>integer</item>
</type_list>
<value_max>9999</value_max>
<value_min>2</value_min>
</parameter>
<parameter id="DLModelHandle">
<default_type>integer</default_type>
<description lang="en_US">Handle of the deep-learning-based model, for which the maximum batch size is determined.</description>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>dl_model</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
</parameters>
</docu>
</procedure>
<procedure name="set_edge_parameter_sliders" access="local">
<interface>
<ic>
<par name="WindowHandle" base_type="ctrl" dimension="0"/>
<par name="ObjectModel3D" base_type="ctrl" dimension="0"/>
<par name="MessageQueues" base_type="ctrl" dimension="0"/>
<par name="MessageQueueOut" base_type="ctrl" dimension="0"/>
<par name="ModelDiameter" base_type="ctrl" dimension="0"/>
<par name="AmplitudeRange" base_type="ctrl" dimension="0"/>
<par name="MaxGapRange" base_type="ctrl" dimension="0"/>
<par name="Viewpoint" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="MinAmplitude" base_type="ctrl" dimension="0"/>
<par name="MaxGap" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<l>try</l>
<l>    MaxGap := MaxGapRange[2]</l>
<l>    MinAmplitude := AmplitudeRange[2]</l>
<l>    ViewpointStr := sum(Viewpoint + ' ')</l>
<c></c>
<c>    * Open (invisible) buffer window to avoid flickering</c>
<l>    get_window_extents (WindowHandle, Row, Column, Width, Height)</l>
<l>    open_window (0, 0, Width, Height, 0, 'buffer', '', WindowHandleBuffer)</l>
<l>    set_part (WindowHandleBuffer, 0, 0, Height - 1, Width - 1)</l>
<c></c>
<c>    * Estimate a good visualization pose</c>
<l>    estimate_visualization_pose_simple (ObjectModel3D, WindowHandleBuffer, PoseEstimated)</l>
<c></c>
<l>    SliderHeight := 25</l>
<l>    RowSlider1 := Height - 10 - 2 * SliderHeight</l>
<l>    RowSlider2 := Height - 10 - 1 * SliderHeight</l>
<l>    ColSliderLabel := 10</l>
<l>    ColSliderValue := Width - 50</l>
<l>    ColSliderStart := ColSliderLabel + 130</l>
<l>    ColSliderEnd := ColSliderValue - 10</l>
<c></c>
<l>    set_display_font (WindowHandle, 12, 'mono', 'true', 'false')</l>
<l>    set_display_font (WindowHandleBuffer, 12, 'mono', 'true', 'false')</l>
<c></c>
<l>    object_model_3d_to_xyz (X, Y, Z, ObjectModel3D, 'from_xyz_map', [], [])</l>
<l>    get_image_size (X, ImgWidth, ImgHeight)</l>
<l>    Factor := min2((1.0 * Width) / ImgWidth,(1.0 * Height - 10 - 2 * SliderHeight) / ImgHeight)</l>
<l>    zoom_image_factor (Z, ZZoomed, Factor, Factor, 'nearest_neighbor')</l>
<l>    disp_obj (ZZoomed, WindowHandle)</l>
<c></c>
<l>    CurrentSliderActive := []</l>
<c></c>
<l>    try</l>
<l>        while (1)</l>
<l>            edges_object_model_3d (ObjectModel3D, MinAmplitude * ModelDiameter, ['max_gap','viewpoint'], [MaxGap,ViewpointStr], ObjectModel3DEdges)</l>
<c>            * </c>
<l>*             disp_object_model_3d (WindowHandleBuffer, ObjectModel3DEdges, [], PoseEstimated, 'color', 'blue')</l>
<l>            clear_window (WindowHandleBuffer)</l>
<l>            disp_obj (ZZoomed, WindowHandleBuffer)</l>
<l>            set_color (WindowHandleBuffer, 'red')</l>
<l>            object_model_3d_to_xyz (XEdges, YEdges, ZEdges, ObjectModel3DEdges, 'from_xyz_map', [], [])</l>
<l>            get_domain (ZEdges, EdgesDomain)</l>
<l>            zoom_region (EdgesDomain, EdgesDomainZoomed, Factor, Factor)</l>
<l>            dilation_circle (EdgesDomainZoomed, EdgesDomainZoomed, 1.5)</l>
<l>            disp_obj (EdgesDomainZoomed, WindowHandleBuffer)</l>
<c>            * </c>
<c>            * Update the 3D object model with the edges in the 3D visualization window</c>
<l>            create_message (MessageHandle)</l>
<l>            set_message_tuple (MessageHandle, 'type', 'replace_object_model')</l>
<l>            set_message_tuple (MessageHandle, 'index', 1)</l>
<l>            set_message_tuple (MessageHandle, 'model', ObjectModel3DEdges)</l>
<l>            enqueue_message (MessageQueueOut[1], MessageHandle, [], [])</l>
<c>            * </c>
<l>            disp_slider (WindowHandleBuffer, RowSlider1, SliderHeight, ColSliderLabel, ColSliderValue, ColSliderStart, ColSliderEnd, 'MinAmplitudeRel: ', AmplitudeRange[0], AmplitudeRange[1], MinAmplitude, '2.3f')</l>
<l>            disp_slider (WindowHandleBuffer, RowSlider2, SliderHeight, ColSliderLabel, ColSliderValue, ColSliderStart, ColSliderEnd, 'MaxGap: ', MaxGapRange[0], MaxGapRange[1], MaxGap, 'd')</l>
<c>            * </c>
<l>            copy_rectangle (WindowHandleBuffer, WindowHandle, 0, 0, Height - 1, Width - 1, 0, 0)</l>
<c>            * </c>
<l>            ValuesUpdated := false</l>
<l>            while (not ValuesUpdated)</l>
<l>                get_mouse_info (WindowHandle, MessageQueues, 0.01, MouseRow, MouseColumn, MouseButton)</l>
<c>                * </c>
<c>                * Find the slider the mouse is in</c>
<l>                Slider := []</l>
<l>                if (MouseRow &gt; RowSlider1 and MouseRow &lt; RowSlider1 + SliderHeight and MouseColumn &gt;= ColSliderStart and MouseColumn &lt;= ColSliderEnd)</l>
<l>                    Slider := 1</l>
<l>                elseif (MouseRow &gt; RowSlider2 and MouseRow &lt; RowSlider2 + SliderHeight and MouseColumn &gt;= ColSliderStart and MouseColumn &lt;= ColSliderEnd)</l>
<l>                    Slider := 2</l>
<l>                endif</l>
<c>                * </c>
<l>                UpdateSlider := false</l>
<l>                if (MouseButton == 1)</l>
<l>                    if (CurrentSliderActive == [])</l>
<l>                        if (Slider != [])</l>
<c>                            * Clicked into a slider -&gt; start sliding</c>
<l>                            CurrentSliderActive := Slider</l>
<l>                            UpdateSlider := true</l>
<l>                        endif</l>
<l>                    else</l>
<c>                        * Continue sliding the current slider</c>
<l>                        UpdateSlider := true</l>
<l>                    endif</l>
<l>                elseif (MouseButton == 0)</l>
<l>                    if (CurrentSliderActive != [])</l>
<c>                        * mouse button released -&gt; stop sliding</c>
<l>                        CurrentSliderActive := []</l>
<l>                    endif</l>
<l>                endif</l>
<c>                * </c>
<l>                if (UpdateSlider)</l>
<l>                    ValueRel := (MouseColumn - ColSliderStart) / (ColSliderEnd - ColSliderStart)</l>
<l>                    if (ValueRel &lt; 0)</l>
<l>                        ValueRel := 0</l>
<l>                    elseif (ValueRel &gt; 1)</l>
<l>                        ValueRel := 1</l>
<l>                    endif</l>
<c></c>
<l>                    if (1 == CurrentSliderActive)</l>
<l>                        MinAmplitude := AmplitudeRange[0] + ValueRel * (AmplitudeRange[1] - AmplitudeRange[0])</l>
<l>                    elseif (2 == CurrentSliderActive)</l>
<l>                        MaxGap := int(MaxGapRange[0] + ValueRel * (MaxGapRange[1] - MaxGapRange[0]))</l>
<c>                        * rounding might push it out of range</c>
<l>                        if (MaxGap &lt; MaxGapRange[0])</l>
<l>                            MaxGap := MaxGapRange[0]</l>
<l>                        elseif (MaxGap &gt; MaxGapRange[1])</l>
<l>                            MaxGap := MaxGapRange[1]</l>
<l>                        endif</l>
<l>                    endif</l>
<l>                    ValuesUpdated := true</l>
<l>                endif</l>
<c>                * </c>
<l>                try</l>
<l>                    dequeue_message (MessageQueues[1], 'timeout', 0, MessageHandle)</l>
<l>                    get_message_tuple (MessageHandle, 'type', MessageType)</l>
<l>                    if (MessageType == 'exit')</l>
<l>                        return ()</l>
<l>                    else</l>
<l>                        throw (['Unknown message type',MessageType,MessageHandle])</l>
<l>                    endif</l>
<l>                catch (Exception)</l>
<l>                    if (Exception[0] != 9400)</l>
<c>                        * Ignore timeout (no message in queue)</c>
<l>                        throw (Exception)</l>
<l>                    endif</l>
<l>                endtry</l>
<l>            endwhile</l>
<l>        endwhile</l>
<l>    catch (Exception)</l>
<l>        if (Exception[0] == 2454 or Exception[0] == 5100)</l>
<c>            * Handle was already cleared -&gt; indicates that the window was closed (by the user)</c>
<c>            * Abort gracefully.</c>
<l>            return ()</l>
<l>        else</l>
<c>            * Unknown / Unexpected exception</c>
<l>            throw (Exception)</l>
<l>        endif</l>
<l>    endtry</l>
<l>catch (Exception)</l>
<l>    create_message (MessageHandle)</l>
<l>    set_message_tuple (MessageHandle, 'type', 'exception')</l>
<l>    set_message_tuple (MessageHandle, 'exception', Exception)</l>
<l>    enqueue_message (MessageQueues[2], MessageHandle, [], [])</l>
<l>endtry</l>
<l>return ()</l>
</body>
<docu id="set_edge_parameter_sliders">
<chapters lang="en_US">
<item>Graphics</item>
<item>Output</item>
</chapters>
<library lang="en_US">MVTec Standard Procedures</library>
<parameters>
<parameter id="AmplitudeRange"/>
<parameter id="MaxGap"/>
<parameter id="MaxGapRange"/>
<parameter id="MessageQueueOut">
<default_type>integer</default_type>
<mixed_type>false</mixed_type>
<sem_type>message_queue</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="MessageQueues">
<default_type>integer</default_type>
<mixed_type>false</mixed_type>
<sem_type>message_queue</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="MinAmplitude"/>
<parameter id="ModelDiameter"/>
<parameter id="ObjectModel3D">
<default_type>integer</default_type>
<mixed_type>false</mixed_type>
<sem_type>object_model_3d</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="Viewpoint"/>
<parameter id="WindowHandle">
<default_type>integer</default_type>
<mixed_type>false</mixed_type>
<sem_type>window</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
</parameters>
</docu>
</procedure>
<procedure name="set_edge_parameter_sliders_find_box_3d" access="local">
<interface>
<ic>
<par name="WindowHandle" base_type="ctrl" dimension="0"/>
<par name="ObjectModel3DScene" base_type="ctrl" dimension="0"/>
<par name="MessageQueues" base_type="ctrl" dimension="0"/>
<par name="MessageQueueOut" base_type="ctrl" dimension="0"/>
<par name="AmplitudeRange" base_type="ctrl" dimension="0"/>
<par name="MaxGapRange" base_type="ctrl" dimension="0"/>
<par name="Viewpoint" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="MinAmplitude" base_type="ctrl" dimension="0"/>
<par name="MaxGap" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<l>try</l>
<l>    MaxGap := MaxGapRange[2]</l>
<l>    MinAmplitude := AmplitudeRange[2]</l>
<l>    ViewpointStr := sum(Viewpoint + ' ')</l>
<c>    * </c>
<c>    * Open (invisible) buffer window to avoid flickering.</c>
<l>    get_window_extents (WindowHandle, Row, Column, Width, Height)</l>
<l>    open_window (0, 0, Width, Height, 0, 'buffer', '', WindowHandleBuffer)</l>
<l>    set_part (WindowHandleBuffer, 0, 0, Height - 1, Width - 1)</l>
<c>    * </c>
<c>    * Estimate a good visualization pose.</c>
<l>    estimate_visualization_pose_simple (ObjectModel3DScene, WindowHandleBuffer, PoseEstimated)</l>
<c>    * </c>
<l>    SliderHeight := 25</l>
<l>    RowSlider1 := Height - 10 - 2 * SliderHeight</l>
<l>    RowSlider2 := Height - 10 - 1 * SliderHeight</l>
<l>    ColSliderLabel := 10</l>
<l>    ColSliderValue := Width - 50</l>
<l>    ColSliderStart := ColSliderLabel + 130</l>
<l>    ColSliderEnd := ColSliderValue - 10</l>
<c>    * </c>
<l>    set_display_font (WindowHandle, 12, 'mono', 'true', 'false')</l>
<l>    set_display_font (WindowHandleBuffer, 12, 'mono', 'true', 'false')</l>
<c>    * </c>
<l>    object_model_3d_to_xyz (X, Y, Z, ObjectModel3DScene, 'from_xyz_map', [], [])</l>
<l>    get_image_size (X, ImgWidth, ImgHeight)</l>
<l>    Factor := min2((1.0 * Width) / ImgWidth,(1.0 * Height - 10 - 2 * SliderHeight) / ImgHeight)</l>
<l>    zoom_image_factor (Z, ZZoomed, Factor, Factor, 'nearest_neighbor')</l>
<l>    disp_obj (ZZoomed, WindowHandle)</l>
<c>    * </c>
<l>    CurrentSliderActive := []</l>
<l>    try</l>
<l>        while (1)</l>
<l>            edges_object_model_3d (ObjectModel3DScene, MinAmplitude, ['max_gap','viewpoint'], [MaxGap,ViewpointStr], ObjectModel3DEdges)</l>
<c>            * </c>
<l>*             disp_object_model_3d (WindowHandleBuffer, ObjectModel3DEdges, [], PoseEstimated, 'color', 'blue')</l>
<l>            clear_window (WindowHandleBuffer)</l>
<l>            disp_obj (ZZoomed, WindowHandleBuffer)</l>
<l>            set_color (WindowHandleBuffer, 'red')</l>
<l>            object_model_3d_to_xyz (XEdges, YEdges, ZEdges, ObjectModel3DEdges, 'from_xyz_map', [], [])</l>
<l>            get_domain (ZEdges, EdgesDomain)</l>
<l>            zoom_region (EdgesDomain, EdgesDomainZoomed, Factor, Factor)</l>
<l>            dilation_circle (EdgesDomainZoomed, EdgesDomainZoomed, 1.5)</l>
<l>            disp_obj (EdgesDomainZoomed, WindowHandleBuffer)</l>
<c>            * </c>
<c>            * Update the 3D object model with the edges in the 3D visualization window.</c>
<l>            create_message (MessageHandle)</l>
<l>            set_message_tuple (MessageHandle, 'type', 'replace_object_model')</l>
<l>            set_message_tuple (MessageHandle, 'index', 1)</l>
<l>            set_message_tuple (MessageHandle, 'model', ObjectModel3DEdges)</l>
<l>            enqueue_message (MessageQueueOut[1], MessageHandle, [], [])</l>
<c>            * </c>
<l>            disp_slider (WindowHandleBuffer, RowSlider1, SliderHeight, ColSliderLabel, ColSliderValue, ColSliderStart, ColSliderEnd, 'MinAmplitude: ', AmplitudeRange[0], AmplitudeRange[1], MinAmplitude, '2.3f')</l>
<l>            disp_slider (WindowHandleBuffer, RowSlider2, SliderHeight, ColSliderLabel, ColSliderValue, ColSliderStart, ColSliderEnd, 'MaxGap: ', MaxGapRange[0], MaxGapRange[1], MaxGap, 'd')</l>
<c>            * </c>
<l>            copy_rectangle (WindowHandleBuffer, WindowHandle, 0, 0, Height - 1, Width - 1, 0, 0)</l>
<c>            * </c>
<l>            ValuesUpdated := false</l>
<l>            while (not ValuesUpdated)</l>
<l>                get_mouse_info (WindowHandle, MessageQueues, 0.01, MouseRow, MouseColumn, MouseButton)</l>
<c>                * </c>
<c>                * Find the slider the mouse is in.</c>
<l>                Slider := []</l>
<l>                if (MouseRow &gt; RowSlider1 and MouseRow &lt; RowSlider1 + SliderHeight and MouseColumn &gt;= ColSliderStart and MouseColumn &lt;= ColSliderEnd)</l>
<l>                    Slider := 1</l>
<l>                elseif (MouseRow &gt; RowSlider2 and MouseRow &lt; RowSlider2 + SliderHeight and MouseColumn &gt;= ColSliderStart and MouseColumn &lt;= ColSliderEnd)</l>
<l>                    Slider := 2</l>
<l>                endif</l>
<c>                * </c>
<l>                UpdateSlider := false</l>
<l>                if (MouseButton == 1)</l>
<l>                    if (CurrentSliderActive == [])</l>
<l>                        if (Slider != [])</l>
<c>                            * Clicked into a slider -&gt; start sliding.</c>
<l>                            CurrentSliderActive := Slider</l>
<l>                            UpdateSlider := true</l>
<l>                        endif</l>
<l>                    else</l>
<c>                        * Continue sliding the current slider.</c>
<l>                        UpdateSlider := true</l>
<l>                    endif</l>
<l>                elseif (MouseButton == 0)</l>
<l>                    if (CurrentSliderActive != [])</l>
<c>                        * Mouse button released -&gt; stop sliding.</c>
<l>                        CurrentSliderActive := []</l>
<l>                    endif</l>
<l>                endif</l>
<c>                * </c>
<l>                if (UpdateSlider)</l>
<l>                    ValueRel := (MouseColumn - ColSliderStart) / (ColSliderEnd - ColSliderStart)</l>
<l>                    if (ValueRel &lt; 0)</l>
<l>                        ValueRel := 0</l>
<l>                    elseif (ValueRel &gt; 1)</l>
<l>                        ValueRel := 1</l>
<l>                    endif</l>
<c>                    * </c>
<l>                    if (1 == CurrentSliderActive)</l>
<l>                        MinAmplitude := AmplitudeRange[0] + ValueRel * (AmplitudeRange[1] - AmplitudeRange[0])</l>
<l>                    elseif (2 == CurrentSliderActive)</l>
<l>                        MaxGap := int(MaxGapRange[0] + ValueRel * (MaxGapRange[1] - MaxGapRange[0]))</l>
<c>                        * Rounding might push it out of range.</c>
<l>                        if (MaxGap &lt; MaxGapRange[0])</l>
<l>                            MaxGap := MaxGapRange[0]</l>
<l>                        elseif (MaxGap &gt; MaxGapRange[1])</l>
<l>                            MaxGap := MaxGapRange[1]</l>
<l>                        endif</l>
<l>                    endif</l>
<l>                    ValuesUpdated := true</l>
<l>                endif</l>
<c>                * </c>
<l>                try</l>
<l>                    dequeue_message (MessageQueues[1], 'timeout', 0, MessageHandle)</l>
<l>                    get_message_tuple (MessageHandle, 'type', MessageType)</l>
<l>                    if (MessageType == 'exit')</l>
<l>                        return ()</l>
<l>                    else</l>
<l>                        throw (['Unknown message type',MessageType,MessageHandle])</l>
<l>                    endif</l>
<l>                catch (Exception)</l>
<l>                    if (Exception[0] != 9400)</l>
<c>                        * Ignore timeout (no message in queue).</c>
<l>                        throw (Exception)</l>
<l>                    endif</l>
<l>                endtry</l>
<l>            endwhile</l>
<l>        endwhile</l>
<l>    catch (Exception)</l>
<l>        if (Exception[0] == 2454 or Exception[0] == 5100)</l>
<c>            * Handle was already cleared -&gt; indicates that the window was closed (by the user).</c>
<c>            * Abort gracefully.</c>
<l>            return ()</l>
<l>        else</l>
<c>            * Unknown / Unexpected exception.</c>
<l>            throw (Exception)</l>
<l>        endif</l>
<l>    endtry</l>
<l>catch (Exception)</l>
<l>    create_message (MessageHandle)</l>
<l>    set_message_tuple (MessageHandle, 'type', 'exception')</l>
<l>    set_message_tuple (MessageHandle, 'exception', Exception)</l>
<l>    enqueue_message (MessageQueues[2], MessageHandle, [], [])</l>
<l>endtry</l>
<l>return ()</l>
</body>
<docu id="set_edge_parameter_sliders_find_box_3d">
<chapters lang="en_US">
<item>Graphics</item>
<item>Output</item>
</chapters>
<library lang="en_US">MVTec Standard Procedures</library>
<parameters>
<parameter id="AmplitudeRange"/>
<parameter id="MaxGap"/>
<parameter id="MaxGapRange"/>
<parameter id="MessageQueueOut">
<default_type>integer</default_type>
<mixed_type>false</mixed_type>
<sem_type>message_queue</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="MessageQueues">
<default_type>integer</default_type>
<mixed_type>false</mixed_type>
<sem_type>message_queue</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="MinAmplitude"/>
<parameter id="ObjectModel3DScene">
<default_type>handle</default_type>
<description lang="en_US">The scene where the object is to be found, as passed to find_box_3d.</description>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>object_model_3d</sem_type>
<type_list>
<item>handle</item>
</type_list>
</parameter>
<parameter id="Viewpoint"/>
<parameter id="WindowHandle">
<default_type>integer</default_type>
<mixed_type>false</mixed_type>
<sem_type>window</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
</parameters>
</docu>
</procedure>
<procedure name="sort_pairs">
<interface>
<ic>
<par name="T1" base_type="ctrl" dimension="0"/>
<par name="T2" base_type="ctrl" dimension="0"/>
<par name="SortMode" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="Sorted1" base_type="ctrl" dimension="0"/>
<par name="Sorted2" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c>* Sort tuple pairs.</c>
<c>* </c>
<c>* input parameters:</c>
<c>* T1: first tuple</c>
<c>* T2: second tuple</c>
<c>* SortMode: if set to '1', sort by the first tuple,</c>
<c>*    if set to '2', sort by the second tuple</c>
<c>* </c>
<l>if (SortMode == '1' or SortMode == 1)</l>
<l>    tuple_sort_index (T1, Indices1)</l>
<l>    Sorted1 := subset(T1,Indices1)</l>
<l>    Sorted2 := subset(T2,Indices1)</l>
<l>elseif (SortMode == 'column' or SortMode == '2' or SortMode == 2)</l>
<l>    tuple_sort_index (T2, Indices2)</l>
<l>    Sorted1 := subset(T1,Indices2)</l>
<l>    Sorted2 := subset(T2,Indices2)</l>
<l>endif</l>
<l>return ()</l>
</body>
<docu id="sort_pairs">
<abstract lang="en_US">Sort tuple pairs.
This procedure first sorts one of the tuples (which one is specified by the parameter SortMode) in ascending order. The second tuple is then ordered such, that their position in the output tuple is the same as the new position of the value of the first tuple, which had the same index before sorting.
Example:
Tuple1 := [5,4,3,2,1]
Tuple2 := [105,204,303,402,501]
sort_pairs (Tuple1, Tuple2, '1', Sorted1, Sorted2)

returns:
Sorted1 := [1,2,3,4,5]
Sorted2 := [501,402,303,204,105]</abstract>
<alternatives>
<item>tuple_sort</item>
<item>tuple_sort_index</item>
</alternatives>
<attention lang="en_US">Both tuples must have the same length.
If the sorted tuple (T1, if SortMode='1' or T2, if SortMode='2') has more elements than the other, an error will occur. 
If the sorted tuple (T1, if SortMode='1' or T2, if SortMode='2') has less elements than the other, the output tuples will have as many elements as the shorter one of the input tuples.</attention>
<chapters>
<item>Tools</item>
<item>Geometry</item>
</chapters>
<chapters lang="de_DE">
<item>Tools</item>
<item>Geometrie</item>
</chapters>
<chapters lang="en_US">
<item>Tools</item>
<item>Geometry</item>
</chapters>
<example lang="en_US">Tuple1 := [5,4,3,2,1]
Tuple2 := [105,204,303,402,501]
sort_pairs (Tuple1, Tuple2, '1', Sorted1, Sorted2)</example>
<keywords lang="de_DE">
<item>Tupelpaare sortieren</item>
</keywords>
<keywords lang="en_US">
<item>sort tuple pairs</item>
</keywords>
<library lang="de_DE">MVTec Standard Procedures</library>
<library lang="en_US">MVTec Standard Procedures</library>
<see_also>
<item>tuple_sort</item>
<item>tuple_sort_index</item>
</see_also>
<short>Sort tuple pairs.</short>
<short lang="de_DE">Sort tuple pairs.</short>
<short lang="en_US">Sort tuple pairs.</short>
<parameters>
<parameter id="SortMode">
<default_type>string</default_type>
<default_value>'1'</default_value>
<description lang="en_US">If set to '1', sort by the first tuple, if set to '2', sort by the second tuple.
</description>
<multivalue>false</multivalue>
<sem_type>attribute.value</sem_type>
<type_list>
<item>integer</item>
<item>string</item>
</type_list>
<values>
<item>'1'</item>
<item>'2'</item>
</values>
</parameter>
<parameter id="Sorted1">
<default_type>integer</default_type>
<description lang="en_US">The first sorted output tuple (corresponding to the input tuple T1)</description>
<mixed_type>optional</mixed_type>
<multivalue>optional</multivalue>
<sem_type>any</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
<item>string</item>
</type_list>
</parameter>
<parameter id="Sorted2">
<default_type>integer</default_type>
<description lang="en_US">The second sorted output tuple (corresponding to the input tuple T2)</description>
<mixed_type>optional</mixed_type>
<multivalue>optional</multivalue>
<sem_type>any</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
<item>string</item>
</type_list>
</parameter>
<parameter id="T1">
<default_type>integer</default_type>
<description lang="en_US">First input tuple of the pair, which shall be sorted.</description>
<mixed_type>optional</mixed_type>
<multivalue>optional</multivalue>
<sem_type>any</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
<item>string</item>
</type_list>
</parameter>
<parameter id="T2">
<default_type>integer</default_type>
<description lang="en_US">Second input tuple of the pair, which shall be sorted.</description>
<mixed_type>optional</mixed_type>
<sem_type>any</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
<item>string</item>
</type_list>
</parameter>
</parameters>
</docu>
</procedure>
<procedure name="split_dl_classifier_data_set">
<interface>
<ic>
<par name="ImageFiles" base_type="ctrl" dimension="0"/>
<par name="GroundTruthLabels" base_type="ctrl" dimension="0"/>
<par name="TrainingPercent" base_type="ctrl" dimension="0"/>
<par name="ValidationPercent" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="TrainingImages" base_type="ctrl" dimension="0"/>
<par name="TrainingLabels" base_type="ctrl" dimension="0"/>
<par name="ValidationImages" base_type="ctrl" dimension="0"/>
<par name="ValidationLabels" base_type="ctrl" dimension="0"/>
<par name="TestImages" base_type="ctrl" dimension="0"/>
<par name="TestLabels" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c>* This procedure divides the data set (images and ground truth labels)</c>
<c>* into three disjoint subsets: training, validation, and test.</c>
<c>* The number of images and labels in each subset is defined</c>
<c>* by the given percentages TrainingPercent and ValidationPercent.</c>
<c>* Each subset contains randomly distributed data,</c>
<c>* whereby the original ratio of class sizes is kept.</c>
<c>* </c>
<c>* Check the input parameters.</c>
<l>if (|ImageFiles| != |GroundTruthLabels|)</l>
<l>    throw ('Please provide a label for every image file.')</l>
<l>endif</l>
<l>if (TrainingPercent &lt; 0)</l>
<l>    throw ('TrainingPercent must not be smaller than zero.')</l>
<l>endif</l>
<l>if (ValidationPercent &lt; 0)</l>
<l>    throw ('ValidationPercent must not be smaller than zero.')</l>
<l>endif</l>
<l>if (|ImageFiles| &lt; 1)</l>
<l>    throw ('ImageFiles must not be empty.')</l>
<l>endif</l>
<l>if (TrainingPercent + ValidationPercent &gt; 100)</l>
<l>    throw ('The sum of TrainingPercent and ValidationPercent must not be greater than 100.')</l>
<l>endif</l>
<c>* </c>
<c>* Set classes and data ratios.</c>
<l>TrainingRatio := TrainingPercent * 0.01</l>
<l>ValidationRatio := ValidationPercent * 0.01</l>
<c>* </c>
<c>* Prepare output tuples.</c>
<l>TrainingImages := []</l>
<l>TrainingLabels := []</l>
<l>ValidationImages := []</l>
<l>ValidationLabels := []</l>
<l>TestImages := []</l>
<l>TestLabels := []</l>
<c>* </c>
<c>* Loop through all unique classes and add data</c>
<c>* according to the specified percentages.</c>
<l>UniqueClasses := uniq(sort(GroundTruthLabels))</l>
<l>for ClassIndex := 0 to |UniqueClasses| - 1 by 1</l>
<c>    * Select all images and ground truth labels with the class.</c>
<l>    Class := UniqueClasses[ClassIndex]</l>
<l>    ClassIndices := find(GroundTruthLabels,Class)</l>
<l>    ImageFilesClass := ImageFiles[ClassIndices]</l>
<l>    LabelsClass := gen_tuple_const(|ImageFilesClass|,Class)</l>
<c>    * Shuffle the images in this class.</c>
<l>    tuple_shuffle (ImageFilesClass, ImageFilesClass)</l>
<c>    * Determine the boundaries of the respective selection.</c>
<l>    IndexTrainingEnd := int(floor(|ImageFilesClass| * TrainingRatio)) - 1</l>
<l>    IndexValidationEnd := int(floor(|ImageFilesClass| * (ValidationRatio + TrainingRatio))) - 1</l>
<c>    * Add the respective images and labels.</c>
<l>    TrainingImages := [TrainingImages,ImageFilesClass[0:IndexTrainingEnd]]</l>
<l>    TrainingLabels := [TrainingLabels,LabelsClass[0:IndexTrainingEnd]]</l>
<l>    ValidationImages := [ValidationImages,ImageFilesClass[IndexTrainingEnd + 1:IndexValidationEnd]]</l>
<l>    ValidationLabels := [ValidationLabels,LabelsClass[IndexTrainingEnd + 1:IndexValidationEnd]]</l>
<l>    TestImages := [TestImages,ImageFilesClass[IndexValidationEnd + 1:|ImageFilesClass| - 1]]</l>
<l>    TestLabels := [TestLabels,LabelsClass[IndexValidationEnd + 1:|ImageFilesClass| - 1]]</l>
<l>endfor</l>
<c>* </c>
<c>* Shuffle the output.</c>
<l>tuple_shuffle ([0:|TrainingImages| - 1], TrainingSequence)</l>
<l>TrainingImages := TrainingImages[TrainingSequence]</l>
<l>TrainingLabels := TrainingLabels[TrainingSequence]</l>
<l>tuple_shuffle ([0:|ValidationImages| - 1], ValidationSequence)</l>
<l>ValidationImages := ValidationImages[ValidationSequence]</l>
<l>ValidationLabels := ValidationLabels[ValidationSequence]</l>
<l>tuple_shuffle ([0:|TestImages| - 1], TestSequence)</l>
<l>TestImages := TestImages[TestSequence]</l>
<l>TestLabels := TestLabels[TestSequence]</l>
<l>return ()</l>
</body>
<docu id="split_dl_classifier_data_set">
<abstract lang="en_US">split_dl_classifier_data_set divides the input data set (input images and ground truth labels) into three different subsets: training, validation, and test set. The number of images in each subset is defined by the given percentages TrainingPercent and ValidationPercent. Each subset contains randomly distributed data, whereby the original ratio of class sizes is kept.

TrainingPercent and ValidationPercent determine the percentage of the respective images and labels in the corresponding subsets, with a number between 0 and 100. The remaining data constitute the test set. The sum of TrainingPercent and ValidationPercent must not be greater than 100. Note that the actual percentages that are achieved can differ depending on the number of images and the number of images per class.</abstract>
<chapters lang="en_US">
<item>Legacy</item>
<item>DL Classification</item>
</chapters>
<example lang="en_US">read_dl_classifier_data_set ('3d_machine_vision', 'last_folder', ImageFiles, GroundTruthLabels, UniqueClasses)
TrainingPercent := 60
ValidationPercent := 20
split_dl_classifier_data_set (ImageFiles, GroundTruthLabels, TrainingPercent, ValidationPercent, TrainingImages, TrainingLabels, ValidationImages, ValidationLabels, TestImages, TestLabels)</example>
<library lang="en_US">MVTec Standard Procedures</library>
<short lang="en_US">Split and shuffle the images and ground truth labels into training, validation and test subsets.</short>
<warning lang="en_US">split_dl_classifier_data_set is obsolete and is only provided for reasons of backward compatibility.
New applications should use the general CNN-based procedure split_dl_dataset.</warning>
<parameters>
<parameter id="GroundTruthLabels">
<default_type>string</default_type>
<description lang="en_US">Ground truth labels of the images.</description>
<sem_type>string</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
<item>string</item>
</type_list>
</parameter>
<parameter id="ImageFiles">
<default_type>string</default_type>
<description lang="en_US">Tuple of the image paths.</description>
<mixed_type>false</mixed_type>
<sem_type>filename.dir</sem_type>
<type_list>
<item>string</item>
</type_list>
</parameter>
<parameter id="TestImages">
<default_type>string</default_type>
<description lang="en_US">The images for testing.</description>
<mixed_type>false</mixed_type>
<multivalue>optional</multivalue>
<sem_type>filename.dir</sem_type>
<type_list>
<item>string</item>
</type_list>
</parameter>
<parameter id="TestLabels">
<default_type>string</default_type>
<description lang="en_US">The ground truth labels of the test images.</description>
<sem_type>string</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
<item>string</item>
</type_list>
</parameter>
<parameter id="TrainingImages">
<default_type>string</default_type>
<description lang="en_US">The images for training.</description>
<mixed_type>false</mixed_type>
<multivalue>optional</multivalue>
<sem_type>filename.dir</sem_type>
<type_list>
<item>string</item>
</type_list>
</parameter>
<parameter id="TrainingLabels">
<default_type>string</default_type>
<description lang="en_US">The ground truth labels of the training images.</description>
<multivalue>optional</multivalue>
<sem_type>string</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
<item>string</item>
</type_list>
</parameter>
<parameter id="TrainingPercent">
<default_type>integer</default_type>
<description lang="en_US">Percentage of the data that should be used for training.</description>
<multivalue>false</multivalue>
<sem_type>integer</sem_type>
<type_list>
<item>integer</item>
</type_list>
<value_max>100</value_max>
<value_min>0.000000000</value_min>
</parameter>
<parameter id="ValidationImages">
<default_type>string</default_type>
<description lang="en_US">The images for validation.</description>
<mixed_type>false</mixed_type>
<multivalue>optional</multivalue>
<sem_type>filename.dir</sem_type>
<type_list>
<item>string</item>
</type_list>
</parameter>
<parameter id="ValidationLabels">
<default_type>string</default_type>
<description lang="en_US">The ground truth labels of the validation images.</description>
<sem_type>string</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
<item>string</item>
</type_list>
</parameter>
<parameter id="ValidationPercent">
<default_type>integer</default_type>
<description lang="en_US">Percentage of the data that should be used for validation.</description>
<multivalue>false</multivalue>
<sem_type>integer</sem_type>
<type_list>
<item>integer</item>
</type_list>
<value_max>100</value_max>
<value_min>0.000000000</value_min>
</parameter>
</parameters>
</docu>
</procedure>
<procedure name="split_dl_dataset">
<interface>
<ic>
<par name="DLDataset" base_type="ctrl" dimension="0"/>
<par name="TrainingPercent" base_type="ctrl" dimension="0"/>
<par name="ValidationPercent" base_type="ctrl" dimension="0"/>
<par name="GenParam" base_type="ctrl" dimension="0"/>
</ic>
</interface>
<body>
<c>* </c>
<c>* This procedure divides the samples in DLDataset</c>
<c>* into three disjoint subsets: train, validation, and test.</c>
<c>* The number of samples in each subset is defined</c>
<c>* by the given percentages TrainingPercent and ValidationPercent.</c>
<c>* As a result, every sample has a new key named 'split'</c>
<c>* with an associated value 'train', 'validation', or 'test'.</c>
<c>* Thereby the classes of every image are taken</c>
<c>* into consideration, in order to avoid accidental predominance</c>
<c>* of certain classes in one of the subsets. In the case of a</c>
<c>* dataset used for anomaly detection, all images of type 'nok'</c>
<c>* are sorted into the 'test' split.</c>
<c>* </c>
<c>* Check input data.</c>
<l>if (TrainingPercent &lt; 0)</l>
<l>    throw ('TrainingPercent must not be smaller than zero.')</l>
<l>endif</l>
<l>if (ValidationPercent &lt; 0)</l>
<l>    throw ('ValidationPercent must not be smaller than zero.')</l>
<l>endif</l>
<l>if (TrainingPercent + ValidationPercent &gt; 100)</l>
<l>    throw ('The sum of TrainingPercent and ValidationPercent must not be greater than 100.')</l>
<l>endif</l>
<c>* </c>
<c>* ** Set the default values ***</c>
<c>* </c>
<c>* Overwrite an existing split?</c>
<l>OverwriteSplit := false</l>
<c>* Initialize model_type of the DLDataset.</c>
<l>ModelType := ''</l>
<c>* Names for split subsets.</c>
<l>SplitNames := ['train','validation','test']</l>
<c>* </c>
<c>* Get input for generic parameters.</c>
<l>if (GenParam != [])</l>
<l>    get_dict_param (GenParam, 'keys', [], GenParamName)</l>
<l>    for GenParamIndex := 0 to |GenParamName| - 1 by 1</l>
<l>        if (GenParamName[GenParamIndex] == 'overwrite_split')</l>
<l>            get_dict_tuple (GenParam, 'overwrite_split', OverwriteSplit)</l>
<l>            Type := type(OverwriteSplit)</l>
<l>            if (Type == 4 and OverwriteSplit == 'true')</l>
<l>                OverwriteSplit := true</l>
<l>            endif</l>
<l>            if (Type == 4 and OverwriteSplit == 'false')</l>
<l>                OverwriteSplit := false</l>
<l>            endif</l>
<l>        elseif (GenParamName[GenParamIndex] == 'model_type')</l>
<l>            get_dict_tuple (GenParam, 'model_type', ModelType)</l>
<l>        else</l>
<l>            throw ('Unknown GenParam entry: ' + GenParamName[GenParamIndex])</l>
<l>        endif</l>
<l>    endfor</l>
<l>endif</l>
<c>* </c>
<c>* Try to guess the ModelType if not set by GenParam.</c>
<l>if (ModelType == '')</l>
<l>    get_dict_tuple (DLDataset, 'samples', DLSamples)</l>
<l>    DLSample := DLSamples[0]</l>
<c>    * Check for relevant keys.</c>
<l>    get_dict_param (DLSample, 'key_exists', 'anomaly_label', AnomalyDetectionLabelExists)</l>
<l>    get_dict_param (DLSample, 'key_exists', 'bbox_label_id', BBoxLabelIdExists)</l>
<l>    get_dict_param (DLSample, 'key_exists', 'image_label_id', ImageLabelIdExists)</l>
<l>    get_dict_param (DLSample, 'key_exists', 'segmentation_file_name', SegmFileExists)</l>
<c>    * </c>
<l>    if (AnomalyDetectionLabelExists)</l>
<l>        ModelType := 'anomaly_detection'</l>
<l>    elseif (ImageLabelIdExists)</l>
<l>        ModelType := 'classification'</l>
<l>    elseif (BBoxLabelIdExists)</l>
<l>        ModelType := 'detection'</l>
<l>    elseif (SegmFileExists)</l>
<l>        ModelType := 'segmentation'</l>
<l>    else</l>
<l>        throw ('Parameter \'model_type\' cannot be determined.')</l>
<l>    endif</l>
<l>endif</l>
<c>* </c>
<c>* Get data from DLDataset.</c>
<l>if (ModelType != 'anomaly_detection')</l>
<l>    get_dict_tuple (DLDataset, 'class_ids', ClassIDs)</l>
<l>    get_dict_tuple (DLDataset, 'class_names', ClassNames)</l>
<l>else</l>
<l>    ClassIDs := [0,1]</l>
<l>    ClassNames := ['ok','nok']</l>
<l>endif</l>
<l>ClassIDToClassIndex := gen_tuple_const(max(ClassIDs) + 1,-1)</l>
<l>ClassIDToClassIndex[ClassIDs] := [0:|ClassIDs| - 1]</l>
<c>* </c>
<c>* Calculate ratios of training and validation datasets.</c>
<l>TrainingRatio := TrainingPercent * 0.01</l>
<l>ValidationRatio := ValidationPercent * 0.01</l>
<l>SplitRatios := [TrainingRatio,ValidationRatio,1.0 - TrainingRatio - ValidationRatio]</l>
<l>SplitRatiosInvSortIndices := inverse(sort_index(SplitRatios))</l>
<c>* </c>
<c>* Test whether the dataset is already split.</c>
<l>SplitKeys := []</l>
<l>for IndexSample := 0 to |DLSamples| - 1 by 1</l>
<l>    get_dict_param (DLSamples[IndexSample], 'key_exists', 'split', SplitExists)</l>
<l>    if (SplitExists)</l>
<l>        get_dict_tuple (DLSamples[IndexSample], 'split', SampleSplit)</l>
<l>        SplitKeys := [SplitKeys,SampleSplit]</l>
<l>    endif</l>
<l>endfor</l>
<l>NotYetSplit := SplitKeys == []</l>
<c>* </c>
<c>* Split the dataset if no split is present</c>
<c>* or split should be overwritten.</c>
<l>if (NotYetSplit or OverwriteSplit)</l>
<c>    * </c>
<c>    * Initialize a dictionary to collect the IDs</c>
<c>    * of images that contain the class.</c>
<l>    create_dict (ImageIDsPerClass)</l>
<l>    for ClassIndex := 0 to |ClassNames| - 1 by 1</l>
<l>        set_dict_tuple (ImageIDsPerClass, ClassNames[ClassIndex], [])</l>
<l>    endfor</l>
<c>    * </c>
<c>    * Get labels of every sample image</c>
<c>    * and count how many images per class there are.</c>
<c>    * </c>
<l>    NumImagesPerClass := gen_tuple_const(|ClassIDs|,0)</l>
<l>    ImageIDList := []</l>
<l>    for IndexSample := 0 to |DLSamples| - 1 by 1</l>
<l>        DLSample := DLSamples[IndexSample]</l>
<l>        get_dict_tuple (DLSample, 'image_id', ImageID)</l>
<l>        ImageIDList := [ImageIDList,ImageID]</l>
<l>        if (ModelType == 'anomaly_detection')</l>
<c>            * Get labels - anomaly detection.</c>
<l>            get_dict_tuple (DLSample, 'anomaly_label', AnomalyLabel)</l>
<l>            Labels := AnomalyLabel != 'ok'</l>
<l>        elseif (ModelType == 'classification')</l>
<c>            * Get labels - classification.</c>
<l>            get_dict_tuple (DLSample, 'image_label_id', ImageLabelID)</l>
<l>            Labels := ImageLabelID</l>
<l>        elseif (ModelType == 'detection')</l>
<c>            * Get labels - object detection.</c>
<l>            get_dict_tuple (DLSample, 'bbox_label_id', BboxLabels)</l>
<l>            Labels := uniq(sort(BboxLabels))</l>
<l>        elseif (ModelType == 'segmentation')</l>
<c>            * Get labels - semantic segmentation.</c>
<l>            get_dict_tuple (DLDataset, 'segmentation_dir', SegmDir)</l>
<l>            get_dict_tuple (DLSample, 'segmentation_file_name', SegmFileName)</l>
<l>            read_image (SegmImage, SegmDir + '/' + SegmFileName)</l>
<c>            * </c>
<l>            gray_histo_abs (SegmImage, SegmImage, 1, AbsoluteHisto)</l>
<l>            Labels := find(AbsoluteHisto [&gt;] 0,1)</l>
<l>        endif</l>
<c>        * </c>
<c>        * Add up images per class.</c>
<l>        LabelIndices := ClassIDToClassIndex[Labels]</l>
<l>        NumImagesPerClass[LabelIndices] := NumImagesPerClass[LabelIndices] + 1</l>
<l>        for Index := 0 to |Labels| - 1 by 1</l>
<c>            * Add ImageIDs to ImageIDsPerClass.</c>
<l>            ClassIndex := LabelIndices[Index]</l>
<l>            get_dict_tuple (ImageIDsPerClass, ClassNames[ClassIndex], ImgIDsClass)</l>
<l>            ImgIDsClass := [ImgIDsClass,ImageID]</l>
<l>            set_dict_tuple (ImageIDsPerClass, ClassNames[ClassIndex], ImgIDsClass)</l>
<l>        endfor</l>
<l>    endfor</l>
<c>    * </c>
<c>    * ** Start splitting. ***</c>
<c>    * </c>
<c>    * Create a dictionary where the ImageIDs</c>
<c>    * for the three subsets are saved.</c>
<l>    create_dict (SplitImageIDs)</l>
<l>    for Index := 0 to |SplitNames| - 1 by 1</l>
<l>        set_dict_tuple (SplitImageIDs, SplitNames[Index], [])</l>
<l>    endfor</l>
<c>    * We split based on classes,</c>
<c>    * starting with the smallest class.</c>
<l>    AssignedImageIDs := []</l>
<l>    ClassSortIndices := sort_index(NumImagesPerClass)</l>
<l>    for ClassIndex := 0 to |NumImagesPerClass| - 1 by 1</l>
<c>        * Get all ImageIDs where this class is present.</c>
<l>        get_dict_tuple (ImageIDsPerClass, ClassNames[ClassSortIndices[ClassIndex]], ImageIDsClass)</l>
<l>        ImageIDsClass := uniq(ImageIDsClass)</l>
<c>        * Remove ImageIDs that have already been assigned.</c>
<l>        ImageIDsClassToBeAssigned := difference(ImageIDsClass,AssignedImageIDs)</l>
<l>        tuple_shuffle (ImageIDsClassToBeAssigned, ImageIDsClassToBeAssigned)</l>
<c>        * </c>
<l>        for SplitIndex := 0 to |SplitNames| - 1 by 1</l>
<c>            * Check how many of the IDs have already been assigned</c>
<c>            * and how many should be assigned.</c>
<l>            if (ModelType == 'anomaly_detection' and ClassNames[ClassSortIndices[ClassIndex]] == 'nok')</l>
<c>                * All 'nok' images for anomaly detection are sorted into the test set.</c>
<l>                if (SplitNames[SplitIndex] == 'test')</l>
<l>                    NumToBeAssignedToThisSplit := |ImageIDsClass|</l>
<l>                else</l>
<l>                    NumToBeAssignedToThisSplit := 0</l>
<l>                endif</l>
<l>            else</l>
<l>                NumToBeAssignedToThisSplit := int(floor(SplitRatios[SplitIndex] * |ImageIDsClass|))</l>
<l>            endif</l>
<l>            get_dict_tuple (SplitImageIDs, SplitNames[SplitIndex], AssignedImageIDsToThisSplit)</l>
<l>            NumAlreadyAssignedToThisSplit := |intersection(ImageIDsClass,AssignedImageIDsToThisSplit)|</l>
<l>            NumStillToBeAssigned := NumToBeAssignedToThisSplit - NumAlreadyAssignedToThisSplit</l>
<c>            * </c>
<l>            if (NumStillToBeAssigned &gt; 0)</l>
<l>                if (NumStillToBeAssigned &gt; |ImageIDsClassToBeAssigned|)</l>
<l>                    NumStillToBeAssigned := |ImageIDsClassToBeAssigned|</l>
<l>                endif</l>
<l>                AssignedImageIDsToThisSplit := [AssignedImageIDsToThisSplit,ImageIDsClassToBeAssigned[0:NumStillToBeAssigned - 1]]</l>
<l>                set_dict_tuple (SplitImageIDs, SplitNames[SplitIndex], AssignedImageIDsToThisSplit)</l>
<c>                * Update the remaining ImageIDs of this class.</c>
<l>                ImageIDsClassToBeAssigned := ImageIDsClassToBeAssigned[NumStillToBeAssigned:|ImageIDsClassToBeAssigned| - 1]</l>
<l>            endif</l>
<l>        endfor</l>
<c>        * The remaining ImageIDs are assigned to random subsets</c>
<c>        * according to the defined ratios.</c>
<l>        if (|ImageIDsClassToBeAssigned| &gt; 0)</l>
<l>            for ImageIndex := 0 to |ImageIDsClassToBeAssigned| - 1 by 1</l>
<l>                Rand := rand(1)</l>
<l>                for RatioIndex := 0 to |SplitRatios| - 1 by 1</l>
<l>                    CurrentSplitIndex := SplitRatiosInvSortIndices[RatioIndex]</l>
<l>                    CurrentSplitRatio := SplitRatios[CurrentSplitIndex]</l>
<l>                    if (Rand &lt;= CurrentSplitRatio)</l>
<l>                        get_dict_tuple (SplitImageIDs, SplitNames[CurrentSplitIndex], AssignedImageIDsToThisSplit)</l>
<l>                        AssignedImageIDsToThisSplit := [AssignedImageIDsToThisSplit,ImageIDsClassToBeAssigned[ImageIndex]]</l>
<l>                        set_dict_tuple (SplitImageIDs, SplitNames[CurrentSplitIndex], AssignedImageIDsToThisSplit)</l>
<l>                        break</l>
<l>                    else</l>
<l>                        Rand := Rand - CurrentSplitRatio</l>
<l>                    endif</l>
<l>                endfor</l>
<l>            endfor</l>
<l>        endif</l>
<l>        AssignedImageIDs := sort(uniq([AssignedImageIDs,ImageIDsClass]))</l>
<l>    endfor</l>
<c>    * </c>
<c>    * There might be images not having any labels:</c>
<c>    * Assign them based on the ratio.</c>
<l>    ImageIDsWithoutLabel := difference(ImageIDList,AssignedImageIDs)</l>
<l>    NumImageIDsWithoutLabel := |ImageIDsWithoutLabel|</l>
<l>    if (NumImageIDsWithoutLabel &gt; 0)</l>
<l>        tuple_shuffle (ImageIDsWithoutLabel, ImageIDsWithoutLabel)</l>
<l>        for Index := 0 to |SplitRatios| - 1 by 1</l>
<l>            NumToBeAssigned := int(SplitRatios[Index] * NumImageIDsWithoutLabel)</l>
<l>            get_dict_tuple (SplitImageIDs, SplitNames[Index], AssignedImageIDsToThisSplit)</l>
<l>            AssignedImageIDsToThisSplit := [AssignedImageIDsToThisSplit,ImageIDsWithoutLabel[0:NumToBeAssigned - 1]]</l>
<l>            set_dict_tuple (SplitImageIDs, SplitNames[Index], sort(AssignedImageIDsToThisSplit))</l>
<l>            ImageIDsWithoutLabel := ImageIDsWithoutLabel[NumToBeAssigned:|ImageIDsWithoutLabel| - 1]</l>
<l>        endfor</l>
<c>        * If there are still ImageIDs, assign them to split with highest ratio.</c>
<l>        MaxRatioIndex := find(SplitRatiosInvSortIndices,0)</l>
<l>        if (|ImageIDsWithoutLabel| &gt; 0)</l>
<l>            get_dict_tuple (SplitImageIDs, SplitNames[MaxRatioIndex], AssignedImageIDsToThisSplit)</l>
<l>            AssignedImageIDsToThisSplit := [AssignedImageIDsToThisSplit,ImageIDsWithoutLabel]</l>
<l>            set_dict_tuple (SplitImageIDs, SplitNames[MaxRatioIndex], sort(AssignedImageIDsToThisSplit))</l>
<l>        endif</l>
<l>    endif</l>
<c>    * </c>
<c>    * Assign 'split' entries to samples.</c>
<l>    for SplitNameIndex := 0 to |SplitNames| - 1 by 1</l>
<l>        SplitName := SplitNames[SplitNameIndex]</l>
<l>        get_dict_tuple (SplitImageIDs, SplitName, SplitIDs)</l>
<l>        for SplitIDIndex := 0 to |SplitIDs| - 1 by 1</l>
<l>            SampleSplitIDs := SplitIDs[SplitIDIndex]</l>
<l>            DLSampleIndex := find(ImageIDList,SampleSplitIDs)</l>
<l>            set_dict_tuple (DLSamples[DLSampleIndex], 'split', SplitName)</l>
<l>        endfor</l>
<l>    endfor</l>
<l>else</l>
<l>    ErrorDict := 'The dataset is already split. You can overwrite the existing split using the generic parameter \'overwrite_split\'.'</l>
<l>    throw (ErrorDict)</l>
<l>endif</l>
<l>return ()</l>
</body>
<docu id="split_dl_dataset">
<abstract lang="en_US">This procedure divides the samples in DLDataset into three disjoint subsets: train, validation, and test.
The number of samples in each subset is defined by the given percentages TrainingPercent and ValidationPercent.
As a result, every sample has a new entry with the key named 'split' and its value 'train', 'validation', or 'test'.

Splitting the dataset, the classes of every image are taken into consideration, to avoid random predominant occurrence of certain classes in one of the subsets. Please note that this might lead to small deviations from the given TrainingPercent and ValidationPercent values in the resulting split. In the case of a dataset used for anomaly detection, all images of type 'nok' are sorted into the 'test' split. The images of type  'ok' are sorted into the three splits according to the given percentages.

The procedure returns a warning if samples already contain a 'split' key. This can be overwritten using GenParam.

GenParam is a dictionary, which can have the following keys:
- 'overwrite_split': If a split key is present in the samples, overwrite it instead of returning a warning. The default value is 'false'.
- 'model_type': Specify whether the Dataset is for classification, object detection, segmentation, or anomaly detection. By default, the model type is guessed depending on the possible presence of certain keys in the DLDataset ('segmentation_dir' for segmentation and sample keys 'bbox_label_id', 'image_label_id' and 'anomaly_label' for detection, classification, and anomaly detection, respectively).</abstract>
<chapters lang="de_DE">
<item>Deep Learning</item>
<item>Modell</item>
</chapters>
<chapters lang="en_US">
<item>Deep Learning</item>
<item>Model</item>
</chapters>
<library lang="en_US">MVTec Standard Procedures</library>
<short lang="en_US">Split the samples into training, validation, and test subsets.</short>
<parameters>
<parameter id="DLDataset">
<default_type>integer</default_type>
<description lang="en_US">Dictionary containing information about the dataset.</description>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>dict</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="GenParam">
<default_type>integer</default_type>
<default_value>[]</default_value>
<description lang="en_US">The dictionary GenParam is used to specify non-default split parameters.</description>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>any</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="TrainingPercent">
<default_type>integer</default_type>
<default_value>60</default_value>
<description lang="en_US">Percentage of samples which are assigned to the training dataset.</description>
<multivalue>false</multivalue>
<sem_type>integer</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
<value_max>100.000000</value_max>
<value_min>0.000000</value_min>
</parameter>
<parameter id="ValidationPercent">
<default_type>integer</default_type>
<default_value>20</default_value>
<description lang="en_US">Percentage of samples which are assigned to the validation dataset.</description>
<sem_type>integer</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
<value_max>100.000000</value_max>
<value_min>0.000000</value_min>
</parameter>
</parameters>
</docu>
</procedure>
<procedure name="structured_light_camera_screen_sync">
<interface>
<oo>
<par name="CameraImages" base_type="iconic" dimension="0"/>
</oo>
<ic>
<par name="AcqHandle" base_type="ctrl" dimension="0"/>
<par name="WindowHandle" base_type="ctrl" dimension="0"/>
<par name="WindowWidth" base_type="ctrl" dimension="0"/>
<par name="WindowHeight" base_type="ctrl" dimension="0"/>
<par name="WaitSeconds" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="ImagesPerSecond" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c>* This procedure helps to establish a synchonization between</c>
<c>* the screen and the camera in a particular structured light setup.</c>
<c>* An in-sync setup ensures accurate camera images that are captured</c>
<c>* at exactly the right time.</c>
<c>* These camera images show exactly one pattern image</c>
<c>* each, rather than overlapping pattern images. If on the other</c>
<c>* hand the camera and screen are not in sync, the captured camera</c>
<c>* images will show overlap between two pattern images.</c>
<c>* </c>
<c>* Define the number of loops for the acquisition.</c>
<l>NumLoops := 10</l>
<c>* Generate test images:</c>
<c>* Vertical stripe image.</c>
<l>gen_image_const (VerticalStripes, 'byte', WindowWidth, WindowHeight)</l>
<l>get_domain (VerticalStripes, ScreenDomain)</l>
<l>get_region_points (ScreenDomain, ScrRows, ScrColumns)</l>
<l>set_grayval (VerticalStripes, ScrRows, ScrColumns, ((ScrColumns / 80) % 2) * 255)</l>
<c>* Horizontal stripe image.</c>
<l>gen_image_const (HorizontalStripes, 'byte', WindowWidth, WindowHeight)</l>
<l>set_grayval (HorizontalStripes, ScrRows, ScrColumns, ((ScrRows / 80) % 2) * 255)</l>
<c>* </c>
<l>gen_empty_obj (CameraImages)</l>
<l>count_seconds (Begin)</l>
<l>for Index := 1 to NumLoops by 1</l>
<c>    * Display the vertical stripes image.</c>
<l>    disp_image (VerticalStripes, WindowHandle)</l>
<c>    * Wait the specified time before acquiring the camera image.</c>
<l>    wait_seconds (WaitSeconds)</l>
<l>    grab_image (Image, AcqHandle)</l>
<c>    * Add the acquired vertical image to the output.</c>
<l>    concat_obj (CameraImages, Image, CameraImages)</l>
<c>    * </c>
<c>    * Display the horizontal stripe image.</c>
<l>    disp_image (HorizontalStripes, WindowHandle)</l>
<c>    * Wait the specified time before acquiring the camera image.</c>
<l>    wait_seconds (WaitSeconds)</l>
<l>    grab_image (Image, AcqHandle)</l>
<c>    * Add the acquired horizontal image to the output.</c>
<l>    concat_obj (CameraImages, Image, CameraImages)</l>
<l>endfor</l>
<l>count_seconds (End)</l>
<c>* </c>
<c>* Acquisition time and acquired images per second.</c>
<l>Time := End - Begin</l>
<l>ImagesPerSecond := 2 * NumLoops / Time</l>
<c>* </c>
<l>return ()</l>
</body>
<docu id="structured_light_camera_screen_sync">
<abstract lang="en_US">This procedure helps to establish a synchonization between the screen and the camera in a particular structured light setup.

For an explanation of the concept of structured light and its supported applications, see the introduction of chapter Inspection / Structured Light. 

In a structured light setup, achieving a synchronization between the screen and the camera is of particular importance. On the one hand, the fastest possible acquisition is usually needed to speed-up the inspection process. On the other hand, a very fast acquisition might lead to overlapping images that result in a wrong inspection result. In other words, if the screen shows alternating pattern images and the camera is triggered to acquire the image too soon, the screen will still be displaying parts of the old image and the acquired camera image will show an overlap of two pattern images. Accordingly, a short pause is needed to ensure that the pattern image is fully displayed before acquiring the new camera image. This pause is defined here as the input parameter WaitSeconds.

To call this procedure, please position the camera in front of the screen in a way that a large part of the screen is seen in the acquired images. Alternatively, you can observe the reflection of the screen in a planar mirror.

The input parameter AcqHandle is the frame grabber used to acquire the images.

The input parameter WindowHandle is the handle of the graphics window on the screen where the pattern images will be displayed. The input parameters WindowWidth and WindowHeight, respectively, are the width and height of the window displaying the pattern images.

The input parameter WaitSeconds specifies the length of the pause (in seconds) to be tested. The optimal value for WaitSeconds has to be found by trial and error.

The output parameter ImagesPerSecond returns the achieved rate, i.e. the number of images acquired per second, in this particular setup for the specified parameter value WaitSeconds.

The output object CameraImages returns the camera images acquired of alternating vertical and horizontal pattern images, with an interval of WaitSeconds between displaying a pattern image and acquiring the camera image.

To find the optimal WaitSeconds, it is recommended to try steadily smaller values, whereby the output CameraImages have to be visually examined for each tested WaitSeconds. If all camera images show exactly one pattern image with correct orientation and without any transition stripes in the other direction, then the tried WaitSeconds is still OK. In this case, a smaller WaitSeconds can be tried out, until the shortest WaitSeconds is found. If, however, an overlap between vertical and horizontal patter images is seen, the tried WaitSeconds is too small and thus not acceptable. This is repeated until you find the shortest acceptable interval WaitSeconds.</abstract>
<chapters lang="en_US">
<item>Inspection</item>
<item>Structured Light</item>
</chapters>
<library lang="en_US">MVTec Standard Procedures</library>
<short lang="en_US">Acquire images for the synchronization between the screen and the camera in a structured light setup.</short>
<parameters>
<parameter id="AcqHandle">
<default_type>integer</default_type>
<description lang="en_US">Handle of the opened image acquisition device to be used in the procedure to acquire the test images.</description>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>framegrabber</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="CameraImages">
<description lang="en_US">Array containing the camera images of alternating pattern images, acquired at the WaitSeconds intervals.</description>
<multichannel>false</multichannel>
<multivalue>true</multivalue>
<sem_type>image</sem_type>
<type_list>
<item>byte</item>
<item>uint2</item>
</type_list>
</parameter>
<parameter id="ImagesPerSecond">
<default_type>integer</default_type>
<description lang="en_US">Achieved rate of acquired images per second.</description>
<sem_type>number</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
<parameter id="WaitSeconds">
<default_type>real</default_type>
<default_value>0.1</default_value>
<description lang="en_US">Waiting time in seconds between displaying a pattern image on the screen and acquiring the camera image.</description>
<sem_type>real</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
<parameter id="WindowHandle">
<default_type>integer</default_type>
<description lang="en_US">Handle of the window in which the alternating pattern images will be displayed.</description>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>window</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="WindowHeight">
<default_type>integer</default_type>
<default_value>1200</default_value>
<description lang="en_US">Height of the window in which the alternating pattern images will be displayed.</description>
<multivalue>false</multivalue>
<sem_type>integer</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="WindowWidth">
<default_type>integer</default_type>
<default_value>1600</default_value>
<description lang="en_US">Width of the window in which the alternating pattern images will be displayed.</description>
<multivalue>false</multivalue>
<sem_type>integer</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
</parameters>
</docu>
</procedure>
<procedure name="structured_light_inspect_segmentation">
<interface>
<io>
<par name="CameraImages" base_type="iconic" dimension="0"/>
<par name="BinarizedImages" base_type="iconic" dimension="0"/>
</io>
<ic>
<par name="WindowHandle" base_type="ctrl" dimension="0"/>
</ic>
</interface>
<body>
<c>* This procedure helps to validate the decoded bright/dark areas</c>
<c>* in the Gray code images of a structured light model, in comparison</c>
<c>* to the bright/dark areas in the camera images.</c>
<c>* </c>
<c>* The procedure can be thus used to find a suitable value for the</c>
<c>* parameter min_gray_difference. Please note that being unable to</c>
<c>* find a suitable value indicates that the actual decoding was wrong</c>
<c>* since the decision whether a pixel is bright or dark was often</c>
<c>* incorrect. In that sense, the procedure can also be used to decide</c>
<c>* whether the surface is partially specular and the pattern_type</c>
<c>* 'single_stripe' should be used.</c>
<c>* </c>
<l>dev_set_window (WindowHandle)</l>
<c>* Check that CameraImages and BinarizedImages have equal lengths.</c>
<l>count_obj (CameraImages, NumCamera)</l>
<l>count_obj (BinarizedImages, NumBinarized)</l>
<l>if (NumCamera != NumBinarized)</l>
<l>    throw ('CameraImages and BinarizedImages do not have equal lengths.')</l>
<l>endif</l>
<c>* </c>
<c>* Visualize the decoded bright region(s) on each camera image.</c>
<l>for Index := 1 to NumCamera by 1</l>
<l>    select_obj (CameraImages, CamImage, Index)</l>
<l>    select_obj (BinarizedImages, BinImage, Index)</l>
<c>    * The bright region in the binarized image is that with gray</c>
<c>    * value = 255.</c>
<l>    threshold (BinImage, BrightRegion, 254, 255)</l>
<l>    dev_clear_window ()</l>
<l>    dev_display (CamImage)</l>
<l>    dev_set_draw ('fill')</l>
<l>    dev_set_color ('#ff000010')</l>
<l>    dev_display (BrightRegion)</l>
<l>    dev_set_draw ('margin')</l>
<l>    dev_set_line_width (1)</l>
<l>    dev_set_color ('#ff0000')</l>
<l>    dev_display (BrightRegion)</l>
<c>    * If the decoded bright region does not match the visible bright</c>
<c>    * areas on the camera image, try calling the procedure after</c>
<c>    * decoding with a different min_gray_difference value.</c>
<c>    * If no appropriate min_gray_difference value can be found, the</c>
<c>    * actual decode might be incorrect and not the segmentation.</c>
<c>    * In that case, the surface might be partially specular and</c>
<c>    * decoding with the pattern_type 'single_stripe' might correct</c>
<c>    * this effect.</c>
<l>    stop ()</l>
<l>endfor</l>
<l>return ()</l>
</body>
<docu id="structured_light_inspect_segmentation">
<abstract lang="en_US">This procedure helps to visually inspect the Gray code images of a structured light model.

For an explanation of the concept of structured light and its supported applications, see the introduction of chapter Inspection / Structured Light.

Calling this procedure for multiple values for the parameter min_gray_difference helps to quickly find the optimal value. If, however, no suitable value can be found, this is an indication that the decoding is incorrect. This might be caused by decoding partially specular surfaces with the default pattern_type. In this sense, the procedure can be also used to decide whether decoding with the pattern type 'single_stripe' is better for the particular surface.

The input parameter CameraImages contains the images acquired by the camera only for the Gray code pattern images. Other pattern images (e.g. phase shift) should be thus excluded before calling the procedure.

The input parameter BinarizedImages contains the binarized images corresponding to the Gray code images passed in CameraImages. If CameraImages and BinarizedImages have different lengths, the procedure throws an exception.

The input parameter WindowHandle is the handle to the window where the bright region should be visualized.

This procedure returns no output, but rather visualizes the decoded bright region on the CameraImages, one at a time.</abstract>
<chapters lang="en_US">
<item>Inspection</item>
<item>Structured Light</item>
</chapters>
<library lang="en_US">MVTec Standard Procedures</library>
<short lang="en_US">Visually inspect the Gray code images of a structured light model.</short>
<parameters>
<parameter id="BinarizedImages">
<description lang="en_US">Array containing the corresponding binarized images of the CameraImages.</description>
<multichannel>false</multichannel>
<multivalue>optional</multivalue>
<sem_type>image</sem_type>
<type_list>
<item>byte</item>
</type_list>
</parameter>
<parameter id="CameraImages">
<description lang="en_US">Array containing the camera images of the Gray code pattern images only.</description>
<multichannel>false</multichannel>
<multivalue>optional</multivalue>
<sem_type>image</sem_type>
<type_list>
<item>byte</item>
<item>uint2</item>
</type_list>
</parameter>
<parameter id="WindowHandle">
<default_type>integer</default_type>
<description lang="en_US">Handle of the window in which the decoded bright regions will be visualized.</description>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>window</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
</parameters>
</docu>
</procedure>
<procedure name="test_features">
<interface>
<ic>
<par name="FeatureNames" base_type="ctrl" dimension="0"/>
</ic>
</interface>
<body>
<c>* </c>
<c>* Test procedure for custom features</c>
<c>* </c>
<c>* This procedure can be used to test, if custom features</c>
<c>* implemented in get_custom_features comply with the</c>
<c>* specifications of the calculate_feature_set library.</c>
<c>* </c>
<c>* In particular, the feature vector Feature, that is</c>
<c>* calculated with calculate_feature must fulfil</c>
<c>* following conditions:</c>
<c>* </c>
<c>* - For a single input region the result of</c>
<c>*   get_feature_length has to be equal to the length</c>
<c>*   of the featue vector: |Feature| == Length</c>
<c>* </c>
<c>* - For an empty input region array, the feature</c>
<c>*   vector has to be empty:</c>
<c>*   Feature == []</c>
<c>* </c>
<c>* - For input region arrays with multiple regions, the</c>
<c>*   following condition must be met:</c>
<c>*   |Feature| == NumRegions * Length</c>
<c>* </c>
<c>* - Additionally, the feature vector has to be sorted</c>
<c>*   according to the 'feature_column' order of</c>
<c>*   add_sample_class_train_data.</c>
<c>* </c>
<l>TestSuccessful := false</l>
<l>read_image (Image, 'patras')</l>
<l>threshold (Image, Region, 128, 255)</l>
<l>get_feature_lengths (FeatureNames, Lengths)</l>
<c>* </c>
<l>TestString[0] := 'Empty region array test (no region)'</l>
<l>TestString[1] := 'Empty region test'</l>
<l>TestString[2] := 'Single region test'</l>
<l>for Test := 0 to 2 by 1</l>
<l>    switch (Test)</l>
<l>    case 0:</l>
<l>        select_shape (Region, TestRegion, 'area', 'and', 0, 0)</l>
<l>        break</l>
<l>    case 1:</l>
<l>        gen_empty_region (TestRegion)</l>
<l>        break</l>
<l>    case 2:</l>
<l>        copy_obj (Region, TestRegion, 1, 1)</l>
<l>        break</l>
<l>    default:</l>
<l>    endswitch</l>
<l>    count_obj (TestRegion, NumRegions)</l>
<l>    AllFeatures := []</l>
<l>    for Index := 0 to |FeatureNames| - 1 by 1</l>
<l>        CurName := FeatureNames[Index]</l>
<l>        CurLength := Lengths[Index]</l>
<l>        calculate_features (TestRegion, Image, CurName, Features)</l>
<l>        if (NumRegions * CurLength != |Features|)</l>
<l>            throw (TestString[Test] + ' failed for feature \'' + CurName + '\'')</l>
<l>        endif</l>
<l>        AllFeatures := [AllFeatures,Features]</l>
<l>    endfor</l>
<l>    SumLengths := sum(Lengths)</l>
<l>    Total := SumLengths * NumRegions</l>
<l>    if (Total != |AllFeatures|)</l>
<l>        throw (['Test ' + Test + ' failed',TestString[Test]])</l>
<l>    endif</l>
<l>endfor</l>
<c>* </c>
<c>* Test multiple input regions</c>
<l>connection (Region, TestRegion)</l>
<l>select_obj (TestRegion, TestRegionSelected, [1:3])</l>
<l>for I := 0 to |FeatureNames| - 1 by 1</l>
<l>    CurName := FeatureNames[I]</l>
<l>    calculate_features (TestRegionSelected, Image, CurName, Features1)</l>
<l>    Features2 := []</l>
<l>    count_obj (TestRegionSelected, NumRegions)</l>
<l>    for J := 1 to NumRegions by 1</l>
<l>        select_obj (TestRegionSelected, ObjectSelected, J)</l>
<l>        calculate_features (ObjectSelected, Image, CurName, Features)</l>
<l>        Features2 := [Features2,Features]</l>
<l>    endfor</l>
<l>    CorrectOrder := Features1 == Features2</l>
<l>    if (not CorrectOrder)</l>
<l>        throw ('Multiple region test failed for feature \'' + CurName + '\'')</l>
<l>    endif</l>
<l>endfor</l>
<l>TestSuccessful := true</l>
<l>return ()</l>
</body>
<docu id="test_features">
<abstract lang="en_US">This procedure can be used to test, if custom features implemented in get_custom_features comply with the specifications of the calculate_feature_set library.

In particular, the feature vector Feature, that is calculated with calculate_feature must fulfil following conditions:

- For a single input region the result of get_feature_length has to be equal to the length of the featue vector: |Feature| == Length

- For an empty input region array, the feature vector has to be empty:   Feature == []

- For input region arrays with multiple regions, the following condition must be met: |Feature| == NumRegions * Length
 
- Additionally, the feature vector has to be sorted according to the 'feature_column' order of  add_sample_class_train_data.</abstract>
<chapters lang="de_DE">
<item>Klassifikation</item>
<item>Sonstiges</item>
</chapters>
<chapters lang="en_US">
<item>Classification</item>
<item>Misc</item>
</chapters>
<library lang="en_US">MVTec Standard Procedures</library>
<short lang="en_US">Test procedure for custom features.</short>
<parameters>
<parameter id="FeatureNames">
<default_type>string</default_type>
<description lang="en_US">Feature names.</description>
<mixed_type>false</mixed_type>
<multivalue>optional</multivalue>
<sem_type>string</sem_type>
<type_list>
<item>string</item>
</type_list>
</parameter>
</parameters>
</docu>
</procedure>
<procedure name="threshold_dl_anomaly_results">
<interface>
<ic>
<par name="AnomalySegmentationThreshold" base_type="ctrl" dimension="0"/>
<par name="AnomalyClassificationThreshold" base_type="ctrl" dimension="0"/>
<par name="DLResults" base_type="ctrl" dimension="0"/>
</ic>
</interface>
<body>
<c>* This procedure applies given thresholds on anomaly detection results.</c>
<c>* The thresholds are used for:</c>
<c>* </c>
<c>* 1. Region segmentation: AnomalySegmentationThreshold is used as threshold</c>
<c>* whether a pixel within the anomaly image belongs to a region of an anomaly.</c>
<c>* The region is returned in DLResult under the key 'anomaly_region'.</c>
<c>* 2. Image classification: AnomalyClassificationThreshold is used as threshold</c>
<c>* whether the image is classified as containing an anomaly ('nok' / class_id: 1) or not ('ok' / class_id: 0).</c>
<c>* The class is returned in DLResult under the keys 'anomaly_class' and 'anomaly_class_id'.</c>
<c>* </c>
<c>* The applied thresholds are also stored in DLResult.</c>
<c>* </c>
<c>* Check for invalid AnomalySegmentationThreshold.</c>
<l>if (|AnomalySegmentationThreshold| != 1)</l>
<l>    throw ('AnomalySegmentationThreshold must be specified by exactly one value.')</l>
<l>endif</l>
<c>* </c>
<l>if (AnomalySegmentationThreshold &lt; 0.0 or AnomalySegmentationThreshold &gt; 1.0)</l>
<l>    throw ('AnomalySegmentationThreshold must be in the interval [0.0, 1.0].')</l>
<l>endif</l>
<c>* </c>
<c>* Check for invalid AnomalyClassificationThreshold.</c>
<l>if (|AnomalyClassificationThreshold| != 1)</l>
<l>    throw ('AnomalyClassificationThreshold must be specified by exactly one value.')</l>
<l>endif</l>
<c>* </c>
<l>if (AnomalyClassificationThreshold &lt; 0.0)</l>
<l>    throw ('AnomalyClassificationThreshold cannot be negative.')</l>
<l>endif</l>
<c>* </c>
<c>* Evaluate each DLResult.</c>
<l>for DLResultIndex := 0 to |DLResults| - 1 by 1</l>
<c>    * </c>
<c>    * Read anomaly image and anomaly score from DLResult.</c>
<l>    DLResult := DLResults[DLResultIndex]</l>
<l>    get_dict_param (DLResult, 'key_exists', 'anomaly_image', AnomalyImageExists)</l>
<l>    get_dict_param (DLResult, 'key_exists', 'anomaly_score', AnomalyScoreExists)</l>
<l>    if (not AnomalyImageExists or not AnomalyScoreExists)</l>
<l>        throw ('DLResult must contain keys \'anomaly_image\' and \'anomaly_score\'.')</l>
<l>    endif</l>
<c>    * </c>
<l>    read_dict_object (AnomalyImage, DLResult, 'anomaly_image')</l>
<l>    read_dict_tuple (DLResult, 'anomaly_score', AnomalyScore)</l>
<c>    * </c>
<c>    * Apply AnomalyThreshold to the anomaly image.</c>
<l>    threshold (AnomalyImage, AnomalyRegion, AnomalySegmentationThreshold, 1.0)</l>
<c>    * </c>
<c>    * Write AnomalyRegion to DLResult.</c>
<l>    set_dict_object (AnomalyRegion, DLResult, 'anomaly_region')</l>
<c>    * </c>
<c>    * Classify sample as 'ok' or 'nok'.</c>
<l>    if (AnomalyScore &lt; AnomalyClassificationThreshold)</l>
<l>        set_dict_tuple (DLResult, 'anomaly_class', 'ok')</l>
<l>        set_dict_tuple (DLResult, 'anomaly_class_id', 0)</l>
<l>    else</l>
<l>        set_dict_tuple (DLResult, 'anomaly_class', 'nok')</l>
<l>        set_dict_tuple (DLResult, 'anomaly_class_id', 1)</l>
<l>    endif</l>
<c>    * </c>
<c>    * Write anomaly thresholds to DLResult.</c>
<l>    set_dict_tuple (DLResult, 'anomaly_classification_threshold', AnomalyClassificationThreshold)</l>
<l>    set_dict_tuple (DLResult, 'anomaly_segmentation_threshold', AnomalySegmentationThreshold)</l>
<l>endfor</l>
<c>* </c>
<l>return ()</l>
</body>
<docu id="threshold_dl_anomaly_results">
<abstract lang="en_US">This procedure applies given thresholds on a tuple of anomaly detection results given in DLResults.

AnomalySegmentationThreshold is used for region segmentation,
as a threshold whether a pixel within the anomaly image belongs to a region of an anomaly.
The region is returned in DLResult under the key 'anomaly_region'.
The threshold used to create the anomaly region is stored in DLResult under the key 'anomaly_segmentation_threshold'.

AnomalyClassificationThreshold is used for image classification, as threshold
whether the image is classified as containing an anomaly ('nok') or not ('ok').
The class is returned in DLResult under the keys 'anomaly_class' and 'anomaly_class_id'.
The key 'anomaly_class' contains the classification result as a string ('ok' or 'nok').
The key 'anomaly_class_id' contains the classification result as an integer (0 or 1).
The threshold used for anomaly classification is stored in DLResult under the key 'anomaly_classification_threshold'.</abstract>
<chapters lang="en_US">
<item>Deep Learning</item>
<item>Anomaly Detection</item>
</chapters>
<library lang="en_US">MVTec Standard Procedures</library>
<short lang="en_US">Apply the given thresholds on anomaly detection results for image classification and region segmentation.</short>
<parameters>
<parameter id="AnomalyClassificationThreshold">
<description lang="en_US">Threshold used to classify the images as containing an anomaly or not.</description>
</parameter>
<parameter id="AnomalySegmentationThreshold">
<description lang="en_US">Threshold to segment possible anomaly regions.</description>
</parameter>
<parameter id="DLResults">
<description lang="en_US">Tuple of dictionaries with the results for the samples, into which the anomaly region and anomaly class will be written.</description>
</parameter>
</parameters>
</docu>
</procedure>
<procedure name="timespan_string">
<interface>
<ic>
<par name="TotalSeconds" base_type="ctrl" dimension="0"/>
<par name="Format" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="TimeString" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c>* </c>
<c>* This procedure creates a readable representation of a time span</c>
<c>* given the elapsed time in seconds.</c>
<c>* </c>
<c>* Ensure that the input is an integer.</c>
<l>TotalSeconds := int(TotalSeconds)</l>
<c>* </c>
<l>Seconds := TotalSeconds % 60</l>
<c>* </c>
<l>TotalMinutes := TotalSeconds / 60</l>
<l>Minutes := TotalMinutes % 60</l>
<c>* </c>
<l>TotalHours := TotalSeconds / 3600</l>
<l>Hours := TotalHours % 24</l>
<c>* </c>
<l>Days := TotalSeconds / 86400</l>
<c>* </c>
<l>if (Format == 'auto')</l>
<c>    * Print the highest non-zero unit and all remaining sub-units.</c>
<l>    if (Days &gt; 0)</l>
<l>        TimeString := Days$'d' + 'd ' + Hours$'d' + 'h ' + Minutes$'d' + 'm ' + Seconds$'d' + 's'</l>
<l>    elseif (Hours &gt; 0)</l>
<l>        TimeString := Hours$'d' + 'h ' + Minutes$'d' + 'm ' + Seconds$'d' + 's'</l>
<l>    elseif (Minutes &gt; 0)</l>
<l>        TimeString := Minutes$'d' + 'm ' + Seconds$'d' + 's'</l>
<l>    else</l>
<l>        TimeString := Seconds$'d' + 's'</l>
<l>    endif</l>
<l>elseif (Format == 'top1')</l>
<c>    * Print the highest non-zero unit.</c>
<l>    if (Days &gt; 0)</l>
<l>        TimeString := Days$'d' + 'd'</l>
<l>    elseif (Hours &gt; 0)</l>
<l>        TimeString := Hours$'d' + 'h'</l>
<l>    elseif (Minutes &gt; 0)</l>
<l>        TimeString := Minutes$'d' + 'm'</l>
<l>    else</l>
<l>        TimeString := Seconds$'d' + 's'</l>
<l>    endif</l>
<l>elseif (Format == 'top2')</l>
<c>    * Print the highest non-zero unit and the following sub-unit.</c>
<l>    if (Days &gt; 0)</l>
<l>        TimeString := Days$'d' + 'd ' + Hours$'d' + 'h'</l>
<l>    elseif (Hours &gt; 0)</l>
<l>        TimeString := Hours$'d' + 'h ' + Minutes$'d' + 'm'</l>
<l>    elseif (Minutes &gt; 0)</l>
<l>        TimeString := Minutes$'d' + 'm ' + Seconds$'d' + 's'</l>
<l>    else</l>
<l>        TimeString := Seconds$'d' + 's'</l>
<l>    endif</l>
<l>elseif (Format == 'dhms')</l>
<c>    * Print a Days-Hours-Minutes-Seconds string.</c>
<l>    TimeString := Days$'d' + 'd ' + Hours$'d' + 'h ' + Minutes$'d' + 'm ' + Seconds$'d' + 's'</l>
<l>elseif (Format == 'hms')</l>
<c>    * Print a Hours-Minutes-Seconds string, where hours can be &gt;= 24.</c>
<l>    TimeString := TotalHours$'d' + 'h ' + Minutes$'d' + 'm ' + Seconds$'d' + 's'</l>
<l>else</l>
<l>    throw ('Unknown format string.')</l>
<l>endif</l>
<c>* </c>
<l>return ()</l>
</body>
<docu id="timespan_string">
<abstract lang="en_US">This procedure creates a readable representation of a time span given the elapsed time in seconds.
The 'Format' parameter determines the format of the output string. There are the following options:
- 'auto' prints the highest non-zero unit and all remaining sub-units.
- 'top1' prints the highest non-zero unit.
- 'top2' prints the highest non-zero unit and the following sub-unit.
- 'dhms' prints a Days-Hours-Minutes-Seconds string.
- 'hms' prints a Hours-Minutes-Seconds string, where hours can be &gt;= 24.</abstract>
<chapters lang="en_US">
<item>Time</item>
</chapters>
<library lang="en_US">MVTec Standard Procedures</library>
<short lang="en_US">Create a formatted string of a time span.</short>
<parameters>
<parameter id="Format">
<default_type>string</default_type>
<default_value>auto</default_value>
<description lang="en_US">The format of the resulting time string.</description>
<sem_type>string</sem_type>
<type_list>
<item>string</item>
</type_list>
<values>
<item>auto</item>
<item>top1</item>
<item>top2</item>
<item>dhms</item>
<item>hms</item>
</values>
</parameter>
<parameter id="TimeString">
<default_type>string</default_type>
<description lang="en_US">The formatted time string.</description>
<sem_type>string</sem_type>
<type_list>
<item>string</item>
</type_list>
</parameter>
<parameter id="TotalSeconds">
<default_type>integer</default_type>
<description lang="en_US">Time span in seconds.</description>
<sem_type>number</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
</parameters>
</docu>
</procedure>
<procedure name="trackball" access="local">
<interface>
<ic>
<par name="MX1" base_type="ctrl" dimension="0"/>
<par name="MY1" base_type="ctrl" dimension="0"/>
<par name="MX2" base_type="ctrl" dimension="0"/>
<par name="MY2" base_type="ctrl" dimension="0"/>
<par name="VirtualTrackball" base_type="ctrl" dimension="0"/>
<par name="TrackballSize" base_type="ctrl" dimension="0"/>
<par name="SensFactor" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="QuatRotation" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c>* </c>
<c>* Compute the 3D rotation from the mouse movement</c>
<c>* </c>
<l>if (MX1 == MX2 and MY1 == MY2)</l>
<l>    QuatRotation := [1,0,0,0]</l>
<l>    return ()</l>
<l>endif</l>
<c>* Project the image point onto the trackball</c>
<l>project_point_on_trackball (MX1, MY1, VirtualTrackball, TrackballSize, P1)</l>
<l>project_point_on_trackball (MX2, MY2, VirtualTrackball, TrackballSize, P2)</l>
<c>* The cross product of the projected points defines the rotation axis</c>
<l>tuple_vector_cross_product (P1, P2, RotAxis)</l>
<c>* Compute the rotation angle</c>
<l>D := P2 - P1</l>
<l>T := sqrt(sum(D * D)) / (2.0 * TrackballSize)</l>
<l>if (T &gt; 1.0)</l>
<l>    T := 1.0</l>
<l>endif</l>
<l>if (T &lt; -1.0)</l>
<l>    T := -1.0</l>
<l>endif</l>
<l>RotAngle := 2.0 * asin(T) * SensFactor</l>
<l>Len := sqrt(sum(RotAxis * RotAxis))</l>
<l>if (Len &gt; 0.0)</l>
<l>    RotAxis := RotAxis / Len</l>
<l>endif</l>
<l>axis_angle_to_quat (RotAxis[0], RotAxis[1], RotAxis[2], RotAngle, QuatRotation)</l>
<l>return ()</l>
</body>
<docu id="trackball">
<chapters lang="de_DE">
<item>Graphik</item>
<item>Ausgabe</item>
</chapters>
<chapters lang="en_US">
<item>Graphics</item>
<item>Output</item>
</chapters>
<library lang="en_US">MVTec Standard Procedures</library>
<short lang="en_US">Compute the 3D rotation from the mouse movement</short>
<parameters>
<parameter id="MX1"/>
<parameter id="MX2"/>
<parameter id="MY1"/>
<parameter id="MY2"/>
<parameter id="QuatRotation"/>
<parameter id="SensFactor"/>
<parameter id="TrackballSize"/>
<parameter id="VirtualTrackball"/>
</parameters>
</docu>
</procedure>
<procedure name="train_dl_model">
<interface>
<ic>
<par name="DLDataset" base_type="ctrl" dimension="0"/>
<par name="DLModelHandle" base_type="ctrl" dimension="0"/>
<par name="TrainParam" base_type="ctrl" dimension="0"/>
<par name="StartEpoch" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="TrainResults" base_type="ctrl" dimension="0"/>
<par name="TrainInfos" base_type="ctrl" dimension="0"/>
<par name="EvaluationInfos" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c>* </c>
<c>* This procedure contains all steps for training a model given through DLModelHandle</c>
<c>* on a dataset DLDataset.</c>
<c>* The required training parameters are provided through the dictionary TrainParam,</c>
<c>* which can be created by create_dl_train_param.</c>
<c>* The training is started at StartEpoch, which allows resuming the training of a model.</c>
<c>* In case of models of type 'anomaly_detection', training cannot be resumed and hence,</c>
<c>* StartEpoch is always 0.</c>
<c>* </c>
<c>* The procedure returns three dictionaries:</c>
<c>* - TrainResults: Collected results returned by train_dl_model_batch of every iteration.</c>
<c>*                 For models of type 'anomaly_detection': The final error and the final epoch.</c>
<c>* - TrainInfo: Collected information of the training progress. This dictionary is empty</c>
<c>*              for models of type 'anomaly_detection'.</c>
<c>* - EvaluationInfos: Evaluation results collected during training. This dictionary is empty</c>
<c>*                    for models of type 'anomaly_detection'.</c>
<c>* </c>
<c>* Get the model type.</c>
<l>get_dl_model_param (DLModelHandle, 'type', ModelType)</l>
<l>if (ModelType != 'classification' and ModelType != 'detection' and ModelType != 'segmentation' and ModelType != 'anomaly_detection')</l>
<l>    throw ('Invalid model type')</l>
<l>endif</l>
<c>* </c>
<c>* Get the samples for training.</c>
<l>get_dict_tuple (DLDataset, 'samples', DLSamples)</l>
<l>find_dl_samples (DLSamples, 'split', 'train', 'match', TrainSampleIndices)</l>
<l>NumTrainSamples := |TrainSampleIndices|</l>
<c>* </c>
<c>* Check inconsistent training parameters.</c>
<l>check_train_dl_model_params (DLDataset, DLModelHandle, NumTrainSamples, StartEpoch, TrainParam)</l>
<c>* </c>
<c>* </c>
<l>if (ModelType == 'classification' or ModelType == 'detection' or ModelType == 'segmentation')</l>
<c>    * </c>
<c>    * Set random seed according to parameter value.</c>
<l>    get_dict_tuple (TrainParam, 'seed_rand', SeedRand)</l>
<l>    if (|SeedRand| &gt; 0)</l>
<c>        * Note, that setting this random seed will not enforce every training to</c>
<c>        * result in the exact same model because the cuDNN library uses approximate</c>
<c>        * algorithms on some architectures.</c>
<c>        * If you want to enforce bit-wise reproducibility, you should also set:</c>
<c>        *    'set_system('cudnn_deterministic', 'true')'</c>
<c>        * However, this can slow down computations on some architectures.</c>
<l>        set_system ('seed_rand', SeedRand)</l>
<l>    endif</l>
<c>    * </c>
<c>    * Generate a random sample index for the whole training independent of batch size.</c>
<l>    get_dict_tuple (TrainParam, 'num_epochs', NumEpochs)</l>
<l>    SampleIndicesTrainRaw := []</l>
<l>    for Index := 0 to ceil(NumEpochs) - 1 by 1</l>
<l>        tuple_shuffle (TrainSampleIndices, Shuffled)</l>
<l>        SampleIndicesTrainRaw := [SampleIndicesTrainRaw,Shuffled]</l>
<l>    endfor</l>
<c>    * </c>
<c>    * Generate a random seed pool for the whole training independent of batch size.</c>
<l>    SampleSeedsTrainRaw := int((pow(2,31) - 1) * rand(|SampleIndicesTrainRaw|))</l>
<c>    * </c>
<c>    * Initialize the variables for the training.</c>
<c>    * </c>
<c>    * Initialize the batch size with an invalid value so that</c>
<c>    * the while loop will initialize all values directly.</c>
<l>    BatchSize := -1</l>
<c>    * </c>
<c>    * Initialize the variable to collect all training results during training.</c>
<l>    TrainResults := []</l>
<c>    * </c>
<c>    * Initialize the variable to collect the evaluation information during training.</c>
<l>    EvaluationInfos := []</l>
<c>    * </c>
<c>    * Initialize the variable to collect the train status information during training.</c>
<l>    TrainInfos := []</l>
<c>    * </c>
<c>    * Initialize change strategies.</c>
<l>    init_train_dl_model_change_strategies (TrainParam, ChangeStrategyData)</l>
<c>    * </c>
<c>    * Initialize serialization strategies.</c>
<l>    init_train_dl_model_serialization_strategies (TrainParam, SerializationData)</l>
<c>    * </c>
<c>    * Initialize visualizations if enabled.</c>
<l>    dev_display_init_train_dl_model (DLModelHandle, TrainParam, DisplayData)</l>
<l>    get_dict_tuple (DisplayData, 'enabled', DisplayEnabled)</l>
<c>    * The following variables are also used for visualization during training.</c>
<l>    if (DisplayEnabled)</l>
<l>        DisplayLossEpochs := []</l>
<l>        DisplayLoss := []</l>
<l>        DisplayEvaluationEpochs := []</l>
<l>        DisplayValidationEvaluationValues := []</l>
<l>        DisplayTrainEvaluationValues := []</l>
<l>        DisplayLearningRates := []</l>
<l>        DisplayPreviewInitialized := false</l>
<l>    endif</l>
<c>    * </c>
<c>    * Start time for measurement of elapsed training time.</c>
<l>    count_seconds (StartTime)</l>
<c>    * </c>
<c>    * The while loop needs to know if it is the very first iteration.</c>
<l>    FirstIteration := true</l>
<l>    while (true)</l>
<c>        * Do some initializations only for the very first iteration.</c>
<l>        if (FirstIteration)</l>
<c>            * Jump to StartEpoch (Default: 0 but it could be used to resume training at given StartIteration).</c>
<l>            Epoch := StartEpoch</l>
<l>        else</l>
<l>            Epoch := (Iteration + 1) / real(NumIterationsPerEpoch)</l>
<l>        endif</l>
<c>        * </c>
<c>        * Update any parameters based on strategies.</c>
<l>        update_train_dl_model_change_strategies (DLModelHandle, ChangeStrategyData, Epoch)</l>
<c>        * </c>
<c>        * Check if the current batch size and total model batch size differ.</c>
<l>        get_dl_model_param (DLModelHandle, 'batch_size', BatchSizeDevice)</l>
<l>        get_dl_model_param (DLModelHandle, 'batch_size_multiplier', BatchSizeMultiplier)</l>
<l>        BatchSizeModel := BatchSizeDevice * BatchSizeMultiplier</l>
<c>        * </c>
<l>        if (BatchSize != BatchSizeModel or FirstIteration)</l>
<c>            * Set the current value.</c>
<l>            BatchSize := BatchSizeModel</l>
<c>            * Now, we compute all values which are related to the batch size of the model.</c>
<c>            * That way, the batch_size can be changed during the training without issues.</c>
<c>            * All inputs/outputs/visualizations are based on epochs.</c>
<c>            * </c>
<c>            * Calculate total number of iterations.</c>
<l>            NumIterationsPerEpoch := int(floor(NumTrainSamples / real(BatchSize)))</l>
<l>            NumIterations := int(NumIterationsPerEpoch * NumEpochs)</l>
<c>            * Select those indices that fit into the batch size.</c>
<l>            SampleIndicesTrain := SampleIndicesTrainRaw[0:NumIterations * BatchSize - 1]</l>
<c>            * The TrainResults tuple will be updated every iteration.</c>
<c>            * Hence, we initialize it as a constant tuple for speedup.</c>
<c>            * It is based on the iterations and hence cannot be reused if the batch size changes.</c>
<l>            tuple_gen_const (NumIterations, -1, TrainResults)</l>
<l>            if (not FirstIteration)</l>
<l>                Iteration := int(floor(real(Epoch) * NumIterationsPerEpoch))</l>
<l>                Epoch := (Iteration + 1) / real(NumIterationsPerEpoch)</l>
<l>            endif</l>
<l>        endif</l>
<c>        * </c>
<c>        * In the first iteration do some initializations.</c>
<l>        if (FirstIteration)</l>
<c>            * Jump to StartEpoch (Default: 0 but it could be used to resume training at given StartIteration).</c>
<l>            Iteration := int(floor(real(StartEpoch) * NumIterationsPerEpoch))</l>
<l>            FirstIteration := false</l>
<l>            if (Iteration * BatchSize + BatchSize &gt; |SampleIndicesTrain|)</l>
<l>                Iteration := NumIterations - 1</l>
<l>                break</l>
<l>            endif</l>
<l>        endif</l>
<c>        * </c>
<c>        * Generate the sample batch indices.</c>
<l>        BatchStart := Iteration * BatchSize</l>
<l>        BatchEnd := BatchStart + BatchSize - 1</l>
<l>        BatchIndices := SampleIndicesTrain[BatchStart:BatchEnd]</l>
<c>        * </c>
<c>        * Set a random seed for the sample batch.</c>
<l>        set_system ('seed_rand', SampleSeedsTrainRaw[BatchEnd])</l>
<c>        * </c>
<c>        * Read preprocessed samples.</c>
<l>        read_dl_samples (DLDataset, BatchIndices, DLSampleBatch)</l>
<c>        * </c>
<c>        * Augment samples based on train parameter.</c>
<l>        get_dict_tuple (TrainParam, 'augmentation_param', AugmentationParam)</l>
<l>        augment_dl_samples (DLSampleBatch, AugmentationParam)</l>
<c>        * </c>
<c>        * Train the model on current batch.</c>
<l>        train_dl_model_batch (DLModelHandle, DLSampleBatch, TrainResult)</l>
<c>        * </c>
<c>        * We store each train result.</c>
<l>        TrainResults[Iteration] := TrainResult</l>
<c>        * </c>
<c>        * Evaluation handling.</c>
<l>        get_dict_tuple (TrainParam, 'evaluation_interval_epochs', EvaluationIntervalEpochs)</l>
<l>        EvaluationInterval := int(floor(EvaluationIntervalEpochs * NumIterationsPerEpoch))</l>
<l>        ValidationEvaluationResult := []</l>
<l>        TrainEvaluationResult := []</l>
<c>        * Get percentage of evaluated training samples from display parameters.</c>
<l>        get_dict_tuple (DisplayData, 'display_param', DisplayParam)</l>
<l>        get_dict_tuple (DisplayParam, 'selected_percentage_train_samples', SelectPercentageTrainSamples)</l>
<l>        if (EvaluationInterval &gt; 0)</l>
<c>            * Evaluate the model at given intervals.</c>
<l>            if (((Iteration + 1) % EvaluationInterval == 0 and Iteration != 0) or Iteration == NumIterations - 1)</l>
<l>                get_dict_tuple (TrainParam, 'evaluation_param', EvaluationParam)</l>
<c>                * Evaluate on validation split.</c>
<l>                evaluate_dl_model (DLDataset, DLModelHandle, 'split', 'validation', EvaluationParam, ValidationEvaluationResult, _)</l>
<c>                * Evaluate a subset of the train split.</c>
<l>                tuple_shuffle (TrainSampleIndices, TrainEvaluationSampleIndices)</l>
<l>                TrainEvaluationRatio := SelectPercentageTrainSamples / 100.0</l>
<l>                NumTrainEvaluationSampleIndices := int(TrainEvaluationRatio * |TrainEvaluationSampleIndices|)</l>
<l>                if (NumTrainEvaluationSampleIndices &gt; 0)</l>
<c>                    * It might happen that the subset is too small for evaluation.</c>
<l>                    try</l>
<l>                        evaluate_dl_model (DLDataset, DLModelHandle, 'sample_indices', TrainEvaluationSampleIndices[0:NumTrainEvaluationSampleIndices - 1], EvaluationParam, TrainEvaluationResult, _)</l>
<l>                    catch (Exception)</l>
<l>                    endtry</l>
<l>                endif</l>
<l>                create_dict (EvaluationInfo)</l>
<l>                set_dict_tuple (EvaluationInfo, 'epoch', Epoch)</l>
<l>                set_dict_tuple (EvaluationInfo, 'result', ValidationEvaluationResult)</l>
<l>                set_dict_tuple (EvaluationInfo, 'result_train', TrainEvaluationResult)</l>
<l>                EvaluationInfos := [EvaluationInfos,EvaluationInfo]</l>
<l>                if (DisplayEnabled)</l>
<l>                    get_dict_tuple (TrainParam, 'evaluation_comparison_keys', EvaluationComparisonKeys)</l>
<l>                    reduce_dl_evaluation_result (ValidationEvaluationResult, EvaluationComparisonKeys, Valuevalidation, _)</l>
<l>                    reduce_dl_evaluation_result (TrainEvaluationResult, EvaluationComparisonKeys, ValueTrain, _)</l>
<l>                    DisplayValidationEvaluationValues := [DisplayValidationEvaluationValues,Valuevalidation]</l>
<l>                    DisplayTrainEvaluationValues := [DisplayTrainEvaluationValues,ValueTrain]</l>
<l>                    DisplayEvaluationEpochs := [DisplayEvaluationEpochs,Epoch]</l>
<l>                endif</l>
<l>            endif</l>
<l>        endif</l>
<c>        * </c>
<c>        * Check if an update is needed.</c>
<l>        get_dict_tuple (TrainParam, 'update_interval_seconds', TrainInfoUpdateIntervalSeconds)</l>
<l>        get_dict_tuple (DisplayData, 'last_update', LastUpdate)</l>
<l>        count_seconds (Seconds)</l>
<c>        * Check for next update (enough time has elapsed or last iteration).</c>
<l>        if (abs(LastUpdate - Seconds) &gt; TrainInfoUpdateIntervalSeconds or Iteration == NumIterations - 1)</l>
<l>            set_dict_tuple (DisplayData, 'last_update', Seconds)</l>
<l>            get_dict_tuple (TrainParam, 'evaluation_comparison_keys', EvaluationComparisonKeys)</l>
<l>            get_dict_tuple (TrainParam, 'num_samples_mean_loss', NumSamplesMeanLoss)</l>
<l>            collect_train_dl_model_info (DLModelHandle, TrainResults, EvaluationInfos, EvaluationComparisonKeys, Iteration, NumIterations, NumIterationsPerEpoch, NumSamplesMeanLoss, TrainInfo)</l>
<l>            set_dict_tuple (TrainInfo, 'start_epoch', StartEpoch)</l>
<l>            set_dict_tuple (TrainInfo, 'start_time', StartTime)</l>
<l>            TrainInfos := [TrainInfos,TrainInfo]</l>
<c>            * </c>
<c>            * Display handling.</c>
<l>            if (DisplayEnabled)</l>
<l>                get_dict_tuple (TrainInfo, 'epoch', EpochsStatus)</l>
<l>                DisplayLossEpochs := [DisplayLossEpochs,EpochsStatus]</l>
<l>                get_dict_tuple (TrainInfo, 'mean_loss', MeanLoss)</l>
<l>                DisplayLoss := [DisplayLoss,MeanLoss]</l>
<l>                get_dl_model_param (DLModelHandle, 'learning_rate', DisplayLearningRate)</l>
<l>                DisplayLearningRates := [DisplayLearningRates,DisplayLearningRate]</l>
<l>                dev_display_update_train_dl_model (TrainParam, DisplayData, TrainInfo, DisplayLossEpochs, DisplayLoss, DisplayLearningRates, DisplayEvaluationEpochs, DisplayValidationEvaluationValues, DisplayTrainEvaluationValues)</l>
<l>            endif</l>
<l>        endif</l>
<c>        * Image result preview handling.</c>
<l>        if (DisplayEnabled)</l>
<c>            * Check if the image preview has to be updated.</c>
<l>            get_dict_tuple (DisplayParam, 'update_images_interval_epochs', UpdateImagesIntervalEpochs)</l>
<l>            UpdateImagesInterval := int(floor(real(UpdateImagesIntervalEpochs) * NumIterationsPerEpoch))</l>
<l>            if (UpdateImagesInterval == 0)</l>
<l>                UpdateImagesInterval := 1</l>
<l>            endif</l>
<l>            if (Iteration % UpdateImagesInterval == 0 or not DisplayPreviewInitialized)</l>
<l>                get_dict_tuple (DisplayData, 'window_images', WindowImages)</l>
<l>                FirstCall := |WindowImages| == 0</l>
<l>                get_dict_tuple (DisplayParam, 'num_images', NumImages)</l>
<l>                get_dict_tuple (DisplayData, 'window_images_genparam', GenParam)</l>
<c>                * </c>
<l>                dev_display_dl_data_tiled (DLDataset, DLModelHandle, NumImages, 'validation', GenParam, WindowImages, WindowImages)</l>
<c>                * </c>
<l>                if (FirstCall)</l>
<l>                    set_dict_tuple (DisplayData, 'window_images', WindowImages)</l>
<l>                    set_display_font (WindowImages, 12, 'mono', 'true', 'false')</l>
<l>                endif</l>
<l>                dev_display_tiled_legend (WindowImages, GenParam)</l>
<l>                DisplayPreviewInitialized := true</l>
<l>            endif</l>
<l>        endif</l>
<c>        * </c>
<c>        * Serialization handling.</c>
<l>        update_train_dl_model_serialization (TrainParam, SerializationData, Iteration, NumIterations, Epoch, ValidationEvaluationResult, DLModelHandle, TrainInfos, EvaluationInfos)</l>
<c>        * </c>
<c>        * Check for end of training.</c>
<l>        if (Iteration &gt;= NumIterations - 1)</l>
<l>            break</l>
<l>        endif</l>
<c>        * </c>
<c>        * Continue with next iteration.</c>
<l>        Iteration := Iteration + 1</l>
<l>    endwhile</l>
<c>    * </c>
<l>elseif (ModelType == 'anomaly_detection')</l>
<c>    * Read the training samples.</c>
<l>    read_dl_samples (DLDataset, TrainSampleIndices, DLSamples)</l>
<c>    * </c>
<c>    * Get training parameters for anomaly detection.</c>
<l>    get_dict_tuple (TrainParam, 'anomaly_param', TrainParamAnomaly)</l>
<c>    * </c>
<c>    * Display information about training.</c>
<l>    get_dict_tuple (TrainParam, 'display_param', DisplayParam)</l>
<l>    get_dict_tuple (DisplayParam, 'enabled', EnableDisplay)</l>
<l>    if (EnableDisplay)</l>
<l>        dev_display_train_info_anomaly_detection (TrainParam, WindowHandleInfo)</l>
<l>    endif</l>
<c>    * </c>
<c>    * Train the model.</c>
<l>    train_dl_model_anomaly_dataset (DLModelHandle, DLSamples, TrainParamAnomaly, TrainResults)</l>
<c>    * </c>
<c>    * Initialize TrainInfos and EvaluationInfos</c>
<l>    TrainInfos := []</l>
<l>    EvaluationInfos := []</l>
<c>    * </c>
<c>    * Close window with information about the training.</c>
<l>    if (EnableDisplay)</l>
<l>        dev_set_window (WindowHandleInfo)</l>
<l>    endif</l>
<l>endif</l>
<c>* </c>
<l>return ()</l>
</body>
<docu id="train_dl_model">
<abstract lang="en_US">Train a deep-learning-based model on a dataset. Thereby, the model is passed by its handle DLModelHandle and the dataset over the dictionary DLDataset.
The dictionary TrainParam declares the training parameters to be used.

For models of type 'classification', 'detection', or 'segmentation':
StartEpoch defines the epoch to start the training at. It allows to resume the training at a given epoch. The model parameters are set based on the change strategies.
As a result, you will obtain:
- TrainResults: A tuple of dictionaries, which contains the output of each call of the operator train_dl_model_batch. Note, this tuple may contain -1 values for iterations at which no train_dl_model_batch was called. Note, that if you change the batch_size or the batch_size_multiplier during training with a change strategy, this array will not contain older train results anymore.
- TrainInfos: A dictionary or tuple of dictionaries returning summarized status information which are calculated during the training.
- EvaluationInfos: A dictionary or tuple of dictionaries with the evaluation information which is calculated during the training.

For models of type 'anomaly_detection':
The parameter StartEpoch is ignored.
As a result, you will obtain:
- TrainResults: A dictionary that contains entries for two keys:
-- 'final error': The final value of the error metric that is used to decide whether the training is stopped after each epoch.
-- 'final_epoch': The epoch after which the training was stopped.
- TrainInfos: This parameter is empty for anomaly detection models.
- EvaluationInfos: This parameter is empty for anomaly detection models.


To create the dictionary TrainParam, it is recommended to use create_dl_train_param. For further information on the parameters, see the documentation of create_dl_train_param.

For further information on training of a deep-learning-based model, see the chapter Deep Learning.</abstract>
<chapters lang="de_DE">
<item>Deep Learning</item>
<item>Modell</item>
</chapters>
<chapters lang="en_US">
<item>Deep Learning</item>
<item>Model</item>
</chapters>
<library lang="en_US">MVTec Standard Procedures</library>
<short lang="en_US">Train a deep-learning-based model on a dataset.</short>
<parameters>
<parameter id="DLDataset">
<default_type>integer</default_type>
<description lang="en_US">Dictionary containing the dataset.</description>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>dict</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="DLModelHandle">
<default_type>integer</default_type>
<description lang="en_US">Handle of the deep-learning-based model to be trained.</description>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>dl_model</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="EvaluationInfos">
<default_type>integer</default_type>
<description lang="en_US">Evaluation information which is calculated during the training.</description>
<mixed_type>false</mixed_type>
<multivalue>optional</multivalue>
<sem_type>dict</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="StartEpoch">
<default_type>real</default_type>
<default_value>0</default_value>
<description lang="en_US">The epoch to start the training with.</description>
<multivalue>false</multivalue>
<sem_type>integer</sem_type>
<type_list>
<item>real</item>
</type_list>
</parameter>
<parameter id="TrainInfos">
<default_type>integer</default_type>
<description lang="en_US">Dictionary or tuple of dictionaries returning summarized status information which are calculated during the training.</description>
<mixed_type>false</mixed_type>
<multivalue>optional</multivalue>
<sem_type>dict</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="TrainParam">
<default_type>integer</default_type>
<description lang="en_US">Dictionary with training parameters.</description>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>dict</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="TrainResults">
<default_type>integer</default_type>
<description lang="en_US">A tuple containing the result of each train_dl_model_batch call during training.</description>
<mixed_type>false</mixed_type>
<multivalue>optional</multivalue>
<sem_type>dict</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
</parameters>
</docu>
</procedure>
<procedure name="tuple_shuffle">
<interface>
<ic>
<par name="Tuple" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="Shuffled" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c>* This procedure sorts the input tuple randomly.</c>
<c>* </c>
<l>if (|Tuple| &gt; 0)</l>
<c>    * Create a tuple of random numbers,</c>
<c>    * sort this tuple, and return the indices</c>
<c>    * of this sorted tuple.</c>
<l>    ShuffleIndices := sort_index(rand(|Tuple|))</l>
<c>    * Assign the elements of Tuple</c>
<c>    * to these random positions.</c>
<l>    Shuffled := Tuple[ShuffleIndices]</l>
<l>else</l>
<c>    * If the input tuple is empty,</c>
<c>    * an empty tuple should be returned.</c>
<l>    Shuffled := []</l>
<l>endif</l>
<l>return ()</l>
</body>
<docu id="tuple_shuffle">
<abstract lang="de_DE">tuple_shuffle sortiert die Elemete des Eingabetupels Tuple zufällig und gibt das Ergebnis in Shuffled zurück. Es ist möglich, Strings und Nummern in Tuple zu vermischen. Ein leeres Eingabetupel resultiert in einem leeren Ausgabetupel.</abstract>
<abstract lang="en_US">tuple_shuffle sorts the elements of the input Tuple randomly, and returns the result in Shuffled. You can mix strings and numbers in Tuple. An empty input tuple results in an empty output tuple.</abstract>
<alternatives>
<item>tuple_sort</item>
</alternatives>
<chapters lang="de_DE">
<item>Tupel</item>
<item>Elementreihenfolge</item>
</chapters>
<chapters lang="en_US">
<item>Tuple</item>
<item>Element Order</item>
</chapters>
<example lang="de_DE">Tuple := [0:10]
tuple_shuffle (Tuple, Shuffled)</example>
<example lang="en_US">Tuple := [0:10]
tuple_shuffle (Tuple, Shuffled)</example>
<library lang="de_DE">MVTec Standard Procedures</library>
<library lang="en_US">MVTec Standard Procedures</library>
<short lang="de_DE">Zufälliges Sortieren der Elemente eines Tupels.</short>
<short lang="en_US">Sort the elements of a tuple randomly.</short>
<parameters>
<parameter id="Shuffled"/>
<parameter id="Tuple"/>
</parameters>
</docu>
</procedure>
<procedure name="tuple_vector_cross_product">
<interface>
<ic>
<par name="V1" base_type="ctrl" dimension="0"/>
<par name="V2" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="VC" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c>* The caller must ensure that the length of both input vectors is 3</c>
<l>VC := V1[1] * V2[2] - V1[2] * V2[1]</l>
<l>VC := [VC,V1[2] * V2[0] - V1[0] * V2[2]]</l>
<l>VC := [VC,V1[0] * V2[1] - V1[1] * V2[0]]</l>
<l>return ()</l>
</body>
<docu id="tuple_vector_cross_product">
<abstract lang="en_US">Calculates the cross product of two vectors of length 3.</abstract>
<chapters lang="de_DE">
<item>Tupel</item>
<item>Arithmetik</item>
</chapters>
<chapters lang="en_US">
<item>Tuple</item>
<item>Arithmetic</item>
</chapters>
<library lang="en_US">MVTec Standard Procedures</library>
<short lang="en_US">Calculates the cross product of two vectors of length 3.</short>
<parameters>
<parameter id="V1">
<default_type>real</default_type>
<description lang="en_US">First Vector</description>
<mixed_type>optional</mixed_type>
<multivalue>true</multivalue>
<sem_type>real</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
<parameter id="V2">
<default_type>real</default_type>
<description lang="en_US">Second vector.</description>
<mixed_type>optional</mixed_type>
<multivalue>true</multivalue>
<sem_type>real</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
<parameter id="VC">
<default_type>real</default_type>
<description lang="en_US">Resulting vector.</description>
<mixed_type>optional</mixed_type>
<sem_type>real</sem_type>
<type_list>
<item>real</item>
</type_list>
</parameter>
</parameters>
</docu>
</procedure>
<procedure name="update_running_evaluation_measures">
<interface>
<ic>
<par name="Samples" base_type="ctrl" dimension="0"/>
<par name="Results" base_type="ctrl" dimension="0"/>
<par name="EvalParams" base_type="ctrl" dimension="0"/>
<par name="RunningMeasures" base_type="ctrl" dimension="0"/>
</ic>
</interface>
<body>
<c>* </c>
<c>* This procedure updates the running measures depending on the evaluation type.</c>
<l>get_dict_tuple (EvalParams, 'evaluation_type', EvaluationType)</l>
<l>if (EvaluationType == 'anomaly_detection')</l>
<l>    update_running_image_anomaly_measures (Samples, Results, EvalParams, RunningMeasures)</l>
<l>elseif (EvaluationType == 'classification')</l>
<l>    update_running_image_classification_measures (Samples, Results, EvalParams, RunningMeasures)</l>
<l>elseif (EvaluationType == 'detection')</l>
<l>    update_running_instance_measures (Samples, Results, EvalParams, RunningMeasures)</l>
<l>elseif (EvaluationType == 'segmentation')</l>
<l>    update_running_pixel_measures (Samples, Results, EvalParams, RunningMeasures)</l>
<l>endif</l>
<c>* </c>
<l>return ()</l>
</body>
<docu id="update_running_evaluation_measures">
<abstract lang="en_US">This procedure calls further procedures to update the running evaluation measures.
These measures are stored in the dictionary RunningMeasures and updated by incorporating the Results the model obtained for the Samples.

The dictionary RunningMeasures is updated in-place and therefore an input as well as an output variable.

The given Samples and Results should accord pairwise, thus they should refer to the same underlying image(s). As a consequence, they need to have the same length.

The evaluation measures and therewith the entries and the structure of RunningMeasures depend on what is evaluated, thus the model type.
The structure and possible entries of the dictionary RunningMeasures is explained in the documentation of init_running_evaluation_measures,
the procedure with which it is usually initialized.
Further information on the dictionary EvalParams and its modifications can be found in the documentation of evaluate_dl_model.
</abstract>
<chapters lang="de_DE">
<item>Deep Learning</item>
<item>Evaluierung</item>
</chapters>
<chapters lang="en_US">
<item>Deep Learning</item>
<item>Evaluation</item>
</chapters>
<library lang="en_US">MVTec Standard Procedures</library>
<short lang="en_US">Update RunningMeasures by evaluating Samples and corresponding Results.
</short>
<parameters>
<parameter id="EvalParams">
<default_type>integer</default_type>
<default_value>EvalParams</default_value>
<description lang="en_US">Dictionary containing the evaluation parameters.</description>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>dict</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="Results">
<default_type>integer</default_type>
<default_value>Results</default_value>
<description lang="en_US">Dictionaries with the results obtained for the Samples.</description>
<mixed_type>false</mixed_type>
<multivalue>optional</multivalue>
<sem_type>dict</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="RunningMeasures">
<default_type>integer</default_type>
<default_value>RunningMeasures</default_value>
<description lang="en_US">Dictionary with the running measures to be updated in-place.</description>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>dict</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="Samples">
<default_type>integer</default_type>
<default_value>Samples</default_value>
<description lang="en_US">Dictonaries of the samples including their ground truth annotations.</description>
<mixed_type>false</mixed_type>
<multivalue>optional</multivalue>
<sem_type>dict</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
</parameters>
</docu>
</procedure>
<procedure name="update_running_image_anomaly_measures" access="local">
<interface>
<ic>
<par name="Samples" base_type="ctrl" dimension="0"/>
<par name="Results" base_type="ctrl" dimension="0"/>
<par name="EvalParams" base_type="ctrl" dimension="0"/>
<par name="RunningMeasures" base_type="ctrl" dimension="0"/>
</ic>
</interface>
<body>
<c>* </c>
<c>* This procedure updates the RunningMeasures for an evaluation for anomaly detection.</c>
<c>* </c>
<c>* These measures are stored in the dictionary RunningMeasures and</c>
<c>* updated by incorporating the Results the model obtained for the Samples.</c>
<c>* </c>
<c>* </c>
<c>* Get image ids.</c>
<l>get_dict_tuple (RunningMeasures, 'image_ids', ImageIDs)</l>
<c>* Get anomaly label ids.</c>
<l>get_dict_tuple (RunningMeasures, 'anomaly_label_ids', AnomalyLabelIDs)</l>
<c>* Get anomaly scores.</c>
<l>get_dict_tuple (RunningMeasures, 'anomaly_scores', AnomalyScores)</l>
<c>* </c>
<c>* Loop over all samples and update running measures accordingly.</c>
<l>for SampleIndex := 0 to |Samples| - 1 by 1</l>
<l>    Sample := Samples[SampleIndex]</l>
<l>    get_dict_tuple (Sample, 'image_id', ImageID)</l>
<l>    get_dict_tuple (Sample, 'anomaly_label_id', AnomalyLabelID)</l>
<l>    Result := Results[SampleIndex]</l>
<l>    get_dict_tuple (Result, 'anomaly_score', AnomalyScore)</l>
<c>    * </c>
<l>    ImageIDs := [ImageIDs,ImageID]</l>
<l>    AnomalyLabelIDs := [AnomalyLabelIDs,AnomalyLabelID]</l>
<l>    AnomalyScores := [AnomalyScores,AnomalyScore]</l>
<l>endfor</l>
<c>* </c>
<c>* Set image ids in running measures.</c>
<l>set_dict_tuple (RunningMeasures, 'image_ids', ImageIDs)</l>
<c>* Set anomaly label ids in running measures.</c>
<l>set_dict_tuple (RunningMeasures, 'anomaly_label_ids', AnomalyLabelIDs)</l>
<c>* Set anomaly scores in running measures.</c>
<l>set_dict_tuple (RunningMeasures, 'anomaly_scores', AnomalyScores)</l>
<c>* </c>
<l>return ()</l>
</body>
<docu id="update_running_image_anomaly_measures">
<abstract lang="en_US">This procedure updates the RunningMeasures for an evaluation for anomaly detection.
These measures are stored in the dictionary RunningMeasures and updated by incorporating the results the model obtained for the Samples.</abstract>
<chapters lang="en_US">
<item>Deep Learning</item>
<item>Anomaly Detection</item>
</chapters>
<library lang="en_US">MVTec Standard Procedures</library>
<short lang="en_US">Update running measures for an image anomaly detection evaluation.</short>
<parameters>
<parameter id="EvalParams"/>
<parameter id="Results"/>
<parameter id="RunningMeasures"/>
<parameter id="Samples"/>
</parameters>
</docu>
</procedure>
<procedure name="update_running_image_classification_measures" access="local">
<interface>
<ic>
<par name="Samples" base_type="ctrl" dimension="0"/>
<par name="Results" base_type="ctrl" dimension="0"/>
<par name="EvalParams" base_type="ctrl" dimension="0"/>
<par name="RunningMeasures" base_type="ctrl" dimension="0"/>
</ic>
</interface>
<body>
<c>* </c>
<c>* This procedure updates the RunningMeasures for an evaluation for classification.</c>
<c>* </c>
<c>* To avoid memory, only save first K predictions per sample.</c>
<l>RegExpTopKError := 'top([0-9]+)_error'</l>
<l>get_dict_tuple (EvalParams, 'measures', Measures)</l>
<l>K := 1</l>
<l>for M := 0 to |Measures| - 1 by 1</l>
<l>    ComputeTopKError := Measures[M] =~ RegExpTopKError</l>
<l>    if (ComputeTopKError)</l>
<l>        K := max2(K,number(regexp_match(Measures[M],RegExpTopKError)))</l>
<l>    endif</l>
<l>endfor</l>
<c>* </c>
<c>* Extend tuples in RunningMeasures with new results.</c>
<l>get_dict_tuple (RunningMeasures, 'image_ids', ImageIDs)</l>
<l>get_dict_tuple (RunningMeasures, 'image_label_ids', ImageLabelIDs)</l>
<l>get_dict_tuple (RunningMeasures, 'top1_predictions', Top1Prediction)</l>
<l>get_dict_tuple (RunningMeasures, 'topk_predictions', TopKPredictionDicts)</l>
<l>for Index := 0 to |Samples| - 1 by 1</l>
<l>    Sample := Samples[Index]</l>
<l>    get_dict_tuple (Sample, 'image_id', ImageID)</l>
<l>    get_dict_tuple (Sample, 'image_label_id', ImageLabelID)</l>
<l>    Result := Results[Index]</l>
<l>    get_dict_tuple (Result, 'classification_class_ids', PredictedClassIDs)</l>
<l>    TopKPrediction := PredictedClassIDs[0:K - 1]</l>
<l>    create_dict (TopKPredictionDict)</l>
<l>    set_dict_tuple (TopKPredictionDict, 'predictions', TopKPrediction)</l>
<c>    * </c>
<l>    ImageIDs := [ImageIDs,ImageID]</l>
<l>    ImageLabelIDs := [ImageLabelIDs,ImageLabelID]</l>
<l>    Top1Prediction := [Top1Prediction,TopKPrediction[0]]</l>
<l>    TopKPredictionDicts := [TopKPredictionDicts,TopKPredictionDict]</l>
<l>endfor</l>
<c>* </c>
<l>set_dict_tuple (RunningMeasures, 'image_ids', ImageIDs)</l>
<l>set_dict_tuple (RunningMeasures, 'image_label_ids', ImageLabelIDs)</l>
<l>set_dict_tuple (RunningMeasures, 'top1_predictions', Top1Prediction)</l>
<l>set_dict_tuple (RunningMeasures, 'topk_predictions', TopKPredictionDicts)</l>
<c>* </c>
<l>return ()</l>
</body>
<docu id="update_running_image_classification_measures">
<abstract lang="en_US">This procedure updates the RunningMeasures for an evaluation for classification.
These measures are stored in the dictionary RunningMeasures and updated by incorporating the results the model obtained for the Samples.</abstract>
<chapters lang="en_US">
<item>Deep Learning</item>
<item>Evaluation</item>
</chapters>
<library lang="en_US">MVTec Standard Procedures</library>
<short lang="en_US">Update running measures for an image classification evaluation.</short>
<parameters>
<parameter id="EvalParams">
<default_type>integer</default_type>
<default_value>EvalParams</default_value>
<description lang="en_US">Dictionary with the evaluation parameters.</description>
<mixed_type>false</mixed_type>
<multivalue>true</multivalue>
<sem_type>dict</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="Results">
<default_type>integer</default_type>
<default_value>Results</default_value>
<description lang="en_US">Dictionaries with the results obtained for the Samples.</description>
<mixed_type>false</mixed_type>
<multivalue>optional</multivalue>
<sem_type>dict</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="RunningMeasures">
<default_type>integer</default_type>
<default_value>RunningMeasures</default_value>
<description lang="en_US">Dictionary with the running measures to be updated in-place.</description>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>dict</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="Samples">
<default_type>integer</default_type>
<default_value>Samples</default_value>
<description lang="en_US">Dictonaries of the samples including their ground truth annotations.</description>
<mixed_type>false</mixed_type>
<multivalue>optional</multivalue>
<sem_type>dict</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
</parameters>
</docu>
</procedure>
<procedure name="update_running_instance_measures" access="local">
<interface>
<ic>
<par name="Samples" base_type="ctrl" dimension="0"/>
<par name="Results" base_type="ctrl" dimension="0"/>
<par name="EvalParams" base_type="ctrl" dimension="0"/>
<par name="RunningMeasures" base_type="ctrl" dimension="0"/>
</ic>
</interface>
<body>
<c>* </c>
<c>* This procedure updates the RunningMeasures</c>
<c>* for an instance-based evaluation for detection.</c>
<c>* These measures are stored in the dictionary RunningMeasures and</c>
<c>* updated by incorporating the Results the model obtained for the Samples.</c>
<c>* </c>
<l>dev_update_off ()</l>
<c>* Get the necessary evaluation parameters.</c>
<l>get_dict_tuple (EvalParams, 'max_num_detections', MaxNumDetections)</l>
<l>get_dict_tuple (EvalParams, 'area_ranges', AreaRanges)</l>
<l>get_dict_tuple (EvalParams, 'iou_threshold', IoUThresholds)</l>
<l>get_dict_tuple (EvalParams, 'instance_type', InstanceType)</l>
<l>get_dict_tuple (EvalParams, 'class_ids', ClassIDs)</l>
<l>get_dict_tuple (EvalParams, 'num_classes', NumClasses)</l>
<l>get_dict_tuple (EvalParams, 'measures', Measures)</l>
<c>* </c>
<c>* Get the area parameters: name, min, and max.</c>
<l>get_dict_tuple (AreaRanges, 'name', AreaNames)</l>
<l>get_dict_tuple (AreaRanges, 'min', MinAreas)</l>
<l>get_dict_tuple (AreaRanges, 'max', MaxAreas)</l>
<l>NumAreaRanges := |AreaNames| - 1</l>
<c>* </c>
<c>* Get the allocation length for extending tuples.</c>
<l>get_dict_tuple (EvalParams, 'allocation_block_length', AllocationBlockLength)</l>
<c>* </c>
<c>* Check if a detailed evaluation should be done.</c>
<l>DetailedEvaluation := false</l>
<l>get_dict_param (EvalParams, 'key_exists', 'detailed_evaluation', KeyExists)</l>
<l>if (KeyExists[0])</l>
<l>    get_dict_tuple (EvalParams, 'detailed_evaluation', DetailedEvaluation)</l>
<l>endif</l>
<l>if (DetailedEvaluation)</l>
<c>    * We need a mapping from class IDs to class indices</c>
<l>    ClassIDToClassIdx := gen_tuple_const(max(ClassIDs) + 1,-1)</l>
<l>    ClassIDToClassIdx[ClassIDs] := [0:NumClasses - 1]</l>
<l>endif</l>
<c>* </c>
<c>* Check if the orientation is to be evaluated.</c>
<l>EvaluateOrientation := false</l>
<l>if (InstanceType == 'rectangle2' and (find(Measures,'soap') != -1 or find(Measures,'all') != -1))</l>
<l>    EvaluateOrientation := true</l>
<l>endif</l>
<c>* </c>
<c>* Go through samples.</c>
<l>for SIdx := 0 to |Samples| - 1 by 1</l>
<c>    * </c>
<l>    CurrentSample := Samples[SIdx]</l>
<l>    CurrentResult := Results[SIdx]</l>
<c>    * </c>
<c>    * * Get classes.</c>
<l>    get_dict_tuple (CurrentSample, 'bbox_label_id', GtClassIDs)</l>
<l>    get_dict_tuple (CurrentResult, 'bbox_class_id', ResClassIDs)</l>
<l>    NumGT := |GtClassIDs|</l>
<l>    NumRes := |ResClassIDs|</l>
<c>    * </c>
<c>    * * Get result confidences and sort them in descending order.</c>
<l>    get_dict_tuple (CurrentResult, 'bbox_confidence', Confidences)</l>
<l>    ResSortIndices := sort_index(-Confidences)</l>
<l>    Confidences := Confidences[ResSortIndices]</l>
<c>    * Sort the result class IDs.</c>
<l>    ResClassIDs := ResClassIDs[ResSortIndices]</l>
<c>    * </c>
<c>    * Compute the IoUs of the instances.</c>
<l>    area_iou (CurrentSample, CurrentResult, InstanceType, ResSortIndices, GtAreas, ResAreas, IoUs)</l>
<c>    * </c>
<l>    if (EvaluateOrientation)</l>
<l>        get_dict_tuple (CurrentSample, 'bbox_phi', GtPhis)</l>
<l>        get_dict_tuple (CurrentResult, 'bbox_phi', ResPhis)</l>
<l>        ResPhis := ResPhis[ResSortIndices]</l>
<l>    endif</l>
<c>    * Loop over the maximal number of detections.</c>
<l>    for MDIdx := 0 to |MaxNumDetections| - 1 by 1</l>
<l>        MaxNum := MaxNumDetections[MDIdx]</l>
<l>        MaxNumStr := '' + MaxNum</l>
<l>        if (MaxNum == -1)</l>
<l>            MaxNumStr := 'all'</l>
<l>        endif</l>
<l>        get_dict_tuple (RunningMeasures, 'max_num_detections_' + MaxNumStr, CurrentRunningMeasures)</l>
<c>        * </c>
<c>        * Loop over the area ranges.</c>
<l>        for AreaIdx := 0 to |AreaNames| - 1 by 1</l>
<c>            * </c>
<c>            * Get information about the current area range.</c>
<l>            MinArea := MinAreas[AreaIdx]</l>
<l>            MaxArea := MaxAreas[AreaIdx]</l>
<l>            AreaName := AreaNames[AreaIdx]</l>
<c>            * </c>
<l>            get_dict_tuple (CurrentRunningMeasures, 'area_' + AreaName, AreaRunningMeasures)</l>
<c>            * </c>
<c>            * Set ignore-flag for ground truth instances.</c>
<l>            GtIgnore := gen_tuple_const(NumGT,0)</l>
<c>            * </c>
<c>            * Ignore ground truth instances with area outside the area range.</c>
<l>            if (NumGT &gt; 0)</l>
<l>                tuple_find (GtAreas [&lt;] MinArea or GtAreas [&gt;] MaxArea, 1, GtIgnoreInds)</l>
<l>                if (GtIgnoreInds &gt; -1)</l>
<l>                    GtIgnore[GtIgnoreInds] := 1</l>
<l>                endif</l>
<l>            endif</l>
<c>            * </c>
<l>            get_dict_tuple (AreaRunningMeasures, 'num_gt', PerClassNumGt)</l>
<l>            get_dict_tuple (AreaRunningMeasures, 'num_pred', PerClassNumPred)</l>
<l>            get_dict_tuple (AreaRunningMeasures, 'confidence', PerClassConfidences)</l>
<l>            get_dict_tuple (AreaRunningMeasures, 'num_gt_ignore', PerClassNumGtIgnore)</l>
<c>            * </c>
<l>            if (DetailedEvaluation)</l>
<c>                * Store if a sample has at least one false positive or false negative (for each IoU threshold).</c>
<l>                SampleHasFP := gen_tuple_const(|IoUThresholds|,false)</l>
<l>                SampleHasFN := gen_tuple_const(|IoUThresholds|,false)</l>
<l>            endif</l>
<c>            * </c>
<c>            * Loop over the classes.</c>
<l>            for ClsIdx := 0 to NumClasses - 1 by 1</l>
<l>                CurrentClassID := ClassIDs[ClsIdx]</l>
<c>                * </c>
<c>                * Get the ground truth for this class.</c>
<l>                CurrentGtIdxs := find(GtClassIDs,CurrentClassID)</l>
<l>                if (CurrentGtIdxs == -1)</l>
<l>                    CurrentGtIdxs := []</l>
<l>                endif</l>
<l>                CurrentNumGt := |CurrentGtIdxs|</l>
<c>                * </c>
<c>                * Get ground truth ignore for this class.</c>
<l>                CurrentGtIgnore := GtIgnore[CurrentGtIdxs]</l>
<l>                if (|CurrentGtIgnore| == 0)</l>
<l>                    CurrentNumGtIgnore := 0</l>
<l>                else</l>
<l>                    CurrentNumGtIgnore := sum(CurrentGtIgnore)</l>
<l>                endif</l>
<c>                * </c>
<c>                * Number of gt for this class and without ignore.</c>
<l>                CurrentNumGtNoIgnore := CurrentNumGt - CurrentNumGtIgnore</l>
<c>                * </c>
<c>                * Get results for this class.</c>
<l>                CurrentResIdxs := find(ResClassIDs,CurrentClassID)</l>
<l>                if (CurrentResIdxs == -1)</l>
<l>                    CurrentResIdxs := []</l>
<l>                endif</l>
<l>                CurrentNumRes := min2(MaxNum,|CurrentResIdxs|)</l>
<c>                * MaxNum -1 corresponds to taking all results.</c>
<l>                if (MaxNum == -1)</l>
<l>                    CurrentNumRes := |CurrentResIdxs|</l>
<l>                endif</l>
<l>                CurrentResIdxs := CurrentResIdxs[0:CurrentNumRes - 1]</l>
<c>                * </c>
<c>                * Get areas of the current results.</c>
<l>                CurrentResAreas := ResAreas[CurrentResIdxs]</l>
<c>                * </c>
<c>                * Update the confidences, num_gt and num_pred for this class.</c>
<l>                OldNumPred := PerClassNumPred[ClsIdx]</l>
<l>                PerClassNumGt[ClsIdx] := PerClassNumGt[ClsIdx] + CurrentNumGt</l>
<l>                PerClassNumGtIgnore[ClsIdx] := PerClassNumGtIgnore[ClsIdx] + CurrentNumGtIgnore</l>
<l>                PerClassNumPred[ClsIdx] := PerClassNumPred[ClsIdx] + CurrentNumRes</l>
<l>                get_dict_tuple (PerClassConfidences, 'class_' + ClassIDs[ClsIdx], CurrentClassConfidences)</l>
<c>                * Confidences are allocated in blocks of AllocationBlockLength. Therefore, we have to check</c>
<c>                * if the allocated block is long enough, otherwise allocate a new block.</c>
<l>                if (PerClassNumPred[ClsIdx] &gt; |CurrentClassConfidences|)</l>
<l>                    CurrentClassConfidences := [CurrentClassConfidences,gen_tuple_const(AllocationBlockLength,-1)]</l>
<l>                endif</l>
<l>                CurrentClassConfidences[OldNumPred:PerClassNumPred[ClsIdx] - 1] := Confidences[CurrentResIdxs]</l>
<l>                set_dict_tuple (PerClassConfidences, 'class_' + ClassIDs[ClsIdx], CurrentClassConfidences)</l>
<c>                * </c>
<c>                * Sort the ground truth: Non-ignored instances first.</c>
<l>                GtSortIdx := sort_index(CurrentGtIgnore)</l>
<l>                CurrentGtIgnore := CurrentGtIgnore[GtSortIdx]</l>
<l>                CurrentGtIdxs := CurrentGtIdxs[GtSortIdx]</l>
<c>                * </c>
<c>                * Get orientations of result and ground truth instances.</c>
<l>                if (EvaluateOrientation)</l>
<l>                    CurrentResPhis := ResPhis[CurrentResIdxs]</l>
<l>                    CurrentGtPhis := GtPhis[CurrentGtIdxs]</l>
<l>                endif</l>
<c>                * </c>
<l>                if (CurrentNumRes &gt; 0)</l>
<c>                    * Loop over IoU thresholds.</c>
<l>                    for ITIdx := 0 to |IoUThresholds| - 1 by 1</l>
<c>                        * We check which ground truth and</c>
<c>                        * result instance can be matched.</c>
<l>                        GtMatched := gen_tuple_const(CurrentNumGt,0)</l>
<l>                        ResMatched := gen_tuple_const(CurrentNumRes,0)</l>
<c>                        * </c>
<l>                        if (EvaluateOrientation)</l>
<c>                            * Initialize the absolute orientation difference to -1.</c>
<l>                            ResAbsOrientationDiff := gen_tuple_const(CurrentNumRes,-1)</l>
<l>                        endif</l>
<c>                        * Store which detections should be ignored.</c>
<l>                        ResIgnore := gen_tuple_const(CurrentNumRes,0)</l>
<l>                        for ResIdx := 0 to CurrentNumRes - 1 by 1</l>
<c>                            * Set the currently best achieved IoU to the IoU threshold and</c>
<c>                            * initialize the matching index.</c>
<l>                            CurrentIoU := min2(IoUThresholds[ITIdx],1 - 1.0e-10)</l>
<l>                            MatchIdx := -1</l>
<c>                            * Loop over ground truth.</c>
<l>                            for GtIdx := 0 to CurrentNumGt - 1 by 1</l>
<c>                                * Continue if this ground truth has already been matched.</c>
<l>                                if (GtMatched[GtIdx])</l>
<l>                                    continue</l>
<l>                                endif</l>
<c>                                * Stop if matched with non-ignored ground truth and current ground truth is on ignore.</c>
<l>                                if (MatchIdx &gt; -1)</l>
<l>                                    if (CurrentGtIgnore[MatchIdx] == 0 and CurrentGtIgnore[GtIdx] == 1)</l>
<l>                                        break</l>
<l>                                    endif</l>
<l>                                endif</l>
<c>                                * Continue if IoU is not better than a previous match.</c>
<l>                                if (IoUs[CurrentGtIdxs[GtIdx] * NumRes + CurrentResIdxs[ResIdx]] &lt; CurrentIoU)</l>
<l>                                    continue</l>
<l>                                endif</l>
<c>                                * We got a new best match, store it.</c>
<l>                                CurrentIoU := IoUs[CurrentGtIdxs[GtIdx] * NumRes + CurrentResIdxs[ResIdx]]</l>
<l>                                MatchIdx := GtIdx</l>
<l>                            endfor</l>
<c>                            * If a match has been made we store it for both ground truth and result.</c>
<l>                            if (MatchIdx != -1)</l>
<c>                                * In COCO they use the IDs of GT and Res, we just use 1</c>
<c>                                * to indicate the matching, but don't store which one has been matched.</c>
<l>                                ResMatched[ResIdx] := 1</l>
<l>                                GtMatched[MatchIdx] := 1</l>
<l>                                ResIgnore[ResIdx] := CurrentGtIgnore[MatchIdx]</l>
<c>                                * </c>
<l>                                if (EvaluateOrientation)</l>
<c>                                    * Set the absolute orientation difference.</c>
<l>                                    ResAbsOrientationDiff[ResIdx] := abs(CurrentResPhis[ResIdx] - CurrentGtPhis[MatchIdx])</l>
<l>                                    if (ResAbsOrientationDiff[ResIdx] &gt; rad(180))</l>
<l>                                        ResAbsOrientationDiff[ResIdx] := rad(360) - ResAbsOrientationDiff[ResIdx]</l>
<l>                                    endif</l>
<l>                                endif</l>
<l>                            endif</l>
<l>                        endfor</l>
<c>                        * Ignore the unmatched results that are outside of the current area range.</c>
<l>                        AreaIgnore := CurrentResAreas [&lt;] MinArea or CurrentResAreas [&gt;] MaxArea</l>
<l>                        ResIgnore := (ResMatched [==] -1 and AreaIgnore [==] 1) or ResIgnore</l>
<c>                        * True positives are the matched results.</c>
<l>                        get_dict_tuple (AreaRunningMeasures, 'iou_' + regexp_replace('' + IoUThresholds[ITIdx],'\\.',''), PerIoUMeasure)</l>
<l>                        get_dict_tuple (PerIoUMeasure, 'class_' + ClassIDs[ClsIdx], PerClassMeasures)</l>
<l>                        get_dict_tuple (PerClassMeasures, 'is_tp', CurrentIsTP)</l>
<c>                        * As for confidences, check if we have to allocate a new block.</c>
<l>                        if (PerClassNumPred[ClsIdx] &gt; |CurrentIsTP|)</l>
<l>                            CurrentIsTP := [CurrentIsTP,gen_tuple_const(AllocationBlockLength,-1)]</l>
<l>                        endif</l>
<l>                        CurrentIsTP[OldNumPred:PerClassNumPred[ClsIdx] - 1] := ResMatched</l>
<l>                        set_dict_tuple (PerClassMeasures, 'is_tp', CurrentIsTP)</l>
<c>                        * Set the ignored results.</c>
<l>                        get_dict_tuple (PerClassMeasures, 'ignore', CurrentIgnore)</l>
<l>                        if (PerClassNumPred[ClsIdx] &gt; |CurrentIgnore|)</l>
<l>                            CurrentIgnore := [CurrentIgnore,gen_tuple_const(AllocationBlockLength,-1)]</l>
<l>                        endif</l>
<l>                        CurrentIgnore[OldNumPred:PerClassNumPred[ClsIdx] - 1] := ResIgnore</l>
<l>                        set_dict_tuple (PerClassMeasures, 'ignore', CurrentIgnore)</l>
<c>                        * Set the absolute orientation difference.</c>
<l>                        if (EvaluateOrientation)</l>
<l>                            get_dict_tuple (PerClassMeasures, 'abs_orientation_diff', CurrentAbsOrientationDiff)</l>
<l>                            if (PerClassNumPred[ClsIdx] &gt; |CurrentAbsOrientationDiff|)</l>
<l>                                CurrentAbsOrientationDiff := [CurrentAbsOrientationDiff,gen_tuple_const(AllocationBlockLength,-1)]</l>
<l>                            endif</l>
<l>                            CurrentAbsOrientationDiff[OldNumPred:PerClassNumPred[ClsIdx] - 1] := ResAbsOrientationDiff</l>
<l>                            set_dict_tuple (PerClassMeasures, 'abs_orientation_diff', CurrentAbsOrientationDiff)</l>
<l>                        endif</l>
<c>                        * </c>
<c>                        * Beginning of detailed evaluation processing (optional).</c>
<c>                        * </c>
<l>                        if (DetailedEvaluation)</l>
<c>                            * Check if there have been false negatives.</c>
<l>                            if (CurrentNumGtNoIgnore &gt; 0)</l>
<l>                                GtMatchedNoIgnore := GtMatched and not CurrentGtIgnore</l>
<l>                                if (sum(GtMatchedNoIgnore) &lt; CurrentNumGtNoIgnore)</l>
<l>                                    SampleHasFN[ITIdx] := true</l>
<l>                                endif</l>
<l>                            endif</l>
<c>                            * </c>
<c>                            * Initialize the detailed running measures.</c>
<l>                            ResIsFPClass := gen_tuple_const(CurrentNumRes,-1)</l>
<l>                            ResIsFPBackground := gen_tuple_const(CurrentNumRes,0)</l>
<l>                            ResIsFPLocalization := gen_tuple_const(CurrentNumRes,0)</l>
<l>                            ResIsFPDuplicate := gen_tuple_const(CurrentNumRes,0)</l>
<l>                            ResIsFPMultiple := gen_tuple_const(CurrentNumRes,0)</l>
<c>                            * </c>
<c>                            * Initialize detailed running measures for orientation difference.</c>
<l>                            if (EvaluateOrientation)</l>
<l>                                ResAbsOrientationDiffClass := gen_tuple_const(CurrentNumRes,-1)</l>
<l>                                ResAbsOrientationDiffLocalization := gen_tuple_const(CurrentNumRes,-1)</l>
<l>                                ResAbsOrientationDiffDuplicate := gen_tuple_const(CurrentNumRes,-1)</l>
<l>                                ResAbsOrientationDiffMultiple := gen_tuple_const(CurrentNumRes,-1)</l>
<l>                            endif</l>
<c>                            * Check if there have been false positives.</c>
<l>                            if (sum(ResMatched) &lt; CurrentNumRes)</l>
<l>                                SampleHasFP[ITIdx] := true</l>
<c>                                * </c>
<c>                                * For each false positive, find out what was the reason for being false positive:</c>
<l>                                FPResIdxsThisClass := find(ResMatched,0)</l>
<l>                                FPResIdxsAllResults := CurrentResIdxs[FPResIdxsThisClass]</l>
<l>                                GTIdxsNotToIgnore := find(GtIgnore,0)</l>
<l>                                for ResIdx := 0 to |FPResIdxsThisClass| - 1 by 1</l>
<l>                                    if (not ResIgnore[FPResIdxsThisClass[ResIdx]])</l>
<l>                                        if (|GTIdxsNotToIgnore| == 0 or GTIdxsNotToIgnore == -1)</l>
<c>                                            * No GT instances or all GT instances are ignored.</c>
<c>                                            * Thus, any detection is a background detection</c>
<l>                                            MaxIoU := 0.0</l>
<l>                                        else</l>
<c>                                            * We have GT instances to consider.</c>
<l>                                            IoUsWithGT := IoUs[GTIdxsNotToIgnore * NumRes + FPResIdxsAllResults[ResIdx]]</l>
<l>                                            MaxIoU := max(IoUsWithGT)</l>
<c>                                            * It is enough to look for the first occurrence because the IoUs to ground truth should be different.</c>
<l>                                            MaxIdx := find_first(IoUsWithGT,MaxIoU)</l>
<l>                                            GTClassIDMaxIoU := GtClassIDs[GTIdxsNotToIgnore[MaxIdx]]</l>
<l>                                        endif</l>
<l>                                        if (EvaluateOrientation and MaxIoU &gt; 0.0)</l>
<c>                                            * Calculate the absolute orientation difference to the GT instance with maximal IoU.</c>
<l>                                            AbsOrientationDiff := abs(ResPhis[FPResIdxsAllResults[ResIdx]] - GtPhis[GTIdxsNotToIgnore[MaxIdx]])</l>
<l>                                            if (AbsOrientationDiff &gt; rad(180))</l>
<l>                                                AbsOrientationDiff := rad(360) - AbsOrientationDiff</l>
<l>                                            endif</l>
<l>                                        endif</l>
<c>                                        * Determine false positive type.</c>
<l>                                        if (MaxIoU == 0.0)</l>
<c>                                            * Background detection. This detection does not overlap to any ground truth (that is not ignored).</c>
<l>                                            ResIsFPBackground[FPResIdxsThisClass[ResIdx]] := 1</l>
<l>                                        elseif (MaxIoU &gt;= IoUThresholds[ITIdx] and CurrentClassID != GTClassIDMaxIoU)</l>
<c>                                            * False class.</c>
<c>                                            * Note that this does not necessarily mean that this detection</c>
<c>                                            * would be a true positive if the class was changed. It could still be a duplicate.</c>
<l>                                            ResIsFPClass[FPResIdxsThisClass[ResIdx]] := ClassIDToClassIdx[GTClassIDMaxIoU]</l>
<c>                                            * Store the absolute orientation difference.</c>
<l>                                            if (EvaluateOrientation)</l>
<l>                                                ResAbsOrientationDiffClass[FPResIdxsThisClass[ResIdx]] := AbsOrientationDiff</l>
<l>                                            endif</l>
<l>                                        elseif (MaxIoU &gt;= IoUThresholds[ITIdx] and CurrentClassID == GTClassIDMaxIoU)</l>
<c>                                            * Duplicate detection. There must exist another detection with a higher confidence with the same ground truth.</c>
<l>                                            ResIsFPDuplicate[FPResIdxsThisClass[ResIdx]] := 1</l>
<c>                                            * Store the absolute orientation difference.</c>
<l>                                            if (EvaluateOrientation)</l>
<l>                                                ResAbsOrientationDiffDuplicate[FPResIdxsThisClass[ResIdx]] := AbsOrientationDiff</l>
<l>                                            endif</l>
<l>                                        elseif (MaxIoU &lt; IoUThresholds[ITIdx] and CurrentClassID == GTClassIDMaxIoU)</l>
<c>                                            * Bad localization. Class is correct, but the IoU is too low.</c>
<l>                                            ResIsFPLocalization[FPResIdxsThisClass[ResIdx]] := 1</l>
<c>                                            * Store the absolute orientation difference.</c>
<l>                                            if (EvaluateOrientation)</l>
<l>                                                ResAbsOrientationDiffLocalization[FPResIdxsThisClass[ResIdx]] := AbsOrientationDiff</l>
<l>                                            endif</l>
<l>                                        elseif (MaxIoU &lt; IoUThresholds[ITIdx] and CurrentClassID != GTClassIDMaxIoU)</l>
<c>                                            * Wrong class and bad localization.</c>
<l>                                            ResIsFPMultiple[FPResIdxsThisClass[ResIdx]] := 1</l>
<c>                                            * Store the absolute orientation difference.</c>
<l>                                            if (EvaluateOrientation)</l>
<l>                                                ResAbsOrientationDiffMultiple[FPResIdxsThisClass[ResIdx]] := AbsOrientationDiff</l>
<l>                                            endif</l>
<l>                                        else</l>
<c>                                            * This case should never occur.</c>
<l>                                            throw ('Fatal error during detailed evaluation.')</l>
<l>                                        endif</l>
<l>                                    endif</l>
<l>                                endfor</l>
<l>                            endif</l>
<c>                            * </c>
<c>                            * Overwrite the detailed running measures.</c>
<l>                            get_dict_tuple (PerClassMeasures, 'is_fp_class', IsFPClass)</l>
<l>                            get_dict_tuple (PerClassMeasures, 'is_fp_background', IsFPBackground)</l>
<l>                            get_dict_tuple (PerClassMeasures, 'is_fp_localization', IsFPLocalization)</l>
<l>                            get_dict_tuple (PerClassMeasures, 'is_fp_duplicate', IsFPDuplicate)</l>
<l>                            get_dict_tuple (PerClassMeasures, 'is_fp_multiple', IsFPMultiple)</l>
<l>                            if (EvaluateOrientation)</l>
<l>                                get_dict_tuple (PerClassMeasures, 'abs_orientation_diff_multiple', AbsOrientationDiffMultiple)</l>
<l>                                get_dict_tuple (PerClassMeasures, 'abs_orientation_diff_duplicate', AbsOrientationDiffDuplicate)</l>
<l>                                get_dict_tuple (PerClassMeasures, 'abs_orientation_diff_localization', AbsOrientationDiffLocalization)</l>
<l>                                get_dict_tuple (PerClassMeasures, 'abs_orientation_diff_class', AbsOrientationDiffClass)</l>
<l>                            endif</l>
<c>                            * Allocate new blocks if necessary (all have the same length).</c>
<l>                            if (PerClassNumPred[ClsIdx] &gt; |IsFPClass|)</l>
<l>                                IsFPClass := [IsFPClass,gen_tuple_const(AllocationBlockLength,-1)]</l>
<l>                                IsFPBackground := [IsFPBackground,gen_tuple_const(AllocationBlockLength,-1)]</l>
<l>                                IsFPLocalization := [IsFPLocalization,gen_tuple_const(AllocationBlockLength,-1)]</l>
<l>                                IsFPDuplicate := [IsFPDuplicate,gen_tuple_const(AllocationBlockLength,-1)]</l>
<l>                                IsFPMultiple := [IsFPMultiple,gen_tuple_const(AllocationBlockLength,-1)]</l>
<l>                                if (EvaluateOrientation)</l>
<l>                                    AbsOrientationDiffMultiple := [AbsOrientationDiffMultiple,gen_tuple_const(AllocationBlockLength,-1)]</l>
<l>                                    AbsOrientationDiffDuplicate := [AbsOrientationDiffDuplicate,gen_tuple_const(AllocationBlockLength,-1)]</l>
<l>                                    AbsOrientationDiffLocalization := [AbsOrientationDiffLocalization,gen_tuple_const(AllocationBlockLength,-1)]</l>
<l>                                    AbsOrientationDiffClass := [AbsOrientationDiffClass,gen_tuple_const(AllocationBlockLength,-1)]</l>
<l>                                endif</l>
<l>                            endif</l>
<l>                            IsFPClass[OldNumPred:PerClassNumPred[ClsIdx] - 1] := ResIsFPClass</l>
<l>                            IsFPBackground[OldNumPred:PerClassNumPred[ClsIdx] - 1] := ResIsFPBackground</l>
<l>                            IsFPLocalization[OldNumPred:PerClassNumPred[ClsIdx] - 1] := ResIsFPLocalization</l>
<l>                            IsFPDuplicate[OldNumPred:PerClassNumPred[ClsIdx] - 1] := ResIsFPDuplicate</l>
<l>                            IsFPMultiple[OldNumPred:PerClassNumPred[ClsIdx] - 1] := ResIsFPMultiple</l>
<l>                            if (EvaluateOrientation)</l>
<l>                                AbsOrientationDiffMultiple[OldNumPred:PerClassNumPred[ClsIdx] - 1] := ResAbsOrientationDiffMultiple</l>
<l>                                AbsOrientationDiffDuplicate[OldNumPred:PerClassNumPred[ClsIdx] - 1] := ResAbsOrientationDiffDuplicate</l>
<l>                                AbsOrientationDiffLocalization[OldNumPred:PerClassNumPred[ClsIdx] - 1] := ResAbsOrientationDiffLocalization</l>
<l>                                AbsOrientationDiffClass[OldNumPred:PerClassNumPred[ClsIdx] - 1] := ResAbsOrientationDiffClass</l>
<l>                            endif</l>
<l>                            set_dict_tuple (PerClassMeasures, 'is_fp_class', IsFPClass)</l>
<l>                            set_dict_tuple (PerClassMeasures, 'is_fp_background', IsFPBackground)</l>
<l>                            set_dict_tuple (PerClassMeasures, 'is_fp_localization', IsFPLocalization)</l>
<l>                            set_dict_tuple (PerClassMeasures, 'is_fp_duplicate', IsFPDuplicate)</l>
<l>                            set_dict_tuple (PerClassMeasures, 'is_fp_multiple', IsFPMultiple)</l>
<l>                            if (EvaluateOrientation)</l>
<l>                                set_dict_tuple (PerClassMeasures, 'abs_orientation_diff_multiple', AbsOrientationDiffMultiple)</l>
<l>                                set_dict_tuple (PerClassMeasures, 'abs_orientation_diff_duplicate', AbsOrientationDiffDuplicate)</l>
<l>                                set_dict_tuple (PerClassMeasures, 'abs_orientation_diff_localization', AbsOrientationDiffLocalization)</l>
<l>                                set_dict_tuple (PerClassMeasures, 'abs_orientation_diff_class', AbsOrientationDiffClass)</l>
<l>                            endif</l>
<l>                        endif</l>
<c>                        * </c>
<c>                        * End of detailed evaluation processing.</c>
<c>                        * </c>
<l>                    endfor</l>
<l>                else</l>
<l>                    if (DetailedEvaluation and CurrentNumGtNoIgnore &gt; 0)</l>
<c>                        * There are false negatives for this class.</c>
<c>                        * Loop over IoU thresholds.</c>
<l>                        for ITIdx := 0 to |IoUThresholds| - 1 by 1</l>
<l>                            SampleHasFN[ITIdx] := true</l>
<l>                        endfor</l>
<l>                    endif</l>
<l>                endif</l>
<l>            endfor</l>
<c>            * Update the confidences, num_gt and num_pred.</c>
<l>            set_dict_tuple (AreaRunningMeasures, 'num_gt', PerClassNumGt)</l>
<l>            set_dict_tuple (AreaRunningMeasures, 'num_pred', PerClassNumPred)</l>
<l>            set_dict_tuple (AreaRunningMeasures, 'confidence', PerClassConfidences)</l>
<l>            set_dict_tuple (AreaRunningMeasures, 'num_gt_ignore', PerClassNumGtIgnore)</l>
<c>            * </c>
<l>            if (DetailedEvaluation)</l>
<c>                * Set values that are calculated over all classes (for each IoU threshold).</c>
<l>                for ITIdx := 0 to |IoUThresholds| - 1 by 1</l>
<l>                    get_dict_tuple (AreaRunningMeasures, 'iou_' + regexp_replace('' + IoUThresholds[ITIdx],'\\.',''), PerIoUMeasure)</l>
<c>                    * Set image IDs with false negatives</c>
<l>                    if (SampleHasFN[ITIdx])</l>
<l>                        get_dict_tuple (CurrentSample, 'image_id', CurrentImageID)</l>
<l>                        get_dict_tuple (PerIoUMeasure, 'image_ids_with_false_negatives', ImageIDsWithFN)</l>
<l>                        get_dict_tuple (PerIoUMeasure, 'num_image_ids_with_false_negatives', NumImageIDsWithFN)</l>
<c>                        * Allocate a new block if necessary.</c>
<l>                        if (NumImageIDsWithFN + 1 &gt; |ImageIDsWithFN|)</l>
<l>                            ImageIDsWithFN := [ImageIDsWithFN,gen_tuple_const(AllocationBlockLength,-1)]</l>
<l>                        endif</l>
<l>                        ImageIDsWithFN[NumImageIDsWithFN] := CurrentImageID</l>
<l>                        set_dict_tuple (PerIoUMeasure, 'image_ids_with_false_negatives', ImageIDsWithFN)</l>
<l>                        set_dict_tuple (PerIoUMeasure, 'num_image_ids_with_false_negatives', NumImageIDsWithFN + 1)</l>
<l>                    endif</l>
<l>                    if (SampleHasFP[ITIdx])</l>
<l>                        get_dict_tuple (CurrentSample, 'image_id', CurrentImageID)</l>
<l>                        get_dict_tuple (PerIoUMeasure, 'image_ids_with_false_positives', ImageIDsWithFP)</l>
<l>                        get_dict_tuple (PerIoUMeasure, 'num_image_ids_with_false_positives', NumImageIDsWithFP)</l>
<c>                        * Allocate a new block if necessary.</c>
<l>                        if (NumImageIDsWithFP + 1 &gt; |ImageIDsWithFP|)</l>
<l>                            ImageIDsWithFP := [ImageIDsWithFP,gen_tuple_const(AllocationBlockLength,-1)]</l>
<l>                        endif</l>
<l>                        ImageIDsWithFP[NumImageIDsWithFP] := CurrentImageID</l>
<l>                        set_dict_tuple (PerIoUMeasure, 'image_ids_with_false_positives', ImageIDsWithFP)</l>
<l>                        set_dict_tuple (PerIoUMeasure, 'num_image_ids_with_false_positives', NumImageIDsWithFP + 1)</l>
<l>                    endif</l>
<l>                endfor</l>
<l>            endif</l>
<l>        endfor</l>
<l>        set_dict_tuple (CurrentRunningMeasures, 'area_' + AreaName, AreaRunningMeasures)</l>
<l>    endfor</l>
<l>endfor</l>
<c>* </c>
<l>return ()</l>
</body>
<docu id="update_running_instance_measures">
<abstract lang="en_US">This procedure updates the RunningMeasures for an instance-based evaluation for detection.
These measures are stored in the dictionary RunningMeasures and updated by incorporating the Results the model obtained for the Samples.
</abstract>
<chapters lang="de_DE">
<item>Deep Learning</item>
<item>Evaluierung</item>
</chapters>
<chapters lang="en_US">
<item>Deep Learning</item>
<item>Evaluation</item>
</chapters>
<library lang="en_US">MVTec Standard Procedures</library>
<short lang="en_US">Update running measures for an instance-based evaluation.</short>
<parameters>
<parameter id="EvalParams">
<default_type>integer</default_type>
<default_value>EvalParams</default_value>
<description lang="en_US">Dictionary containing the evaluation parameters.</description>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>dict</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="Results">
<default_type>integer</default_type>
<default_value>Results</default_value>
<description lang="en_US">Dictionaries with the results obtained for the Samples.</description>
<mixed_type>false</mixed_type>
<multivalue>optional</multivalue>
<sem_type>dict</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="RunningMeasures">
<default_type>integer</default_type>
<default_value>RunningMeasures</default_value>
<description lang="en_US">Dictionary with the running measures to be updated in-place.</description>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>dict</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="Samples">
<default_type>integer</default_type>
<default_value>Samples</default_value>
<description lang="en_US">Dictonaries of the samples including their ground truth annotations.</description>
<mixed_type>false</mixed_type>
<multivalue>optional</multivalue>
<sem_type>dict</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
</parameters>
</docu>
</procedure>
<procedure name="update_running_pixel_measures" access="local">
<interface>
<ic>
<par name="Samples" base_type="ctrl" dimension="0"/>
<par name="Results" base_type="ctrl" dimension="0"/>
<par name="EvalParams" base_type="ctrl" dimension="0"/>
<par name="RunningMeasures" base_type="ctrl" dimension="0"/>
</ic>
</interface>
<body>
<c>* </c>
<c>* This procedure updates the RunningMeasures</c>
<c>* for a pixel-based evaluation for segmentation.</c>
<c>* These measures are stored in the dictionary RunningMeasures and</c>
<c>* updated by incorporating the Results the model obtained for the Samples.</c>
<c>* </c>
<c>* Get the class IDs.</c>
<l>get_dict_tuple (EvalParams, 'class_ids', ClassIDs)</l>
<c>* Get the ignore class IDs.</c>
<l>get_dict_tuple (EvalParams, 'ignore_class_ids', IgnoreClassIDs)</l>
<c>* Check if we need to compute/update the confusion matrix.</c>
<l>get_dict_tuple (EvalParams, 'measures', Measures)</l>
<l>CalcConfMatrix := (find(Measures,'pixel_confusion_matrix') &gt; -1) or (find(Measures,'all') &gt; -1)</l>
<c>* Get the number of classes.</c>
<l>get_dict_tuple (EvalParams, 'num_classes', NumClasses)</l>
<c>* Get the maximum class ID plus a possible ignore-class.</c>
<l>MaxId := max(ClassIDs) + (|IgnoreClassIDs| &gt; 0)</l>
<c>* </c>
<l>if (CalcConfMatrix)</l>
<c>    * Get the current confusion matrix.</c>
<l>    get_dict_tuple (RunningMeasures, 'pixel_confusion_matrix', ConfMatrix)</l>
<c>    * Check if we need to map the class IDs.</c>
<l>    get_dict_param (EvalParams, 'key_exists', 'class_id_mapping', MapClassIDs)</l>
<l>    if (MapClassIDs)</l>
<l>        get_dict_tuple (EvalParams, 'class_id_mapping', ClsIdToClsIdx)</l>
<l>        NumClasses := max(ClsIdToClsIdx) + 1</l>
<l>    endif</l>
<l>else</l>
<c>    * Get the tuples for TP/FP/FN</c>
<l>    get_dict_tuple (RunningMeasures, 'tp', TP)</l>
<l>    get_dict_tuple (RunningMeasures, 'fp', FP)</l>
<l>    get_dict_tuple (RunningMeasures, 'fn', FN)</l>
<l>endif</l>
<c>* </c>
<c>* Loop over images, i.e. sample dicts.</c>
<l>for SampleIndex := 0 to |Samples| - 1 by 1</l>
<c>    * Get annotation.</c>
<l>    get_dict_object (Annot, Samples[SampleIndex], 'segmentation_image')</l>
<c>    * Get result.</c>
<l>    get_dict_object (Result, Results[SampleIndex], 'segmentation_image')</l>
<c>    * </c>
<c>    * Update the measures.</c>
<l>    if (CalcConfMatrix)</l>
<c>        * Get the ground truth and predicted class IDs of all pixels.</c>
<l>        get_region_points (Annot, Rows, Columns)</l>
<l>        get_grayval (Annot, Rows, Columns, AnnotVals)</l>
<l>        get_grayval (Result, Rows, Columns, ResultVals)</l>
<c>        * Map the class IDs to class indices.</c>
<l>        if (MapClassIDs)</l>
<l>            AnnotVals := ClsIdToClsIdx[AnnotVals]</l>
<l>            ResultVals := ClsIdToClsIdx[ResultVals]</l>
<l>        endif</l>
<c>        * The ground truth and predicted IDs are accumulated</c>
<c>        * such that each confusion pair (class_i &lt;-&gt; class_j) gets a unique value.</c>
<l>        ConfTuple := NumClasses * AnnotVals + ResultVals</l>
<c>        * Compute the histogram of this confusion tuple.</c>
<l>        tuple_histo_range (ConfTuple, 0, NumClasses * NumClasses - 1, NumClasses * NumClasses, ConfHist, BinSize)</l>
<l>        create_matrix (NumClasses, NumClasses, ConfHist, ConfMatrixTmp)</l>
<l>        transpose_matrix (ConfMatrixTmp, ConfMatrixTmp)</l>
<l>        add_matrix (ConfMatrix, ConfMatrixTmp, ConfMatrix)</l>
<l>    else</l>
<c>        * Get the ignore region.</c>
<l>        gen_empty_region (ClsIgnore)</l>
<l>        for IgnoreIndex := 0 to |IgnoreClassIDs| - 1 by 1</l>
<l>            threshold (Annot, ClsIgnoreTmp, IgnoreClassIDs[IgnoreIndex], IgnoreClassIDs[IgnoreIndex])</l>
<l>            union2 (ClsIgnore, ClsIgnoreTmp, ClsIgnore)</l>
<l>        endfor</l>
<c>        * </c>
<c>        * Go through model classes.</c>
<l>        for ClsIndex := 0 to |ClassIDs| - 1 by 1</l>
<l>            ClsId := ClassIDs[ClsIndex]</l>
<c>            * Get the annotated region for this class.</c>
<l>            threshold (Annot, ClsAnnot, ClsId, ClsId)</l>
<c>            * Get the result region for this class.</c>
<l>            threshold (Result, ClsResult, ClsId, ClsId)</l>
<c>            * The pixels in the ignore region should not be considered.</c>
<l>            difference (ClsResult, ClsIgnore, ClsResult)</l>
<c>            * Get TP/FP/FN.</c>
<l>            intersection (ClsAnnot, ClsResult, TPReg)</l>
<l>            difference (ClsResult, ClsAnnot, FPReg)</l>
<c>            * We define false negatives as pixels that have been labeled as this class,</c>
<c>            * but not been correctly predicted.</c>
<l>            difference (ClsAnnot, ClsResult, FNReg)</l>
<c>            * Get corresponding pixel numbers and update.</c>
<l>            region_features (TPReg, 'area', ClsTP)</l>
<l>            region_features (FPReg, 'area', ClsFP)</l>
<l>            region_features (FNReg, 'area', ClsFN)</l>
<l>            TP[ClsIndex] := TP[ClsIndex] + ClsTP</l>
<l>            FP[ClsIndex] := FP[ClsIndex] + ClsFP</l>
<l>            FN[ClsIndex] := FN[ClsIndex] + ClsFN</l>
<l>        endfor</l>
<l>    endif</l>
<l>endfor</l>
<c>* </c>
<c>* Update running measures.</c>
<l>if (CalcConfMatrix)</l>
<l>    set_dict_tuple (RunningMeasures, 'pixel_confusion_matrix', ConfMatrix)</l>
<l>else</l>
<l>    set_dict_tuple (RunningMeasures, 'tp', TP)</l>
<l>    set_dict_tuple (RunningMeasures, 'fp', FP)</l>
<l>    set_dict_tuple (RunningMeasures, 'fn', FN)</l>
<l>endif</l>
<c>* </c>
<l>return ()</l>
</body>
<docu id="update_running_pixel_measures">
<abstract lang="en_US">This procedure updates the RunningMeasures for a pixel-based evaluation for segmentation.
These measures are stored in the dictionary RunningMeasures and updated by incorporating the Results the model obtained for the Samples.

</abstract>
<chapters lang="de_DE">
<item>Deep Learning</item>
<item>Evaluierung</item>
</chapters>
<chapters lang="en_US">
<item>Deep Learning</item>
<item>Evaluation</item>
</chapters>
<library lang="en_US">MVTec Standard Procedures</library>
<short lang="en_US">Update running measures for a pixel-based evaluation.</short>
<parameters>
<parameter id="EvalParams">
<default_type>integer</default_type>
<default_value>EvalParams</default_value>
<description lang="en_US">Dictionary with the evaluation parameters.</description>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>dict</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="Results">
<default_type>integer</default_type>
<default_value>Results</default_value>
<description lang="en_US">Dictionaries with the results obtained for the Samples.</description>
<mixed_type>false</mixed_type>
<multivalue>optional</multivalue>
<sem_type>dict</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="RunningMeasures">
<default_type>integer</default_type>
<default_value>RunningMeasures</default_value>
<description lang="en_US">Dictionary with the running measures to be updated in-place.</description>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>dict</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="Samples">
<default_type>integer</default_type>
<default_value>Samples</default_value>
<description lang="en_US">Dictonaries of the samples including their ground truth annotations.</description>
<mixed_type>false</mixed_type>
<multivalue>optional</multivalue>
<sem_type>dict</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
</parameters>
</docu>
</procedure>
<procedure name="update_train_dl_model_change_strategies" access="local">
<interface>
<ic>
<par name="DLModelHandle" base_type="ctrl" dimension="0"/>
<par name="ChangeStrategyData" base_type="ctrl" dimension="0"/>
<par name="Epoch" base_type="ctrl" dimension="0"/>
</ic>
</interface>
<body>
<c>* </c>
<c>* This procedure updates all parameters according to the change strategies</c>
<c>* with respect to the current iteration.</c>
<c>* </c>
<l>get_dict_tuple (ChangeStrategyData, 'enabled', Enabled)</l>
<l>if (not Enabled)</l>
<l>    return ()</l>
<l>endif</l>
<c>* </c>
<l>get_dict_tuple (ChangeStrategyData, 'strategies', ChangeStrategies)</l>
<c>* </c>
<c>* Update the parameter of each strategy.</c>
<l>for Index := 0 to |ChangeStrategies| - 1 by 1</l>
<l>    ChangeStrategy := ChangeStrategies[Index]</l>
<l>    get_dict_tuple (ChangeStrategy, 'model_param', ModelParam)</l>
<l>    get_dict_tuple (ChangeStrategy, 'epochs', Epochs)</l>
<l>    get_dict_tuple (ChangeStrategy, 'values', Values)</l>
<l>    get_dict_tuple (ChangeStrategy, 'initial_value', Initial)</l>
<c>    * Epochs defines at which epoch the change happens. Its sorting is enforced during initialization.</c>
<l>    Greater := Epoch [&gt;=] Epochs</l>
<l>    tuple_find_last (Greater, 1, ValueIndex)</l>
<l>    if (ValueIndex == -1)</l>
<l>        Value := Initial</l>
<l>    else</l>
<l>        Value := Values[ValueIndex]</l>
<l>    endif</l>
<c>    * Check current value and only make changes if the value changed.</c>
<l>    get_dict_param (ChangeStrategy, 'key_exists', 'internal_current_value', InternalCurrentExists)</l>
<l>    if (InternalCurrentExists)</l>
<l>        get_dict_tuple (ChangeStrategy, 'internal_current_value', InternalCurrent)</l>
<l>    else</l>
<l>        get_dl_model_param (DLModelHandle, ModelParam, InternalCurrent)</l>
<l>    endif</l>
<c>    * If the current value differs from the new value we change it.</c>
<l>    if (sum(InternalCurrent [!=] Value) &gt; 0)</l>
<c>        * If the changed model parameter is the learning rate, we also change the momentum</c>
<c>        * to adapt the scale of the previous update.</c>
<l>        if (ModelParam == 'learning_rate')</l>
<c>            * Get the threshold.</c>
<l>            get_dict_tuple (ChangeStrategy, 'scale_momentum_threshold', ScaleThreshold)</l>
<l>            if (|ScaleThreshold| &gt; 0)</l>
<l>                get_dl_model_param (DLModelHandle, ModelParam, CurrentLR)</l>
<c>                * Check if the change is larger than the specified threshold.</c>
<l>                LRChangeRatio := max2(real(Value) / max2(CurrentLR,1e-10),real(CurrentLR) / max2(Value,1e-10))</l>
<l>                if (LRChangeRatio &gt; ScaleThreshold and CurrentLR &gt; 1e-7)</l>
<l>                    get_dict_param (ChangeStrategy, 'key_exists', 'previous_momentum', PreviousMomentumExists)</l>
<l>                    if (PreviousMomentumExists)</l>
<l>                        get_dict_tuple (ChangeStrategy, 'previous_momentum', CurrentMomentum)</l>
<l>                    else</l>
<l>                        get_dl_model_param (DLModelHandle, 'momentum', CurrentMomentum)</l>
<l>                    endif</l>
<l>                    AdaptedMomentum := Value / real(CurrentLR) * CurrentMomentum</l>
<l>                    set_dl_model_param (DLModelHandle, 'momentum', AdaptedMomentum)</l>
<c>                    * In the next iteration the momentum has to be set back.</c>
<l>                    set_dict_tuple (ChangeStrategy, 'adapted_momentum', true)</l>
<l>                    set_dict_tuple (ChangeStrategy, 'previous_momentum', CurrentMomentum)</l>
<l>                endif</l>
<l>            endif</l>
<l>        endif</l>
<l>        set_dl_model_param (DLModelHandle, ModelParam, Value)</l>
<l>    elseif (ModelParam == 'learning_rate')</l>
<c>        * Get the threshold.</c>
<l>        get_dict_tuple (ChangeStrategy, 'scale_momentum_threshold', ScaleThreshold)</l>
<l>        if (|ScaleThreshold| &gt; 0)</l>
<c>            * Set the momentum back if it was adapted in the previous iteration.</c>
<l>            get_dict_param (ChangeStrategy, 'key_exists', 'adapted_momentum', AdaptedMomentumExists)</l>
<l>            if (AdaptedMomentumExists)</l>
<l>                get_dict_tuple (ChangeStrategy, 'adapted_momentum', AdaptedMomentum)</l>
<l>                if (AdaptedMomentum)</l>
<l>                    get_dict_tuple (ChangeStrategy, 'previous_momentum', PreviousMomentum)</l>
<l>                    set_dl_model_param (DLModelHandle, 'momentum', PreviousMomentum)</l>
<l>                    set_dict_tuple (ChangeStrategy, 'adapted_momentum', false)</l>
<l>                    remove_dict_key (ChangeStrategy, 'previous_momentum')</l>
<l>                endif</l>
<l>            endif</l>
<l>        endif</l>
<l>    endif</l>
<c>    * Store the new internal current value.</c>
<l>    set_dict_tuple (ChangeStrategy, 'internal_current_value', Value)</l>
<l>endfor</l>
<l>return ()</l>
</body>
<docu id="update_train_dl_model_change_strategies">
<abstract lang="en_US">This procedure updates the model parameters according to the change strategies given in the dictionary ChangeStrategyData with respect to the current epoch.
The dictionary determines the change strategy and is initialized by init_train_dl_model_change_strategies.</abstract>
<chapters lang="de_DE">
<item>Deep Learning</item>
<item>Modell</item>
</chapters>
<chapters lang="en_US">
<item>Deep Learning</item>
<item>Model</item>
</chapters>
<library lang="en_US">MVTec Standard Procedures</library>
<short lang="en_US">Update model parameters according to the change strategies.</short>
<parameters>
<parameter id="ChangeStrategyData">
<default_type>integer</default_type>
<description lang="en_US">Dictionary with the data concerning the change strategies.</description>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>dict</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="DLModelHandle">
<default_type>integer</default_type>
<description lang="en_US">Handle of the deep-learning-based model.</description>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>dl_model</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="Epoch">
<description lang="en_US">Current epoch iteration.</description>
</parameter>
</parameters>
</docu>
</procedure>
<procedure name="update_train_dl_model_serialization" access="local">
<interface>
<ic>
<par name="TrainParam" base_type="ctrl" dimension="0"/>
<par name="SerializationData" base_type="ctrl" dimension="0"/>
<par name="Iteration" base_type="ctrl" dimension="0"/>
<par name="NumIterations" base_type="ctrl" dimension="0"/>
<par name="Epoch" base_type="ctrl" dimension="0"/>
<par name="EvaluationResult" base_type="ctrl" dimension="0"/>
<par name="DLModelHandle" base_type="ctrl" dimension="0"/>
<par name="TrainInfos" base_type="ctrl" dimension="0"/>
<par name="EvaluationInfos" base_type="ctrl" dimension="0"/>
</ic>
</interface>
<body>
<c>* </c>
<c>* Serialize the model if a strategy applies to the current training status.</c>
<c>* </c>
<l>get_dict_tuple (SerializationData, 'raw_data', RawData)</l>
<l>get_dict_tuple (SerializationData, 'types', Types)</l>
<l>get_dict_tuple (SerializationData, 'strategies', Strategies)</l>
<c>* </c>
<c></c>
<l>for Index := 0 to |Types| - 1 by 1</l>
<c>    * </c>
<l>    Type := Types[Index]</l>
<l>    Data := RawData[Index]</l>
<l>    Strategy := Strategies[Index]</l>
<c>    * </c>
<l>    if (Type == 'best')</l>
<c>        * If there is no new evaluation result, we will not serialize.</c>
<l>        if (|EvaluationResult| == 0)</l>
<l>            continue</l>
<l>        endif</l>
<c>        * Get result and check if the new result is better than the serialized old result.</c>
<l>        get_dict_tuple (TrainParam, 'evaluation_comparison_keys', EvaluationComparisonKeys)</l>
<l>        reduce_dl_evaluation_result (EvaluationResult, EvaluationComparisonKeys, Value, ValidEvaluationKeys)</l>
<l>        get_dict_tuple (Data, 'best_value', CurrentBest)</l>
<l>        get_dl_model_param (DLModelHandle, 'type', ModelType)</l>
<c>        * For some model types the score is maximalized, for others it is minimalized.</c>
<l>        if (ModelType == 'classification')</l>
<l>            BestScoreHighest := 0</l>
<l>        else</l>
<l>            BestScoreHighest := 1</l>
<l>        endif</l>
<l>        if (CurrentBest == -1 or ((Value &lt; CurrentBest) and not BestScoreHighest) or ((Value &gt; CurrentBest) and BestScoreHighest))</l>
<l>            set_dict_tuple (Data, 'best_value', Value)</l>
<l>            serialize_train_dl_model_intermediate (DLModelHandle, Epoch, Strategy, TrainInfos, EvaluationInfos, FilenameModel, FilenameMetaData)</l>
<l>        endif</l>
<l>    elseif (Type == 'final')</l>
<l>        if (Iteration == NumIterations - 1)</l>
<c>            * Serialize final model.</c>
<l>            serialize_train_dl_model_intermediate (DLModelHandle, Epoch, Strategy, TrainInfos, EvaluationInfos, FilenameModel, FilenameMetaData)</l>
<l>        endif</l>
<l>    elseif (Type == 'epochs')</l>
<c>        * Check if the specified epoch is reached.</c>
<l>        get_dict_tuple (Data, 'epochs', Epochs)</l>
<l>        tuple_find_last (Epoch [&lt;=] Epochs, 0, Indices)</l>
<c>        * Also check that the last saved epoch is not the same.</c>
<l>        get_dict_tuple (Data, 'last_epoch_index', LastIndex)</l>
<l>        if (|Indices| &gt; 0)</l>
<c>            * </c>
<l>            if (Indices[0] &gt; -1 and Indices[0] != LastIndex)</l>
<l>                set_dict_tuple (Data, 'last_epoch_index', Indices[0])</l>
<c>                * Serialize final model.</c>
<l>                serialize_train_dl_model_intermediate (DLModelHandle, Epoch, Strategy, TrainInfos, EvaluationInfos, FilenameModel, FilenameMetaData)</l>
<l>            endif</l>
<l>        endif</l>
<l>    endif</l>
<l>endfor</l>
<c>* </c>
<l>return ()</l>
</body>
<docu id="update_train_dl_model_serialization">
<abstract lang="en_US">This procedure serializes the model if a strategy applies to the current training status.
</abstract>
<chapters lang="de_DE">
<item>Deep Learning</item>
<item>Modell</item>
</chapters>
<chapters lang="en_US">
<item>Deep Learning</item>
<item>Model</item>
</chapters>
<library lang="en_US">MVTec Standard Procedures</library>
<short lang="en_US">Serialize the model if a strategy applies to the current training status.</short>
<parameters>
<parameter id="DLModelHandle">
<default_type>integer</default_type>
<description lang="en_US">Handle of the deep-learning-based model.</description>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>dl_model</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="Epoch">
<default_type>real</default_type>
<description lang="en_US">Current epoch iteration.</description>
<multivalue>false</multivalue>
<sem_type>real</sem_type>
<type_list>
<item>real</item>
</type_list>
<value_min>0.000000</value_min>
</parameter>
<parameter id="EvaluationInfos">
<default_type>integer</default_type>
<description lang="en_US">Evaluation information which is calculated during the training.</description>
<mixed_type>false</mixed_type>
<multivalue>optional</multivalue>
<sem_type>dict</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="EvaluationResult">
<default_type>integer</default_type>
<description lang="en_US">Dictionary with the evaluation results.</description>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>dict</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="Iteration">
<default_type>integer</default_type>
<mixed_type>false</mixed_type>
<sem_type>integer</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="NumIterations">
<default_type>integer</default_type>
<sem_type>integer</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="SerializationData">
<default_type>integer</default_type>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>dict</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="TrainInfos">
<default_type>integer</default_type>
<description lang="en_US">Dictionary or tuple of dictionaries with summarized training status information.</description>
<mixed_type>false</mixed_type>
<multivalue>optional</multivalue>
<sem_type>dict</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="TrainParam">
<default_type>integer</default_type>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>dict</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
</parameters>
</docu>
</procedure>
<procedure name="update_window_meta_information" access="local">
<interface>
<ic>
<par name="WindowHandle" base_type="ctrl" dimension="0"/>
<par name="WidthImage" base_type="ctrl" dimension="0"/>
<par name="HeightImage" base_type="ctrl" dimension="0"/>
<par name="WindowRow1" base_type="ctrl" dimension="0"/>
<par name="WindowColumn1" base_type="ctrl" dimension="0"/>
<par name="MapColorBarWidth" base_type="ctrl" dimension="0"/>
<par name="MarginBottom" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="WindowImageRatioHeight" base_type="ctrl" dimension="0"/>
<par name="WindowImageRatioWidth" base_type="ctrl" dimension="0"/>
<par name="SetPartRow2" base_type="ctrl" dimension="0"/>
<par name="SetPartColumn2" base_type="ctrl" dimension="0"/>
<par name="PrevWindowCoordinatesOut" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c>* </c>
<c>* This procedure sets and returns meta information to display images correctly.</c>
<c>* </c>
<c>* Set part for the image to be displayed later and adapt window size (+ MarginBottom + MapColorBarWidth).</c>
<l>get_window_extents (WindowHandle, _, _, WindowWidth, WindowHeight)</l>
<l>WindowImageRatioHeight := WindowHeight / (HeightImage * 1.0)</l>
<l>WindowImageRatioWidth := WindowWidth / (WidthImage * 1.0)</l>
<c>* </c>
<c>* Set window part such that image is displayed undistorted.</c>
<l>WindowRow2 := WindowHeight</l>
<l>WindowColumn2 := WindowWidth</l>
<l>WindowRatio := WindowColumn2 / (WindowRow2 * 1.0)</l>
<c>* </c>
<l>ImageRow2 := HeightImage + MarginBottom / WindowImageRatioHeight</l>
<l>ImageColumn2 := WidthImage + MapColorBarWidth / WindowImageRatioWidth</l>
<l>ImageRatio := ImageColumn2 / (ImageRow2 * 1.0)</l>
<l>if (ImageRatio &gt; WindowRatio)</l>
<c>    * </c>
<c>    * Extend image until right window border.</c>
<l>    SetPartColumn2 := ImageColumn2</l>
<l>    ImageWindowRatioHeight := ImageColumn2 / (WindowColumn2 * 1.0)</l>
<l>    ImageRow2InWindow := ImageRow2 / ImageWindowRatioHeight</l>
<l>    SetPartRow2 := ImageRow2 + (WindowRow2 - ImageRow2InWindow) / WindowImageRatioWidth</l>
<l>else</l>
<c>    * </c>
<c>    * Extend image until bottom of window.</c>
<l>    SetPartRow2 := ImageRow2</l>
<l>    ImageWindowRatioHeight := ImageRow2 / (WindowRow2 * 1.0)</l>
<l>    ImageCol2InWindow := ImageColumn2 / ImageWindowRatioHeight</l>
<l>    SetPartColumn2 := ImageColumn2 + (WindowColumn2 - ImageCol2InWindow) / WindowImageRatioHeight</l>
<l>endif</l>
<l>dev_set_part (0, 0, SetPartRow2, SetPartColumn2)</l>
<c>* </c>
<c>* Return the coordinates of the new window.</c>
<l>PrevWindowCoordinatesOut := [WindowRow1,WindowColumn1,WindowWidth,WindowHeight]</l>
<c>* </c>
<l>return ()</l>
</body>
<docu id="update_window_meta_information">
<chapters lang="de_DE">
<item>Graphik</item>
<item>Fenster</item>
</chapters>
<chapters lang="en_US">
<item>Graphics</item>
<item>Window</item>
</chapters>
<library lang="en_US">MVTec Standard Procedures</library>
<short lang="en_US">This procedure sets and returns meta information to display images correctly.</short>
<parameters>
<parameter id="HeightImage">
<default_type>integer</default_type>
<multivalue>false</multivalue>
<sem_type>integer</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="MapColorBarWidth">
<default_type>integer</default_type>
<multivalue>false</multivalue>
<sem_type>integer</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="MarginBottom"/>
<parameter id="PrevWindowCoordinatesOut">
<default_type>integer</default_type>
<multivalue>true</multivalue>
<sem_type>integer</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="SetPartColumn2">
<default_type>integer</default_type>
<multivalue>false</multivalue>
<sem_type>integer</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="SetPartRow2">
<default_type>integer</default_type>
<multivalue>false</multivalue>
<sem_type>integer</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="WidthImage">
<default_type>integer</default_type>
<multivalue>false</multivalue>
<sem_type>integer</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="WindowColumn1">
<default_type>integer</default_type>
<multivalue>false</multivalue>
<sem_type>integer</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="WindowHandle">
<default_type>integer</default_type>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>window</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="WindowImageRatioHeight">
<default_type>real</default_type>
<multivalue>false</multivalue>
<sem_type>real</sem_type>
<type_list>
<item>real</item>
</type_list>
</parameter>
<parameter id="WindowImageRatioWidth"/>
<parameter id="WindowRow1">
<default_type>integer</default_type>
<multivalue>false</multivalue>
<sem_type>integer</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
</parameters>
</docu>
</procedure>
<procedure name="validate_evaluation_param" access="local">
<interface>
<ic>
<par name="EvalParams" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="Valid" base_type="ctrl" dimension="0"/>
<par name="Exception" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c>* </c>
<c>* This procedure checks if the dictionary EvalParams</c>
<c>* contains all necessary parameters and if they are valid (type, range, ...).</c>
<c>* </c>
<l>Valid := false</l>
<l>Exception := ''</l>
<c>* Check class IDs.</c>
<l>get_dict_param (EvalParams, 'key_exists', 'class_ids', ClassIDsExist)</l>
<l>if (not ClassIDsExist)</l>
<l>    Exception := 'The evaluation parameters need a key-value pair for \'class_ids\''</l>
<l>    return ()</l>
<l>else</l>
<l>    get_dict_tuple (EvalParams, 'class_ids', ClassIDs)</l>
<l>    if (|ClassIDs| &lt; 1)</l>
<l>        Exception := '\'class_ids\' should have at least length 1'</l>
<l>        return ()</l>
<l>    endif</l>
<l>    if (is_int_elem(ClassIDs) != gen_tuple_const(|ClassIDs|,1))</l>
<l>        Exception := '\'class_ids\' should be of type int'</l>
<l>        return ()</l>
<l>    endif</l>
<l>    if (find(ClassIDs [&lt;] 0,1) &gt; -1)</l>
<l>        Exception := '\'class_ids\' should be positive or zero'</l>
<l>        return ()</l>
<l>    endif</l>
<l>endif</l>
<c>* Check the entry num_classes.</c>
<l>get_dict_param (EvalParams, 'key_exists', 'num_classes', NumClassesExist)</l>
<l>if (not NumClassesExist)</l>
<l>    Exception := 'The evaluation parameters need a key-value pair for \'num_classes\''</l>
<l>    return ()</l>
<l>else</l>
<l>    get_dict_tuple (EvalParams, 'num_classes', NumClasses)</l>
<l>    if (|NumClasses| != 1)</l>
<l>        Exception := '\'num_classes\' should have length 1'</l>
<l>        return ()</l>
<l>    endif</l>
<l>    if (type(NumClasses) != type(int(1)))</l>
<l>        Exception := '\'num_classes\' should be of type int'</l>
<l>        return ()</l>
<l>    endif</l>
<l>    if (NumClasses &lt; 1)</l>
<l>        Exception := '\'num_classes\' should be at least 1'</l>
<l>        return ()</l>
<l>    endif</l>
<l>endif</l>
<c>* Check that num_classes is equal to |class_ids|.</c>
<l>if (NumClasses != |ClassIDs|)</l>
<l>    Exception := '\'num_classes\' has to be set to the number of \'class_ids\''</l>
<l>    return ()</l>
<l>endif</l>
<c>* Check the entry 'evaluate_instances'.</c>
<l>get_dict_param (EvalParams, 'key_exists', 'evaluate_instances', EvalInstancesExists)</l>
<l>if (not EvalInstancesExists)</l>
<l>    Exception := 'The evaluation parameters need a key-value pair for \'evaluate_instances\''</l>
<l>    return ()</l>
<l>endif</l>
<c>* Check the entry 'evaluation_type'.</c>
<l>get_dict_param (EvalParams, 'key_exists', 'evaluation_type', EvaluationTypeExists)</l>
<l>if (not EvaluationTypeExists)</l>
<l>    Exception := 'The evaluation parameters need a key-value pair for \'evaluation_type\''</l>
<l>    return ()</l>
<l>else</l>
<l>    get_dict_tuple (EvalParams, 'evaluation_type', EvaluationType)</l>
<l>    tuple_find (['anomaly_detection','classification','segmentation','detection'], EvaluationType, Indices)</l>
<l>    if (Indices == -1 or Indices == [])</l>
<l>        Exception := 'Invalid entry for \'evaluation_type\': ' + EvaluationType</l>
<l>        return ()</l>
<l>    endif</l>
<l>endif</l>
<c>* Check the entry 'measures'.</c>
<l>get_dict_param (EvalParams, 'key_exists', 'measures', MeasuresExists)</l>
<l>if (not MeasuresExists)</l>
<l>    Exception := 'The evaluation parameters need a key-value pair for \'measures\''</l>
<l>    return ()</l>
<l>else</l>
<l>    get_dict_tuple (EvalParams, 'measures', Measures)</l>
<l>    if (|Measures| == 0)</l>
<l>        Exception := '\'measures\' should contain at least one entry'</l>
<l>        return ()</l>
<l>    endif</l>
<l>endif</l>
<c>* Check evaluation type specific entries of EvalParams.</c>
<l>get_dict_tuple (EvalParams, 'evaluation_type', EvaluationType)</l>
<l>if (EvaluationType == 'anomaly_detection')</l>
<c>    * </c>
<c>    * Check for correct number of classes.</c>
<l>    if (|ClassIDs| != 2)</l>
<l>        throw ('The number of classes must be 2 for model type anomaly detection.')</l>
<l>    endif</l>
<c>    * </c>
<c>    * Currently only the anomaly score histogram is evaluated</c>
<l>    ValidMeasures := 'anomaly_score_histogram'</l>
<l>elseif (EvaluationType == 'classification')</l>
<l>    tuple_gen_sequence (1, |ClassIDs|, 1, Ks)</l>
<l>    ValidMeasures := 'top' + Ks + '_error'</l>
<l>    ValidMeasures := [ValidMeasures,'precision','recall','f_score','absolute_confusion_matrix','relative_confusion_matrix']</l>
<c>    * </c>
<c>    * Check if not both of the two options to specify the evaluated classes are chosen.</c>
<l>    get_dict_param (EvalParams, 'key_exists', ['class_names_to_evaluate','class_ids_to_evaluate'], KeysExist)</l>
<l>    if (sum(KeysExist) == 2)</l>
<l>        Exception := 'No more than one option of \'class_names_to_evaluate\' and \'class_ids_to_evaluate\' is allowed'</l>
<l>        return ()</l>
<l>    endif</l>
<l>    if (KeysExist[0])</l>
<l>        get_dict_tuple (EvalParams, 'class_names', ClassNames)</l>
<l>        get_dict_tuple (EvalParams, 'class_names_to_evaluate', ClassesToEvaluate)</l>
<l>        if (difference(ClassesToEvaluate,[ClassNames,'global']) != [])</l>
<l>            Exception := 'Invalid entry in \'class_names_to_evaluate\''</l>
<l>            return ()</l>
<l>        endif</l>
<l>    endif</l>
<l>    if (KeysExist[1])</l>
<l>        get_dict_tuple (EvalParams, 'class_ids', ClassIDs)</l>
<l>        get_dict_tuple (EvalParams, 'class_ids_to_evaluate', ClassIDsToEvaluate)</l>
<l>        if (difference(ClassIDsToEvaluate,[ClassIDs,'global']) != [])</l>
<l>            Exception := 'Invalid entry in \'class_ids_to_evaluate\''</l>
<l>            return ()</l>
<l>        endif</l>
<l>    endif</l>
<l>elseif (EvaluationType == 'detection')</l>
<c>    * Instance-based evaluation.</c>
<c>    * Add instance measures.</c>
<l>    ValidMeasures := ['all','mean_ap']</l>
<c>    * </c>
<c>    * Check if the entry 'iou_threshold' is present.</c>
<l>    get_dict_param (EvalParams, 'key_exists', 'iou_threshold', IouThreshExists)</l>
<l>    if (not IouThreshExists)</l>
<l>        Exception := 'The evaluation parameters need a key-value pair for \'iou_threshold\''</l>
<l>        return ()</l>
<l>    else</l>
<l>        get_dict_tuple (EvalParams, 'iou_threshold', IouThresholds)</l>
<c>        * Check the length of 'iou_threshold'.</c>
<l>        if (|IouThresholds| &lt; 1)</l>
<l>            Exception := '\'iou_threshold\' is empty'</l>
<l>            return ()</l>
<l>        endif</l>
<l>        if (is_real_elem(IouThresholds) != gen_tuple_const(|IouThresholds|,1))</l>
<l>            Exception := '\'iou_threshold\' should be of type real'</l>
<l>            return ()</l>
<l>        endif</l>
<c>        * Check if the IoU thresholds are within (0.0, 1.0).</c>
<l>        if (min(IouThresholds) &lt;= 0.0 or max(IouThresholds) &gt;= 1.0)</l>
<l>            Exception := 'Invalid \'iou_threshold\', not in range (0.0, 1.0)'</l>
<l>            return ()</l>
<l>        endif</l>
<l>    endif</l>
<c>    * </c>
<c>    * Check if the entry 'max_num_detections' is present.</c>
<l>    get_dict_param (EvalParams, 'key_exists', 'max_num_detections', MaxNumDetectionsExists)</l>
<l>    if (not MaxNumDetectionsExists)</l>
<l>        Exception := 'The evaluation parameters need a key-value pair for \'max_num_detections\''</l>
<l>        return ()</l>
<l>    else</l>
<l>        get_dict_tuple (EvalParams, 'max_num_detections', MaxNumDetections)</l>
<c>        * Check the length of 'max_num_detections'.</c>
<l>        if (|MaxNumDetections| &lt; 1)</l>
<l>            Exception := '\'max_num_detections\' is empty'</l>
<l>            return ()</l>
<l>        endif</l>
<l>        if (is_int_elem(MaxNumDetections) != gen_tuple_const(|MaxNumDetections|,1))</l>
<l>            Exception := '\'max_num_detections\' should be of type int'</l>
<l>            return ()</l>
<l>        endif</l>
<c>        * Check if 'max_num_detections' is -1 (to use all detections) or positive.</c>
<l>        if (min(MaxNumDetections) &lt; -1 or find(MaxNumDetections,0) &gt; -1)</l>
<l>            Exception := '\'max_num_detections\' should be -1 or positive'</l>
<l>            return ()</l>
<l>        endif</l>
<l>    endif</l>
<c>    * </c>
<c>    * Check if the entry 'area_ranges' is present.</c>
<l>    get_dict_param (EvalParams, 'key_exists', 'area_ranges', AreaRangesExist)</l>
<l>    if (not AreaRangesExist)</l>
<l>        Exception := 'The evaluation parameters need a key-value pair for \'area_ranges\''</l>
<l>        return ()</l>
<l>    else</l>
<c>        * Check if the entry 'area_ranges' is a dict.</c>
<l>        get_dict_tuple (EvalParams, 'area_ranges', AreaRanges)</l>
<l>        if (sem_type(AreaRanges) != 'dict')</l>
<l>            Exception := '\'area_ranges\' must be a dict'</l>
<l>            return ()</l>
<l>        endif</l>
<c>        * Check that the necessary keys exist.</c>
<l>        get_dict_param (AreaRanges, 'key_exists', ['name','min','max'], AreaKeysExist)</l>
<l>        if (not AreaKeysExist[0])</l>
<l>            Exception := '\'area_ranges\' need a key-value pair for \'name\''</l>
<l>            return ()</l>
<l>        endif</l>
<l>        if (not AreaKeysExist[1])</l>
<l>            Exception := '\'area_ranges\' need a key-value pair for \'min\''</l>
<l>            return ()</l>
<l>        endif</l>
<l>        if (not AreaKeysExist[2])</l>
<l>            Exception := '\'area_ranges\' need a key-value pair for \'max\''</l>
<l>            return ()</l>
<l>        endif</l>
<c>        * Check the lengths of the area keys.</c>
<l>        get_dict_tuple (AreaRanges, 'name', AreaNames)</l>
<l>        if (|AreaNames| &lt; 1)</l>
<l>            Exception := '\'area_ranges\': \'name\' is empty'</l>
<l>            return ()</l>
<l>        endif</l>
<l>        get_dict_tuple (AreaRanges, 'min', MinAreas)</l>
<l>        if (|MinAreas| &lt; 1)</l>
<l>            Exception := '\'area_ranges\': \'min\' is empty'</l>
<l>            return ()</l>
<l>        endif</l>
<l>        get_dict_tuple (AreaRanges, 'max', MaxAreas)</l>
<l>        if (|MaxAreas| &lt; 1)</l>
<l>            Exception := '\'area_ranges\': \'max\' is empty'</l>
<l>            return ()</l>
<l>        endif</l>
<l>        if (|AreaNames| != |MinAreas| or |AreaNames| != |MaxAreas|)</l>
<l>            Exception := '\'area_ranges\': \'name\', \'min\' and \'max\' must have the same length'</l>
<l>            return ()</l>
<l>        endif</l>
<c>        * Check values of min, max.</c>
<l>        if (find(MinAreas [&gt;=] MaxAreas,1) &gt; -1)</l>
<l>            Exception := '\'area_ranges\': \'min\' must be elementwise smaller than \'max\''</l>
<l>            return ()</l>
<l>        endif</l>
<l>    endif</l>
<c>    * </c>
<c>    * Check if instance-type is valid.</c>
<l>    get_dict_param (EvalParams, 'key_exists', 'instance_type', InstanceTypeExists)</l>
<l>    if (not InstanceTypeExists)</l>
<l>        Exception := 'The evaluation parameters need a key-value pair for \'instance_type\''</l>
<l>        return ()</l>
<l>    else</l>
<l>        get_dict_tuple (EvalParams, 'instance_type', InstanceType)</l>
<l>        ValidInstanceTypes := ['rectangle1','rectangle2']</l>
<l>        if (find(ValidInstanceTypes,InstanceType) == -1)</l>
<l>            Exception := 'Invalid instance type \'' + InstanceType + '\''</l>
<l>            return ()</l>
<l>        endif</l>
<l>    endif</l>
<c>    * </c>
<c>    * Check if the entry 'allocation_block_length' is present and valid.</c>
<l>    get_dict_param (EvalParams, 'key_exists', 'allocation_block_length', AllocationBlockLengthExists)</l>
<l>    if (not AllocationBlockLengthExists)</l>
<l>        Exception := 'The evaluation parameters need a key-value pair for \'allocation_block_length\''</l>
<l>        return ()</l>
<l>    else</l>
<l>        get_dict_tuple (EvalParams, 'allocation_block_length', AllocationBlockLength)</l>
<c>        * Check the length of 'allocation_block_length'.</c>
<l>        if (|AllocationBlockLength| != 1)</l>
<l>            Exception := '\'allocation_block_length\' should have length 1'</l>
<l>            return ()</l>
<l>        endif</l>
<c>        * Check the type of 'allocation_block_length'.</c>
<l>        if (type(AllocationBlockLength) != type(int(0)))</l>
<l>            Exception := '\'allocation_block_length\' should be of type int'</l>
<l>            return ()</l>
<l>        endif</l>
<c>        * Check if 'allocation_block_length' is larger than zero.</c>
<l>        if (AllocationBlockLength &lt; 1)</l>
<l>            Exception := '\'allocation_block_length\' should be positive'</l>
<l>            return ()</l>
<l>        endif</l>
<l>    endif</l>
<c>    * </c>
<c>    * Check if the entry 'detailed_evaluation' is valid if present.</c>
<l>    get_dict_param (EvalParams, 'key_exists', 'detailed_evaluation', DetailedEvaluationExists)</l>
<l>    if (not DetailedEvaluationExists)</l>
<l>        Exception := 'The evaluation parameters need a key-value pair for \'detailed_evaluation\''</l>
<l>        return ()</l>
<l>    else</l>
<l>        get_dict_tuple (EvalParams, 'detailed_evaluation', DetailedEvaluation)</l>
<c>        * Check the length of 'detailed_evaluation'.</c>
<l>        if (|DetailedEvaluation| != 1)</l>
<l>            Exception := '\'detailed_evaluation\' should have length 1'</l>
<l>            return ()</l>
<l>        endif</l>
<c>        * Check the type of 'detailed_evaluation'.</c>
<l>        if (type(DetailedEvaluation) != type(true))</l>
<l>            Exception := '\'detailed_evaluation\' should be of type int'</l>
<l>            return ()</l>
<l>        endif</l>
<c>        * Check if 'detailed_evaluation' is larger than zero.</c>
<l>        if (DetailedEvaluation != false and DetailedEvaluation != true)</l>
<l>            Exception := '\'detailed_evaluation\' should be zero or one'</l>
<l>            return ()</l>
<l>        endif</l>
<l>    endif</l>
<c>    * </c>
<c>    * Add valid measure 'soap' if instance_type is 'rectangle2'.</c>
<l>    if (InstanceType == 'rectangle2')</l>
<l>        ValidMeasures := [ValidMeasures,'soap']</l>
<l>    endif</l>
<l>elseif (EvaluationType == 'segmentation')</l>
<c>    * Pixel-based evaluation.</c>
<l>    ValidMeasures := ['all','pixel_accuracy','mean_accuracy','mean_iou','class_iou','class_pixel_accuracy','pixel_confusion_matrix','frequency_weighted_iou']</l>
<c>    * </c>
<c>    * Check if the entry 'ignore_class_ids' exists.</c>
<l>    get_dict_param (EvalParams, 'key_exists', 'ignore_class_ids', IgnoreClassIDsExist)</l>
<l>    if (not IgnoreClassIDsExist)</l>
<l>        Exception := 'The evaluation parameters need a key-value pair for \'ignore_class_ids\''</l>
<l>        return ()</l>
<l>    endif</l>
<l>else</l>
<l>    Exception := 'Unknown evaluation_type: ' + EvaluationType</l>
<l>    return ()</l>
<l>endif</l>
<c>* Check measures.</c>
<l>ValidMeasuresString := gen_tuple_const(|ValidMeasures| * 2 - 1,'\',\'')</l>
<l>ValidMeasuresString[0:2:|ValidMeasuresString| - 1] := ValidMeasures</l>
<l>ValidMeasuresString := sum(ValidMeasuresString)</l>
<l>for Idx := 0 to |Measures| - 1 by 1</l>
<l>    ValidMeasure := find(ValidMeasures,Measures[Idx]) [&gt;] -1</l>
<l>    if (not ValidMeasure)</l>
<l>        Exception := 'Invalid measure \'' + Measures[Idx] + '\', choose one of [\'' + ValidMeasuresString + '\']'</l>
<l>        return ()</l>
<l>    endif</l>
<l>endfor</l>
<c>* </c>
<c>* Done with checks.</c>
<l>Valid := true</l>
<l>return ()</l>
</body>
<docu id="validate_evaluation_param">
<abstract lang="en_US">This procedure checks that all entries in the dictionary EvalParams are valid. 
In particular this procedure checks that the EvalParams dictionary contains all necessary keys and that the parameters have the correct type. 

Output: 
- Valid: An integer with the value true (=1) if all entries in EvalParams are valid, and false (=0) elsewise.
- Exception: A string which is empty if Valid =1 and else describes why the entries in EvalParams are not valid.

</abstract>
<chapters lang="de_DE">
<item>Deep Learning</item>
<item>Evaluierung</item>
</chapters>
<chapters lang="en_US">
<item>Deep Learning</item>
<item>Evaluation</item>
</chapters>
<library lang="en_US">MVTec Standard Procedures</library>
<short lang="en_US">Check that all given entries in EvalParams are valid.</short>
<parameters>
<parameter id="EvalParams">
<default_type>integer</default_type>
<default_value>EvalParams</default_value>
<description lang="en_US">Dictionary with the evaluation parameters.</description>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>dict</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="Exception">
<default_type>string</default_type>
<description lang="en_US">A string which is empty if Valid =1 and else describes why the entries in EvalParams are not valid.</description>
<multivalue>false</multivalue>
<sem_type>string</sem_type>
<type_list>
<item>string</item>
</type_list>
</parameter>
<parameter id="Valid">
<default_type>integer</default_type>
<description lang="en_US">If the parameters are valid: true, else false.</description>
<multivalue>false</multivalue>
<sem_type>integer</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
</parameters>
</docu>
</procedure>
<procedure name="visualize_calibrated_touching_point" access="local">
<interface>
<ic>
<par name="RobotTouchingPointInToolCoordinates" base_type="ctrl" dimension="0"/>
<par name="ToolInBasePosesTouchingPoint" base_type="ctrl" dimension="1"/>
<par name="WindowHandle" base_type="ctrl" dimension="0"/>
</ic>
</interface>
<body>
<c>* </c>
<c>* Create 3D object models.</c>
<l>gen_tool_to_touching_point_object_model_3d (ToolInBasePosesTouchingPoint, RobotTouchingPointInToolCoordinates, OM3DToolTouchingPoint)</l>
<c>* </c>
<c>* Prepare parameters for visualize_object_model_3d.</c>
<c>* Instructions.</c>
<l>Instructions[0] := 'Rotate: Left button'</l>
<l>Instructions[1] := 'Zoom:   Shift + left button'</l>
<l>Instructions[2] := 'Move:   Ctrl  + left button'</l>
<c>* 3D visualization pose.</c>
<l>create_pose (0.326, 0.016, 3.137, 83.33, 341.96, 99.32, 'Rp+T', 'gba', 'point', PoseIn)</l>
<c>* </c>
<l>GenParamName := ['color_0','color_1','color_2','color_3','color_4','color_5','color_6','color_7','color_8','color_9','color_10','color_11']</l>
<l>GenParamValue := ['red','green','blue','magenta','red','green','blue','magenta','red','green','blue','magenta']</l>
<c>* </c>
<l>Title := 'Visualization of the read poses. The magenta lines connect the'</l>
<l>Title[1] := 'tool coordinate system with the touching point. They intersect'</l>
<l>Title[2] := 'in the approached point in the plane. Calculated touching point'</l>
<l>Title[3] := 'coordinates with respect to the robot\'s tool: '</l>
<l>Title[4] := 'X: ' + (RobotTouchingPointInToolCoordinates[0] * 1000)$'.2f' + ' mm, Y: ' + (RobotTouchingPointInToolCoordinates[1] * 1000)$'.2f' + ' mm, Z: ' + (RobotTouchingPointInToolCoordinates[2] * 1000)$'.2f' + ' mm'</l>
<c>* Labels for the visualized 3D object models.</c>
<l>NumOM3D := |OM3DToolTouchingPoint|</l>
<l>tuple_gen_const (NumOM3D, '', Label)</l>
<l>Label[2] := 'ToolInBasePosesTouchingPoint 1'</l>
<l>Label[6] := 'ToolInBasePosesTouchingPoint 2'</l>
<l>Label[10] := 'ToolInBasePosesTouchingPoint 3'</l>
<c>* </c>
<l>visualize_object_model_3d (WindowHandle, OM3DToolTouchingPoint, [], PoseIn, GenParamName, GenParamValue, Title, Label, Instructions, PoseOut)</l>
<c>* </c>
<c>* Clean up.</c>
<l>clear_object_model_3d (OM3DToolTouchingPoint)</l>
<l>return ()</l>
</body>
<docu id="visualize_calibrated_touching_point">
<chapters lang="de_DE">
<item>Graphik</item>
<item>3D-Szene</item>
</chapters>
<chapters lang="en_US">
<item>Graphics</item>
<item>3D Scene</item>
</chapters>
<library lang="en_US">MVTec Standard Procedures</library>
<predecessor>
<item>get_robot_touching_point_in_tool_coordinates</item>
</predecessor>
<see_also>
<item>calibrate_robot_touching_point</item>
</see_also>
<short lang="en_US">Visualize the poses that were used to calculate the touching point, and the result.</short>
<parameters>
<parameter id="RobotTouchingPointInToolCoordinates"/>
<parameter id="ToolInBasePosesTouchingPoint">
<sem_type>pose</sem_type>
</parameter>
<parameter id="WindowHandle">
<default_type>integer</default_type>
<mixed_type>false</mixed_type>
<sem_type>window</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
</parameters>
</docu>
</procedure>
<procedure name="visualize_object_model_3d">
<interface>
<ic>
<par name="WindowHandle" base_type="ctrl" dimension="0"/>
<par name="ObjectModel3D" base_type="ctrl" dimension="0"/>
<par name="CamParam" base_type="ctrl" dimension="0"/>
<par name="PoseIn" base_type="ctrl" dimension="0"/>
<par name="GenParamName" base_type="ctrl" dimension="0"/>
<par name="GenParamValue" base_type="ctrl" dimension="0"/>
<par name="Title" base_type="ctrl" dimension="0"/>
<par name="Label" base_type="ctrl" dimension="0"/>
<par name="Information" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="PoseOut" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c>* The procedure visualize_object_model_3d can be used to display</c>
<c>* one or more 3d object models and to interactively modify</c>
<c>* the object poses by using the mouse.</c>
<c>* </c>
<c>* The pose can be modified by moving the mouse while</c>
<c>* pressing a mouse button. The default settings are:</c>
<c>* </c>
<c>*  Rotate: Left mouse button</c>
<c>*  Zoom: Shift + Left mouse button (or Center mouse button)</c>
<c>*  Pan: Ctrl + Left mouse button</c>
<c>* </c>
<c>* Furthermore, it is possible to select and deselect objects,</c>
<c>* to decrease the mouse sensitivity, and to toggle the</c>
<c>* inspection mode (see the description of the generic parameter</c>
<c>* 'inspection_mode' below):</c>
<c>* </c>
<c>*  (De-)select object(s): Right mouse button</c>
<c>*  Low mouse sensitivity: Alt + Mouse button</c>
<c>*  Toggle inspection mode: Ctrl + Alt + Left mouse button</c>
<c>* </c>
<c>* In GenParamName and GenParamValue all generic Parameters</c>
<c>* of disp_object_model_3d are supported.</c>
<c>* </c>
<c>* **********************************************************</c>
<c>* Define global variables</c>
<c>* **********************************************************</c>
<c>* </c>
<l>global def tuple gDispObjOffset</l>
<l>global def tuple gLabelsDecor</l>
<l>global def tuple gInfoDecor</l>
<l>global def tuple gInfoPos</l>
<l>global def tuple gTitlePos</l>
<l>global def tuple gTitleDecor</l>
<l>global def tuple gTerminationButtonLabel</l>
<l>global def tuple gAlphaDeselected</l>
<l>global def tuple gIsSinglePose</l>
<l>global def tuple gUsesOpenGL</l>
<c>* </c>
<c>* **********************************************************</c>
<c>* Initialize Handles to enable correct handling in error case</c>
<c>* **********************************************************</c>
<l>Scene3DTest := []</l>
<l>Scene3D := []</l>
<l>WindowHandleBuffer := []</l>
<c></c>
<c>* **********************************************************</c>
<c>* Some user defines that may be adapted if desired</c>
<c>* **********************************************************</c>
<c>* </c>
<c>* TrackballSize defines the diameter of the trackball in</c>
<c>* the image with respect to the smaller image dimension.</c>
<l>TrackballSize := 0.8</l>
<c>* </c>
<c>* VirtualTrackball defines the type of virtual trackball that</c>
<c>* shall be used ('shoemake' or 'bell').</c>
<l>VirtualTrackball := 'shoemake'</l>
<l>* VirtualTrackball := 'bell'</l>
<c>* </c>
<c>* Functionality of mouse buttons</c>
<c>*     1: Left Button</c>
<c>*     2: Middle Button</c>
<c>*     4: Right Button</c>
<c>*     5: Left+Right Mousebutton</c>
<c>*   8+x: Shift + Mousebutton</c>
<c>*  16+x: Ctrl + Mousebutton</c>
<c>*  48+x: Ctrl + Alt + Mousebutton</c>
<c>* in the order [Translate, Rotate, Scale, ScaleAlternative1, ScaleAlternative2, SelectObjects, ToggleSelectionMode]</c>
<l>MouseMapping := [17,1,2,5,9,4,49]</l>
<c>* </c>
<c>* The labels of the objects appear next to their projected</c>
<c>* center. With gDispObjOffset a fixed offset is added</c>
<c>*                   R,  C</c>
<l>gDispObjOffset := [-30,0]</l>
<c>* </c>
<c>* Customize the decoration of the different text elements</c>
<c>*               Color,   Box</c>
<l>gInfoDecor := ['white','false']</l>
<l>gLabelsDecor := ['white','false']</l>
<l>gTitleDecor := ['black','true']</l>
<c>* </c>
<c>* Customize the position of some text elements</c>
<c>*   gInfoPos has one of the values</c>
<c>*   {'UpperLeft', 'LowerLeft', 'UpperRight'}</c>
<l>gInfoPos := 'LowerLeft'</l>
<c>*   gTitlePos has one of the values</c>
<c>*   {'UpperLeft', 'UpperCenter', 'UpperRight'}</c>
<l>gTitlePos := 'UpperLeft'</l>
<c>* Alpha value (=1-transparency) that is used for visualizing</c>
<c>* the objects that are not selected</c>
<l>gAlphaDeselected := 0.3</l>
<c>* Customize the label of the continue button</c>
<l>gTerminationButtonLabel := ' Continue '</l>
<c>* Define if the continue button responds to a single click event or</c>
<c>* if it responds only if the mouse button is released while being placed</c>
<c>* over the continue button.</c>
<c>* 'true':  Wait until the continue button has been released.</c>
<c>*          This should be used to avoid unwanted continuations of</c>
<c>*          subsequent calls of visualize_object_model_3d, which can</c>
<c>*          otherwise occur if the mouse button remains pressed while the</c>
<c>*          next visualization is active.</c>
<c>* 'false': Continue the execution already if the continue button is</c>
<c>*          pressed. This option allows a fast forwarding through</c>
<c>*          subsequent calls of visualize_object_model_3d.</c>
<l>WaitForButtonRelease := 'true'</l>
<c>* Number of 3D Object models that can be selected and handled individually.</c>
<c>* If there are more models passed then this number, some calculations</c>
<c>* are performed differently and the individual selection and handling</c>
<c>* of models is not supported anymore. Note that the value of MaxNumModels</c>
<c>* can be overwritten with the generic parameter max_num_selectable_models.</c>
<l>MaxNumModels := 1000</l>
<c>* Defines the default for the initial state of the rotation center:</c>
<c>* (1) The rotation center is fixed in the center of the image and lies</c>
<c>*     on the surface of the object.</c>
<c>* (2) The rotation center lies in the center of the object.</c>
<l>WindowCenteredRotation := 2</l>
<c>* </c>
<c>* **********************************************************</c>
<c>* </c>
<c>* Initialize some values</c>
<l>NumModels := |ObjectModel3D|</l>
<l>SelectedObject := gen_tuple_const(NumModels,1)</l>
<c>* </c>
<c>* Apply some system settings</c>
<l>dev_set_preferences ('graphics_window_context_menu', 'false')</l>
<l>dev_get_preferences ('graphics_window_mouse_wheel', WindowMouseWheel)</l>
<l>dev_set_preferences ('graphics_window_mouse_wheel', 'false')</l>
<l>get_system ('clip_region', ClipRegion)</l>
<l>set_system ('clip_region', 'false')</l>
<l>dev_update_off ()</l>
<c>* </c>
<c>* Check if GenParamName matches GenParamValue</c>
<l>if (|GenParamName| != |GenParamValue|)</l>
<l>    throw ('Number of generic parameters does not match number of generic parameter values')</l>
<l>endif</l>
<c>* </c>
<l>try</l>
<c>    * </c>
<c>    * Refactor camera parameters to fit to window size</c>
<c>    * </c>
<l>    CPLength := |CamParam|</l>
<l>    get_window_extents (WindowHandle, RowNotUsed, ColumnNotUsed, Width, Height)</l>
<l>    get_part (WindowHandle, WPRow1, WPColumn1, WPRow2, WPColumn2)</l>
<l>    set_part (WindowHandle, 0, 0, Height - 1, Width - 1)</l>
<l>    if (CPLength == 0)</l>
<l>        gen_cam_par_area_scan_division (0.06, 0, 8.5e-6, 8.5e-6, Width / 2, Height / 2, Width, Height, CamParam)</l>
<l>    else</l>
<l>        get_cam_par_data (CamParam, ['sx','sy','cx','cy','image_width','image_height'], CamParamValue)</l>
<l>        CamWidth := real(CamParamValue[4])</l>
<l>        CamHeight := real(CamParamValue[5])</l>
<l>        Scale := min([Width / CamWidth,Height / CamHeight])</l>
<l>        set_cam_par_data (CamParam, 'sx', CamParamValue[0] / Scale, CamParam)</l>
<l>        set_cam_par_data (CamParam, 'sy', CamParamValue[1] / Scale, CamParam)</l>
<l>        set_cam_par_data (CamParam, 'cx', CamParamValue[2] * Scale, CamParam)</l>
<l>        set_cam_par_data (CamParam, 'cy', CamParamValue[3] * Scale, CamParam)</l>
<l>        set_cam_par_data (CamParam, 'image_width', int(CamParamValue[4] * Scale), CamParam)</l>
<l>        set_cam_par_data (CamParam, 'image_height', int(CamParamValue[5] * Scale), CamParam)</l>
<l>    endif</l>
<c>    * </c>
<c>    * Check the generic parameters for max_num_selectable_models</c>
<c>    * (Note that the default is set above to MaxNumModels := 1000)</c>
<l>    Indices := find(GenParamName,'max_num_selectable_models')</l>
<l>    if (Indices != -1 and Indices != [])</l>
<l>        if (is_number(GenParamValue[Indices[0]]))</l>
<l>            if (int(number(GenParamValue[Indices[0]])) &lt; 1)</l>
<c>                * Wrong parameter value: Only integer values greater than 0 are allowed</c>
<l>                throw ('Wrong value for parameter \'max_num_selectable_models\' (must be an integer value greater than 0)')</l>
<l>            endif</l>
<l>        else</l>
<c>            * Wrong parameter value: Only integer values greater than 0 are allowed</c>
<l>            throw ('Wrong value for parameter \'max_num_selectable_models\' (must be an integer value greater than 0)')</l>
<l>        endif</l>
<l>        MaxNumModels := int(number(GenParamValue[Indices[0]]))</l>
<l>        GenParamName := remove(GenParamName,Indices)</l>
<l>        GenParamValue := remove(GenParamValue,Indices)</l>
<l>    endif</l>
<c>    * </c>
<c>    * Check the generic parameters for window_centered_rotation</c>
<c>    * (Note that the default is set above to WindowCenteredRotation := 2)</c>
<l>    Indices := find(GenParamName,'inspection_mode')</l>
<l>    if (Indices != -1 and Indices != [])</l>
<l>        if (GenParamValue[Indices[0]] == 'surface')</l>
<l>            WindowCenteredRotation := 1</l>
<l>        elseif (GenParamValue[Indices[0]] == 'standard')</l>
<l>            WindowCenteredRotation := 2</l>
<l>        else</l>
<c>            * Wrong parameter value, use default value</c>
<l>        endif</l>
<l>        GenParamName := remove(GenParamName,Indices)</l>
<l>        GenParamValue := remove(GenParamValue,Indices)</l>
<l>    endif</l>
<c>    * </c>
<c>    * Check the generic parameters for disp_background</c>
<c>    * (The former parameter name 'use_background' is still supported</c>
<c>    *  for compatibility reasons)</c>
<l>    DispBackground := 'false'</l>
<l>    if (|GenParamName| &gt; 0)</l>
<l>        Mask := GenParamName [==] 'disp_background' or GenParamName [==] 'use_background'</l>
<l>        Indices := find(Mask,1)</l>
<l>    else</l>
<l>        Indices := -1</l>
<l>    endif</l>
<l>    if (Indices != -1 and Indices != [])</l>
<l>        DispBackground := GenParamValue[Indices[0]]</l>
<l>        if (DispBackground != 'true' and DispBackground != 'false')</l>
<c>            * Wrong parameter value: Only 'true' and 'false' are allowed</c>
<l>            throw ('Wrong value for parameter \'disp_background\' (must be either \'true\' or \'false\')')</l>
<l>        endif</l>
<c>        * Note the the background is handled explicitly in this procedure</c>
<c>        * and therefore, the parameter is removed from the list of</c>
<c>        * parameters and disp_background is always set to true (see below)</c>
<l>        GenParamName := remove(GenParamName,Indices)</l>
<l>        GenParamValue := remove(GenParamValue,Indices)</l>
<l>    endif</l>
<c>    * </c>
<c>    * Read and check the parameter Label for each object</c>
<l>    if (|Label| == 0)</l>
<l>        Label := 0</l>
<l>    elseif (|Label| == 1)</l>
<l>        Label := gen_tuple_const(NumModels,Label)</l>
<l>    else</l>
<l>        if (|Label| != NumModels)</l>
<c>            * Number of elements in Label does not match</c>
<c>            * the number of object models.</c>
<l>            throw ('Number of elements in Label (' + |Label| + ') does not match the number of object models(' + NumModels + ').')</l>
<l>        endif</l>
<l>    endif</l>
<c>    * </c>
<c>    * Read and check the parameter PoseIn for each object</c>
<l>    get_object_models_center (ObjectModel3D, Center)</l>
<l>    if (Center == [])</l>
<l>        Center := [0,0,0]</l>
<l>    endif</l>
<l>    if (|PoseIn| == 0)</l>
<c>        * If no pose was specified by the caller, automatically calculate</c>
<c>        * a pose that is appropriate for the visualization.</c>
<c>        * Set the initial model reference pose. The orientation is parallel</c>
<c>        * to the object coordinate system, the position is at the center</c>
<c>        * of gravity of all models.</c>
<l>        create_pose (-Center[0], -Center[1], -Center[2], 0, 0, 0, 'Rp+T', 'gba', 'point', PoseIn)</l>
<l>        determine_optimum_pose_distance (ObjectModel3D, CamParam, 0.9, PoseIn, PoseEstimated)</l>
<l>        Poses := []</l>
<l>        HomMat3Ds := []</l>
<l>        Sequence := [0:NumModels * 7 - 1]</l>
<l>        Poses := PoseEstimated[Sequence % 7]</l>
<l>        gIsSinglePose := true</l>
<l>    elseif (|PoseIn| == 7)</l>
<l>        Poses := []</l>
<l>        HomMat3Ds := []</l>
<l>        Sequence := [0:NumModels * 7 - 1]</l>
<l>        Poses := PoseIn[Sequence % 7]</l>
<l>        gIsSinglePose := true</l>
<l>    else</l>
<l>        if (|PoseIn| != |ObjectModel3D| * 7)</l>
<c>            * Wrong number of values of input control parameter 'PoseIn'</c>
<l>            throw ('Wrong number of values of input control parameter \'PoseIn\'.')</l>
<l>        else</l>
<l>            Poses := PoseIn</l>
<l>        endif</l>
<l>        gIsSinglePose := false</l>
<l>    endif</l>
<c></c>
<c>    * </c>
<c>    * Open (invisible) buffer window to avoid flickering</c>
<l>    open_window (0, 0, Width, Height, 0, 'buffer', '', WindowHandleBuffer)</l>
<l>    set_part (WindowHandleBuffer, 0, 0, Height - 1, Width - 1)</l>
<l>    get_font (WindowHandle, Font)</l>
<l>    try</l>
<l>        set_font (WindowHandleBuffer, Font)</l>
<l>    catch (Exception)</l>
<l>    endtry</l>
<c>    * </c>
<c>    *  Is OpenGL available and should it be used?</c>
<l>    gUsesOpenGL := 'true'</l>
<l>    Indices := find(GenParamName,'opengl')</l>
<l>    if (Indices != -1 and Indices != [])</l>
<l>        gUsesOpenGL := GenParamValue[Indices[0]]</l>
<l>        GenParamName := remove(GenParamName,Indices)</l>
<l>        GenParamValue := remove(GenParamValue,Indices)</l>
<l>        if (gUsesOpenGL != 'true' and gUsesOpenGL != 'false')</l>
<c>            * Wrong parameter value: Only 'true' and 'false' are allowed</c>
<l>            throw ('Wrong value for parameter \'opengl\' (must be either \'true\' or \'false\')')</l>
<l>        endif</l>
<l>    endif</l>
<l>    if (gUsesOpenGL == 'true')</l>
<l>        get_system ('opengl_info', OpenGLInfo)</l>
<l>        if (OpenGLInfo == 'No OpenGL support included.')</l>
<l>            gUsesOpenGL := 'false'</l>
<l>        else</l>
<l>            gen_object_model_3d_from_points (0, 0, 0, DummyObjectModel3D)</l>
<l>            create_scene_3d (Scene3DTest)</l>
<l>            add_scene_3d_camera (Scene3DTest, CamParam, CameraIndexTest)</l>
<l>            determine_optimum_pose_distance (DummyObjectModel3D, CamParam, 0.9, [0,0,0,0,0,0,0], PoseTest)</l>
<l>            add_scene_3d_instance (Scene3DTest, DummyObjectModel3D, PoseTest, InstanceIndexTest)</l>
<l>            try</l>
<l>                display_scene_3d (WindowHandleBuffer, Scene3DTest, InstanceIndexTest)</l>
<l>            catch (Exception)</l>
<l>                gUsesOpenGL := 'false'</l>
<l>            endtry</l>
<l>            clear_scene_3d (Scene3DTest)</l>
<l>            Scene3DTest := []</l>
<l>            clear_object_model_3d (DummyObjectModel3D)</l>
<l>        endif</l>
<l>    endif</l>
<c>    * </c>
<c>    * Compute the trackball</c>
<l>    MinImageSize := min([Width,Height])</l>
<l>    TrackballRadiusPixel := TrackballSize * MinImageSize / 2.0</l>
<c>    * </c>
<c>    * Measure the text extents for the continue button in the</c>
<c>    * graphics window</c>
<l>    get_string_extents (WindowHandleBuffer, gTerminationButtonLabel + '  ', Ascent, Descent, TextWidth, TextHeight)</l>
<c>    * </c>
<c>    * Store background image</c>
<l>    if (DispBackground == 'false')</l>
<l>        clear_window (WindowHandle)</l>
<l>    endif</l>
<l>    dump_window_image (Image, WindowHandle)</l>
<c>    * Special treatment for color background images necessary</c>
<l>    count_channels (Image, NumChannels)</l>
<l>    ColorImage := NumChannels == 3</l>
<c>    * </c>
<l>    create_scene_3d (Scene3D)</l>
<l>    add_scene_3d_camera (Scene3D, CamParam, CameraIndex)</l>
<l>    add_scene_3d_instance (Scene3D, ObjectModel3D, Poses, AllInstances)</l>
<c>    * Always set 'disp_background' to true,  because it is handled explicitly</c>
<c>    * in this procedure (see above)</c>
<l>    set_scene_3d_param (Scene3D, 'disp_background', 'true')</l>
<c>    * Check if we have to set light specific parameters</c>
<l>    SetLight := regexp_test(GenParamName,'light_')</l>
<l>    if (SetLight)</l>
<c>        * set position of light source</c>
<l>        Indices := find(GenParamName,'light_position')</l>
<l>        if (Indices != -1 and Indices != [])</l>
<c>            * If multiple light positions are given, use the last one</c>
<l>            LightParam := number(split(GenParamValue[Indices[|Indices| - 1]],', '))</l>
<l>            if (|LightParam| != 4)</l>
<l>                throw ('light_position must be given as a string that contains four space separated floating point numbers')</l>
<l>            endif</l>
<l>            LightPosition := LightParam[0:2]</l>
<l>            LightKind := 'point_light'</l>
<l>            if (LightParam[3] == 0)</l>
<l>                LightKind := 'directional_light'</l>
<l>            endif</l>
<c>            * Currently, only one light source is supported</c>
<l>            remove_scene_3d_light (Scene3D, 0)</l>
<l>            add_scene_3d_light (Scene3D, LightPosition, LightKind, LightIndex)</l>
<l>            tuple_remove (GenParamName, Indices, GenParamName)</l>
<l>            tuple_remove (GenParamValue, Indices, GenParamValue)</l>
<l>        endif</l>
<c>        * set ambient part of light source</c>
<l>        Indices := find(GenParamName,'light_ambient')</l>
<l>        if (Indices != -1 and Indices != [])</l>
<c>            * If the ambient part is set multiple times, use the last setting</c>
<l>            LightParam := number(split(GenParamValue[Indices[|Indices| - 1]],', '))</l>
<l>            if (|LightParam| &lt; 3)</l>
<l>                throw ('light_ambient must be given as a string that contains three space separated floating point numbers')</l>
<l>            endif</l>
<l>            set_scene_3d_light_param (Scene3D, 0, 'ambient', LightParam[0:2])</l>
<l>            tuple_remove (GenParamName, Indices, GenParamName)</l>
<l>            tuple_remove (GenParamValue, Indices, GenParamValue)</l>
<l>        endif</l>
<c>        * Set diffuse part of light source</c>
<l>        Indices := find(GenParamName,'light_diffuse')</l>
<l>        if (Indices != -1 and Indices != [])</l>
<c>            * If the diffuse part is set multiple times, use the last setting</c>
<l>            LightParam := number(split(GenParamValue[Indices[|Indices| - 1]],', '))</l>
<l>            if (|LightParam| &lt; 3)</l>
<l>                throw ('light_diffuse must be given as a string that contains three space separated floating point numbers')</l>
<l>            endif</l>
<l>            set_scene_3d_light_param (Scene3D, 0, 'diffuse', LightParam[0:2])</l>
<l>            tuple_remove (GenParamName, Indices, GenParamName)</l>
<l>            tuple_remove (GenParamValue, Indices, GenParamValue)</l>
<l>        endif</l>
<l>    endif</l>
<c>    * </c>
<c>    * Handle persistence parameters separately because persistence will</c>
<c>    * only be activated immediately before leaving the visualization</c>
<c>    * procedure</c>
<l>    PersistenceParamName := []</l>
<l>    PersistenceParamValue := []</l>
<c>    * Set position of light source</c>
<l>    Indices := find(GenParamName,'object_index_persistence')</l>
<l>    if (Indices != -1 and Indices != [])</l>
<l>        if (GenParamValue[Indices[|Indices| - 1]] == 'true')</l>
<l>            PersistenceParamName := [PersistenceParamName,'object_index_persistence']</l>
<l>            PersistenceParamValue := [PersistenceParamValue,'true']</l>
<l>        elseif (GenParamValue[Indices[|Indices| - 1]] == 'false')</l>
<l>        else</l>
<l>            throw ('Wrong value for parameter \'object_index_persistence\' (must be either \'true\' or \'false\')')</l>
<l>        endif</l>
<l>        tuple_remove (GenParamName, Indices, GenParamName)</l>
<l>        tuple_remove (GenParamValue, Indices, GenParamValue)</l>
<l>    endif</l>
<l>    Indices := find(GenParamName,'depth_persistence')</l>
<l>    if (Indices != -1 and Indices != [])</l>
<l>        if (GenParamValue[Indices[|Indices| - 1]] == 'true')</l>
<l>            PersistenceParamName := [PersistenceParamName,'depth_persistence']</l>
<l>            PersistenceParamValue := [PersistenceParamValue,'true']</l>
<l>        elseif (GenParamValue[Indices[|Indices| - 1]] == 'false')</l>
<l>        else</l>
<l>            throw ('Wrong value for parameter \'depth_persistence\' (must be either \'true\' or \'false\')')</l>
<l>        endif</l>
<l>        tuple_remove (GenParamName, Indices, GenParamName)</l>
<l>        tuple_remove (GenParamValue, Indices, GenParamValue)</l>
<l>    endif</l>
<c>    * </c>
<c>    * Parse the generic parameters</c>
<c>    * - First, all parameters that are understood by set_scene_3d_instance_param</c>
<l>    AlphaOrig := gen_tuple_const(NumModels,1)</l>
<l>    for I := 0 to |GenParamName| - 1 by 1</l>
<l>        ParamName := GenParamName[I]</l>
<l>        ParamValue := GenParamValue[I]</l>
<c>        * Check if this parameter is understood by set_scene_3d_param</c>
<l>        if (ParamName == 'alpha')</l>
<l>            AlphaOrig := gen_tuple_const(NumModels,ParamValue)</l>
<l>        endif</l>
<l>        try</l>
<l>            set_scene_3d_param (Scene3D, ParamName, ParamValue)</l>
<l>            continue</l>
<l>        catch (Exception)</l>
<l>            if (Exception[0] == 1203 or Exception[0] == 1303)</l>
<l>                throw ('Wrong type or value for parameter ' + ParamName + ': ' + ParamValue)</l>
<l>            endif</l>
<l>        endtry</l>
<c>        * Check if it is a parameter that is valid for only one instance</c>
<c>        * and therefore can be set only with set_scene_3d_instance_param</c>
<l>        ParamNameTrunk := regexp_replace(ParamName,'_\\d+$','')</l>
<l>        if (ParamName == ParamNameTrunk)</l>
<l>            Instance := [0:NumModels - 1]</l>
<l>        else</l>
<l>            Instance := number(regexp_replace(ParamName,'^' + ParamNameTrunk + '_(\\d+)$','$1'))</l>
<l>            if (Instance &lt; 0 or Instance &gt; NumModels - 1)</l>
<l>                throw ('Parameter ' + ParamName + ' refers to a non existing 3D object model')</l>
<l>            endif</l>
<l>        endif</l>
<l>        try</l>
<l>            set_scene_3d_instance_param (Scene3D, Instance, ParamNameTrunk, ParamValue)</l>
<l>        catch (Exception)</l>
<l>            if (Exception[0] == 1204 or Exception[0] == 1304)</l>
<l>                throw ('Wrong type or value for parameter ' + ParamName + ': ' + ParamValue)</l>
<l>            elseif (Exception[0] == 1203 or Exception[0] == 1303)</l>
<l>                throw ('Wrong parameter name ' + ParamName)</l>
<l>            else</l>
<l>                throw (Exception)</l>
<l>            endif</l>
<l>        endtry</l>
<l>        if (ParamNameTrunk == 'alpha')</l>
<l>            AlphaOrig[Instance] := ParamValue</l>
<l>        endif</l>
<l>    endfor</l>
<c>    * </c>
<c>    * Start the visualization loop</c>
<l>    pose_to_hom_mat3d (Poses[0:6], HomMat3D)</l>
<l>    affine_trans_point_3d (HomMat3D, Center[0], Center[1], Center[2], Qx, Qy, Qz)</l>
<l>    TBCenter := [Qx,Qy,Qz]</l>
<l>    TBSize := (0.5 + 0.5 * sum(SelectedObject) / NumModels) * TrackballRadiusPixel</l>
<l>    ButtonHold := false</l>
<l>    while (1)</l>
<l>        VisualizeTB := max(SelectedObject) != 0</l>
<l>        MaxIndex := min([|ObjectModel3D|,MaxNumModels]) - 1</l>
<c>        * Set trackball fixed in the center of the window</c>
<l>        TrackballCenterRow := Height / 2</l>
<l>        TrackballCenterCol := Width / 2</l>
<l>        if (WindowCenteredRotation == 1)</l>
<l>            try</l>
<l>                get_trackball_center_fixed (SelectedObject[0:MaxIndex], TrackballCenterRow, TrackballCenterCol, TrackballRadiusPixel, Scene3D, ObjectModel3D[0:MaxIndex], Poses[0:(MaxIndex + 1) * 7 - 1], WindowHandleBuffer, CamParam, GenParamName, GenParamValue, TBCenter, TBSize)</l>
<l>            catch (Exception)</l>
<l>                disp_message (WindowHandle, 'Surface inspection mode is not available.', 'image', 5, 20, 'red', 'true')</l>
<l>                WindowCenteredRotation := 2</l>
<l>                get_trackball_center (SelectedObject[0:MaxIndex], TrackballRadiusPixel, ObjectModel3D[0:MaxIndex], Poses[0:(MaxIndex + 1) * 7 - 1], TBCenter, TBSize)</l>
<l>                wait_seconds (1)</l>
<l>            endtry</l>
<l>        else</l>
<l>            get_trackball_center (SelectedObject[0:MaxIndex], TrackballRadiusPixel, ObjectModel3D[0:MaxIndex], Poses[0:(MaxIndex + 1) * 7 - 1], TBCenter, TBSize)</l>
<l>        endif</l>
<l>        dump_image_output (Image, WindowHandleBuffer, Scene3D, AlphaOrig, ObjectModel3D, GenParamName, GenParamValue, CamParam, Poses, ColorImage, Title, Information, Label, VisualizeTB, 'true', TrackballCenterRow, TrackballCenterCol, TBSize, SelectedObject, WindowCenteredRotation, TBCenter)</l>
<l>        dump_window_image (ImageDump, WindowHandleBuffer)</l>
<l>        dev_set_window (WindowHandle)</l>
<l>        dev_display (ImageDump)</l>
<c>        * </c>
<c>        * Check for mouse events</c>
<l>        GraphEvent := false</l>
<l>        Exit := false</l>
<l>        while (1)</l>
<c>            * </c>
<c>            * Check graphic event</c>
<l>            try</l>
<l>                get_mposition_sub_pix (WindowHandle, GraphButtonRow, GraphButtonColumn, GraphButton)</l>
<l>                if (GraphButton != 0)</l>
<l>                    if (GraphButtonRow &gt; Height - TextHeight - 25 and GraphButtonRow &lt; Height and GraphButtonColumn &gt; Width - TextWidth - 15 and GraphButtonColumn &lt; Width)</l>
<c>                        * Wait until the continue button has been released</c>
<l>                        if (WaitForButtonRelease == 'true')</l>
<l>                            while (1)</l>
<l>                                get_mposition_sub_pix (WindowHandle, GraphButtonRow, GraphButtonColumn, GraphButton)</l>
<l>                                if (GraphButton == 0 or GraphButton == [])</l>
<l>                                    if (GraphButtonRow &gt; Height - TextHeight - 25 and GraphButtonRow &lt; Height and GraphButtonColumn &gt; Width - TextWidth - 15 and GraphButtonColumn &lt; Width)</l>
<l>                                        ButtonReleased := true</l>
<l>                                    else</l>
<l>                                        ButtonReleased := false</l>
<l>                                    endif</l>
<c>                                    * </c>
<l>                                    break</l>
<l>                                endif</l>
<c>                                * Keep waiting until mouse button is released or moved out of the window</c>
<l>                            endwhile</l>
<l>                        else</l>
<l>                            ButtonReleased := true</l>
<l>                        endif</l>
<c>                        * Exit the visualization loop</c>
<l>                        if (ButtonReleased)</l>
<l>                            Exit := true</l>
<l>                            break</l>
<l>                        endif</l>
<l>                    endif</l>
<l>                    GraphEvent := true</l>
<l>                    break</l>
<l>                else</l>
<l>                    ButtonHold := false</l>
<l>                endif</l>
<l>            catch (Exception)</l>
<c>                * Keep waiting</c>
<l>            endtry</l>
<l>        endwhile</l>
<l>        if (GraphEvent)</l>
<l>            analyze_graph_event (Image, MouseMapping, GraphButton, GraphButtonRow, GraphButtonColumn, WindowHandle, WindowHandleBuffer, VirtualTrackball, TrackballSize, SelectedObject, Scene3D, AlphaOrig, ObjectModel3D, CamParam, Label, Title, Information, GenParamName, GenParamValue, Poses, ButtonHold, TBCenter, TBSize, WindowCenteredRotation, MaxNumModels, Poses, SelectedObject, ButtonHold, WindowCenteredRotation)</l>
<l>        endif</l>
<l>        if (Exit)</l>
<l>            break</l>
<l>        endif</l>
<l>    endwhile</l>
<c>    * </c>
<c>    * Display final state with persistence, if requested</c>
<c>    * Note that disp_object_model_3d must be used instead of the 3D scene</c>
<l>    if (|PersistenceParamName| &gt; 0)</l>
<l>        disp_object_model_3d (WindowHandle, ObjectModel3D, CamParam, Poses, ['disp_background','alpha',PersistenceParamName], ['true',0.0,PersistenceParamValue])</l>
<l>    endif</l>
<c>    * </c>
<c>    * Compute the output pose</c>
<l>    if (gIsSinglePose)</l>
<l>        PoseOut := Poses[0:6]</l>
<l>    else</l>
<l>        PoseOut := Poses</l>
<l>    endif</l>
<c>    * </c>
<c>    * Clean up</c>
<l>    set_system ('clip_region', ClipRegion)</l>
<l>    dev_set_preferences ('graphics_window_context_menu', 'true')</l>
<l>    dev_set_preferences ('graphics_window_mouse_wheel', WindowMouseWheel)</l>
<l>    dump_image_output (Image, WindowHandleBuffer, Scene3D, AlphaOrig, ObjectModel3D, GenParamName, GenParamValue, CamParam, Poses, ColorImage, Title, [], Label, 0, 'false', TrackballCenterRow, TrackballCenterCol, TBSize, SelectedObject, WindowCenteredRotation, TBCenter)</l>
<l>    dump_window_image (ImageDump, WindowHandleBuffer)</l>
<l>    dev_set_window (WindowHandle)</l>
<l>    dev_display (ImageDump)</l>
<l>    close_window (WindowHandleBuffer)</l>
<l>    set_part (WindowHandle, WPRow1, WPColumn1, WPRow2, WPColumn2)</l>
<l>    clear_scene_3d (Scene3D)</l>
<l>    Scene3D := []</l>
<l>catch (Exception)</l>
<l>    try</l>
<l>        if (0 &lt; |Scene3DTest|)</l>
<l>            clear_scene_3d (Scene3DTest)</l>
<l>            Scene3DTest := []</l>
<l>        endif</l>
<l>        if (0 &lt; |Scene3D|)</l>
<l>            clear_scene_3d (Scene3D)</l>
<l>            Scene3D := []</l>
<l>        endif</l>
<l>        if (0 &lt; |WindowHandleBuffer|)</l>
<l>            close_window (WindowHandleBuffer)</l>
<l>            WindowHandleBuffer := []</l>
<l>        endif</l>
<l>    catch (e)</l>
<c>        * suppress all further exceptions to return the original exception</c>
<l>    endtry</l>
<c></c>
<l>    throw (Exception)</l>
<l>endtry</l>
<l>return ()</l>
</body>
<docu id="visualize_object_model_3d">
<abstract lang="en_US">The procedure visualize_object_model_3d displays the 3D object models of ObjectModel3D in the window with the handle WindowHandle and allows to interactively modify the object poses with the mouse. The current content of the window will be kept as background.

The pose can be modified by moving the mouse while pressing a mouse button. The default settings are:

- Rotate: Left mouse button
- Zoom: Shift + Left mouse button (or Center mouse button)
- Pan: Ctrl + Left mouse button

Furthermore, it is possible to select and deselect objects, to decrease the mouse sensitivity, and to toggle the inspection mode (see the description of the generic parameter 'inspection_mode' below):

- (De-)select object(s): Right mouse button
- Low mouse sensitivity: Alt + Mouse button
- Toggle inspection mode: Ctrl + Alt + Left mouse button

Note that the selection of individual 3D object models is only available, if the number of models is not greater than 1000 (or the value passed with the generic parameter 'max_num_selectable_models', see below).

Set CamParam and the individual poses (in PoseIn) of the 3D object models to setup the displayed scene. 
If an empty tuple is given for CamParam, visualize_object_model_3d uses default camera parameters that correspond to the window size.
PoseIn can contain either multiple poses (one for each 3D object model) or one pose for all 3D object models.
If an empty tuple is given for PoseIn, visualize_object_model_3d estimates a pose, such that all 3D object models are visible.

The parameter Title can be used to specify text that will be displayed in a box at the top of the window.

The parameter Label can be used to specify a list of labels, which are displayed aligned with the corresponding 3D object model. It must either contain one entry per 3D object model or it must be empty.

The parameter Information can be used to specify text that is displayed without a box at the bottom left of the window.

The output parameter PoseOut contains the possibly modified poses used for the visualization of the 3D object models. These poses can be used directly in disp_object_model_3d and render_object_model_3d or in visualize_object_model_3d to start the visualization with exactly the poses that have been chosen interactively.

The visualization can be configured with a set of parameters, which are given in GenParamName and GenParamValue. The detailed description  of these parameters can be found in the reference documentation of disp_object_model_3d.

The following values influence the whole scene: 

'disp_background':
Flag, if the current window content should be used as background.
Values: 'true' or 'false'
Default: 'false' 

'opengl':
Decides if  OpenGL is used to display the 3D object models. Otherwise the CPU based fallback solution is used.
Values: 'true' or 'false'
Default: 'true' 

'light_position':
Position of the light source. Must be given as a string containing four space separated floating point numbers. If the fourth number is 0.0, a directional light source is used (the first three components represent the direction), otherwise a point light source is used (with the first three components representing the position). 
Default: '-100.0 -100.0 0.0 1.0'

'light_ambient':
Ambient part of the light source. Must be given as a string containing three space separated floating point numbers.
Default value: '0.2 0.2 0.2'

'light_diffuse':
Diffuse part of the light source. Must be given as a string containing three space separated floating point numbers.
Default value: '0.8 0.8 0.8' 

'colored':
Display object models in different colors. The value of this parameter defines the number of colors that are used.
Values: 3, 6, or 12
Default: all objects are white 

'object_index_persistence':
Must be set to 'true' to enable the object index query in get_disp_object_model_3d_info.
Values: 'true' or 'false'
Default: 'false' 

'depth_persistence':
Must be set to 'true' to enable the depth query in get_disp_object_model_3d_info.
Values: 'true' or 'false'
Default: 'false' 

The following parameters can be set for all objects in the scene or for a specific object by appending the index of the object to the parameter name (e.g., 'color_0' to set the color of the first object).

'attribute'
Explicitly select in which way a 3D object model is visualized.
Values: 'auto', 'faces', 'primitive', 'points', 'lines'
Default Value: 'auto'

'color':
Color of the 3D object model. The available colors can be queried with the operator query_color. In addition, the color may be specified as an RGB triplet in the form '#rrggbb', where 'rr', 'gg', and 'bb' are hexadecimal numbers between '00' and 'ff', respectively.
Values: 'red', 'green', ...
Default value: 'white'

'alpha':
Transparency of the 3D object models. Displaying 3D object models with transparency set to less than 1.0 may significantly increase the runtime ofdisplay_scene_3d and render_scene_3d.
Values: floating point value between 0.0 (fully transparent) and 1.0 (fully opaque).
Default value: 1.0

'disp_pose':
Flag, if the pose of the 3D object models should be visualized.
Values: 'true' or 'false'
Default value: 'false'

'disp_lines':
Flag, if the contours of the 3D object models' polygons should be displayed.
Values: 'true' or 'false'
Default value: 'false'

'disp_normals':
Flag, if the surface normals of the 3D object models should be visualized.
Values: 'true' or 'false'
Default value: 'false'

'line_color':
Color of the lines if 'disp_lines' is set to 'true'. The available colors can be queried with the operator query_color. In addition, the color may be specified as an RGB triplet in the form '#rrggbb', where 'rr', 'gg', and 'bb' are hexadecimal numbers.
Values: 'red', 'green', ...
Default value: The value of 'color'

'line_width':
Sets the width of lines in pixel.
Default value: 1.0

'normal_color':
Color of the visualized normals if 'disp_normals' is set to 'true'. The available colors can be queried with the operator query_color. In addition, the color may be specified as an RGB triplet in the form '#rrggbb', where 'rr', 'gg', and 'bb' are hexadecimal numbers.
Values: 'red', 'green', ...
Default value: The value of 'color'

'point_size':
Sets the diameter of the points in pixel.
Default value: 3.5

'lut':
Sets the LUT that transforms the values of the attribute set with 'color_attrib' into a color.
See set_lut for available LUTs. If 'lut' is set to anything but 'default', 'color' is ignored.
Default value: 'default'

'color_attrib':
Name of a point attribute that is used for false color visualization.
If an attribute is set, the color of the displayed 3D points is determined by the point's attribute value and the currently set LUT (see 'lut'). This way, it is possible to visualize attributes in false colors.
Example: If 'color_attrib' is set to 'coord_z', and 'lut' is set to 'color1', the z-coordinates will be color coded from red to blue.
If 'lut' is set to 'default', the attribute values are used to scale the color that was set by the parameter 'color'.
If 'lut' is set to a different value, the attribute values of all points are internally scaled to the interval [0,255] and used as input value for the LUT function.
The mapping is also controlled by the parameters 'color_attrib_start' and 'color_attrib_end' (see below).
If faces are displayed, their color is interpolated between the color of the corner points.
Values: 'none', '&amp;distance', 'coord_x', 'coord_y', 'coord_z', user defined point attributes, or any other point attribute available.
Default: 'none'

'color_attrib_start','color_attrib_end':
The range of interest of the values of the attribute set with 'color_attrib'.
The attribute values between 'color_attrib_start' and 'color_attrib_end' are scaled to the start and end of the selected LUT. Attribute values outside the selected range are clipped. This allows to use a fixed color mapping which will not be distorted by outliers.
If set to 'auto', the minimum attribute value is mapped to the start of the LUT, the maximum is mapped to the end of the LUT, except if 'color_attrib' is 'normal_x','normal_y', or 'normal_z'. In this case, start and end are automatically set to -1 and 1.
It is possible to enter start value that is higher than the end value. This will in effect flip the used LUT.
Values: 0, 0.1, 1, 100, 255, ...
Default value: 'auto'

'red_channel_attrib', 'green_channel_attrib', 'blue_channel_attrib':
Name of a point attribute that is used for the red, green, or blue color channel.
This is most useful when used with a group of three connected attributes, like RGB colors or normal vectors. This way it is possible to display points in colored texture, e.g., display the object model with overlayed RGB-sensor data, or display point normals in false colors.
To display only a single attribute in false colors, please use 'color_attrib' (see above).
By default, the attribute values are assumed to lie between 0 and 255. If the attributes have a different range, you additionally have to set the parameters'rgb_channel_attrib_start' and 'rgb_channel_attrib_end' (see below).
If only 1 or 2 channels are set, the remaining channels use the RGB value of the color set with 'color'.
If faces are displayed, their color is interpolated between the color of the corner points.
Values: 'none', '&amp;red','&amp;green','&amp;blue', 'normal_x', 'normal_y', 'normal_z', user defined point attributes, or any other point attribute available.
Default: 'none'

'rgb_channel_attrib_start', 'rgb_channel_attrib_end':
The range of interest of the values of attributes set with 'red_channel_attrib', 'green_channel_attrib', and 'blue_channel_attrib'.
These parameters define the value range that is scaled to the full RGB channels. This is useful, if the input attribute values are not in the interval [0,255].
If set to 'auto', the minimum attribute value is mapped to 0, the maximum is mapped to 255, except if the attribute is 'normal_x', 'normal_y', or 'normal_z'. In this case, start and end are automatically set to -1 and 1.
It is possible to enter start value that is higher than the end value. This will in effect invert the displayed RGB colors.
The range can be set for the channels individually by replacing 'rgb' in the parameter name with the channel name, e.g., 'green_channel_attrib_start'.
Values: 'auto', 0, 0.1, 1, 100, 255, ...
Default values: 0, 255

The following value defines the maximum number of models, for which the selection of individual models is available:

'max_num_selectable_models':
Number of 3D Object models that can be selected and handled individually. If there are more models passed then this number, some calculations are performed differently and for reasons of efficiency, the individual selection and handling of models is not supported anymore.
Values: 1, 2, ...
Default: 1000

The following value influences the handling how the pose can be modified interactively: 

'inspection_mode':
Flag that controls the initial state of the inspection mode.
If 'inspection_mode' is set to 'standard', the rotation center is fixed in the center of the displayed object. In this mode, the rotation center is indicated by a vertical cross (+). This mode is  particularly well suited for getting an impression of the whole object.
If 'inspection_mode' is set to 'surface', the rotation center is fixed in the center of the window and it lies on the surface of the displayed object. In this mode, the rotation center is indicated by a diagonal cross (x). This mode is particularly well suited for a detailed inspection of the object's surface. It is less suitable for the inspection of point clouds, because they do not provide surface information.
Note that the trackball itself is kept in the center of the image, regardless of the selected inspection mode. Note also that the inspection mode can be toggled interactively during the visualization with Ctrl + Alt + Left mouse button (see above).
Values: 'standard' or 'surface'
Default: 'standard''
  </abstract>
<alternatives>
<item>disp_object_model_3d</item>
</alternatives>
<chapters lang="de_DE">
<item>Graphik</item>
<item>Ausgabe</item>
</chapters>
<chapters lang="en_US">
<item>Graphics</item>
<item>Output</item>
</chapters>
<example lang="en_US">read_object_model_3d ('pipe_joint', 'm', [], [], ObjectModel3D1, Status)
read_object_model_3d ('clamp_sloped', 'mm', [], [], ObjectModel3D2, Status)
gen_cam_par_area_scan_division (0.016, 0, 5e-6, 5e-6, 320, 240, 640, 480, CamParam)
get_cam_par_data (CamParam, 'image_width', Width)
get_cam_par_data (CamParam, 'image_height', Height)
dev_open_window (0, 0, Width, Height, 'black', WindowHandle)
create_pose (-0.02, 0.01, .6, 110, 5, 320, 'Rp+T', 'gba', 'point', Pose1)
create_pose (0.01, 0.03, .6, 130, 315, 340, 'Rp+T', 'gba', 'point', Pose2)
visualize_object_model_3d (WindowHandle, [ObjectModel3D1, ObjectModel3D2], \ 
                           CamParam, [Pose1, Pose2], \
                           ['alpha', 'color_0', 'color_1', 'disp_pose'], \
                           [0.5,     'orange',  'yellow',  'true'], \
                           ['3D visualization demo'], ['pipe joint', 'clamp'], \
                           ['Use mouse to change view'], PoseOut)</example>
<library lang="en_US">MVTec Standard Procedures</library>
<predecessor>
<item>read_object_model_3d</item>
<item>gen_object_model_3d_from_points</item>
</predecessor>
<see_also>
<item>disp_object_model_3d</item>
</see_also>
<short lang="en_US">Interactively display 3D object models</short>
<successor>
<item>clear_object_model_3d</item>
</successor>
<parameters>
<parameter id="CamParam">
<default_type>real</default_type>
<default_value>[]</default_value>
<description lang="en_US">Camera parameters of the scene.</description>
<mixed_type>optional</mixed_type>
<multivalue>true</multivalue>
<sem_type>real</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
<parameter id="GenParamName">
<default_type>string</default_type>
<default_value>[]</default_value>
<description lang="en_US">Names of the generic parameters. All generic parameters of disp_object_model_3d can be passed here as well.</description>
<multivalue>optional</multivalue>
<sem_type>string</sem_type>
<type_list>
<item>string</item>
</type_list>
<values>
<item>'alpha'</item>
<item>'attribute'</item>
<item>'color'</item>
<item>'colored'</item>
<item>'disp_background'</item>
<item>'disp_lines'</item>
<item>'disp_normals'</item>
<item>'disp_pose'</item>
<item>'inspection_mode'</item>
<item>'intensity'</item>
<item>'intensity_red'</item>
<item>'intensity_green'</item>
<item>'intensity_blue'</item>
<item>'light_position'</item>
<item>'light_ambient'</item>
<item>'light_diffuse'</item>
<item>'line_color'</item>
<item>'line_width'</item>
<item>'lut'</item>
<item>'max_num_selectable_models'</item>
<item>'normal_color'</item>
<item>'point_size'</item>
</values>
</parameter>
<parameter id="GenParamValue">
<default_type>string</default_type>
<default_value>[]</default_value>
<description lang="en_US">Values of the generic parameters. All generic parameters of disp_object_model_3d can be passed here as well.</description>
<mixed_type>optional</mixed_type>
<multivalue>optional</multivalue>
<sem_type>any</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
<item>string</item>
</type_list>
<values>
<item>'true'</item>
<item>'false'</item>
<item>'coord_x'</item>
<item>'coord_y'</item>
<item>'coord_z'</item>
<item>'red'</item>
<item>'green'</item>
<item>'blue'</item>
<item>'auto'</item>
<item>'faces'</item>
<item>'primitive'</item>
<item>'points'</item>
<item>'lines'</item>
<item>'normal_x'</item>
<item>'normal_y,'normal_z'</item>
<item>'standard'</item>
<item>'surface'</item>
</values>
</parameter>
<parameter id="Information">
<default_type>string</default_type>
<default_value>[]</default_value>
<description lang="en_US">Text that is to be displayed in the lower left corner of the output graphics window.</description>
<multivalue>optional</multivalue>
<sem_type>string</sem_type>
<type_list>
<item>string</item>
</type_list>
</parameter>
<parameter id="Label">
<default_type>string</default_type>
<default_value>[]</default_value>
<description lang="en_US">Text that is to be displayed at the position of each displayed object model.</description>
<multivalue>optional</multivalue>
<sem_type>string</sem_type>
<type_list>
<item>string</item>
</type_list>
</parameter>
<parameter id="ObjectModel3D">
<default_type>integer</default_type>
<description lang="en_US">Handles of the 3D object models.</description>
<mixed_type>false</mixed_type>
<multivalue>optional</multivalue>
<sem_type>object_model_3d</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="PoseIn">
<default_type>real</default_type>
<default_value>[]</default_value>
<description lang="en_US">3D poses of the objects.</description>
<mixed_type>optional</mixed_type>
<multivalue>optional</multivalue>
<sem_type>pose</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
<parameter id="PoseOut">
<default_type>real</default_type>
<description lang="en_US">Poses of all object models that were possibly interactively changed by the user.</description>
<mixed_type>optional</mixed_type>
<multivalue>true</multivalue>
<sem_type>pose</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
<parameter id="Title">
<default_type>string</default_type>
<default_value>[]</default_value>
<description lang="en_US">Text that is to be displayed in the upper left corner of the output graphics window.</description>
<multivalue>optional</multivalue>
<sem_type>string</sem_type>
<type_list>
<item>string</item>
</type_list>
</parameter>
<parameter id="WindowHandle">
<default_type>integer</default_type>
<description lang="en_US">Window identifier.</description>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>window</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
</parameters>
</docu>
</procedure>
<procedure name="visualize_object_model_3d_ext" access="local">
<interface>
<ic>
<par name="WindowHandle" base_type="ctrl" dimension="0"/>
<par name="ObjectModel3D" base_type="ctrl" dimension="0"/>
<par name="CamParam" base_type="ctrl" dimension="0"/>
<par name="PoseIn" base_type="ctrl" dimension="0"/>
<par name="GenParamName" base_type="ctrl" dimension="0"/>
<par name="GenParamValue" base_type="ctrl" dimension="0"/>
<par name="Title" base_type="ctrl" dimension="0"/>
<par name="Label" base_type="ctrl" dimension="0"/>
<par name="Information" base_type="ctrl" dimension="0"/>
<par name="MessageQueue" base_type="ctrl" dimension="0"/>
<par name="Buttons" base_type="ctrl" dimension="0"/>
<par name="Type" base_type="ctrl" dimension="0"/>
<par name="Message" base_type="ctrl" dimension="0"/>
<par name="DispViewPoint" base_type="ctrl" dimension="0"/>
<par name="ViewPoint" base_type="ctrl" dimension="0"/>
</ic>
</interface>
<body>
<c>* The procedure visualize_object_model_3d can be used to display</c>
<c>* one or more 3d object models and to interactively modify</c>
<c>* the object poses by using the mouse.</c>
<c>* </c>
<c>* The pose can be modified by moving the mouse while</c>
<c>* pressing a mouse button. The default settings are:</c>
<c>* </c>
<c>*  Rotate: Left mouse button</c>
<c>*  Zoom: Shift + Left mouse button (or Center mouse button)</c>
<c>*  Pan: Ctrl + Left mouse button</c>
<c>* </c>
<c>* Furthermore, it is possible to select and deselect objects,</c>
<c>* to decrease the mouse sensitivity, and to toggle the</c>
<c>* inspection mode (see the description of the generic parameter</c>
<c>* 'inspection_mode' below):</c>
<c>* </c>
<c>*  (De-)select object(s): Right mouse button</c>
<c>*  Low mouse sensitivity: Alt + Mouse button</c>
<c>*  Toggle inspection mode: Ctrl + Alt + Left mouse button</c>
<c>* </c>
<c>* In GenParamName and GenParamValue all generic Parameters</c>
<c>* of disp_object_model_3d are supported.</c>
<l>try</l>
<c>    * </c>
<c>    * **********************************************************</c>
<c>    * Define parameter variables</c>
<c>    * **********************************************************</c>
<c>    * </c>
<l>    create_message (Parameters)</l>
<l>    set_message_tuple (Parameters, 'MessageQueue', MessageQueue)</l>
<c></c>
<c>    * </c>
<c>    * **********************************************************</c>
<c>    * Initialize Handles to enable correct handling in error case</c>
<c>    * **********************************************************</c>
<l>    Scene3DTest := []</l>
<l>    Scene3D := []</l>
<l>    WindowHandleBuffer := []</l>
<c></c>
<c>    * **********************************************************</c>
<c>    * Some user defines that may be adapted if desired</c>
<c>    * **********************************************************</c>
<c>    * </c>
<c>    * TrackballSize defines the diameter of the trackball in</c>
<c>    * the image with respect to the smaller image dimension.</c>
<l>    TrackballSize := 0.8</l>
<c>    * </c>
<c>    * VirtualTrackball defines the type of virtual trackball that</c>
<c>    * shall be used ('shoemake' or 'bell').</c>
<l>    VirtualTrackball := 'shoemake'</l>
<l>*     VirtualTrackball := 'bell'</l>
<c>    * </c>
<c>    * Functionality of mouse buttons</c>
<c>    *     1: Left Button</c>
<c>    *     2: Middle Button</c>
<c>    *     4: Right Button</c>
<c>    *     5: Left+Right Mousebutton</c>
<c>    *   8+x: Shift + Mousebutton</c>
<c>    *  16+x: Ctrl + Mousebutton</c>
<c>    *  48+x: Ctrl + Alt + Mousebutton</c>
<c>    * in the order [Translate, Rotate, Scale, ScaleAlternative1, ScaleAlternative2, SelectObjects, ToggleSelectionMode]</c>
<l>    MouseMapping := [17,1,2,5,9,4,49]</l>
<c>    * </c>
<c>    * The labels of the objects appear next to their projected</c>
<c>    * center. With gDispObjOffset a fixed offset is added</c>
<c>    *                   R,  C</c>
<l>    gDispObjOffset := [-30,0]</l>
<l>    set_message_tuple (Parameters, 'gDispObjOffset', gDispObjOffset)</l>
<c>    * </c>
<c>    * Customize the decoration of the different text elements</c>
<c>    *               Color,   Box</c>
<l>    gInfoDecor := ['white','false']</l>
<l>    set_message_tuple (Parameters, 'gInfoDecor', gInfoDecor)</l>
<l>    gLabelsDecor := ['white','false']</l>
<l>    set_message_tuple (Parameters, 'gLabelsDecor', gLabelsDecor)</l>
<l>    gTitleDecor := ['black','true']</l>
<l>    set_message_tuple (Parameters, 'gTitleDecor', gTitleDecor)</l>
<c>    * </c>
<c>    * Customize the position of some text elements</c>
<c>    *   gInfoPos has one of the values</c>
<c>    *   {'UpperLeft', 'LowerLeft', 'UpperRight'}</c>
<l>    gInfoPos := 'LowerLeft'</l>
<l>    set_message_tuple (Parameters, 'gInfoPos', gInfoPos)</l>
<c>    *   gTitlePos has one of the values</c>
<c>    *   {'UpperLeft', 'UpperCenter', 'UpperRight'}</c>
<l>    gTitlePos := 'UpperLeft'</l>
<l>    set_message_tuple (Parameters, 'gTitlePos', gTitlePos)</l>
<c>    * Alpha value (=1-transparency) that is used for visualizing</c>
<c>    * the objects that are not selected</c>
<l>    gAlphaDeselected := 0.3</l>
<l>    set_message_tuple (Parameters, 'gAlphaDeselected', gAlphaDeselected)</l>
<c>    * BUTTONS</c>
<l>    ExitButton := -1</l>
<l>    if (Buttons == [])</l>
<c>        * Customize the label of the continue button</c>
<l>        Buttons[0] := ' Continue '</l>
<c>        * Position of the button</c>
<l>        Buttons[1] := 'right'</l>
<l>        Buttons[2] := 'bottom'</l>
<l>        Buttons[3] := -1</l>
<l>        Buttons[4] := -1</l>
<l>        ExitButton := 0</l>
<l>    endif</l>
<c>    * Number of 3D Object models that can be selected and handled individually.</c>
<c>    * If there are more models passed then this number, some calculations</c>
<c>    * are performed differently and the individual selection and handling</c>
<c>    * of models is not supported anymore. Note that the value of MaxNumModels</c>
<c>    * can be overwritten with the generic parameter max_num_selectable_models.</c>
<l>    MaxNumModels := 1000</l>
<c>    * Defines the default for the initial state of the rotation center:</c>
<c>    * (1) The rotation center is fixed in the center of the image and lies</c>
<c>    *     on the surface of the object.</c>
<c>    * (2) The rotation center lies in the center of the object.</c>
<l>    WindowCenteredRotation := 2</l>
<c>    * </c>
<c>    * **********************************************************</c>
<c>    * </c>
<c>    * Initialize some values</c>
<l>    NumModels := |ObjectModel3D|</l>
<l>    SelectedObject := gen_tuple_const(NumModels,1)</l>
<l>    ButtonPressStatus := 0</l>
<c>    * </c>
<c>    * Apply some system settings</c>
<l>    dev_set_preferences ('graphics_window_context_menu', 'false')</l>
<l>    dev_get_preferences ('graphics_window_mouse_wheel', WindowMouseWheel)</l>
<l>    dev_set_preferences ('graphics_window_mouse_wheel', 'false')</l>
<l>    get_system ('clip_region', ClipRegion)</l>
<l>    set_system ('clip_region', 'false')</l>
<l>    dev_update_off ()</l>
<c>    * </c>
<c>    * Check if GenParamName matches GenParamValue</c>
<l>    if (|GenParamName| != |GenParamValue|)</l>
<l>        throw ('Number of generic parameters does not match number of generic parameter values')</l>
<l>    endif</l>
<c>    * </c>
<c>    * </c>
<c>    * Refactor camera parameters to fit to window size</c>
<c>    * </c>
<l>    CPLength := |CamParam|</l>
<l>    get_window_extents (WindowHandle, RowNotUsed, ColumnNotUsed, Width, Height)</l>
<l>    get_part (WindowHandle, WPRow1, WPColumn1, WPRow2, WPColumn2)</l>
<l>    set_part (WindowHandle, 0, 0, Height - 1, Width - 1)</l>
<l>    if (CPLength == 0)</l>
<l>        gen_cam_par_area_scan_division (0.06, 0, 8.5e-6, 8.5e-6, Width / 2, Height / 2, Width, Height, CamParam)</l>
<l>    else</l>
<l>        get_cam_par_data (CamParam, ['sx','sy','cx','cy','image_width','image_height'], CamParamValue)</l>
<l>        CamWidth := real(CamParamValue[4])</l>
<l>        CamHeight := real(CamParamValue[5])</l>
<l>        Scale := min([Width / CamWidth,Height / CamHeight])</l>
<l>        set_cam_par_data (CamParam, 'sx', CamParamValue[0] / Scale, CamParam)</l>
<l>        set_cam_par_data (CamParam, 'sy', CamParamValue[1] / Scale, CamParam)</l>
<l>        set_cam_par_data (CamParam, 'cx', CamParamValue[2] * Scale, CamParam)</l>
<l>        set_cam_par_data (CamParam, 'cy', CamParamValue[3] * Scale, CamParam)</l>
<l>        set_cam_par_data (CamParam, 'image_width', int(CamParamValue[4] * Scale), CamParam)</l>
<l>        set_cam_par_data (CamParam, 'image_height', int(CamParamValue[5] * Scale), CamParam)</l>
<l>    endif</l>
<c>    * </c>
<c>    * Check the generic parameters for max_num_selectable_models</c>
<c>    * (Note that the default is set above to MaxNumModels := 1000)</c>
<l>    Indices := find(GenParamName,'max_num_selectable_models')</l>
<l>    if (Indices != -1 and Indices != [])</l>
<l>        if (is_number(GenParamValue[Indices[0]]))</l>
<l>            if (int(number(GenParamValue[Indices[0]])) &lt; 1)</l>
<c>                * Wrong parameter value: Only integer values greater than 0 are allowed</c>
<l>                throw ('Wrong value for parameter \'max_num_selectable_models\' (must be an integer value greater than 0)')</l>
<l>            endif</l>
<l>        else</l>
<c>            * Wrong parameter value: Only integer values greater than 0 are allowed</c>
<l>            throw ('Wrong value for parameter \'max_num_selectable_models\' (must be an integer value greater than 0)')</l>
<l>        endif</l>
<l>        MaxNumModels := int(number(GenParamValue[Indices[0]]))</l>
<l>        GenParamName := remove(GenParamName,Indices)</l>
<l>        GenParamValue := remove(GenParamValue,Indices)</l>
<l>    endif</l>
<c>    * </c>
<c>    * Check the generic parameters for window_centered_rotation</c>
<c>    * (Note that the default is set above to WindowCenteredRotation := 2)</c>
<l>    Indices := find(GenParamName,'inspection_mode')</l>
<l>    if (Indices != -1 and Indices != [])</l>
<l>        if (GenParamValue[Indices[0]] == 'surface')</l>
<l>            WindowCenteredRotation := 1</l>
<l>        elseif (GenParamValue[Indices[0]] == 'standard')</l>
<l>            WindowCenteredRotation := 2</l>
<l>        else</l>
<c>            * Wrong parameter value, use default value</c>
<l>        endif</l>
<l>        GenParamName := remove(GenParamName,Indices)</l>
<l>        GenParamValue := remove(GenParamValue,Indices)</l>
<l>    endif</l>
<c>    * </c>
<c>    * Check the generic parameters for disp_background</c>
<c>    * (The former parameter name 'use_background' is still supported</c>
<c>    *  for compatibility reasons)</c>
<l>    DispBackground := 'false'</l>
<l>    if (|GenParamName| &gt; 0)</l>
<l>        Mask := GenParamName [==] 'disp_background' or GenParamName [==] 'use_background'</l>
<l>        Indices := find(Mask,1)</l>
<l>    else</l>
<l>        Indices := -1</l>
<l>    endif</l>
<l>    if (Indices != -1 and Indices != [])</l>
<l>        DispBackground := GenParamValue[Indices[0]]</l>
<l>        if (DispBackground != 'true' and DispBackground != 'false')</l>
<c>            * Wrong parameter value: Only 'true' and 'false' are allowed</c>
<l>            throw ('Wrong value for parameter \'disp_background\' (must be either \'true\' or \'false\')')</l>
<l>        endif</l>
<c>        * Note the the background is handled explicitly in this procedure</c>
<c>        * and therefore, the parameter is removed from the list of</c>
<c>        * parameters and disp_background is always set to true (see below)</c>
<l>        GenParamName := remove(GenParamName,Indices)</l>
<l>        GenParamValue := remove(GenParamValue,Indices)</l>
<l>    endif</l>
<c>    * </c>
<c>    * Read and check the parameter Label for each object</c>
<l>    if (|Label| == 0)</l>
<l>        Label := 0</l>
<l>    elseif (|Label| == 1)</l>
<l>        Label := gen_tuple_const(NumModels,Label)</l>
<l>    else</l>
<l>        if (|Label| != NumModels)</l>
<c>            * Error: Number of elements in Label does not match the</c>
<c>            * number of object models</c>
<l>            stop ()</l>
<l>        endif</l>
<l>    endif</l>
<c>    * </c>
<c>    * Read and check the parameter PoseIn for each object</c>
<l>    get_object_models_center (ObjectModel3D, Center)</l>
<l>    if (Center == [])</l>
<l>        Center := [0,0,0]</l>
<l>    endif</l>
<l>    if (|PoseIn| == 0)</l>
<c>        * If no pose was specified by the caller, automatically calculate</c>
<c>        * a pose that is appropriate for the visualization.</c>
<c>        * Set the initial model reference pose. The orientation is parallel</c>
<c>        * to the object coordinate system, the position is at the center</c>
<c>        * of gravity of all models.</c>
<l>        create_pose (-Center[0], -Center[1], -Center[2], 0, 0, 0, 'Rp+T', 'gba', 'point', PoseIn)</l>
<l>        determine_optimum_pose_distance (ObjectModel3D, CamParam, 0.9, PoseIn, PoseEstimated)</l>
<l>        Poses := []</l>
<l>        HomMat3Ds := []</l>
<l>        Sequence := [0:NumModels * 7 - 1]</l>
<l>        Poses := PoseEstimated[Sequence % 7]</l>
<l>        gIsSinglePose := true</l>
<l>        set_message_tuple (Parameters, 'gIsSinglePose', gIsSinglePose)</l>
<l>    elseif (|PoseIn| == 7)</l>
<l>        Poses := []</l>
<l>        HomMat3Ds := []</l>
<l>        Sequence := [0:NumModels * 7 - 1]</l>
<l>        Poses := PoseIn[Sequence % 7]</l>
<l>        gIsSinglePose := true</l>
<l>        set_message_tuple (Parameters, 'gIsSinglePose', gIsSinglePose)</l>
<l>    else</l>
<l>        if (|PoseIn| != |ObjectModel3D| * 7)</l>
<c>            * Error: Wrong number of values of input control parameter 'PoseIn'</c>
<l>            stop ()</l>
<l>        else</l>
<l>            Poses := PoseIn</l>
<l>        endif</l>
<l>        gIsSinglePose := false</l>
<l>        set_message_tuple (Parameters, 'gIsSinglePose', gIsSinglePose)</l>
<l>    endif</l>
<c></c>
<c>    * </c>
<c>    * Open (invisible) buffer window to avoid flickering</c>
<l>    open_window (0, 0, Width, Height, 0, 'buffer', '', WindowHandleBuffer)</l>
<l>    set_part (WindowHandleBuffer, 0, 0, Height - 1, Width - 1)</l>
<l>    get_font (WindowHandle, Font)</l>
<l>    try</l>
<l>        set_font (WindowHandleBuffer, Font)</l>
<l>    catch (Exception)</l>
<l>    endtry</l>
<c>    * </c>
<c>    *  Is OpenGL available and should it be used?</c>
<l>    gUsesOpenGL := 'true'</l>
<l>    set_message_tuple (Parameters, 'gUsesOpenGL', gUsesOpenGL)</l>
<l>    Indices := find(GenParamName,'opengl')</l>
<l>    if (Indices != -1 and Indices != [])</l>
<l>        gUsesOpenGL := GenParamValue[Indices[0]]</l>
<l>        set_message_tuple (Parameters, 'gUsesOpenGL', gUsesOpenGL)</l>
<l>        GenParamName := remove(GenParamName,Indices)</l>
<l>        GenParamValue := remove(GenParamValue,Indices)</l>
<l>        if (gUsesOpenGL != 'true' and gUsesOpenGL != 'false')</l>
<c>            * Wrong parameter value: Only 'true' and 'false' are allowed</c>
<l>            throw ('Wrong value for parameter \'opengl\' (must be either \'true\' or \'false\')')</l>
<l>        endif</l>
<l>    endif</l>
<l>    if (gUsesOpenGL == 'true')</l>
<l>        get_system ('opengl_info', OpenGLInfo)</l>
<l>        if (OpenGLInfo == 'No OpenGL support included.')</l>
<l>            gUsesOpenGL := 'false'</l>
<l>            set_message_tuple (Parameters, 'gUsesOpenGL', gUsesOpenGL)</l>
<l>        else</l>
<l>            gen_object_model_3d_from_points (0, 0, 0, DummyObjectModel3D)</l>
<l>            create_scene_3d (Scene3DTest)</l>
<l>            add_scene_3d_camera (Scene3DTest, CamParam, CameraIndexTest)</l>
<l>            determine_optimum_pose_distance (DummyObjectModel3D, CamParam, 0.9, [0,0,0,0,0,0,0], PoseTest)</l>
<l>            add_scene_3d_instance (Scene3DTest, DummyObjectModel3D, PoseTest, InstanceIndexTest)</l>
<l>            try</l>
<l>                display_scene_3d (WindowHandleBuffer, Scene3DTest, InstanceIndexTest)</l>
<l>            catch (Exception)</l>
<l>                gUsesOpenGL := 'false'</l>
<l>                set_message_tuple (Parameters, 'gUsesOpenGL', gUsesOpenGL)</l>
<l>            endtry</l>
<l>            Scene3DTest := []</l>
<l>            DummyObjectModel3D := []</l>
<l>        endif</l>
<l>    endif</l>
<c>    * </c>
<c>    * Compute the trackball</c>
<l>    MinImageSize := min([Width,Height])</l>
<l>    TrackballRadiusPixel := TrackballSize * MinImageSize / 2.0</l>
<c>    * </c>
<c>    * Measure the text extents for the continue button in the</c>
<c>    * graphics window</c>
<c>    * Finalize Buttons</c>
<l>    for idx := 0 to |Buttons| - 1 by 5</l>
<l>        get_font_extents (WindowHandle, MaxAscent, MaxDescent, MaxWidth, MaxHeight)</l>
<l>        get_string_extents (WindowHandleBuffer, Buttons[idx + 0] + '  ', Ascent, Descent, TextWidth, TextHeight)</l>
<l>        ButtonWidth := Buttons[idx + 3]</l>
<l>        if (ButtonWidth == -1)</l>
<l>            ButtonWidth := TextWidth</l>
<l>        endif</l>
<l>        ButtonHeight := Buttons[idx + 4]</l>
<l>        if (ButtonHeight == -1)</l>
<c>            * Button border is of size 2</c>
<l>            ButtonHeight := MaxHeight</l>
<l>        endif</l>
<c>        * X position</c>
<l>        if (Buttons[idx + 1] == 'right')</l>
<l>            Buttons[idx + 1] := Width - 15 - ButtonWidth</l>
<l>        elseif (Buttons[idx + 1] == 'left')</l>
<l>            Buttons[idx + 1] := 15</l>
<l>        elseif (Buttons[idx + 1] == 'center')</l>
<l>            Buttons[idx + 1] := Width / 2 - ButtonWidth / 2</l>
<l>        else</l>
<l>            throw ('Invalid button horizontal position: ' + Buttons[idx + 1])</l>
<l>        endif</l>
<l>        Buttons[idx + 3] := Buttons[idx + 1] + ButtonWidth</l>
<c>        * Y position</c>
<l>        if (Buttons[idx + 2] == 'bottom')</l>
<l>            Buttons[idx + 2] := Height - 25 - ButtonHeight</l>
<l>        elseif (Buttons[idx + 2] == 'above_bottom')</l>
<l>            Buttons[idx + 2] := Height - 25 - ButtonHeight * 2.5</l>
<l>        elseif (Buttons[idx + 2] == 'top')</l>
<l>            Buttons[idx + 2] := 25</l>
<l>        elseif (Buttons[idx + 2] == 'center')</l>
<l>            Buttons[idx + 2] := Height / 2 - ButtonHeight / 2</l>
<l>        else</l>
<l>            throw ('Invalid button vertical position: ' + Buttons[idx + 2])</l>
<l>        endif</l>
<l>        Buttons[idx + 4] := Buttons[idx + 2] + ButtonHeight</l>
<l>    endfor</l>
<l>    gButtons := Buttons</l>
<l>    set_message_tuple (Parameters, 'gButtons', gButtons)</l>
<c>    * </c>
<c>    * Store background image</c>
<l>    if (DispBackground == 'false')</l>
<l>        clear_window (WindowHandle)</l>
<l>    endif</l>
<l>    dump_window_image (Image, WindowHandle)</l>
<c>    * Special treatment for color background images necessary</c>
<l>    count_channels (Image, NumChannels)</l>
<l>    ColorImage := NumChannels == 3</l>
<c>    * </c>
<l>    OriginalGenParamName := GenParamName</l>
<l>    OriginalGenParamValue := GenParamValue</l>
<c></c>
<l>    Exit := 0</l>
<l>    PreviousSentPose := []</l>
<l>    while (not Exit)</l>
<l>        GenParamName := OriginalGenParamName</l>
<l>        GenParamValue := OriginalGenParamValue</l>
<c></c>
<l>        create_scene_3d (Scene3D)</l>
<l>        add_scene_3d_camera (Scene3D, CamParam, CameraIndex)</l>
<l>        add_scene_3d_instance (Scene3D, ObjectModel3D, Poses, AllInstances)</l>
<c>        * Always set 'disp_background' to true,  because it is handled explicitly</c>
<c>        * in this procedure (see above)</c>
<l>        set_scene_3d_param (Scene3D, 'disp_background', 'true')</l>
<c>        * Check if we have to set light specific parameters</c>
<l>        SetLight := regexp_test(GenParamName,'light_')</l>
<l>        if (SetLight)</l>
<c>            * set position of light source</c>
<l>            Indices := find(GenParamName,'light_position')</l>
<l>            if (Indices != -1 and Indices != [])</l>
<c>                * If multiple light positions are given, use the last one</c>
<l>                LightParam := number(split(GenParamValue[Indices[|Indices| - 1]],', '))</l>
<l>                if (|LightParam| != 4)</l>
<l>                    throw ('light_position must be given as a string that contains four space separated floating point numbers')</l>
<l>                endif</l>
<l>                LightPosition := LightParam[0:2]</l>
<l>                LightKind := 'point_light'</l>
<l>                if (LightParam[3] == 0)</l>
<l>                    LightKind := 'directional_light'</l>
<l>                endif</l>
<c>                * Currently, only one light source is supported</c>
<l>                remove_scene_3d_light (Scene3D, 0)</l>
<l>                add_scene_3d_light (Scene3D, LightPosition, LightKind, LightIndex)</l>
<l>                tuple_remove (GenParamName, Indices, GenParamName)</l>
<l>                tuple_remove (GenParamValue, Indices, GenParamValue)</l>
<l>            endif</l>
<c>            * set ambient part of light source</c>
<l>            Indices := find(GenParamName,'light_ambient')</l>
<l>            if (Indices != -1 and Indices != [])</l>
<c>                * If the ambient part is set multiple times, use the last setting</c>
<l>                LightParam := number(split(GenParamValue[Indices[|Indices| - 1]],', '))</l>
<l>                if (|LightParam| &lt; 3)</l>
<l>                    throw ('light_ambient must be given as a string that contains three space separated floating point numbers')</l>
<l>                endif</l>
<l>                set_scene_3d_light_param (Scene3D, 0, 'ambient', LightParam[0:2])</l>
<l>                tuple_remove (GenParamName, Indices, GenParamName)</l>
<l>                tuple_remove (GenParamValue, Indices, GenParamValue)</l>
<l>            endif</l>
<c>            * Set diffuse part of light source</c>
<l>            Indices := find(GenParamName,'light_diffuse')</l>
<l>            if (Indices != -1 and Indices != [])</l>
<c>                * If the diffuse part is set multiple times, use the last setting</c>
<l>                LightParam := number(split(GenParamValue[Indices[|Indices| - 1]],', '))</l>
<l>                if (|LightParam| &lt; 3)</l>
<l>                    throw ('light_diffuse must be given as a string that contains three space separated floating point numbers')</l>
<l>                endif</l>
<l>                set_scene_3d_light_param (Scene3D, 0, 'diffuse', LightParam[0:2])</l>
<l>                tuple_remove (GenParamName, Indices, GenParamName)</l>
<l>                tuple_remove (GenParamValue, Indices, GenParamValue)</l>
<l>            endif</l>
<l>        endif</l>
<c>        * </c>
<c>        * Handle persistence parameters separately because persistence will</c>
<c>        * only be activated immediately before leaving the visualization</c>
<c>        * procedure</c>
<l>        PersistenceParamName := []</l>
<l>        PersistenceParamValue := []</l>
<c>        * Set position of light source</c>
<l>        Indices := find(GenParamName,'object_index_persistence')</l>
<l>        if (Indices != -1 and Indices != [])</l>
<l>            if (GenParamValue[Indices[|Indices| - 1]] == 'true')</l>
<l>                PersistenceParamName := [PersistenceParamName,'object_index_persistence']</l>
<l>                PersistenceParamValue := [PersistenceParamValue,'true']</l>
<l>            elseif (GenParamValue[Indices[|Indices| - 1]] == 'false')</l>
<l>            else</l>
<l>                throw ('Wrong value for parameter \'object_index_persistence\' (must be either \'true\' or \'false\')')</l>
<l>            endif</l>
<l>            tuple_remove (GenParamName, Indices, GenParamName)</l>
<l>            tuple_remove (GenParamValue, Indices, GenParamValue)</l>
<l>        endif</l>
<l>        Indices := find(GenParamName,'depth_persistence')</l>
<l>        if (Indices != -1 and Indices != [])</l>
<l>            if (GenParamValue[Indices[|Indices| - 1]] == 'true')</l>
<l>                PersistenceParamName := [PersistenceParamName,'depth_persistence']</l>
<l>                PersistenceParamValue := [PersistenceParamValue,'true']</l>
<l>            elseif (GenParamValue[Indices[|Indices| - 1]] == 'false')</l>
<l>            else</l>
<l>                throw ('Wrong value for parameter \'depth_persistence\' (must be either \'true\' or \'false\')')</l>
<l>            endif</l>
<l>            tuple_remove (GenParamName, Indices, GenParamName)</l>
<l>            tuple_remove (GenParamValue, Indices, GenParamValue)</l>
<l>        endif</l>
<c>        * </c>
<c>        * Parse the generic parameters</c>
<c>        * - First, all parameters that are understood by set_scene_3d_instance_param</c>
<l>        AlphaOrig := gen_tuple_const(NumModels,1)</l>
<l>        for I := 0 to |GenParamName| - 1 by 1</l>
<l>            ParamName := GenParamName[I]</l>
<l>            ParamValue := GenParamValue[I]</l>
<c>            * Check if this parameter is understood by set_scene_3d_param</c>
<l>            if (ParamName == 'alpha')</l>
<l>                AlphaOrig := gen_tuple_const(NumModels,ParamValue)</l>
<l>            endif</l>
<l>            try</l>
<l>                set_scene_3d_param (Scene3D, ParamName, ParamValue)</l>
<l>                continue</l>
<l>            catch (Exception)</l>
<l>                if (Exception[0] == 1203 or Exception[0] == 1303)</l>
<l>                    throw ('Wrong type or value for parameter ' + ParamName + ': ' + ParamValue)</l>
<l>                endif</l>
<l>            endtry</l>
<c>            * Check if it is a parameter that is valid for only one instance</c>
<c>            * and therefore can be set only with set_scene_3d_instance_param</c>
<l>            ParamNameTrunk := regexp_replace(ParamName,'_\\d+$','')</l>
<l>            if (ParamName == ParamNameTrunk)</l>
<l>                Instance := [0:NumModels - 1]</l>
<l>            else</l>
<l>                Instance := number(regexp_replace(ParamName,'^' + ParamNameTrunk + '_(\\d+)$','$1'))</l>
<l>                if (Instance &lt; 0 or Instance &gt; NumModels - 1)</l>
<l>                    throw ('Parameter ' + ParamName + ' refers to a non existing 3D object model')</l>
<l>                endif</l>
<l>            endif</l>
<l>            try</l>
<l>                set_scene_3d_instance_param (Scene3D, Instance, ParamNameTrunk, ParamValue)</l>
<l>            catch (Exception)</l>
<l>                if (Exception[0] == 1204 or Exception[0] == 1304)</l>
<l>                    throw ('Wrong type or value for parameter ' + ParamName + ': ' + ParamValue)</l>
<l>                elseif (Exception[0] == 1203 or Exception[0] == 1303)</l>
<l>                    throw ('Wrong parameter name ' + ParamName)</l>
<l>                else</l>
<l>                    throw (Exception)</l>
<l>                endif</l>
<l>            endtry</l>
<l>            if (ParamNameTrunk == 'alpha')</l>
<l>                AlphaOrig[Instance] := ParamValue</l>
<l>            endif</l>
<l>        endfor</l>
<c>        * </c>
<c>        * Start the visualization loop</c>
<l>        pose_to_hom_mat3d (Poses[0:6], HomMat3D)</l>
<l>        affine_trans_point_3d (HomMat3D, Center[0], Center[1], Center[2], Qx, Qy, Qz)</l>
<l>        TBCenter := [Qx,Qy,Qz]</l>
<l>        TBSize := (0.5 + 0.5 * sum(SelectedObject) / NumModels) * TrackballRadiusPixel</l>
<l>        ButtonHold := false</l>
<l>        SupressUpdateMessage := false</l>
<l>        while (not Exit)</l>
<l>            VisualizeTB := max(SelectedObject) != 0</l>
<l>            MaxIndex := min([|ObjectModel3D|,MaxNumModels]) - 1</l>
<c>            * Set trackball fixed in the center of the window</c>
<l>            TrackballCenterRow := Height / 2</l>
<l>            TrackballCenterCol := Width / 2</l>
<l>            if (WindowCenteredRotation == 1)</l>
<l>                try</l>
<l>                    get_trackball_center_fixed (SelectedObject[0:MaxIndex], TrackballCenterRow, TrackballCenterCol, TrackballRadiusPixel, Scene3D, ObjectModel3D[0:MaxIndex], Poses[0:(MaxIndex + 1) * 7 - 1], WindowHandleBuffer, CamParam, GenParamName, GenParamValue, TBCenter, TBSize)</l>
<l>                catch (Exception)</l>
<l>                    disp_message (WindowHandle, 'Surface inspection mode is not available.', 'image', 5, 20, 'red', 'true')</l>
<l>                    WindowCenteredRotation := 2</l>
<l>                    get_trackball_center (SelectedObject[0:MaxIndex], TrackballRadiusPixel, ObjectModel3D[0:MaxIndex], Poses[0:(MaxIndex + 1) * 7 - 1], TBCenter, TBSize)</l>
<l>                    wait_seconds (1)</l>
<l>                endtry</l>
<l>            else</l>
<l>                get_trackball_center (SelectedObject[0:MaxIndex], TrackballRadiusPixel, ObjectModel3D[0:MaxIndex], Poses[0:(MaxIndex + 1) * 7 - 1], TBCenter, TBSize)</l>
<l>            endif</l>
<l>            dump_image_output (Image, Parameters, WindowHandleBuffer, Scene3D, AlphaOrig, ObjectModel3D, GenParamName, GenParamValue, CamParam, Poses, ColorImage, Title, Information, Label, VisualizeTB, 'true', TrackballCenterRow, TrackballCenterCol, TBSize, SelectedObject, WindowCenteredRotation, TBCenter, Type, Message, DispViewPoint, ViewPoint)</l>
<l>            dump_window_image (ImageDump, WindowHandleBuffer)</l>
<l>            if (1)</l>
<l>                disp_obj (ImageDump, WindowHandle)</l>
<l>            else</l>
<l>                dev_set_window (WindowHandle)</l>
<l>                dev_display (ImageDump)</l>
<l>            endif</l>
<c></c>
<l>            if (Poses != PreviousSentPose)</l>
<l>                send_pose_update (Parameters, Poses)</l>
<l>                PreviousSentPose := Poses</l>
<l>            endif</l>
<c>            * </c>
<c>            * </c>
<c>            * Check for mouse events</c>
<l>            GraphEvent := false</l>
<l>            Exit := false</l>
<l>            Redraw := false</l>
<l>            RecreateScene3D := false</l>
<l>            while (not Exit)</l>
<c>                * </c>
<c>                * Check graphic event</c>
<l>                try</l>
<l>                    get_mouse_info (WindowHandle, MessageQueue, 0.01, GraphButtonRow, GraphButtonColumn, GraphButton)</l>
<c></c>
<l>                    if (GraphButton == -1)</l>
<c>                        * timeout! Check the second message queue</c>
<l>                        try</l>
<c>                            * Process all messages first, then perform any update</c>
<c>                            * This avoids message congestion, where we are too slow with the redrawing.</c>
<l>                            while (1)</l>
<l>                                dequeue_message (MessageQueue[1], 'timeout', 0.001, MessageHandle)</l>
<l>                                get_message_tuple (MessageHandle, 'type', MessageType)</l>
<l>                                if (MessageType == 'exit')</l>
<c>                                    * Graceful exit</c>
<l>                                    Exit := 1</l>
<l>                                    break</l>
<l>                                elseif (MessageType == 'exit_fast')</l>
<c>                                    * Fast exit - no cleanup of resources! Use only for debugging.</c>
<l>                                    return ()</l>
<l>                                elseif (MessageType == 'toggle_param')</l>
<l>                                    get_message_tuple (MessageHandle, 'param', ParamName)</l>
<l>                                    Pos := find(OriginalGenParamName,ParamName)</l>
<l>                                    if (Pos != -1 and Pos != [])</l>
<l>                                        if (OriginalGenParamValue[Pos] == 'true')</l>
<l>                                            OriginalGenParamValue[Pos] := 'false'</l>
<l>                                        else</l>
<l>                                            OriginalGenParamValue[Pos] := 'true'</l>
<l>                                        endif</l>
<l>                                    else</l>
<l>                                        OriginalGenParamName := [OriginalGenParamName,ParamName]</l>
<l>                                        OriginalGenParamValue := [OriginalGenParamValue,'true']</l>
<l>                                        Pos := |OriginalGenParamName| - 1</l>
<l>                                    endif</l>
<l>*                                     try</l>
<l>*                                         set_scene_3d_param (Scene3D, GenParamName[Pos], GenParamValue[Pos])</l>
<l>*                                     catch (Exception)</l>
<c>                                        * If the parameter cannot be set directly, recreate the scene</c>
<c>                                        * completely</c>
<l>                                        RecreateScene3D := true</l>
<l>*                                     endtry</l>
<l>                                    Redraw := true</l>
<l>                                elseif (MessageType == 'auto_rotate')</l>
<l>                                    get_message_tuple (MessageHandle, 'angle', Angle)</l>
<l>                                    Pose := [0,0,0,0,0,Angle,0]</l>
<l>                                    pose_compose (Poses, Pose, Poses)</l>
<l>                                    set_scene_3d_instance_pose (Scene3D, AllInstances, Poses)</l>
<l>                                    Redraw := true</l>
<l>                                elseif (MessageType == 'set_pose')</l>
<l>                                    get_message_tuple (MessageHandle, 'poses', NewPoses)</l>
<l>                                    if (|NewPoses| == |Poses|)</l>
<l>                                        NewPoses := Poses</l>
<l>                                    elseif (|NewPoses| == 7)</l>
<l>                                        Poses := NewPoses[[0:|Poses| - 1] % 7]</l>
<l>                                    else</l>
<c>                                        * use only first pose in NewPoses</c>
<l>                                        Poses := NewPoses[[0:|Poses| - 1] % 7]</l>
<l>                                    endif</l>
<l>                                    set_scene_3d_instance_pose (Scene3D, AllInstances, Poses)</l>
<l>                                    Redraw := true</l>
<l>                                elseif (MessageType == 'replace_object_model')</l>
<l>                                    get_message_tuple (MessageHandle, 'index', Index)</l>
<l>                                    get_message_tuple (MessageHandle, 'model', Model)</l>
<l>                                    ObjectModel3D[Index] := Model</l>
<l>                                    RecreateScene3D := true</l>
<l>                                    Redraw := true</l>
<l>                                elseif (MessageType == 'force_redraw')</l>
<l>                                    Redraw := true</l>
<l>                                elseif (MessageType == 'change_button_text')</l>
<l>                                    get_message_tuple (MessageHandle, 'index', ButtonIndex)</l>
<l>                                    get_message_tuple (MessageHandle, 'text', ButtonText)</l>
<l>                                    if (ButtonIndex &gt;= 0 and ButtonIndex &lt; |gButtons| / 5)</l>
<l>                                        gButtons[5 * ButtonIndex] := ButtonText</l>
<l>                                        set_message_tuple (Parameters, 'gButtons', gButtons)</l>
<l>                                    endif</l>
<l>                                    Redraw := true</l>
<l>                                elseif (MessageType == 'change_title')</l>
<l>                                    get_message_tuple (MessageHandle, 'title', Title)</l>
<l>                                    Redraw := true</l>
<l>                                endif</l>
<l>                            endwhile</l>
<l>                        catch (Exception)</l>
<c>                            * Timeout in dequeue_message is OK</c>
<l>                            if (Exception[0] != 9400)</l>
<l>                                throw (Exception)</l>
<l>                            endif</l>
<l>                        endtry</l>
<l>                        if (Redraw)</l>
<l>                            break</l>
<l>                        endif</l>
<l>                        continue</l>
<l>                    endif</l>
<c></c>
<l>                    if (GraphButton != 0)</l>
<l>                        check_mouse_over_button (Parameters, GraphButtonRow, GraphButtonColumn, FoundButton)</l>
<l>                        ButtonPressed := -1</l>
<l>                        if (FoundButton &gt;= 0)</l>
<c>                            * Wait until the button has been released</c>
<l>                            while (1)</l>
<l>                                get_mouse_info (WindowHandle, MessageQueue, [], GraphButtonRow, GraphButtonColumn, GraphButton)</l>
<l>                                if (GraphButton == 0)</l>
<l>                                    check_mouse_over_button (Parameters, GraphButtonRow, GraphButtonColumn, FoundButton2)</l>
<l>                                    if (FoundButton2 == FoundButton)</l>
<l>                                        ButtonPressed := FoundButton</l>
<l>                                    endif</l>
<l>                                    break</l>
<l>                                endif</l>
<c>                                * Keep waiting until mouse button is released or moved out of the window</c>
<l>                            endwhile</l>
<l>                            if (ButtonPressed &gt;= 0)</l>
<l>                                if (ButtonPressed == ExitButton)</l>
<l>                                    Exit := true</l>
<l>                                    break</l>
<l>                                else</l>
<l>                                    create_message (MessageHandle)</l>
<l>                                    set_message_tuple (MessageHandle, 'type', 'button_pressed')</l>
<l>                                    set_message_tuple (MessageHandle, 'button', ButtonPressed / 5)</l>
<l>                                    enqueue_message (MessageQueue[2], MessageHandle, [], [])</l>
<l>                                endif</l>
<l>                            endif</l>
<l>                        endif</l>
<l>                        GraphEvent := true</l>
<l>                        break</l>
<l>                    else</l>
<l>                        ButtonHold := false</l>
<l>                    endif</l>
<l>                catch (Exception)</l>
<c>                    * Keep waiting</c>
<l>                endtry</l>
<l>            endwhile</l>
<l>            if (GraphEvent)</l>
<l>                analyze_graph_event (Image, Parameters, MouseMapping, GraphButton, GraphButtonRow, GraphButtonColumn, WindowHandle, WindowHandleBuffer, VirtualTrackball, TrackballSize, SelectedObject, Scene3D, AlphaOrig, ObjectModel3D, CamParam, Label, Title, Information, GenParamName, GenParamValue, Poses, ButtonHold, TBCenter, TBSize, WindowCenteredRotation, MaxNumModels, MessageQueue, Poses, SelectedObject, ButtonHold, WindowCenteredRotation)</l>
<l>            endif</l>
<l>            if (RecreateScene3D)</l>
<l>                break</l>
<l>            endif</l>
<l>        endwhile</l>
<l>    endwhile</l>
<c></c>
<l>    try</l>
<c>        * </c>
<c>        * Display final state with persistence, if requested</c>
<c>        * Note that disp_object_model_3d must be used instead of the 3D scene</c>
<l>        if (|PersistenceParamName| &gt; 0)</l>
<l>            try</l>
<l>                disp_object_model_3d (WindowHandle, ObjectModel3D, CamParam, Poses, ['disp_background','alpha',PersistenceParamName], ['true',0.0,PersistenceParamValue])</l>
<l>            catch (Exception)</l>
<l>                stop ()</l>
<l>            endtry</l>
<l>        endif</l>
<c>        * </c>
<c>        * Compute the output pose</c>
<l>        get_message_tuple (Parameters, 'gIsSinglePose', gIsSinglePose)</l>
<l>        if (gIsSinglePose)</l>
<l>            PoseOut := Poses[0:6]</l>
<l>        else</l>
<l>            PoseOut := Poses</l>
<l>        endif</l>
<c>        * </c>
<c>        * Clean up</c>
<l>        set_system ('clip_region', ClipRegion)</l>
<l>        dev_set_preferences ('graphics_window_context_menu', 'true')</l>
<l>        dev_set_preferences ('graphics_window_mouse_wheel', WindowMouseWheel)</l>
<l>        dump_image_output (Image, Parameters, WindowHandleBuffer, Scene3D, AlphaOrig, ObjectModel3D, GenParamName, GenParamValue, CamParam, Poses, ColorImage, Title, [], Label, 0, 'false', TrackballCenterRow, TrackballCenterCol, TBSize, SelectedObject, WindowCenteredRotation, TBCenter, Type, Message, DispViewPoint, ViewPoint)</l>
<l>        dump_window_image (ImageDump, WindowHandleBuffer)</l>
<l>        dev_set_window (WindowHandle)</l>
<l>        dev_display (ImageDump)</l>
<l>        close_window (WindowHandleBuffer)</l>
<l>        set_part (WindowHandle, WPRow1, WPColumn1, WPRow2, WPColumn2)</l>
<c></c>
<c>        * Notify listener that we have terminated</c>
<l>        if (MessageQueue != [])</l>
<l>            create_message (MessageHandle)</l>
<l>            set_message_tuple (MessageHandle, 'type', 'done')</l>
<l>            enqueue_message (MessageQueue[2], MessageHandle, [], [])</l>
<l>        endif</l>
<l>    catch (Exception)</l>
<l>        if (Exception[0] == 2454 or Exception[0] == 5100)</l>
<c>            * Handle was already cleared -&gt; indicates that the window was closed (by the user)</c>
<c>            * Abort gracefully.</c>
<l>            return ()</l>
<l>        else</l>
<c>            * Unknown / Unexpected exception</c>
<l>            throw (Exception)</l>
<l>        endif</l>
<l>    endtry</l>
<l>catch (Exception)</l>
<l>    create_message (MessageHandle)</l>
<l>    set_message_tuple (MessageHandle, 'type', 'exception')</l>
<l>    set_message_tuple (MessageHandle, 'exception', Exception)</l>
<l>    enqueue_message (MessageQueue[2], MessageHandle, [], [])</l>
<l>endtry</l>
<l>return ()</l>
</body>
<docu id="visualize_object_model_3d_ext">
<abstract lang="en_US">The procedure visualize_object_model_3d displays the 3D object models of ObjectModel3D in the window with the handle WindowHandle and allows to interactively modify the object poses with the mouse. The current content of the window will be kept as background.

The pose can be modified by moving the mouse while pressing a mouse button. The default settings are:

- Rotate: Left mouse button
- Zoom: Shift + Left mouse button (or Center mouse button)
- Pan: Ctrl + Left mouse button

Furthermore, it is possible to select and deselect objects, to decrease the mouse sensitivity, and to toggle the inspection mode (see the description of the generic parameter 'inspection_mode' below):

- (De-)select object(s): Right mouse button
- Low mouse sensitivity: Alt + Mouse button
- Toggle inspection mode: Ctrl + Alt + Left mouse button

Note that the selection of individual 3D object models is only available, if the number of models is not greater than 1000 (or the value passed with the generic parameter 'max_num_selectable_models', see below).

Set CamParam and the individual poses (in PoseIn) of the 3D object models to setup the displayed scene. 
If an empty tuple is given for CamParam, visualize_object_model_3d uses default camera parameters that correspond to the window size.
PoseIn can contain either multiple poses (one for each 3D object model) or one pose for all 3D object models.
If an empty tuple is given for PoseIn, visualize_object_model_3d estimates a pose, such that all 3D object models are visible.

The parameter Title can be used to specify text that will be displayed in a box at the top of the window.

The parameter Label can be used to specify a list of labels, which are displayed aligned with the corresponding 3D object model. It must either contain one entry per 3D object model or it must be empty.

The parameter Information can be used to specify text that is displayed without a box at the bottom left of the window.

The output parameter PoseOut contains the possibly modified poses used for the visualization of the 3D object models. These poses can be used directly in disp_object_model_3d and render_object_model_3d or in visualize_object_model_3d to start the visualization with exactly the poses that have been chosen interactively.

The visualization can be configured with a set of parameters, which are given in GenParamName and GenParamValue. The detailed description  of these parameters can be found in the reference documentation of disp_object_model_3d.

The following values influence the whole scene: 

'disp_background':
Flag, if the current window content should be used as background.
Values: 'true' or 'false'
Default: 'false' 

'opengl':
Decides if  OpenGL is used to display the 3D object models. Otherwise the CPU based fallback solution is used.
Values: 'true' or 'false'
Default: 'true' 

'light_position':
Position of the light source. Must be given as a string containing four space separated floating point numbers. If the fourth number is 0.0, a directional light source is used (the first three components represent the direction), otherwise a point light source is used (with the first three components representing the position). 
Default: '-100.0 -100.0 0.0 1.0'

'light_ambient':
Ambient part of the light source. Must be given as a string containing three space separated floating point numbers.
Default value: '0.2 0.2 0.2'

'light_diffuse':
Diffuse part of the light source. Must be given as a string containing three space separated floating point numbers.
Default value: '0.8 0.8 0.8' 

'colored':
Display object models in different colors. The value of this parameter defines the number of colors that are used.
Values: 3, 6, or 12
Default: all objects are white 

'object_index_persistence':
Must be set to 'true' to enable the object index query in get_disp_object_model_3d_info.
Values: 'true' or 'false'
Default: 'false' 

'depth_persistence':
Must be set to 'true' to enable the depth query in get_disp_object_model_3d_info.
Values: 'true' or 'false'
Default: 'false' 

The following parameters can be set for all objects in the scene or for a specific object by appending the index of the object to the parameter name (e.g., 'color_0' to set the color of the first object).

'attribute'
Explicitly select in which way a 3D object model is visualized.
Values: 'auto', 'faces', 'primitive', 'points', 'lines'
Default Value: 'auto'

'color':
Color of the 3D object model. The available colors can be queried with the operator query_color. In addition, the color may be specified as an RGB triplet in the form '#rrggbb', where 'rr', 'gg', and 'bb' are hexadecimal numbers between '00' and 'ff', respectively.
Values: 'red', 'green', ...
Default value: 'white'

'alpha':
Transparency of the 3D object models. Displaying 3D object models with transparency set to less than 1.0 may significantly increase the runtime ofdisplay_scene_3d and render_scene_3d.
Values: floating point value between 0.0 (fully transparent) and 1.0 (fully opaque).
Default value: 1.0

'disp_pose':
Flag, if the pose of the 3D object models should be visualized.
Values: 'true' or 'false'
Default value: 'false'

'disp_lines':
Flag, if the contours of the 3D object models' polygons should be displayed.
Values: 'true' or 'false'
Default value: 'false'

'disp_normals':
Flag, if the surface normals of the 3D object models should be visualized.
Values: 'true' or 'false'
Default value: 'false'

'line_color':
Color of the lines if 'disp_lines' is set to 'true'. The available colors can be queried with the operator query_color. In addition, the color may be specified as an RGB triplet in the form '#rrggbb', where 'rr', 'gg', and 'bb' are hexadecimal numbers.
Values: 'red', 'green', ...
Default value: The value of 'color'

'line_width':
Sets the width of lines in pixel.
Default value: 1.0

'normal_color':
Color of the visualized normals if 'disp_normals' is set to 'true'. The available colors can be queried with the operator query_color. In addition, the color may be specified as an RGB triplet in the form '#rrggbb', where 'rr', 'gg', and 'bb' are hexadecimal numbers.
Values: 'red', 'green', ...
Default value: The value of 'color'

'point_size':
Sets the diameter of the points in pixel.
Default value: 3.5

'lut':
Sets the LUT that transforms the values of the attribute set with 'color_attrib' into a color.
See set_lut for available LUTs. If 'lut' is set to anything but 'default', 'color' is ignored.
Default value: 'default'

'color_attrib':
Name of a point attribute that is used for false color visualization.
If an attribute is set, the color of the displayed 3D points is determined by the point's attribute value and the currently set LUT (see 'lut'). This way, it is possible to visualize attributes in false colors.
Example: If 'color_attrib' is set to 'coord_z', and 'lut' is set to 'color1', the z-coordinates will be color coded from red to blue.
If 'lut' is set to 'default', the attribute values are used to scale the color that was set by the parameter 'color'.
If 'lut' is set to a different value, the attribute values of all points are internally scaled to the interval [0,255] and used as input value for the LUT function.
The mapping is also controlled by the parameters 'color_attrib_start' and 'color_attrib_end' (see below).
If faces are displayed, their color is interpolated between the color of the corner points.
Values: 'none', '&amp;distance', 'coord_x', 'coord_y', 'coord_z', user defined point attributes, or any other point attribute available.
Default: 'none'

'color_attrib_start','color_attrib_end':
The range of interest of the values of the attribute set with 'color_attrib'.
The attribute values between 'color_attrib_start' and 'color_attrib_end' are scaled to the start and end of the selected LUT. Attribute values outside the selected range are clipped. This allows to use a fixed color mapping which will not be distorted by outliers.
If set to 'auto', the minimum attribute value is mapped to the start of the LUT, the maximum is mapped to the end of the LUT, except if 'color_attrib' is 'normal_x','normal_y', or 'normal_z'. In this case, start and end are automatically set to -1 and 1.
It is possible to enter start value that is higher than the end value. This will in effect flip the used LUT.
Values: 0, 0.1, 1, 100, 255, ...
Default value: 'auto'

'red_channel_attrib', 'green_channel_attrib', 'blue_channel_attrib':
Name of a point attribute that is used for the red, green, or blue color channel.
This is most useful when used with a group of three connected attributes, like RGB colors or normal vectors. This way it is possible to display points in colored texture, e.g., display the object model with overlayed RGB-sensor data, or display point normals in false colors.
To display only a single attribute in false colors, please use 'color_attrib' (see above).
By default, the attribute values are assumed to lie between 0 and 255. If the attributes have a different range, you additionally have to set the parameters'rgb_channel_attrib_start' and 'rgb_channel_attrib_end' (see below).
If only 1 or 2 channels are set, the remaining channels use the RGB value of the color set with 'color'.
If faces are displayed, their color is interpolated between the color of the corner points.
Values: 'none', '&amp;red','&amp;green','&amp;blue', 'normal_x', 'normal_y', 'normal_z', user defined point attributes, or any other point attribute available.
Default: 'none'

'rgb_channel_attrib_start', 'rgb_channel_attrib_end':
The range of interest of the values of attributes set with 'red_channel_attrib', 'green_channel_attrib', and 'blue_channel_attrib'.
These parameters define the value range that is scaled to the full RGB channels. This is useful, if the input attribute values are not in the interval [0,255].
If set to 'auto', the minimum attribute value is mapped to 0, the maximum is mapped to 255, except if the attribute is 'normal_x', 'normal_y', or 'normal_z'. In this case, start and end are automatically set to -1 and 1.
It is possible to enter start value that is higher than the end value. This will in effect invert the displayed RGB colors.
The range can be set for the channels individually by replacing 'rgb' in the parameter name with the channel name, e.g., 'green_channel_attrib_start'.
Values: 'auto', 0, 0.1, 1, 100, 255, ...
Default values: 0, 255

The following value defines the maximum number of models, for which the selection of individual models is available:

'max_num_selectable_models':
Number of 3D Object models that can be selected and handled individually. If there are more models passed then this number, some calculations are performed differently and for reasons of efficiency, the individual selection and handling of models is not supported anymore.
Values: 1, 2, ...
Default: 1000

The following value influences the handling how the pose can be modified interactively: 

'inspection_mode':
Flag that controls the initial state of the inspection mode.
If 'inspection_mode' is set to 'standard', the rotation center is fixed in the center of the displayed object. In this mode, the rotation center is indicated by a vertical cross (+). This mode is  particularly well suited for getting an impression of the whole object.
If 'inspection_mode' is set to 'surface', the rotation center is fixed in the center of the window and it lies on the surface of the displayed object. In this mode, the rotation center is indicated by a diagonal cross (x). This mode is particularly well suited for a detailed inspection of the object's surface. It is less suitable for the inspection of point clouds, because they do not provide surface information.
Note that the trackball itself is kept in the center of the image, regardless of the selected inspection mode. Note also that the inspection mode can be toggled interactively during the visualization with Ctrl + Alt + Left mouse button (see above).
Values: 'standard' or 'surface'
Default: 'standard''
  </abstract>
<alternatives>
<item>disp_object_model_3d</item>
</alternatives>
<chapters lang="de_DE">
<item>Graphik</item>
<item>Ausgabe</item>
</chapters>
<chapters lang="en_US">
<item>Graphics</item>
<item>Output</item>
</chapters>
<example lang="en_US">read_object_model_3d ('pipe_joint', 'm', [], [], ObjectModel3D1, Status)
read_object_model_3d ('clamp_sloped', 'mm', [], [], ObjectModel3D2, Status)
gen_cam_par_area_scan_division (0.016, 0, 5e-6, 5e-6, 320, 240, 640, 480, CamParam)
get_cam_par_data (CamParam, 'image_width', Width)
get_cam_par_data (CamParam, 'image_height', Height)
dev_open_window (0, 0, Width, Height, 'black', WindowHandle)
create_pose (-0.02, 0.01, .6, 110, 5, 320, 'Rp+T', 'gba', 'point', Pose1)
create_pose (0.01, 0.03, .6, 130, 315, 340, 'Rp+T', 'gba', 'point', Pose2)
visualize_object_model_3d (WindowHandle, [ObjectModel3D1, ObjectModel3D2], \ 
                           CamParam, [Pose1, Pose2], \
                           ['alpha', 'color_0', 'color_1', 'disp_pose'], \
                           [0.5,     'orange',  'yellow',  'true'], \
                           ['3D visualization demo'], ['pipe joint', 'clamp'], \
                           ['Use mouse to change view'], PoseOut)</example>
<library lang="en_US">MVTec Standard Procedures</library>
<predecessor>
<item>read_object_model_3d</item>
<item>gen_object_model_3d_from_points</item>
</predecessor>
<see_also>
<item>disp_object_model_3d</item>
</see_also>
<short lang="en_US">Interactively display 3D object models</short>
<successor>
<item>clear_object_model_3d</item>
</successor>
<parameters>
<parameter id="Buttons">
<default_value>[]</default_value>
</parameter>
<parameter id="CamParam">
<default_type>real</default_type>
<default_value>[]</default_value>
<description lang="en_US">Camera parameters of the scene.</description>
<mixed_type>optional</mixed_type>
<multivalue>true</multivalue>
<sem_type>real</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
<parameter id="DispViewPoint"/>
<parameter id="GenParamName">
<default_type>string</default_type>
<default_value>[]</default_value>
<description lang="en_US">Names of the generic parameters. All generic parameters of disp_object_model_3d can be passed here as well.</description>
<multivalue>optional</multivalue>
<sem_type>string</sem_type>
<type_list>
<item>string</item>
</type_list>
<values>
<item>'alpha'</item>
<item>'attribute'</item>
<item>'color'</item>
<item>'colored'</item>
<item>'disp_background'</item>
<item>'disp_lines'</item>
<item>'disp_normals'</item>
<item>'disp_pose'</item>
<item>'inspection_mode'</item>
<item>'intensity'</item>
<item>'intensity_red'</item>
<item>'intensity_green'</item>
<item>'intensity_blue'</item>
<item>'light_position'</item>
<item>'light_ambient'</item>
<item>'light_diffuse'</item>
<item>'line_color'</item>
<item>'line_width'</item>
<item>'lut'</item>
<item>'max_num_selectable_models'</item>
<item>'normal_color'</item>
<item>'point_size'</item>
</values>
</parameter>
<parameter id="GenParamValue">
<default_type>string</default_type>
<default_value>[]</default_value>
<description lang="en_US">Values of the generic parameters. All generic parameters of disp_object_model_3d can be passed here as well.</description>
<mixed_type>optional</mixed_type>
<multivalue>optional</multivalue>
<sem_type>any</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
<item>string</item>
</type_list>
<values>
<item>'true'</item>
<item>'false'</item>
<item>'coord_x'</item>
<item>'coord_y'</item>
<item>'coord_z'</item>
<item>'red'</item>
<item>'green'</item>
<item>'blue'</item>
<item>'auto'</item>
<item>'faces'</item>
<item>'primitive'</item>
<item>'points'</item>
<item>'lines'</item>
<item>'normal_x'</item>
<item>'normal_y,'normal_z'</item>
<item>'standard'</item>
<item>'surface'</item>
</values>
</parameter>
<parameter id="Information">
<default_type>string</default_type>
<default_value>[]</default_value>
<description lang="en_US">Text that is to be displayed in the lower left corner of the output graphics window.</description>
<multivalue>optional</multivalue>
<sem_type>string</sem_type>
<type_list>
<item>string</item>
</type_list>
</parameter>
<parameter id="Label">
<default_type>string</default_type>
<default_value>[]</default_value>
<description lang="en_US">Text that is to be displayed at the position of each displayed object model.</description>
<multivalue>optional</multivalue>
<sem_type>string</sem_type>
<type_list>
<item>string</item>
</type_list>
</parameter>
<parameter id="Message"/>
<parameter id="MessageQueue">
<default_type>integer</default_type>
<default_value>[]</default_value>
<mixed_type>false</mixed_type>
<sem_type>message_queue</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="ObjectModel3D">
<default_type>integer</default_type>
<description lang="en_US">Handles of the 3D object models.</description>
<mixed_type>false</mixed_type>
<multivalue>optional</multivalue>
<sem_type>object_model_3d</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="PoseIn">
<default_type>real</default_type>
<default_value>[]</default_value>
<description lang="en_US">3D poses of the objects.</description>
<mixed_type>optional</mixed_type>
<multivalue>optional</multivalue>
<sem_type>pose</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
<parameter id="Title">
<default_type>string</default_type>
<default_value>[]</default_value>
<description lang="en_US">Text that is to be displayed in the upper left corner of the output graphics window.</description>
<multivalue>optional</multivalue>
<sem_type>string</sem_type>
<type_list>
<item>string</item>
</type_list>
</parameter>
<parameter id="Type"/>
<parameter id="ViewPoint"/>
<parameter id="WindowHandle">
<default_type>integer</default_type>
<description lang="en_US">Window identifier.</description>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>window</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
</parameters>
</docu>
</procedure>
<procedure name="wait_continue_button" access="local">
<interface>
<ic>
<par name="WindowHandle" base_type="ctrl" dimension="0"/>
</ic>
</interface>
<body>
<c>* Wait for the user to click the exit button</c>
<l>get_window_extents (WindowHandle, Row1, Column1, WinWidth, WinHeight)</l>
<l>get_string_extents (WindowHandle, 'Continue', Ascent1, Descent1, TextWidth, TextHeight)</l>
<l>ButtonRow := WinHeight - TextHeight - 20</l>
<l>ButtonCol := WinWidth - TextWidth - 30</l>
<l>disp_text_button (WindowHandle, 'Continue', 'window', ButtonRow, ButtonCol, 'black', '#f28f26')</l>
<l>while (1)</l>
<l>    try</l>
<l>        get_mposition (WindowHandle, Row, Column, Button)</l>
<l>        if (Button != 0 and Row &gt;= ButtonRow and Column &gt;= ButtonCol)</l>
<l>            break</l>
<l>        endif</l>
<l>    catch (Exception)</l>
<l>        if (Exception[0] == 2454 or Exception[0] == 5100)</l>
<c>            * Handle was already cleared -&gt; indicates that the window was closed (by the user)</c>
<c>            * Abort gracefully.</c>
<l>            return ()</l>
<l>        elseif (Exception[0] == H_MSG_FAIL)</l>
<c>            * Ignore -&gt; mouse outside of window</c>
<l>        else</l>
<c>            * Unknown / Unexpected exception</c>
<c>            * Ignore for now</c>
<l>        endif</l>
<l>    endtry</l>
<l>    wait_seconds (0.01)</l>
<l>endwhile</l>
<l>return ()</l>
</body>
<docu id="wait_continue_button">
<abstract lang="en_US">Displays a continue button in the window and waits for the user to press that button.</abstract>
<chapters lang="en_US">
<item>Graphics</item>
<item>Output</item>
</chapters>
<library lang="en_US">MVTec Standard Procedures</library>
<short lang="en_US">Display continue button and wait for user to click it</short>
<parameters>
<parameter id="WindowHandle">
<default_type>integer</default_type>
<mixed_type>false</mixed_type>
<sem_type>window</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
</parameters>
</docu>
</procedure>
<procedure name="write_dl_samples">
<interface>
<ic>
<par name="DLDataset" base_type="ctrl" dimension="0"/>
<par name="SampleIndices" base_type="ctrl" dimension="0"/>
<par name="DLSampleBatch" base_type="ctrl" dimension="0"/>
<par name="GenParamName" base_type="ctrl" dimension="0"/>
<par name="GenParamValue" base_type="ctrl" dimension="0"/>
</ic>
</interface>
<body>
<c>* </c>
<c>* This procedure writes all given DLSamples in DLSampleBatch to hdict files</c>
<c>* and stores the file paths in the respective samples of the DLDataset.</c>
<c>* The directory needs to be given in dlsample_dir, before calling this procedure.</c>
<c>* </c>
<c>* The output filename is created in the following way: image_id + '_dlsample.hdict'</c>
<c>* </c>
<c>* Set the default values.</c>
<c>* Raise error when writing dictionary.</c>
<l>RaiseErrorWriteDict := 'true'</l>
<c>* </c>
<c>* Transfer generic parameters.</c>
<l>if (|GenParamName| != |GenParamValue|)</l>
<l>    throw ('GenParamName and GenParamValue have to be of equal length.')</l>
<l>endif</l>
<c>* </c>
<l>if (GenParamName != [])</l>
<l>    for IndexGenParam := 0 to |GenParamName| - 1 by 1</l>
<l>        if (GenParamName[IndexGenParam] == 'raise_error_if_content_not_serializable')</l>
<c>            * Set 'raise_error_if_content_not_serializable' for writing write_dict.</c>
<l>            RaiseErrorWriteDict := GenParamValue[IndexGenParam]</l>
<l>        else</l>
<l>            throw ('Unknown GenParam key : ' + GenParamName[IndexGenParam])</l>
<l>        endif</l>
<l>    endfor</l>
<l>endif</l>
<c>* </c>
<c>* Check the parameters.</c>
<c>* Check that the base path is available in the DLDataset.</c>
<l>get_dict_param (DLDataset, 'key_exists', 'dlsample_dir', DLSampleDirExists)</l>
<l>if (not DLSampleDirExists)</l>
<l>    throw ('The dataset needs to include the key \'dlsample_dir\'.')</l>
<l>    return ()</l>
<l>endif</l>
<c></c>
<l>if (|DLSampleBatch| != |SampleIndices|)</l>
<l>    throw ('The input tuples DLSampleBatch and SampleIndices need to match in length.')</l>
<l>    return ()</l>
<l>endif</l>
<c>* </c>
<c>* Write preprocessed data.</c>
<c>* </c>
<c>* Get the base path for the outputs.</c>
<l>get_dict_tuple (DLDataset, 'dlsample_dir', OutDir)</l>
<c>* </c>
<c>* Get the samples.</c>
<l>get_dict_tuple (DLDataset, 'samples', DatasetSamples)</l>
<c>* </c>
<c>* Loop over all samples in the batch.</c>
<l>for I := 0 to |DLSampleBatch| - 1 by 1</l>
<c>    * Get the sample dictionaries.</c>
<l>    DLDatasetIndex := SampleIndices[I]</l>
<l>    DatasetSample := DatasetSamples[DLDatasetIndex]</l>
<l>    DLSample := DLSampleBatch[I]</l>
<c>    * </c>
<c>    * Check that image IDs match.</c>
<l>    get_dict_tuple (DatasetSample, 'image_id', DatasetImageID)</l>
<l>    get_dict_tuple (DLSampleBatch[I], 'image_id', SampleImageID)</l>
<l>    if (DatasetImageID != SampleImageID)</l>
<l>        throw ('Image IDs do not match. Please use correct indexing in input argument SampleIndices.')</l>
<l>        return ()</l>
<l>    endif</l>
<c>    * </c>
<c>    * Generate the output file name.</c>
<l>    FileNameOut := SampleImageID + '_dlsample.hdict'</l>
<c>    * </c>
<c>    * Write output dictionary.</c>
<l>    write_dict (DLSample, OutDir + '/' + FileNameOut, 'raise_error_if_content_not_serializable', RaiseErrorWriteDict)</l>
<c>    * Add output path to DLDataset sample dictionary.</c>
<l>    set_dict_tuple (DatasetSamples[DLDatasetIndex], 'dlsample_file_name', FileNameOut)</l>
<c>    * </c>
<l>endfor</l>
<c></c>
<l>return ()</l>
</body>
<docu id="write_dl_samples">
<abstract lang="en_US">This procedure writes all given samples in DLSampleBatch to files.

SampleIndices specifies the indices which the samples given in DLSampleBatch have within the tuple 'samples' out of DLDataset.
Thus, SampleIndices and DLSampleBatch need to have the same number of items.

These files are written with the default HALCON file extension for a dictionary, hdict.
The directory needs to be given in DLDataset with the key 'dlsample_dir', already before calling this procedure. This folder is internally used for caching.
The output filename is created in the following way: image_id + '_dlsample.hdict'
The output path is stored in the respective samples of DLDataset.

Using GenParamName and GenParamValue, you can provide additional parameters. Thereby, the following pairs are possible:
- 'raise_error_if_content_not_serializable' (default: 'true'): Error handling of write_dict. For further information and possible values, please see the documentation of write_dict.

During training and evaluation it is faster to read preprocessed samples directly than doing the preprocessing on the fly.

Attention:
The used file size can get rather big (up to several GBs). For optimal performance you should use a fast storage solution.
</abstract>
<chapters lang="de_DE">
<item>Deep Learning</item>
<item>Modell</item>
</chapters>
<chapters lang="en_US">
<item>Deep Learning</item>
<item>Model</item>
</chapters>
<library lang="en_US">MVTec Standard Procedures</library>
<short lang="en_US">Write the dictionaries of the samples in DLSampleBatch to hdict files and store the paths in DLDataset.</short>
<parameters>
<parameter id="DLDataset">
<default_type>integer</default_type>
<description lang="en_US">Dictionary containing information about the dataset.</description>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>dict</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="DLSampleBatch">
<default_type>integer</default_type>
<description lang="en_US">Tuple of DLSample dictionaries to be written to a file.</description>
<mixed_type>false</mixed_type>
<multivalue>optional</multivalue>
<sem_type>dict</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="GenParamName">
<default_type>string</default_type>
<default_value>[]</default_value>
<description lang="en_US">Name of the generic parameter.</description>
<mixed_type>false</mixed_type>
<multivalue>optional</multivalue>
<sem_type>attribute</sem_type>
<type_list>
<item>string</item>
</type_list>
<values>
<item>'raise_error_if_content_not_serializable'</item>
</values>
</parameter>
<parameter id="GenParamValue">
<default_type>string</default_type>
<default_value>[]</default_value>
<description lang="en_US">Value of the generic parameter.</description>
<mixed_type>optional</mixed_type>
<multivalue>optional</multivalue>
<sem_type>attribute</sem_type>
<type_list>
<item>integer</item>
<item>string</item>
</type_list>
<values>
<item>'true'</item>
<item>'false'</item>
<item>'low_level'</item>
</values>
</parameter>
<parameter id="SampleIndices">
<default_type>integer</default_type>
<description lang="en_US">Index or tuple of indices which the samples given in DLSampleBatch have within the tuple 'samples' out of DLDataset.</description>
<mixed_type>false</mixed_type>
<multivalue>optional</multivalue>
<sem_type>integer</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
</parameters>
</docu>
</procedure>
<procedure name="write_note" access="local">
<interface>
<ic>
<par name="WindowHandle" base_type="ctrl" dimension="0"/>
<par name="Type" base_type="ctrl" dimension="0"/>
<par name="String" base_type="ctrl" dimension="0"/>
</ic>
</interface>
<body>
<l>Strings := ['              ','[INSTRUCTION] ','[OK         ] ','[WARNING    ] ','[INFO       ] ','[ERROR      ] ']</l>
<c></c>
<l>if (Type == 'Title')</l>
<c></c>
<l>endif</l>
<l>if (Type == 'none')</l>
<l>    write_string (WindowHandle, Strings[0])</l>
<l>    set_color (WindowHandle, 'white')</l>
<l>elseif (Type == 'instruction')</l>
<l>    set_color (WindowHandle, 'cornflower blue')</l>
<l>    write_string (WindowHandle, Strings[1])</l>
<l>    set_color (WindowHandle, 'light steel blue')</l>
<l>elseif (Type == 'ok')</l>
<l>    set_color (WindowHandle, 'green')</l>
<l>    write_string (WindowHandle, Strings[2])</l>
<l>    set_color (WindowHandle, '#AAFFAA')</l>
<l>elseif (Type == 'warning')</l>
<l>    set_color (WindowHandle, 'yellow')</l>
<l>    write_string (WindowHandle, Strings[3])</l>
<l>    set_color (WindowHandle, '#FFFF00')</l>
<l>elseif (Type == 'info')</l>
<l>    set_color (WindowHandle, 'white')</l>
<l>    write_string (WindowHandle, Strings[4])</l>
<l>elseif (Type == 'error')</l>
<l>    set_color (WindowHandle, 'red')</l>
<l>    write_string (WindowHandle, Strings[5])</l>
<l>    set_color (WindowHandle, '#FFAAAA')</l>
<l>else</l>
<l>    stop ()</l>
<l>endif</l>
<c></c>
<c>* Break into lines such that</c>
<c>* "[SomeInfo]  Text" does not overflow</c>
<l>get_window_extents (WindowHandle, Row, Column, WinWidth, WinHeight)</l>
<l>Pos := 0</l>
<l>while (Pos &lt; |String|)</l>
<l>    get_string_extents (WindowHandle, Strings[0] + String[Pos], Ascent, Descent, Width, Height)</l>
<l>    if (Width &gt; WinWidth - 20)</l>
<c>        * Break this line!</c>
<l>        tuple_split (String[Pos], ' ', SubStrings)</l>
<l>        for Num := |SubStrings| - 1 to 1 by -1</l>
<l>            CurrTestString := sum(SubStrings[0:Num - 1] + ' ')</l>
<l>            get_string_extents (WindowHandle, Strings[0] + CurrTestString, Ascent, Descent, Width, Height)</l>
<l>            if (Width &gt; WinWidth - 20)</l>
<l>                continue</l>
<l>            else</l>
<c>                * Split the line here</c>
<l>                String[Pos] := sum(SubStrings[0:Num - 1] + ' ')</l>
<l>                tuple_insert (String, Pos + 1, sum(SubStrings[Num:|SubStrings| - 1] + ' '), String)</l>
<l>                break</l>
<l>            endif</l>
<l>        endfor</l>
<l>    endif</l>
<l>    Pos := Pos + 1</l>
<l>endwhile</l>
<c></c>
<l>for Index := 0 to |String| - 1 by 1</l>
<l>    if (Index &gt; 0)</l>
<l>        new_line (WindowHandle)</l>
<l>        write_string (WindowHandle, Strings[0])</l>
<l>    endif</l>
<l>    write_string (WindowHandle, String[Index])</l>
<l>endfor</l>
<c></c>
<l>new_line (WindowHandle)</l>
<l>set_color (WindowHandle, 'white')</l>
<c></c>
<l>return ()</l>
</body>
<docu id="write_note">
<chapters lang="en_US">
<item>Graphics</item>
<item>Text</item>
</chapters>
<library lang="en_US">MVTec Standard Procedures</library>
<parameters>
<parameter id="String">
<sem_type>string</sem_type>
</parameter>
<parameter id="Type">
<sem_type>string</sem_type>
<values>
<item>'none'</item>
<item>'info'</item>
<item>'warning'</item>
<item>'ok'</item>
<item>'error'</item>
</values>
</parameter>
<parameter id="WindowHandle">
<default_type>integer</default_type>
<mixed_type>false</mixed_type>
<sem_type>window</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
</parameters>
</docu>
</procedure>
<procedure name="xyz_attrib_to_object_model_3d">
<interface>
<io>
<par name="X" base_type="iconic" dimension="0"/>
<par name="Y" base_type="iconic" dimension="0"/>
<par name="Z" base_type="iconic" dimension="0"/>
<par name="AttribImage" base_type="iconic" dimension="0"/>
</io>
<ic>
<par name="AttribName" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="ObjectModel3D" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c>* </c>
<c>* Consistency checks:</c>
<l>count_obj (AttribImage, Number)</l>
<l>if (Number != 1)</l>
<l>    throw ('The attribute image must be an image array with exactly one object. If you want to set multiple attributes, use a multichannel image.')</l>
<l>endif</l>
<c>* </c>
<l>count_channels (AttribImage, Channels)</l>
<l>if (Channels != |AttribName|)</l>
<l>    throw ('The number of channels of the attribute image (' + Channels + ') must be equal to the number of attribute names (' + |AttribName| + ').')</l>
<l>endif</l>
<c>* </c>
<l>get_image_size (X, WidthX, HeightX)</l>
<l>get_image_size (Y, WidthY, HeightY)</l>
<l>get_image_size (Z, WidthZ, HeightZ)</l>
<l>get_image_size (AttribImage, WidthA, HeightA)</l>
<l>if (WidthX != WidthY or HeightX != HeightY or WidthX != WidthZ or HeightX != HeightZ or WidthX != WidthA or HeightX != HeightA)</l>
<l>    throw ('Image sizes do not match. The size of all input images must be equal.')</l>
<l>endif</l>
<c>* </c>
<l>get_param_info ('set_object_model_3d_attrib_mod', 'AttribName', 'value_list', AvailableAttributes)</l>
<l>tuple_regexp_select (AvailableAttributes, 'point_.*', Selection)</l>
<l>tuple_difference (AttribName, Selection, Difference)</l>
<l>tuple_regexp_select (Difference, '^[^&amp;]', InvalidParameters)</l>
<l>if (|InvalidParameters| &gt; 0)</l>
<l>    Exception := 'The following attribute names are invalid: ' + sum(InvalidParameters + ', ') + 'please use a \'&amp;\' prefix for extended attributes, e.g., \'&amp;' + InvalidParameters[0] + '\', or a standard point attribute.'</l>
<l>    throw (Exception)</l>
<l>endif</l>
<c>* </c>
<c>* Get the domain of the images containing the 3D points and get the region all</c>
<c>* three of them share. This is because xyz_to_object_model_3d only uses points</c>
<c>* in the intersecting domains of all three images.</c>
<l>get_domain (X, DomainX)</l>
<l>get_domain (Y, DomainY)</l>
<l>get_domain (Z, DomainZ)</l>
<l>intersection (DomainX, DomainY, RegionIntersectionTmp)</l>
<l>intersection (RegionIntersectionTmp, DomainZ, RegionIntersection)</l>
<c>* </c>
<c>* Transform the images that contain the X, Y, and Z-coordinates to a 3D object model.</c>
<l>xyz_to_object_model_3d (X, Y, Z, ObjectModel3D)</l>
<c>* </c>
<c>* Loop through all channels and collect the corresponding attribute values</c>
<l>AttribValues := []</l>
<l>for Index := 1 to Channels by 1</l>
<l>    access_channel (AttribImage, Channel, Index)</l>
<l>    get_region_points (RegionIntersection, Rows, Columns)</l>
<l>    get_grayval (Channel, Rows, Columns, AttribValuesTmp)</l>
<l>    AttribValues := [AttribValues,AttribValuesTmp]</l>
<l>endfor</l>
<c>* </c>
<c>* Set the attributes</c>
<l>set_object_model_3d_attrib_mod (ObjectModel3D, AttribName, 'points', AttribValues)</l>
<l>return ()</l>
</body>
<docu id="xyz_attrib_to_object_model_3d">
<abstract lang="en_US">The procedure xyz_attrib_to_object_model_3d transforms the images X, Y, and Z into a 3D object model ObjectModel3D. Additionally, it sets the point attributes in AttribName to the values in AttribImage.

The procedure can be used, e.g., to create a 3D object model that uses an RGB image to set the extended attributes '&amp;amp;red', '&amp;amp;green', and '&amp;amp;blue'. Then, as seen in the example code below, the procedure visualize_object_model_3d can be used to display the object model with the respective texture.

AttribImage can be a multichannel image. The number of channels of the attribute image must be equal to the size of the tuple AttribName. Additionally, the images X, Y, Z, and AttribImage must be the same size.

Only points in the intersecting domains of the X, Y, and Z-image are used. The domain of AttribImage is ignored. The created 3D object model contains the coordinates of the points, as well as the xyz mapping attribute that contains the original row and column of each 3D point. Points where one of the coordinates is infinity or "Not a Number" (NaN) are ignored and not added to the 3D object model.

Note that if a 3D object model is no longer needed or should be overwritten, the memory has to be freed first by calling the operator clear_object_model_3d.</abstract>
<alternatives>
<item>xyz_to_object_model_3d</item>
<item>set_object_model_3d_attrib</item>
</alternatives>
<chapters lang="de_DE">
<item>3D-Objektmodell</item>
<item>Transformationen</item>
</chapters>
<chapters lang="en_US">
<item>3D Object Model</item>
<item>Transformations</item>
</chapters>
<example lang="en_US">xyz_attrib_to_object_model_3d (X, Y, Z, ImageRGB, ['&amp;amp;red', '&amp;amp;green', '&amp;amp;blue'], ObjectModel3D)
prepare_object_model_3d (ObjectModel3D, 'segmentation', 'true', [], [])
visualize_object_model_3d (WindowHandle, ObjectModel3D, [], [], ['red_channel_attrib', 'green_channel_attrib', 'blue_channel_attrib'], ['&amp;amp;red', '&amp;amp;green', '&amp;amp;blue'], [], [], [], PoseOut)</example>
<library lang="en_US">MVTec Standard Procedures</library>
<predecessor>
<item>disparity_image_to_xyz</item>
</predecessor>
<short lang="en_US">Transform 3D points from images to a 3D object model, and add extended attributes to the points of the object model.</short>
<successor>
<item>prepare_object_model_3d</item>
<item>select_points_object_model_3d</item>
</successor>
<parameters>
<parameter id="AttribImage">
<description lang="en_US">The (multichannel) image with the attributes.</description>
<multichannel>optional</multichannel>
<multivalue>false</multivalue>
<sem_type>image</sem_type>
<type_list>
<item>real</item>
</type_list>
</parameter>
<parameter id="AttribName">
<default_type>string</default_type>
<default_value>'&amp;gray'</default_value>
<description lang="en_US">The names of the attributes.</description>
<multivalue>optional</multivalue>
<sem_type>string</sem_type>
<type_list>
<item>string</item>
</type_list>
<values>
<item>['&amp;red', '&amp;green', '&amp;blue']</item>
<item>'&amp;distance'</item>
</values>
</parameter>
<parameter id="ObjectModel3D">
<default_type>integer</default_type>
<description lang="en_US">Handle of the 3D object model.</description>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>object_model_3d</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="X">
<description lang="en_US">Image with the X coordinates of the 3D points.</description>
<multichannel>false</multichannel>
<multivalue>false</multivalue>
<sem_type>image</sem_type>
<type_list>
<item>real</item>
</type_list>
</parameter>
<parameter id="Y">
<description lang="en_US">Image with the Y coordinates of the 3D points.</description>
<multichannel>false</multichannel>
<multivalue>false</multivalue>
<sem_type>image</sem_type>
<type_list>
<item>real</item>
</type_list>
</parameter>
<parameter id="Z">
<description lang="en_US">Image with the Z coordinates of the 3D points.</description>
<multichannel>false</multichannel>
<multivalue>false</multivalue>
<sem_type>image</sem_type>
<type_list>
<item>real</item>
</type_list>
</parameter>
</parameters>
</docu>
</procedure>
<procedure name="gen_right_edge">
<interface>
<io>
<par name="Image" base_type="iconic" dimension="0"/>
</io>
<ic>
<par name="CenterRow" base_type="ctrl" dimension="0"/>
<par name="CenterColumn" base_type="ctrl" dimension="0"/>
<par name="BaseRectDistRow" base_type="ctrl" dimension="0"/>
<par name="BaseRectDistColumn" base_type="ctrl" dimension="0"/>
<par name="MaxCircleColumn" base_type="ctrl" dimension="0"/>
<par name="BasePhi" base_type="ctrl" dimension="0"/>
<par name="ImageWidth" base_type="ctrl" dimension="0"/>
<par name="ImageHeight" base_type="ctrl" dimension="0"/>
<par name="RotatePhi" base_type="ctrl" dimension="0"/>
<par name="BaseRectPhi" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="RightRowEdge1" base_type="ctrl" dimension="0"/>
<par name="RightColumnEdge1" base_type="ctrl" dimension="0"/>
<par name="RightRowEdge2" base_type="ctrl" dimension="0"/>
<par name="RightColumnEdge2" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<l>gen_rectangle2 (Rectangle3, CenterRow-BaseRectDistRow, CenterColumn+BaseRectDistColumn, BaseRectPhi, 100, 50)</l>
<l>gen_rectangle2 (Rectangle4, CenterRow+BaseRectDistRow, CenterColumn+BaseRectDistColumn, BaseRectPhi, 100, 50)</l>
<l>if (MaxCircleColumn &gt; CenterColumn)</l>
<l>    vector_angle_to_rigid (CenterRow, CenterColumn, BaseRectPhi, CenterRow, CenterColumn, BasePhi+rad(180), HomMat2D7)</l>
<l>    affine_trans_region (Rectangle3, RightMeasureRectionAffineTrans1, HomMat2D7, 'nearest_neighbor')</l>
<l>    area_center (RightMeasureRectionAffineTrans1, RightMeasureRectArea, RightMeasureRectRow1, RightMeasureRectColumn1)</l>
<l>    orientation_region (RightMeasureRectionAffineTrans1, RightMeasureRectPhi1)</l>
<l>    gen_measure_rectangle2 (RightMeasureRectRow1, RightMeasureRectColumn1, RightMeasureRectPhi1, 100, 50, ImageWidth, ImageHeight, 'bicubic', MeasureHandle7)</l>
<c></c>
<l>    affine_trans_region (Rectangle4, RightMeasureRectionAffineTrans2, HomMat2D7, 'nearest_neighbor')</l>
<l>    area_center (RightMeasureRectionAffineTrans2, RightMeasureRectArea, RightMeasureRectRow2, RightMeasureRectColumn2)</l>
<l>    orientation_region (RightMeasureRectionAffineTrans2, RightMeasureRectPhi2)</l>
<l>    gen_measure_rectangle2 (RightMeasureRectRow2, RightMeasureRectColumn2, RightMeasureRectPhi2, 100, 50, ImageWidth, ImageHeight, 'bicubic', MeasureHandle8)</l>
<l>else</l>
<l>    vector_angle_to_rigid (CenterRow, CenterColumn, BaseRectPhi, CenterRow, CenterColumn, BasePhi, HomMat2D7)</l>
<l>    affine_trans_region (Rectangle3, RightMeasureRectionAffineTrans1, HomMat2D7, 'nearest_neighbor')</l>
<l>    area_center (RightMeasureRectionAffineTrans1, RightMeasureRectArea, RightMeasureRectRow1, RightMeasureRectColumn1)</l>
<l>    orientation_region (RightMeasureRectionAffineTrans1, RightMeasureRectPhi1)</l>
<l>    gen_measure_rectangle2 (RightMeasureRectRow1, RightMeasureRectColumn1, RightMeasureRectPhi1, 100, 50, ImageWidth, ImageHeight, 'bicubic', MeasureHandle7)</l>
<c></c>
<l>    affine_trans_region (Rectangle4, RightMeasureRectionAffineTrans2, HomMat2D7, 'nearest_neighbor')</l>
<l>    area_center (RightMeasureRectionAffineTrans2, RightMeasureRectArea, RightMeasureRectRow2, RightMeasureRectColumn2)</l>
<l>    orientation_region (RightMeasureRectionAffineTrans2, RightMeasureRectPhi2)</l>
<l>    gen_measure_rectangle2 (RightMeasureRectRow2, RightMeasureRectColumn2, RightMeasureRectPhi2, 100, 50, ImageWidth, ImageHeight, 'bicubic', MeasureHandle8)</l>
<l>endif</l>
<c>* 抓取右侧边缘</c>
<l>measure_pos (Image, MeasureHandle7, 1, 30, 'all', 'all', RightRowEdge1, RightColumnEdge1, RightAmplitude, RightDistance)</l>
<l>measure_pos (Image, MeasureHandle8, 1, 30, 'all', 'all', RightRowEdge2, RightColumnEdge2, RightAmplitude, RightDistance)</l>
<l>close_measure (MeasureHandle7)</l>
<l>close_measure (MeasureHandle8)</l>
<l>return ()</l>
</body>
<docu id="gen_right_edge">
<parameters>
<parameter id="BasePhi"/>
<parameter id="BaseRectDistColumn"/>
<parameter id="BaseRectDistRow"/>
<parameter id="BaseRectPhi"/>
<parameter id="CenterColumn"/>
<parameter id="CenterRow"/>
<parameter id="Image"/>
<parameter id="ImageHeight"/>
<parameter id="ImageWidth"/>
<parameter id="MaxCircleColumn"/>
<parameter id="RightColumnEdge1"/>
<parameter id="RightColumnEdge2"/>
<parameter id="RightRowEdge1"/>
<parameter id="RightRowEdge2"/>
<parameter id="RotatePhi"/>
</parameters>
</docu>
</procedure>
<procedure name="gen_L1L2_Measure10">
<interface>
<io>
<par name="Image" base_type="iconic" dimension="0"/>
</io>
<ic>
<par name="CenterRow" base_type="ctrl" dimension="0"/>
<par name="CenterColumn" base_type="ctrl" dimension="0"/>
<par name="MinCircleRadius" base_type="ctrl" dimension="0"/>
<par name="BasePhi" base_type="ctrl" dimension="0"/>
<par name="Width" base_type="ctrl" dimension="0"/>
<par name="Height" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="RightCircleRowEdge1" base_type="ctrl" dimension="0"/>
<par name="RightCircleColumnEdge1" base_type="ctrl" dimension="0"/>
<par name="LeftCircleRowEdge1" base_type="ctrl" dimension="0"/>
<par name="LeftCircleColumnEdge1" base_type="ctrl" dimension="0"/>
<par name="RightCircleRowEdge2" base_type="ctrl" dimension="0"/>
<par name="RightCircleColumnEdge2" base_type="ctrl" dimension="0"/>
<par name="LeftCircleRowEdge2" base_type="ctrl" dimension="0"/>
<par name="LeftCircleColumnEdge2" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c>*生成基准矩形</c>
<l>gen_rectangle2 (Rect1, CenterRow-100, CenterColumn+MinCircleRadius, 0, 100, 20)</l>
<c>*生成测量矩形</c>
<l>vector_angle_to_rigid (CenterRow, CenterColumn, 0, CenterRow, CenterColumn, BasePhi, HomMat2D1)</l>
<l>affine_trans_region (Rect1, RightRect1, HomMat2D1, 'nearest_neighbor')</l>
<l>area_center (RightRect1, RightRect1Area,RightRect1Row, RightRect1Column)</l>
<l>orientation_region (RightRect1, RightRect1Phi)</l>
<l>gen_measure_rectangle2 (RightRect1Row,RightRect1Column, RightRect1Phi, 100, 50, Width, Height, 'bicubic', MeasureHandle1)</l>
<c></c>
<l>vector_angle_to_rigid (CenterRow, CenterColumn, 0, CenterRow, CenterColumn, BasePhi+rad(180), HomMat2D2)</l>
<l>affine_trans_region (Rect1, LeftRect1, HomMat2D2, 'nearest_neighbor')</l>
<l>area_center (LeftRect1, LeftRect1Area, LeftRect1Row, LeftRect1Column)</l>
<l>orientation_region (LeftRect1, LeftRect1Phi)</l>
<l>gen_measure_rectangle2 (LeftRect1Row, LeftRect1Column, LeftRect1Phi, 100, 50, Width, Height, 'bicubic', MeasureHandle3)</l>
<c>*生成基准矩形</c>
<l>gen_rectangle2 (Rect2, CenterRow+100, CenterColumn+MinCircleRadius, 0, 100, 20)</l>
<c>*生成测量矩形</c>
<l>affine_trans_region (Rect2, RightRect2, HomMat2D1, 'nearest_neighbor')</l>
<l>area_center (RightRect2, RightRect2Area,RightRect2Row, RightRect2Column)</l>
<l>orientation_region (RightRect2, RightRect2Phi)</l>
<l>gen_measure_rectangle2 (RightRect2Row,RightRect2Column, RightRect2Phi, 100, 50, Width, Height, 'bicubic', MeasureHandle2)</l>
<c></c>
<l>affine_trans_region (Rect2, LeftRect2, HomMat2D2, 'nearest_neighbor')</l>
<l>area_center (LeftRect2, LeftRect2Area, LeftRect2Row, LeftRect2Column)</l>
<l>orientation_region (LeftRect2, LeftRect2Phi)</l>
<l>gen_measure_rectangle2 (LeftRect2Row, LeftRect2Column, LeftRect2Phi, 100, 50, Width, Height, 'bicubic', MeasureHandle4)</l>
<c>*抓取边缘点</c>
<l>measure_pos (Image, MeasureHandle1, 1, 30, 'all', 'all', RightCircleRowEdge1, RightCircleColumnEdge1, Amplitude, Distance)</l>
<l>measure_pos (Image, MeasureHandle3, 1, 30, 'all', 'all', LeftCircleRowEdge1, LeftCircleColumnEdge1, Amplitude, Distance)</l>
<l>measure_pos (Image, MeasureHandle2, 1, 30, 'all', 'all', RightCircleRowEdge2, RightCircleColumnEdge2, Amplitude, Distance)</l>
<l>measure_pos (Image, MeasureHandle4, 1, 30, 'all', 'all', LeftCircleRowEdge2, LeftCircleColumnEdge2, Amplitude, Distance)</l>
<l>return ()</l>
</body>
<docu id="gen_L1L2_Measure10">
<parameters>
<parameter id="BasePhi"/>
<parameter id="CenterColumn"/>
<parameter id="CenterRow"/>
<parameter id="Height"/>
<parameter id="Image"/>
<parameter id="LeftCircleColumnEdge1"/>
<parameter id="LeftCircleColumnEdge2"/>
<parameter id="LeftCircleRowEdge1"/>
<parameter id="LeftCircleRowEdge2"/>
<parameter id="MinCircleRadius"/>
<parameter id="RightCircleColumnEdge1"/>
<parameter id="RightCircleColumnEdge2"/>
<parameter id="RightCircleRowEdge1"/>
<parameter id="RightCircleRowEdge2"/>
<parameter id="Width"/>
</parameters>
</docu>
</procedure>
<procedure name="gen_TwoCircle_info">
<interface>
<io>
<par name="Image" base_type="iconic" dimension="0"/>
</io>
<oc>
<par name="MaxCircleRow" base_type="ctrl" dimension="0"/>
<par name="MaxCircleColumn" base_type="ctrl" dimension="0"/>
<par name="MaxCircleRadius" base_type="ctrl" dimension="0"/>
<par name="MinCircleRow" base_type="ctrl" dimension="0"/>
<par name="MinCircleColumn" base_type="ctrl" dimension="0"/>
<par name="MinCircleRadius" base_type="ctrl" dimension="0"/>
<par name="TwoCirclePhi" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<l>fast_threshold (Image, Regions, 128, 255, 20)</l>
<l>connection (Regions, ConnectedRegions)</l>
<c>*提取两个圆形区域</c>
<l>select_shape (ConnectedRegions, MinCircleSelectedRegions, ['area','circularity'], 'and', [727440,0.8407], [1.22468e+06,1])</l>
<l>select_shape (ConnectedRegions, MaxCircleSelectedRegions, ['area','circularity'], 'and', [1.15101e+06,0.6473], [1.68508e+06,0.837])</l>
<l>inner_circle (MaxCircleSelectedRegions, MaxCircleRow, MaxCircleColumn, MaxCircleRadius)</l>
<l>inner_circle (MinCircleSelectedRegions, MinCircleRow, MinCircleColumn, MinCircleRadius) </l>
<c>*求两圆心连线方向</c>
<l>line_orientation (MaxCircleRow, MaxCircleColumn, MinCircleRow, MinCircleColumn, TwoCirclePhi) </l>
<l>return ()</l>
</body>
<docu id="gen_TwoCircle_info">
<parameters>
<parameter id="Image"/>
<parameter id="MaxCircleColumn"/>
<parameter id="MaxCircleRadius"/>
<parameter id="MaxCircleRow"/>
<parameter id="MinCircleColumn"/>
<parameter id="MinCircleRadius"/>
<parameter id="MinCircleRow"/>
<parameter id="TwoCirclePhi"/>
</parameters>
</docu>
</procedure>
</hdevelop>
